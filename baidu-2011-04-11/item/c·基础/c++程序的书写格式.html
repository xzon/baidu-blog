<html><head><title>c++程序的书写格式</title></head><body><div id='tit'>c++程序的书写格式</div><div id='cate'>c&middot;基础</div><div id='date'>2007年12月16日 星期日 04:35 A.M.</div><div id='page'>185</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/46ba07e986f3d73cb90e2dc5.html'>http://hi.baidu.com/hxzon/blog/item/46ba07e986f3d73cb90e2dc5.html</a><div id='cnt'><div class="tit"> 
 <p>c++程序的书写格式</p> 
</div> 
<table style="table-layout: fixed" class="FCK__ShowTableBorders"> 
 <tbody> 
  <tr> 
   <td> 
    <div class="cnt">
     文件结构 
     <br /> 文件头注释 
     <br /> 
     <br /> 所有C++的源文件均必须包含一个规范的文件头，文件头包含了该文件的名称、功能概述、作者、版权和版本历史信息等内容。标准文件头的格式为： 
     <br /> /*! @file 
     <br /> ******************************************************************************** 
     <br /> &lt;PRE&gt; 
     <br /> 模块名 : &lt;文件所属的模块名称&gt; 
     <br /> 文件名 : &lt;文件名&gt; 
     <br /> 相关文件 : &lt;与此文件相关的其它文件&gt; 
     <br /> 文件实现功能 : &lt;描述该文件实现的主要功能&gt; 
     <br /> 作者 : &lt;作者部门和姓名&gt; 
     <br /> 版本 : &lt;当前版本号&gt; 
     <br /> -------------------------------------------------------------------------------- 
     <br /> 备注 : &lt;其它说明&gt; 
     <br /> -------------------------------------------------------------------------------- 
     <br /> 修改记录 : 
     <br /> 日 期 版本 修改人 修改内容 
     <br /> YYYY/MM/DD X.Y &lt;作者或修改者名&gt; &lt;修改内容&gt; 
     <br /> &lt;/PRE&gt; 
     <br /> *******************************************************************************/ 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 如果该文件有其它需要说明的地方，还可以专门为此扩展一节： 
     <br /> 
     <br /> /*! @file 
     <br /> ******************************************************************************** 
     <br /> &lt;PRE&gt; 
     <br /> 模块名 : &lt;文件所属的模块名称&gt; 
     <br /> 文件名 : &lt;文件名&gt; 
     <br /> 相关文件 : &lt;与此文件相关的其它文件&gt; 
     <br /> 文件实现功能 : &lt;描述该文件实现的主要功能&gt; 
     <br /> 作者 : &lt;作者部门和姓名&gt; 
     <br /> 版本 : &lt;当前版本号&gt; 
     <br /> -------------------------------------------------------------------------------- 
     <br /> 备注 : &lt;其它说明&gt; 
     <br /> -------------------------------------------------------------------------------- 
     <br /> 修改记录 : 
     <br /> 日 期 版本 修改人 修改内容 
     <br /> YYYY/MM/DD X.Y &lt;作者或修改者名&gt; &lt;修改内容&gt; 
     <br /> &lt;/PRE&gt; 
     <br /> ******************************************************************************** 
     <br /> 
     <br /> * 项目1 
     <br /> - 项目1.1 
     <br /> - 项目1.2 
     <br /> 
     <br /> ================================================================================ 
     <br /> * 项目2 
     <br /> - 项目2.1 
     <br /> - 项目2.2 
     <br /> .... 
     <br /> 
     <br /> *******************************************************************************/ 
     <br /> 
     <br /> 
     <br /> 每行注释的长度都不应该超过80个半角字符。还要注意缩进和对其，以利阅读。 
     <br /> 
     <br /> 关于文件头的完整例子，请参见：文件头例子 
     <br /> 
     <br /> 关于文件头的模板，请参见：文件头注释模板 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 头文件 
     <br /> 
     <br /> 头文件通常由以下几部分组成： 
     <br /> 文件头注释 每个头文件，无论是内部的还是外部的，都应该由一个规范的文件头注释作为开始。 
     <br /> 
     <br /> 
     <br /> 预处理块 为了防止头文件被重复引用，应当用ifndef/define/endif结构产生预处理块。 
     <br /> 
     <br /> 
     <br /> 函数和类/结构的声明等 声明模块的接口 
     <br /> 
     <br /> 
     <br /> 需要包含的内联函数定义文件（如果有的话） 如果类中的内联函数较多，或者一个头文件中包含多个类的定义（不推荐），可以将所有内联函数定义放入一个单独的内联函数定义文件中，并在类声明之后用“#include”指令把它包含进来。 
     <br /> 
     <br /> 头文件的编码规则： 
     <br /> 
     <br /> 引用文件的格式 用 #include &lt;filename.h&gt; 格式来引用标准库和系统库的头文件（编译器将从标准库目录开始搜索）。 
     <br /> 用 #include &quot;filename.h&quot; 格式来引用当前工程中的头文件（编译器将从该文件所在目录开始搜索）。 
     <br /> 
     <br /> 
     <br /> 
     <br /> 分割多组接口（如果有的话） 如果在一个头件中定义了多个类或者多组接口（不推荐），为了便于浏览，应该在每个类/每组接口间使用分割带把它们相互分开。 
     <br /> 
     <br /> 关于头文件的完整例子，请参见：头文件例子 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 内联函数定义文件 
     <br /> 
     <br /> 如上所述，在内联函数较多的情况下，为了避免头文件过长、版面混乱，可以将所有的内联函数定义移到一个单独的文件中去，然后再用#include指令将它包含到类声明的后面。这样的文件称为一个内联函数定义文件。 
     <br /> 按照惯例，应该将这个文件命名为“filename.inl”，其中“filename”与相应的头文件和实现文件相同。 
     <br /> 
     <br /> 内联函数定义文件由以下几部分组成： 
     <br /> 
     <br /> 文件头注释 每内联函数定义文件都应该由一个规范的文件头注释作为开始 
     <br /> 内联函数定义 内联函数的实现体 
     <br /> 
     <br /> 内联函数定义文件的编码规则： 
     <br /> 
     <br /> 分割多组接口（如果有的话） 如果在一个内联函数定义文件中定义了多个类或者多组接口的内联函数（不推荐），必须在每个类/每组接口间使用分割带把它们相互分开。 
     <br /> 
     <br /> 
     <br /> 文件组成中为什么没有预处理块？ 与头文件不同，内联函数定义文件通常不需要定义预处理块，这是因为它通常被包含在与其相应的头文件预处理块内。 
     <br /> 
     <br /> 关于内联函数定义文件的完整例子，请参见：内联函数定义文件例子 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 实现文件 
     <br /> 
     <br /> 实现文件包含所有数据和代码的实现体。实现文件的格式为： 
     <br /> 文件头注释 每个实现文件都应该由一个规范的文件头注释作为开始 
     <br /> 
     <br /> 
     <br /> 对配套头文件的引用 引用声明了此文件实现的类、函数及数据的头文件 
     <br /> 
     <br /> 
     <br /> 对一些仅用于实现的头文件的引用（如果有的话） 将仅与实现相关的接口包含在实现文件里（而不是头文件中）是一个非常好的编程习惯。这样可以有效地屏蔽不应该暴露的实现细节，将实现改变对其它模块的影响降低到最少 。 
     <br /> 
     <br /> 
     <br /> 程序的实现体 数据和函数的定义 
     <br /> 
     <br /> 实现文件的编码规则： 
     <br /> 
     <br /> 分割每个部分 在本地（静态）定义和外部定义间，以及不同接口或不同类的实现之间，应使用分割带相互分开。 
     <br /> 
     <br /> 关于实现文件的完整例子，请参见：实现文件例子 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 文件的组织结构 
     <br /> 
     <br /> 由于项目性质、规模上存在着差异，不同项目间的文件组织形式差别很大。但文件、目录组织的基本原则应当是一致的：使外部接口与内部实现尽量分离；尽可能清晰地表达软件的层次结构…… 
     <br /> 为此提供两组典型项目的文件组织结构范例作为参考： 
     <br /> 
     <br /> 功能模块/库的文件组织形式 
     <br /> 显而易见，编写功能模块和库的主要目的是为其它模块提供一套完成特定功能的API，这类项目的文件组织结构通常如下图所示： 
     <br /> 
     <br /> 
     <br /> 其中： 
     <br /> 
     <br /> contrib 当前项目所依赖的所有第三方软件，可以按类别分设子目录。 
     <br /> doc 项目文档 
     <br /> include 声明外部接口的所有头文件和内联定义文件。 
     <br /> lib 编译好的二进制库文件，可以按编译器、平台分设子目录。 
     <br /> makefile 用于编译项目的makefile文件和project文件等。可以按编译器、平台分设子目录。 
     <br /> src 所有实现文件和声明内部接口的头文件、内联定义文件。可按功能划分；支持编译器、平台等类别分设子目录。 
     <br /> test 存放测试用代码的目录。 
     <br /> 
     <br /> 
     <br /> 应用程序的文件组织形式 
     <br /> 与功能模块不同，应用程序是一个交付给最终用于使用的、可以独立运行并提供完整功能的软件产品，它通常不提供编程接口，应用程序的典型文件组织形式如下图所示： 
     <br /> 
     <br /> 
     <br /> contrib 当前项目所依赖的所有第三方软件，可以按类别分设子目录。 
     <br /> doc 项目文档 
     <br /> makefile 用于编译项目的makefile文件和project文件等。可以按编译器、平台分设子目录。 
     <br /> setup 安装程序，以及制作安装程序所需要的项目文件和角本。 
     <br /> src 所有源文件。可按功能划分；支持编译器、平台等类别分设子目录。 
     <br /> test 存放测试用代码的目录。 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> -------------------------------------------------------------------------------- 
     <br /> 
     <br /> 命名规则 
     <br /> 如果想要有效的管理一个稍微复杂一点的体系，针对其中事物的一套统一、带层次结构、清晰明了的命名准则就是必不可少而且非常好用的工具。 
     <br /> 活跃在生物学、化学、军队、监狱、黑社会、恐怖组织等各个领域内的大量有识先辈们都曾经无数次地以实际行动证明了以上公理的正确性。除了上帝（设它可以改变世间万物的秩序）以外，相信没人有实力对它不屑一顾 
     <br /> 
     <br /> 在软件开发这一高度抽象而且十分复杂的活动中，命名规则的重要性更显得尤为突出。一套定义良好并且完整的、在整个项目中统一使用的命名规范将大大提升源代码的可读性和软件的可维护性。 
     <br /> 
     <br /> 在引入细节之前，先说明一下命名规范的整体原则： 
     <br /> 
     <br /> 同一性 在编写一个子模块或派生类的时候，要遵循其基类或整体模块的命名风格，保持命名风格在整个模块中的同一性。 
     <br /> 
     <br /> 
     <br /> 标识符组成 标识符采用英文单词或其组合，应当直观且可以拼读，可望文知意，用词应当准确。 
     <br /> 
     <br /> 
     <br /> 最小化长度 &amp;&amp; 最大化信息量原则 在保持一个标识符意思明确的同时，应当尽量缩短其长度。 
     <br /> 
     <br /> 
     <br /> 避免过于相似 不要出现仅靠大小写区分的相似的标识符，例如“i”与“I”，“function”与“Function”等等。 
     <br /> 
     <br /> 
     <br /> 避免在不同级别的作用域中重名 程序中不要出现名字完全相同的局部变量和全局变量，尽管两者的作用域不同而不会发生语法错误，但容易使人误解。 
     <br /> 
     <br /> 
     <br /> 正确命名具有互斥意义的标识符 用正确的反义词组命名具有互斥意义的标识符，如：&quot;nMinValue&quot; 和 &quot;nMaxValue&quot;，&quot;GetName()&quot; 和 &quot;SetName()&quot; .... 
     <br /> 
     <br /> 
     <br /> 避免名字中出现数字编号 尽量避免名字中出现数字编号，如Value1,Value2等，除非逻辑上的确需要编号。这是为了防止程序员偷懒，不肯为命名动脑筋而导致产生无意义的名字（因为用数字编号最省事）。 
     <br /> 
     <br /> 
     <br /> 类/结构 
     <br /> 
     <br /> 除了异常类等个别情况（不希望用户把该类看作一个普通的、正常的类之情况）外，C++类/结构的命名应该遵循以下准则： 
     <br /> C++类/结构的命名 类的名称都要以大写字母“C”开头，后跟一个或多个单词。为便于界定，每个单词的首字母要大写。 
     <br /> 
     <br /> 
     <br /> 推荐的组成形式 类的命名推荐用&quot;名词&quot;或&quot;形容词＋名词&quot;的形式，例如：&quot;CAnalyzer&quot;, &quot;CFastVector&quot; .... 
     <br /> 
     <br /> 不同于C++类的概念，传统的C结构体只是一种将一组数据捆绑在一起的方式。传统C结构体的命名规则为： 
     <br /> 
     <br /> 传统C结构体的命名 传统C结构体的名称全部由大写字母组成，单词间使用下划线界定，例如：&quot;SERVICE_STATUS&quot;, &quot;DRIVER_INFO&quot; .... 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 函数 
     <br /> 
     <br /> 函数的命名 函数的名称由一个或多个单词组成。为便于界定，每个单词的首字母要大写。 
     <br /> 
     <br /> 
     <br /> 推荐的组成形式 函数名应当使用&quot;动词&quot;或者&quot;动词＋名词&quot;（动宾词组）的形式。例如：&quot;GetName()&quot;, &quot;SetValue()&quot;, &quot;Erase()&quot;, &quot;Reserve()&quot; .... 
     <br /> 
     <br /> 
     <br /> 保护成员函数 保护成员函数的开头应当加上一个下划线“_”以示区别，例如：&quot;_SetState()&quot; .... 
     <br /> 
     <br /> 
     <br /> 私有成员函数 类似地，私有成员函数的开头应当加上两个下划线“__”，例如：&quot;__DestroyImp()&quot; .... 
     <br /> 
     <br /> 
     <br /> 虚函数 虚函数习惯以“Do”开头，如：&quot;DoRefresh()&quot;, &quot;_DoEncryption()&quot; .... 
     <br /> 
     <br /> 
     <br /> 回调和事件处理函数 回调和事件处理函数习惯以单词“On”开头。例如：&quot;_OnTimer()&quot;, &quot;OnExit()&quot; .... 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 变量 
     <br /> 
     <br /> 变量应该是程序中使用最多的标识符了，变量的命名规范可能是一套C++命名准则中最重要的部分： 
     <br /> 
     <br /> 变量的命名 变量名由作用域前缀＋类型前缀＋一个或多个单词组成。为便于界定，每个单词的首字母要大写。 
     <br /> 对于某些用途简单明了的局部变量，也可以使用简化的方式，如：i, j, k, x, y, z .... 
     <br /> 
     <br /> 
     <br /> 
     <br /> 作用域前缀 作用域前缀标明一个变量的可见范围。作用域可以有如下几种： 
     <br /> 前缀 说明 
     <br /> 无 局部变量 
     <br /> m_ 类的成员变量（member） 
     <br /> sm_ 类的静态成员变量（static member） 
     <br /> s_ 静态变量（static） 
     <br /> g_ 外部全局变量（global） 
     <br /> sg_ 静态全局变量（static global） 
     <br /> gg_ 进程间共享的共享数据段全局变量（global global） 
     <br /> 
     <br /> 除非不得已，否则应该尽可能少使用全局变量。 
     <br /> 
     <br /> 
     <br /> 
     <br /> 类型前缀 类型前缀标明一个变量的类型，可以有如下几种： 
     <br /> 前缀 说明 
     <br /> n 整型和位域变量（number） 
     <br /> e 枚举型变量（enumeration） 
     <br /> c 字符型变量（char） 
     <br /> b 布尔型变量（bool） 
     <br /> f 浮点型变量（float） 
     <br /> p 指针型变量和迭代子（pointer） 
     <br /> pfn 特别针对指向函数的指针变量和函数对象指针（pointer of function） 
     <br /> g 数组（grid） 
     <br /> i 类的实例（instance） 
     <br /> 对于经常用到的类，也可以定义一些专门的前缀，如：std::string和std::wstring类的前缀可以定义为&quot;st&quot;，std::vector类的前缀可以定义为&quot;v&quot;等等。 
     <br /> 
     <br /> 
     <br /> 类型前缀可以组合使用，例如&quot;gc&quot;表示字符数组，&quot;ppn&quot;表示指向整型的指针的指针等等。 
     <br /> 
     <br /> 
     <br /> 
     <br /> 推荐的组成形式 变量的名字应当使用&quot;名词&quot;或者&quot;形容词＋名词&quot;。例如：&quot;nCode&quot;, &quot;m_nState&quot;，&quot;nMaxWidth&quot; .... 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 常量 
     <br /> 
     <br /> C++中引入了对常量的支持，常量的命名规则如下： 
     <br /> 
     <br /> 常量的命名 常量名由类型前缀＋全大写字母组成，单词间通过下划线来界定，如：cDELIMITER, nMAX_BUFFER .... 
     <br /> 类型前缀的定义与变量命名规则中的相同。 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 枚举、联合、typedef 
     <br /> 
     <br /> 枚举、联合及typedef语句都是定义新类型的简单手段，它们的命名规则为： 
     <br /> 
     <br /> 枚举、联合、typedef的命名 枚举、联合、typedef语句生成的类型名由全大写字母组成，单词间通过下划线来界定，如：FAR_PROC, ERROR_TYPE .... 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 宏、枚举值 
     <br /> 
     <br /> 宏、枚举值的命名 宏和枚举值由全大写字母组成，单词间通过下划线来界定，如：ERROR_UNKNOWN, OP_STOP .... 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 名空间 
     <br /> 
     <br /> C++名空间是“类”概念的一种退化（相当于只包含静态成员且不能实例化的类）。它的引入为标识符名称提供了更好的层次结构，使标识符看起来更加直观简捷，同时大大降低了名字冲突的可能性。 
     <br /> 名空间的命名规则包括： 
     <br /> 
     <br /> 名空间的命名 名空间的名称不应该过长，通常都使用缩写的形式来命名。 
     <br /> 例如，一个图形库可以将其所有外部接口存放在名空间&quot;GLIB&quot;中，但是将其换成&quot;GRAPHIC_LIBRARY&quot;就不大合适。 
     <br /> 
     <br /> 如果碰到较长的名空间，为了简化程序书写，可以使用： 
     <br /> 
     <br /> namespace new_name = old_long_name; 
     <br /> 
     <br /> 语句为其定义一个较短的别名。 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> -------------------------------------------------------------------------------- 
     <br /> 
     <br /> 代码风格与版式 
     <br /> 代码风格的重要性怎么强调都不过分。一段稍长一点的无格式代码基本上是不可读的。 
     <br /> 先来看一下这方面的整体原则： 
     <br /> 
     <br /> 空行的使用 空行起着分隔程序段落的作用。空行得体（不过多也不过少）将使程序的布局更加清晰。空行不会浪费内存，虽然打印含有空行的程序是会多消耗一些纸张，但是值得。所以不要舍不得用空行。 
     <br /> 在每个类声明之后、每个函数定义结束之后都要加2行空行。 
     <br /> 
     <br /> 在一个函数体内，逻揖上密切相关的语句之间不加空行，其它地方应加空行分隔。 
     <br /> 
     <br /> 语句与代码行 一行代码只做一件事情，如只定义一个变量，或只写一条语句。这样的代码容易阅读，并且方便于写注释。 
     <br /> 
     <br /> &quot;if&quot;、&quot;for&quot;、&quot;while&quot;、&quot;do&quot;、&quot;try&quot;、&quot;catch&quot; 等语句自占一行，执行语句不得紧跟其后。不论执行语句有多少都要加 &quot;{ }&quot; 。这样可以防止书写失误。 
     <br /> 
     <br /> 缩进和对齐 程序的分界符 &quot;{&quot; 和 &quot;}&quot; 应独占一行并且位于同一列，同时与引用它们的语句左对齐。 
     <br /> 
     <br /> &quot;{ }&quot; 之内的代码块在 &quot;{&quot; 右边一个制表符（4个半空格符）处左对齐。如果出现嵌套的 &quot;{ }&quot;，则使用缩进对齐。 
     <br /> 
     <br /> 如果一条语句会对其后的多条语句产生影响的话，应该只对该语句做半缩进（2个半角空格符），以突出该语句。 
     <br /> 例如： 
     <br /> 
     <br /> void 
     <br /> Function(int x) 
     <br /> { 
     <br /> CSessionLock iLock(*m_psemLock); 
     <br /> 
     <br /> for (初始化; 终止条件; 更新) 
     <br /> { 
     <br /> // ... 
     <br /> } 
     <br /> 
     <br /> try 
     <br /> { 
     <br /> // ... 
     <br /> } 
     <br /> catch (const exception&amp; err) 
     <br /> { 
     <br /> // ... 
     <br /> } 
     <br /> catch (...) 
     <br /> { 
     <br /> // ... 
     <br /> } 
     <br /> 
     <br /> // ... 
     <br /> } 
     <br /> 
     <br /> 
     <br /> 
     <br /> 最大长度 代码行最大长度宜控制在70至80个字符以内。代码行不要过长，否则眼睛看不过来，也不便于打印。 
     <br /> 
     <br /> 
     <br /> 长行拆分 长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首（以便突出操作符）。拆分出的新行要进行适当的缩进，使排版整齐，语句可读。 
     <br /> 例如： 
     <br /> 
     <br /> if ((very_longer_variable1 &gt;= very_longer_variable2) 
     <br /> &amp;&amp; (very_longer_variable3 &lt;= very_longer_variable4) 
     <br /> &amp;&amp; (very_longer_variable5 &lt;= very_longer_variable6)) 
     <br /> { 
     <br /> dosomething(); 
     <br /> } 
     <br /> 
     <br /> 
     <br /> 
     <br /> 空格的使用 关键字之后要留空格。象 &quot;const&quot;、&quot;virtual&quot;、&quot;inline&quot;、&quot;case&quot; 等关键字之后至少要留一个空格，否则无法辨析关键字。象 &quot;if&quot;、&quot;for&quot;、&quot;while&quot;、&quot;catch&quot; 等关键字之后应留一个空格再跟左括号 &quot;(&quot;，以突出关键字。 
     <br /> 
     <br /> 函数名之后不要留空格，紧跟左括号 &quot;(&quot; ，以与关键字区别。 
     <br /> 
     <br /> &quot;(&quot; 向后紧跟。而 &quot;)&quot;、&quot;,&quot;、&quot;;&quot; 向前紧跟，紧跟处不留空格。 
     <br /> 
     <br /> &quot;,&quot; 之后要留空格，如 Function(x, y, z)。如果 &quot;;&quot; 不是一行的结束符号，其后要留空格，如 for (initialization; condition; update)。 
     <br /> 
     <br /> 赋值操作符、比较操作符、算术操作符、逻辑操作符、位域操作符，如&quot;=&quot;、&quot;+=&quot; &quot;&gt;=&quot;、&quot;&lt;=&quot;、&quot;+&quot;、&quot;*&quot;、&quot;%&quot;、&quot;&amp;&amp;&quot;、&quot;||&quot;、&quot;&lt;&lt;&quot;, &quot;^&quot; 等二元操作符的前后应当加空格。 
     <br /> 
     <br /> 一元操作符如 &quot;!&quot;、&quot;~&quot;、&quot;++&quot;、&quot;--&quot;、&quot;&amp;&quot;（地址运算符）等前后不加空格。 
     <br /> 
     <br /> 象&quot;[]&quot;、&quot;.&quot;、&quot;-&gt;&quot;这类操作符前后不加空格。 
     <br /> 
     <br /> 对于表达式比较长的for、do、while、switch语句和if语句，为了紧凑起见可以适当地去掉一些空格，如for (i=0; i&lt;10; i++)和if ((a&lt;=b) &amp;&amp; (c&lt;=d)) 
     <br /> 例如： 
     <br /> 
     <br /> void Func1(int x, int y, int z); // 良好的风格 
     <br /> void Func1 (int x,int y,int z); // 不良的风格 
     <br /> 
     <br /> // =========================================================== 
     <br /> if (year &gt;= 2000) // 良好的风格 
     <br /> if(year&gt;=2000) // 不良的风格 
     <br /> if ((a&gt;=b) &amp;&amp; (c&lt;=d)) // 良好的风格 
     <br /> if(a&gt;=b&amp;&amp;c&lt;=d) // 不良的风格 
     <br /> 
     <br /> // =========================================================== 
     <br /> for (i=0; i&lt;10; i++) // 良好的风格 
     <br /> for(i=0;i&lt;10;i++) // 不良的风格 
     <br /> for (i = 0; I &lt; 10; i ++) // 过多的空格 
     <br /> 
     <br /> // =========================================================== 
     <br /> x = a &lt; b ? a : b; // 良好的风格 
     <br /> x=a&lt;b?a:b; // 不好的风格 
     <br /> 
     <br /> // =========================================================== 
     <br /> int* x = &amp;y; // 良好的风格 
     <br /> int * x = &amp; y; // 不良的风格 
     <br /> 
     <br /> // =========================================================== 
     <br /> array[5] = 0; // 不要写成 array [ 5 ] = 0; 
     <br /> a.Function(); // 不要写成 a . Function(); 
     <br /> b-&gt;Function(); // 不要写成 b -&gt; Function(); 
     <br /> 
     <br /> 
     <br /> 
     <br /> 修饰符的位置 为便于理解，应当将修饰符 &quot;*&quot; 和 &quot;&amp;&quot; 紧靠数据类型。 
     <br /> 例如： 
     <br /> 
     <br /> char* name; 
     <br /> 
     <br /> int* x, 
     <br /> y; // 为避免y被误解为指针，这里必须分行写。 
     <br /> 
     <br /> int* Function(void* p); 
     <br /> 
     <br /> 参见：变量、常量的风格与版式 -&gt; 指针或引用类型的定义和声明 
     <br /> 
     <br /> 
     <br /> 
     <br /> 注释 注释的位置应与被描述的代码相邻，可以放在代码的上方或右方，不可放在下方。 
     <br /> 边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。 
     <br /> 注释应当准确、易懂，防止注释有二义性。错误的注释不但无益反而有害。 
     <br /> 当代码比较长，特别是有多重嵌套时，应当在一些段落的结束处加注释，便于阅读。 
     <br /> 
     <br /> 与常量的比较 在与宏、常量进行 &quot;==&quot;, &quot;!=&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot; 等比较运算时，应当将常量写在运算符左边，而变量写在运算符右边。这样可以避免因为偶然写错把比较运算变成了赋值运算的问题。 
     <br /> 例如： 
     <br /> 
     <br /> if (NULL == p) // 如果把 &quot;==&quot; 错打成 &quot;=&quot;，编译器就会报错 
     <br /> { 
     <br /> // ... 
     <br /> } 
     <br /> 
     <br /> 
     <br /> 
     <br /> 为增强代码的可读性而定义的宏 以下预定义宏对程序的编译没有任何影响，只为了增加代码的可读性： 
     <br /> 宏 说明 
     <br /> NOTE 需要注意的代码 
     <br /> TODO 尚未实现的接口、类、算法等 
     <br /> FOR_DBG 标记为调试方便而临时增加的代码 
     <br /> OK 仅用于调试的标记 
     <br /> 
     <br /> 例如： 
     <br /> 
     <br /> TODO class CMyClass; 
     <br /> TODO void Function(void); 
     <br /> 
     <br /> FOR_DBG cout &lt;&lt; &quot;...&quot;; 
     <br /> 
     <br /> 
     <br /> 
     <br /> 
     <br /> 类/结构 
     <br /> 
     <br /> 类是C++中最重要也是使用频率最高的新特性之一。类的版式好坏将极大地影响代码品质。 
     <br /> 注释头与类声明 与文件一样，每个类应当有一个注释头用来说明该类的各个方面。 
     <br /> 类声明换行紧跟在注释头后面，&quot;class&quot; 关键字由行首开始书写，后跟类名称。界定符 &quot;{&quot; 和 &quot;};&quot; 应独占一行，并与 &quot;class&quot; 关键字左对其。 
     <br /> 
     <br /> /*! @class 
     <br /> ******************************************************************************** 
     <br /> &lt;PRE&gt; 
     <br /> 类名称 : CXXX 
     <br /> 功能 : &lt;简要说明该类所完成的功能&gt; 
     <br /> 异常类 : &lt;属于该类的异常类（如果有的话）&gt; 
     <br /> -------------------------------------------------------------------------------- 
     <br /> 备注 : &lt;使用该类时需要注意的问题（如果有的话）&gt; 
     <br /> 典型用法 : &lt;如果该类的使用方法较复杂或特殊，给出典型的代码例子&gt; 
     <br /> -------------------------------------------------------------------------------- 
     <br /> 作者 : &lt;xxx&gt; 
     <br /> &lt;/PRE&gt; 
     <br /> *******************************************************************************/ 
     <br /> class CXXX 
     <br /> { 
     <br /> // ... 
     <br /> }; 
     <br /> 
     <br /> 对于功能明显的简单类（接口小于10个），也可以使用简单的单行注释头： 
     <br /> 
     <br /> //! &lt;简要说明该类所完成的功能&gt; 
     <br /> class CXXX 
     <br /> { 
     <br /> // ... 
     <br /> }; 
     <br /> 
     <br /> 
     <br /> 
     <br /> 继承 基类直接跟在类名称之后，不换行，访问说明符（public, private, 或protected）不可省略。如： 
     <br /> class CXXX : public CAAA, private CBBB 
     <br /> { 
     <br /> // ... 
     <br /> }; 
     <br /> 
     <br /> 
     <br /> 
     <br /> 以行为为中心 没人喜欢上来就看到一大堆私有数据，大多数用户关心的是类的接口与其提供的服务，而不是其实现。 
     <br /> 所以应当将公有的定义和成员放在类声明的最前面，保护的放在中间，而私有的摆在最后。 
     <br /> 
     <br /> 
     <br /> 
     <br /> 访问说明符 访问说明符（public, private, 或protected）应该独占一行，并与类声明中的‘class’关键字左对其。 
     <br /> 
     <br /> 
     <br /> 类成员的声明版式 对于比较复杂（成员多于20个）的类，其成员必须分类声明。 
     <br /> 每类成员的声明由访问说明符（public, private, 或protected）+ 全行注释开始。注释不满全行（80个半角字符）的，由 &quot;/&quot; 字符补齐，最后一个 &quot;/&quot; 字符与注释间要留一个半角空格符。 
     <br /> 
     <br /> 如果一类声明中有很多组功能不同的成员，还应该用分组注释将其分组。分组注释也要与 &quot;class&quot; 关键字对其。 
     <br /> 
     <br /> 每个成员的声明都应该由 &quot;class&quot; 关键字开始向右缩进一个制表符（4个半角空格符），成员之间左对其。 
     <br /> 
     <br /> 例如： 
     <br /> 
     <br /> class CXXX 
     <br /> { 
     <br /> public: 
     <br /> /////////////////////////////////////////////////////////////////////// 类型定义 
     <br /> typedef vector&lt;string&gt; VSTR; 
     <br /> 
     <br /> public: 
     <br /> ///////////////////////////////////////////////////////////// 构造、析构、初始化 
     <br /> CXXX(); 
     <br /> ~CXXX(); 
     <br /> 
     <br /> public: 
     <br /> /////////////////////////////////////////////////////////////////////// 公用方法 
     <br /> 
     <br /> // [[ 功能组1 
     <br /> void Function1(void) const; 
     <br /> long Function2(IN int n); 
     <br /> // ]] 功能组1 
     <br /> 
     <br /> // [[ 功能组2 
     <br /> void Function3(void) const; 
     <br /> bool Function4(OUT int&amp; n); 
     <br /> // ]] 功能组2 
     <br /> 
     <br /> private: 
     <br /> /////////////////////////////////////////////////////////////////////////// 属性 
     <br /> // ... 
     <br /> 
     <br /> private: 
     <br /> ///////////////////////////////////////////////////////////////////// 禁用的方法 
     <br /> // 禁止复制 
     <br /> CXXX(IN const CXXX&amp; rhs); 
     <br /> CXXX&amp; operator=(IN const CXXX&amp; rhs); 
     <br /> }; 
     <br /> 
     <br /> 
     <br /> 
     <br /> 正确地使用const和mutable 把不改变对象逻辑状态的成员都标记为const成员不仅有利于用户对成员的理解，更可以最大化对象使用方式的灵活性及合理性（比如通过const指针或const引用的形式传递一个对象）。 
     <br /> 如果某个属性的改变并不影响该对象逻辑上的状态，而且这个属性需要在const方法中被改变，则该属性应该标记为 &quot;mutable&quot;。 
     <br /> 
     <br /> 例如： 
     <br /> 
     <br /> class CString 
     <br /> { 
     <br /> public: 
     <br /> //! 查找一个子串，find()不会改变字符串的值所以为const函数 
     <br /> int find(IN const CString&amp; str) const; 
     <br /> // ... 
     <br /> 
     <br /> private: 
     <br /> // 最后一次错误值，改动这个值不会影响对象的逻辑状态， 
     <br /> // 像find()这样的const函数也可能修改这个值 
     <br /> mutable int m_nLastError; 
     <br /> // ... 
     <br /> }; 
     <br /> 
     <br /> 
     <br /> 
     <br /> 嵌套的类声明 在相应的逻辑关系确实存在时，类声明可以嵌套。嵌套类可以使用简单的单行注释头： 
     <br /> class CXXX 
     <br /> { 
     <br /> //! 嵌套类说明 
     <br /> calss CYYY 
     <br /> { 
     <br /> // ... 
     <br /> }; 
     <br /> }; 
     <br /> 
     <br /> 
     <br /> 
     <br /> 初始化列表 应当尽可能通过构造函数的初始化列表来初始化成员和基类。初始化列表至少独占一行，并且与构造函数的定义保持一个制表符（4个半角空格）的缩进。 
     <br /> 例如： 
     <br /> 
     <br /> CXXX::CXXXX(IN int nA, IN bool bB) 
     <br /> : m_nA(nA), m_bB(bB) 
     <br /> { 
     <br /> // ... 
     <br /> }; 
     <br /> 
     <br /> 
     <br /> 
     <br /> 初始化列表的书写顺序应当与对象的构造顺序一致，即：先按照声明顺序写基
    </div> </td> 
  </tr> 
 </tbody> 
</table> 
<a href="http://hi.baidu.com/tieshashi/blog">http://hi.baidu.com/tieshashi/blog</a></div></body></html>