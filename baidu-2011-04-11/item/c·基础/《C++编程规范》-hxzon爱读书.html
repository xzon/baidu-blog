<html><head><title>《C++编程规范》-hxzon爱读书</title></head><body><div id='tit'>《C++编程规范》-hxzon爱读书</div><div id='cate'>c&middot;基础</div><div id='date'>2007年12月16日 星期日 08:49 A.M.</div><div id='page'>185</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/6c45c81b4d1b0af9af5133d8.html'>http://hi.baidu.com/hxzon/blog/item/6c45c81b4d1b0af9af5133d8.html</a><div id='cnt'><span class="STYLE2"><font size="5"><strong>《C++编程规范》-hxzon爱读书</strong></font></span>
<span class="m"><strong><font color="#ff0000"><br /> </font></strong>Herb Sutter, Andrei Alexandrescu 著<br /> 刘基诚 译<br /> 人民邮电出版社图灵公司<br /> 定价： 35.00元<br /> </span> 
<p class="s" align="left"><span class="m">本书特色：C++编程标准，程序员案头必备，软件学院师生必读</span></p> 
<span class="m"> 
 <div class="STYLE2" align="left">
  作者简介
 </div> 
 <hr color="#d1d1d1" size="1" width="100%" /> <p class="s" align="left"> </p>
 <table class="FCK__ShowTableBorders" border="0" width="100%"> 
  <tbody> 
   <tr> 
    <td valign="top"> <p class="m" align="left">Herb Sutter 是 ISO C++ 标准委员会主席，《C++ Users Journal》杂志特邀编辑和专栏作家。他目前在微软公司领导 .NET 环境下 C++ 语言扩展的设计工作。除本书外，他还撰写了三本广受赞誉的图书：《Exceptional C++ Style》 (中文版即将由人民邮电出版社出版) 、《Exceptional C++》和《More Exceptional C++》。Andrei Alexandrescu 是世界顶尖的 C++ 专家，《C++ Users Journal》杂志的专栏作家，他的《Modern C++ Design》一书曾荣获 2001 年最佳 C++ 图书称号。书中所开发的 Loki 已经成为最负盛名的 C++ 程序库之一。</p> </td> 
   </tr> 
  </tbody> 
 </table>  
 <div class="STYLE2" align="left">
  目录
 </div> 
 <hr color="#d1d1d1" size="1" width="100%" /> 
 <table class="FCK__ShowTableBorders" border="0" width="100%"> 
  <tbody> 
   <tr> 
    <td valign="top"> <p>组织和策略问题 1<br /> 第0条 不要拘泥于小节（又名：了解哪些东西不应该标准化） 2<br /> 第1条 在高警告级别干净利落地进行编译 4<br /> 第2条 使用自动构建系统 7<br /> 第3条 使用版本控制系统 8<br /> 第4条 在代码审查上投入 9<br /> 设计风格 11<br /> 第5条 一个实体应该只有一个紧凑的职责 12<br /> 第6条 正确、简单和清晰第一 13<br /> 第7条 编程中应知道何时和如何考虑可伸缩性 14<br /> 第8条 不要进行不成熟的优化 16<br /> 第9条 不要进行不成熟的劣化 18<br /> 第10条 尽量减少全局和共享数据 19<br /> 第11条 隐藏信息 20<br /> 第12条 懂得何时和如何进行并发性编程 21<br /> 第13条 确保资源为对象所拥有。使用显式的RAII和智能指针 24<br /> 编程风格 27<br /> 第14条 宁要编译时和连接时错误，也不要运行时错误 28<br /> 第15条 积极使用const 30<br /> 第16条 避免使用宏 32<br /> 第17条 避免使用“魔数” 34<br /> 第18条 尽可能局部地声明变量 35<br /> 第19条 总是初始化变量 36<br /> 第20条 避免函数过长，避免嵌套过深 38<br /> 第21条 避免跨编译单元的初始化依赖 39<br /> 第22条 尽量减少定义性依赖。避免循环依赖 40<br /> 第23条 头文件应该自给自足 42<br /> 第24条 总是编写内部#include保护符，决不要编写外部#include保护符 43<br /> 函数与操作符 45<br /> 第25条 正确地选择通过值、（智能）指针或者引用传递参数 46<br /> 第26条 保持重载操作符的自然语义 47<br /> 第27条 优先使用算术操作符和赋值操作符的标准形式 48<br /> 第28条 优先使用++和- -的标准形式。优先调用前缀形式 50<br /> 第29条 考虑重载以避免隐含类型转换 51<br /> 第30条 避免重载&amp;&amp;、||或 ,（逗号） 52<br /> 第31条 不要编写依赖于函数参数求值顺序的代码 54<br /> 类的设计与继承 55<br /> 第32条 弄清所要编写的是哪种类 56<br /> 第33条 用小类代替巨类 57<br /> 第34条 用组合代替继承 58<br /> 第35条 避免从并非要设计成基类的类中继承 60<br /> 第36条 优先提供抽象接口 62<br /> 第37条 公用继承即可替换性。继承，不是为了重用，而是为了被重用 64<br /> 第38条 实施安全的改写 66<br /> 第39条 考虑将虚拟函数声明为非公用的，将公用函数声明为非虚拟的 68<br /> 第40条 要避免提供隐式转换 70<br /> 第41条 将数据成员设为私有的，无行为的聚集（C语言形式的struct）除外 72<br /> 第42条 不要公开内部数据 74<br /> 第43条 明智地使用Pimpl 76<br /> 第44条 优先编写非成员非友元函数 79<br /> 第45条 总是一起提供new和delete 80<br /> 第46条 如果提供类专门的new，应该提供所有标准形式（普通、就地和不抛出） 82<br /> 构造、析构与复制 85<br /> 第47条 以同样的顺序定义和初始化成员变量 86<br /> 第48条 在构造函数中用初始化代替赋值 87<br /> 第49条 避免在构造函数和析构函数中调用虚拟函数 88<br /> 第50条 将基类析构函数设为公用且虚拟的，或者保护且非虚拟的 90<br /> 第51条 析构函数、释放和交换绝对不能失败 92<br /> 第52条 一致地进行复制和销毁 94<br /> 第53条 显式地启用或者禁止复制 95<br /> 第54条 避免切片。在基类中考虑用克隆代替复制 96<br /> 第55条 使用赋值的标准形式 99<br /> 第56条 只要可行，就提供不会失败的swap（而且要正确地提供） 100<br /> 名字空间与模块 103<br /> 第57条 将类型及其非成员函数接口置于同一名字空间中 104<br /> 第58条 应该将类型和函数分别置于不同的名字空间中，除非有意想让它们<br /> 一起工作 106<br /> 第59条 不要在头文件中或者#include之前编写名字空间using 108<br /> 第60条 要避免在不同的模块中分配和释放内存 111<br /> 第61条 不要在头文件中定义具有链接的实体 112<br /> 第62条 不要允许异常跨越模块边界传播 114<br /> 第63条 在模块的接口中使用具有良好可移植性的类型 116<br /> 模板与泛型 119<br /> 第64条 理智地结合静态多态性和动态多态性 120<br /> 第65条 有意地进行显式自定义 122<br /> 第66条 不要特化函数模板 126<br /> 第67条 不要无意地编写不通用的代码 128<br /> 错误处理与异常 129<br /> 第68条 广泛地使用断言记录内部假设和不变式 130<br /> 第69条 建立合理的错误处理策略，并严格遵守 132<br /> 第70条 区别错误与非错误 134<br /> 第71条 设计和编写错误安全代码 137<br /> 第72条 优先使用异常报告错误 140<br /> 第73条 通过值抛出，通过引用捕获 144<br /> 第74条 正确地报告、处理和转换错误 145<br /> 第75条 避免使用异常规范 146</p> <p>STL：容器 149<br /> 第76条 默认时使用vector。否则，选择其他合适的容器 150<br /> 第77条 用vector和string代替数组 152<br /> 第78条 使用vector（和string::c_str）与非C++ API交换数据 153<br /> 第79条 在容器中只存储值和智能指针 154<br /> 第80条 用push_back代替其他扩展序列的方式 155<br /> 第81条 多用范围操作，少用单元素操作 156<br /> 第82条 使用公认的惯用法真正地压缩容量，真正地删除元素 157<br /> STL：算法 159<br /> 第83条 使用带检查的STL实现 160<br /> 第84条 用算法调用代替手工编写的循环 162<br /> 第85条 使用正确的STL查找算法 165<br /> 第86条 使用正确的STL排序算法 166<br /> 第87条 使谓词成为纯函数 168<br /> 第88条 算法和比较器的参数应多用函数对象少用函数 170<br /> 第89条 正确编写函数对象 172<br /> 类型安全 173<br /> 第90条 避免使用类型分支，多使用多态 174<br /> 第91条 依赖类型，而非其表示方式 176<br /> 第92条 避免使用reinterpret_cast 177<br /> 第93条 避免对指针使用static_cast 178<br /> 第94条 避免强制转换const 179<br /> 第95条 不要使用C风格的强制转换 180<br /> 第96条 不要对非POD进行memcpy操作或者memcmp操作 182<br /> 第97条 不要使用联合重新解释表示方式 183<br /> 第98条 不要使用可变长参数（...） 184<br /> 第99条 不要使用失效对象。不要使用不安全函数 185<br /> 第100条 不要多态地处理数组 186<br /> 参考文献 187<br /> 摘要汇总 193<br /> 索引 20</p> </td> 
   </tr> 
  </tbody> 
 </table> </span></div></body></html>