<html><head><title>stdafx.h、stdafx.cpp的作用</title></head><body><div id='tit'>stdafx.h、stdafx.cpp的作用</div><div id='cate'>c&middot;库</div><div id='date'>2007年12月15日 星期六 04:54 P.M.</div><div id='page'>186</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/166e57da9caeccd8b7fd4877.html'>http://hi.baidu.com/hxzon/blog/item/166e57da9caeccd8b7fd4877.html</a><div id='cnt'><div class="tit">
 stdafx.h、stdafx.cpp的作用
</div> 
<div class="date"> 
</div> 
<table style="table-layout: fixed" class="FCK__ShowTableBorders"> 
 <tbody> 
  <tr> 
   <td> 
    <div class="cnt"> 
     <p>stdafx.h、stdafx.cpp是干什么用的？为什么我的每一个cpp文件都必须包含stdafx.h？</p> 
     <p>Windows和MFC的include文件都非常大，即使有一个快速的处理程序，编译程序也要花费相当长的时间来完成工作。由于每个.CPP文件都包含相同的include文件，为每个.CPP文件都重复处理这些文件就显得很傻了。 <br /> 为避免这种浪费，AppWizard和Visual C++编译程序一起进行工作，如下所示： <br /> ◎AppWizard建立了文件stdafx.h，该文件包含了所有当前工程文件需要的MFC include文件。且这一文件可以随被选择的选项而变化。 <br /> ◎AppWizard然后就建立stdafx.cpp。这个文件通常都是一样的。 <br /> ◎然后AppWizard就建立起工程文件，这样第一个被编译的文件就是stdafx.cpp。 <br /> ◎当Visual C++编译stdafx.cpp文件时，它将结果保存在一个名为stdafx.pch的文件里。 (扩展名pch表示预编译头文件。) <br /> ◎当Visual C++编译随后的每个.cpp文件时，它阅读并使用它刚生成的.pch文件。 Visual C++不再分析Windows include文件，除非你又编缉了stdafx.cpp或stdafx.h。 <br /> 这个技术很精巧，你不这么认为吗？(还要说一句，Microsoft并非是首先采用这种技术的公司，Borland才是。) 在这个过程中你必须遵守以下规则： <br /> ◎你编写的任何.cpp文件都必须首先包含stdafx.h。 <br /> ◎如果你有工程文件里的大多数.cpp文件需要.h文件，顺便将它们加在stdafx.h (后部)上，然后预编译stdafx.cpp。 <br /> ◎由于.pch文件具有大量的符号信息，它是你的工程文件里最大的文件。 <br /> 如果你的磁盘空间有限，你就希望能将这个你从没使用过的工程文件中的.pch文件删除。执行程序时并不需要它们，且随着工程文件的重新建立，它们也自动地重新建立。</p> 
    </div> </td> 
  </tr> 
 </tbody> 
</table></div></body></html>