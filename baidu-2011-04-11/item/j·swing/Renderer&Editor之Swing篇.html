<html><head><title>Renderer&amp;Editor之Swing篇</title></head><body><div id='tit'>Renderer&amp;Editor之Swing篇</div><div id='cate'>j&middot;swing</div><div id='date'>2011年02月15日 星期二 10:06 P.M.</div><div id='page'>1</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/1c607dcb99401b0cbe09e6a1.html'>http://hi.baidu.com/hxzon/blog/item/1c607dcb99401b0cbe09e6a1.html</a><div id='cnt'><p></p>
<p><span>Renderer&amp;Editor之Swing篇</span></p> 
<p><span>2009年7月10日</span></p> 
<p>http://twaver.servasoft.com/?p=461</p> 
<p><a href="http://twaver.servasoft.com/?p=461">Renderer&amp;Editor之Swing篇（一）</a></p> 
<p>renderer 和editor的机制的掌握对于能否灵活深入使用Swing、Flex、Silverlight包括Web组件尤为重要，但 renderer和editor的机制对于初学者而已的确有一定的门槛，甚至可以说有相当的UI开发者纵使简历上赫然写着具备N年UI开发经验，当你面试 问及renderer和editor原理是很多人是一头雾水，更有甚者会反过来问你啥叫“renderer”？啥叫“editor”？即使听过的大部分也 是一知半解，他会敷衍的回答：“不就是表格上的那个什么什么..”，更别提现场让他写个哪怕是bool的check类型的renderer和 edtior。</p> 
<p>如果作为interviewer哪天你有幸遇到一位能和你深入讨论如何让tree、combobox、list和 table的renderer进行 代码复用，如何让renderer对象实例进行复用以及复用需要注意的副作用时，我强烈建议你赶紧留着此人，这种人已是稀有物种了。</p> 
<p>言归正传，以下通过Swing的表格为例通过几个例子帮助大家理解：<br />TableCellRenderer就是用来绘制展示当前cell单元数值内容的，你可以用文字、数值或者图片来表示内容，当然最强大展示方式的就是通过自定义自己的renderer组件，通过Java2D来绘制各种天花乱坠的效果。<br />TableCellEditor主要是用来当用户点击在具体cell时进行编辑的组件，所以TableCellEditor除了具有 TableCellRenderer一样的绘制功能外还可以进行交互动作，例如在cell上出现下拉框、勾选框甚至通过按钮弹出更复杂的对话框让用户进行 输入编辑。</p> 
<p>以下是在cell中嵌入start、stop两个按钮的表格，注意这里的renderer只是用来显示效果，并没有进行交互动作，真正进行动作的是 当你将鼠标点击在cell上时，JTable定位上去的editor，所以不要徒劳在renderer上做点击事项处理，renderer是不会接受到交 互事项的，renderer只是个画笔，你看到的start、stop按钮只是这个画笔画出来的内容，是虚的并没有真正的组件在上面。</p> 
<pre>import java.awt.*;<br />import java.awt.event.*;<br />import javax.swing.*;<br />import javax.swing.table.*;<br />public class TableTest1 extends JFrame {<br /> JTable table;<br /> String[] states = new String[]{&quot;stop&quot;, &quot;stop&quot;, &quot;stop&quot;};<br /><br /> // model<br /> class TableModel extends AbstractTableModel{<br />  public int getColumnCount() {<br />   return 2;<br />  }<br />  public int getRowCount() {<br />   return states.length;<br />  }<br />  public Object getValueAt(int rowIndex, int columnIndex) {<br />   if(columnIndex == 0){<br />    return states[rowIndex];<br />   }<br />   return null;<br />  }<br />     public String getColumnName(int columnIndex) {<br />   if(columnIndex == 0){<br />    return &quot;state&quot;;<br />   }else{<br />    return &quot;operate&quot;;<br />   }<br />     }<br />     public boolean isCellEditable(int rowIndex, int columnIndex) {<br />   if(columnIndex == 0){<br />    return false;<br />   }else{<br />    return true;<br />   }<br />     }<br /> }<br /><br /> // cell editor<br /> class Editor extends AbstractCellEditor implements TableCellEditor, ActionListener {<br />  int row;<br />  JTable table;<br />  JPanel panel;<br />  JButton start;<br />  JButton stop;<br />  Editor(){<br />   panel = new JPanel();<br />   panel.setLayout(new GridLayout(1, 2));<br />   start = new JButton(&quot;start&quot;);<br />   stop = new JButton(&quot;stop&quot;);<br />   start.addActionListener(this);<br />   stop.addActionListener(this);<br />   panel.add(start);<br />   panel.add(stop);<br />  }<br />     public Object getCellEditorValue() {<br />         return null;<br />     }<br />     public Component getTableCellEditorComponent(JTable table,<br />                                                  Object value,<br />                                                  boolean isSelected,<br />                                                  int row,<br />                                                  int column) {<br />      this.table = table;<br />      this.row = row;<br />      return panel;<br />     }<br /><br />  public void actionPerformed(ActionEvent e) {<br />   if(e.getSource() == start){<br />    states[row] = &quot;start&quot;;<br />   }else{<br />    states[row] = &quot;stop&quot;;<br />   }<br />   ((AbstractTableModel)table.getModel()).fireTableCellUpdated(row, 0);<br />  }<br /><br /> }<br /><br /> // cell render<br /> class Renderer extends JComponent implements TableCellRenderer{<br />  JPanel panel;<br />  JButton start;<br />  JButton stop;<br />  Renderer(){<br />   panel = new JPanel();<br />   panel.setLayout(new GridLayout(1, 2));<br />   start = new JButton(&quot;start&quot;);<br />   stop = new JButton(&quot;stop&quot;);<br />   panel.add(start);<br />   panel.add(stop);<br />  }<br />  public Component getTableCellRendererComponent(JTable table, Object value,<br />    boolean isSelected, boolean hasFocus, int row, int column) {<br />   return panel;<br />  }<br /> }<br /><br /> public TableTest1(){<br />  super(&quot;renderer and editor self-existent&quot;);<br />  table = new JTable(new TableModel());<br />  TableColumn tableColumn = table.getColumnModel().getColumn(1);<br />  tableColumn.setCellRenderer(new Renderer());<br />  tableColumn.setCellEditor(new Editor());<br /><br />        this.getContentPane().setLayout(new BorderLayout());<br />        this.getContentPane().add(new JScrollPane(table), BorderLayout.CENTER);<br />        this.setSize(500, 300);<br />        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br /> }<br /> public static void main(String[] args) {<br />  new TableTest1().show();<br /> }<br />}
</pre>
<p><a href="http://twaver.servasoft.com/wp-content/uploads/2010/07/blog10.jpg"><img class="alignnone size-full wp-image-462" src="image/Renderer&amp;Editor之Swin.3d8e6d6095bf6e16eaf8f8ee.jpg" height="450" width="600" /><p class="origImg">http://hiphotos.baidu.com/hxzon/pic/item/3d8e6d6095bf6e16eaf8f8ee.jpg</p></a></p> 
<p><a href="http://twaver.servasoft.com/?p=467">Renderer&amp;Editor之Swing篇（二）</a></p> 
<p><a href="http://twaver.servasoft.com/?p=461">上篇</a>的例子主要的动作在editor上，不过 editor只有在点击在cell单元的时候才会显示，所以还不得不造一个界面跟editor一样的renderer进行“造假”，当然由于这个例子只有 两个按钮，所以renderer的代码不多，不过如果editor的组件很多，而且经常需要改动那不就麻烦了，所以我们可以考虑一下让renderer复 用editor的显示部分，以下的代码就是很好的说明了这种复用</p> 
<pre>import java.awt.*;<br />import java.awt.event.*;<br />import javax.swing.*;<br />import javax.swing.table.*;<br /><br />public class TableTest2 extends JFrame {<br /> JTable table;<br /> String[] states = new String[]{&quot;stop&quot;, &quot;stop&quot;, &quot;stop&quot;};<br /><br /> // model<br /> class TableModel extends AbstractTableModel{<br />  public int getColumnCount() {<br />   return 2;<br />  }<br />  public int getRowCount() {<br />   return states.length;<br />  }<br />  public Object getValueAt(int rowIndex, int columnIndex) {<br />   if(columnIndex == 0){<br />    return states[rowIndex];<br />   }<br />   return null;<br />  }<br />     public String getColumnName(int columnIndex) {<br />   if(columnIndex == 0){<br />    return &quot;state&quot;;<br />   }else{<br />    return &quot;operate&quot;;<br />   }<br />     }<br />     public boolean isCellEditable(int rowIndex, int columnIndex) {<br />   if(columnIndex == 0){<br />    return false;<br />   }else{<br />    return true;<br />   }<br />     }<br /> }<br /><br /> // cell editor<br /> class Editor extends AbstractCellEditor implements TableCellEditor, ActionListener {<br />  int row;<br />  JTable table;<br />  JPanel panel;<br />  JButton start;<br />  JButton stop;<br />  Editor(){<br />   panel = new JPanel();<br />   panel.setLayout(new GridLayout(1, 2));<br />   start = new JButton(&quot;start&quot;);<br />   stop = new JButton(&quot;stop&quot;);<br />   start.addActionListener(this);<br />   stop.addActionListener(this);<br />   panel.add(start);<br />   panel.add(stop);<br />  }<br />     public Object getCellEditorValue() {<br />         return null;<br />     }<br />     public Component getTableCellEditorComponent(<br />       JTable table, Object value, boolean isSelected, int row, int column) {<br />      this.table = table;<br />      this.row = row;<br />      return panel;<br />     }<br /><br />  public void actionPerformed(ActionEvent e) {<br />   if(e.getSource() == start){<br />    states[row] = &quot;start&quot;;<br />   }else{<br />    states[row] = &quot;stop&quot;;<br />   }<br />   ((AbstractTableModel)table.getModel()).fireTableCellUpdated(row, 0);<br />  }<br /><br /> }<br /><br /> // cell render<br /> class Renderer extends JComponent implements TableCellRenderer{<br />  TableCellEditor editor;<br />  Renderer(TableCellEditor editor){<br />   this.editor = editor;<br />  }<br />  public Component getTableCellRendererComponent(JTable table, Object value,<br />    boolean isSelected, boolean hasFocus, int row, int column) {<br />   return editor.getTableCellEditorComponent(table, value, isSelected, row, column);<br />  }<br /> }<br /><br /> public TableTest2(){<br />  super(&quot;editor used by renderer&quot;);<br />  table = new JTable(new TableModel());<br />  TableColumn tableColumn = table.getColumnModel().getColumn(1);<br />  tableColumn.setCellRenderer(new Renderer(new Editor()));<br />  tableColumn.setCellEditor(new Editor());<br /><br />        this.getContentPane().setLayout(new BorderLayout());<br />        this.getContentPane().add(new JScrollPane(table), BorderLayout.CENTER);<br />        this.setSize(500, 300);<br />        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br /> }<br /> public static void main(String[] args) {<br />  new TableTest2().show();<br /> }<br />}
</pre>
<p><a href="http://twaver.servasoft.com/wp-content/uploads/2010/07/blog11.jpg"><img class="alignnone size-full wp-image-468" src="image/Renderer&amp;Editor之Swin.c79981447074f31e500ffeee.jpg" height="450" width="600" /><p class="origImg">http://hiphotos.baidu.com/hxzon/pic/item/c79981447074f31e500ffeee.jpg</p></a></p> 
<p><a href="http://twaver.servasoft.com/?p=471">Renderer&amp;Editor之Swing篇（三）</a></p> 
<p><a href="http://twaver.servasoft.com/?p=467">上文</a>实现了renderer复用 editor的功能，那么反过来editor是否也可以复用renderer的功能呢?而且第一篇提到“通过Java2D来绘制各种天花乱坠的效果”如何 实现?这俩个疑问在以下代码中都有了很好的解答，里面有不少技术细节，我就不多说了大家自己仔细看看。</p> 
<p>其实Flex也有同样的机制，可参见<a href="http://help.adobe.com/en_US/flex/using/WS2db454920e96a9e51e63e3d11c0bf651fa-7ff1.html#WS2db454920e96a9e51e63e3d11c0bf69084-7ca2">Example: Using an item renderer as an item editor</a></p> 
<pre>/**
 *  A flag that indicates that the item renderer is also an item editor.
 *  If this property is &lt;code&gt;true&lt;/code&gt;, Flex
 *  ignores the &lt;code&gt;itemEditor&lt;/code&gt; property and uses the item
 *  renderer for that item as the editor.
 *
 *  @default false
 */
public var rendererIsEditor:Boolean = false; </pre>
<pre>import java.awt.*;<br />import java.awt.geom.*;<br />import java.awt.event.*;<br />import javax.swing.*;<br />import javax.swing.border.*;<br />import javax.swing.table.*;<br />public class TableTest3 extends JFrame {<br /> JTable table;<br /> Double[] values = new Double[]{new Double(0.1), new Double(0.3), new Double(0.8)};<br /><br /> // model<br /> class TableModel extends AbstractTableModel{<br />  public int getColumnCount() {<br />   return 2;<br />  }<br />  public int getRowCount() {<br />   return values.length;<br />  }<br />  public Object getValueAt(int rowIndex, int columnIndex) {<br />   return values[rowIndex];<br />  }<br />  public void setValueAt(Object value, int rowIndex, int columnIndex) {<br />   values[rowIndex] = (Double)value;<br />   this.fireTableCellUpdated(rowIndex, 0);<br />  }<br />     public String getColumnName(int columnIndex) {<br />   if(columnIndex == 0){<br />    return &quot;plain&quot;;<br />   }else{<br />    return &quot;beauty&quot;;<br />   }<br />     }<br />     public boolean isCellEditable(int rowIndex, int columnIndex) {<br />   if(columnIndex == 0){<br />    return false;<br />   }else{<br />    return true;<br />   }<br />     }<br /> }<br /><br /> // cell editor<br /> class Editor extends AbstractCellEditor implements TableCellEditor, ActionListener {<br />  JSlider slider = new JSlider(JSlider.HORIZONTAL, 0, 100, 50);<br />  TableCellRenderer renderer;<br />  JButton actionButton;<br /><br />     Object value;<br />     JTable table;<br />     int row;<br />     int column;<br /><br />     JPanel panel = new JPanel(new BorderLayout()); <br /><br />     public Editor(TableCellRenderer renderer){<br />         this.renderer = renderer;<br />         actionButton = new JButton(new ImageIcon(TableTest3.class.getResource(&quot;dotdotdot.gif&quot;)));<br />         actionButton.addActionListener(this);<br />         actionButton.setFocusable(false);<br />         actionButton.setFocusPainted(false);<br />         actionButton.setMargin(new Insets(0, 0, 0, 0));<br />         panel.add(actionButton, BorderLayout.EAST);<br />     } <br /><br />     public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column){<br />      this.value = value;<br />         this.table = table;<br />         this.row = row;<br />         this.column = column;<br />         panel.add(renderer.getTableCellRendererComponent(table, value, true, isSelected, row, column));<br />         return panel;<br />     } <br /><br />     public Object getCellEditorValue(){<br />         return value;<br />     }<br />  public void actionPerformed(ActionEvent e) {<br />         int intValue = (int)(((Number)value).doubleValue() * 100);<br />         slider.setValue(intValue);<br /><br />         int result = JOptionPane.showOptionDialog(TableTest3.this,<br />                 slider, &quot;change value&quot;,<br />                 JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE, null, null, null); <br /><br />         if(result==JOptionPane.OK_OPTION) {<br />          this.value = new Double(slider.getValue()/100.0);<br />             this.fireEditingStopped();<br />         }else{<br />          this.fireEditingCanceled();<br />         }<br />  }<br /> }<br /><br /> // cell render<br /> class Renderer extends JComponent implements TableCellRenderer{<br />  Border noFocusBorder = new EmptyBorder(1, 1, 1, 1);<br />  Border focusBorder = UIManager.getBorder(&quot;Table.focusCellHighlightBorder&quot;);<br /><br />  private boolean hasFocus;<br />  private Double value;<br /><br />     public void paintComponent(Graphics g) {<br />      super.paintComponent(g);<br /><br />      if(hasFocus){<br />       this.setBorder(focusBorder);<br />      }else{<br />       this.setBorder(noFocusBorder);<br />      }<br />      Dimension size = this.getSize();<br /><br />      Graphics2D g2 = (Graphics2D) g;<br />      g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);<br />         GradientPaint gp = new GradientPaint(0, 0, Color.BLUE, size.width, 0, Color.YELLOW, true);<br />         g2.setPaint(gp);<br />         g2.fillRect(0, 0, size.width, size.height);<br /><br />         g2.setColor(Color.GREEN);<br />      double r = (size.height - 8 )  /  2.0;<br />      int centerX = (int)(size.width * value.doubleValue());<br />      int centerY = (int)r;<br />      g2.fill(new Ellipse2D.Double(centerX-r, centerY-r+4, r * 2, r * 2));<br />     }<br /><br />  public Component getTableCellRendererComponent(JTable table, Object value,<br />    boolean isSelected, boolean hasFocus, int row, int column) {<br />   this.hasFocus = hasFocus;<br />   this.value = (Double)value;<br />      this.setToolTipText(value + &quot;&quot;);<br />   return this;<br />  }<br /> }<br /><br /> public TableTest3(){<br />  super(&quot;renderer used by editor&quot;);<br />  table = new JTable(new TableModel());<br />  TableColumn tableColumn = table.getColumnModel().getColumn(1);<br />  tableColumn.setCellRenderer(new Renderer());<br />  tableColumn.setCellEditor(new Editor(new Renderer()));<br /><br />        this.getContentPane().setLayout(new BorderLayout());<br />        this.getContentPane().add(new JScrollPane(table), BorderLayout.CENTER);<br />        this.setSize(500, 300);<br />        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br /> }<br /> public static void main(String[] args) {<br />  new TableTest3().show();<br /> }<br />}
</pre>
<p><a href="http://twaver.servasoft.com/?p=475">Renderer&amp;Editor之Swing篇（四）</a></p> 
<p>继前面三篇也许大家会根据例子太简单而且很丑，如果你想看更多的例子我强烈建议你看看TWaver Java的产品Demo，里面有各种复杂、花哨和实用的应用，很有多人惊叹JDK6新增的 com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel，感觉其默认表格的各行换色很酷，其实该功能多年前 就在TWaver Java的产品Demo中有体现，并且还能实现各行渐进的效果，不过这个例子需要点非常规的小技巧，通过重载JTable的 prepareRenderer来实现，我就不细介绍了大家看代码吧：</p> 
<pre>public Component prepareRenderer(TableCellRenderer renderer, int row, int col) {<br />  Component componet = super.prepareRenderer(renderer, row, col);<br />  if (componet instanceof JComponent) {<br />      JComponent comp = (JComponent) componet;<br />      comp.setOpaque(true);<br />      Person person = (Person)this.getElementByRowIndex(row);<br />      int blueValue = 255 - (person.getAge() * 2);<br /><br />      TTableColumn column = (TTableColumn)this.getColumnByIndex(col);<br />      if(column.getName().equals(&quot;age&quot;)){<br />   if(!person.isSelected()){<br />       comp.setBackground(new Color(255, blueValue, 255));<br />   }<br />   comp.setFont(font);<br />      }<br />      else{<br />   if(!person.isSelected()){<br />       comp.setBackground(new Color(255, 255, blueValue));<br />   }<br />      }<br />  }<br />  return componet;<br /> }
</pre>
<p><img src="image/Renderer&amp;Editor之Swin.20521c4ccc8330abd62afcee.jpg" /><p class="origImg">http://hiphotos.baidu.com/hxzon/pic/item/20521c4ccc8330abd62afcee.jpg</p></p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p><br />&nbsp;</p>
<span></span></div></body></html>