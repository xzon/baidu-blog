<html><head><title>史上最潮的Swing三态CheckBox实现</title></head><body><div id='tit'>史上最潮的Swing三态CheckBox实现</div><div id='cate'>j&middot;swing</div><div id='date'>2010年08月02日 星期一 03:22 P.M.</div><div id='page'>11</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/6f687b1e93cec5f91ad576e9.html'>http://hi.baidu.com/hxzon/blog/item/6f687b1e93cec5f91ad576e9.html</a><div id='cnt'><div> 
 <p>史上最潮的Swing三态CheckBox实现</p> 
 <p><a href="http://twaver.servasoft.com/?p=495">http://twaver.servasoft.com/?p=495</a></p> 
 <p><a href="http://twaver.servasoft.com/?attachment_id=496" rel="attachment wp-att-496"><img class="alignnone size-full wp-image-496" src="image/史上最潮的Swing三态CheckBox.4ceeedf875d6474dd8f9fde3.jpg" width="187" height="122" /><p class="origImg">http://hiphotos.baidu.com/hxzon/pic/item/4ceeedf875d6474dd8f9fde3.jpg</p></a><br /><a href="http://twaver.servasoft.com/?attachment_id=497" rel="attachment wp-att-497"><img class="alignnone size-full wp-image-497" src="image/史上最潮的Swing三态CheckBox.8468d3622faff39fe6113ae3.jpg" width="195" height="148" /><p class="origImg">http://hiphotos.baidu.com/hxzon/pic/item/8468d3622faff39fe6113ae3.jpg</p></a></p> 
 <p>对于大部分近五年内新推出UI平台，如果再没将TristateCheckBox作为基础组件提供那就未免太落伍了，以上两个分别是 Silverlight和JavaFX的自带支持三态的CheckBox组件，当然你不能怪罪于Swing这个已经为人类服务的十几年，且依然在电信行业担当重任的平台没有在设计之初考虑到这样的功能，不过这也正好给了此文一个表现的机会。</p> 
 <p>实现三态的CheckBox最简单的解决方案就是code from scratch，完全自己绘制实现forget java.swing.JCheckBox，这个方案肯定可行不过缺点也是显而易见的，首先看看javax.swing.ButtonModel接口有多少model的逻辑需要考虑，再查查以下有多少ButtonUI在不同LookAndFeel你需要考虑绘制的风格一致性，如果你要做个通用的组件此路基本不通。</p> 
 <p><a href="http://twaver.servasoft.com/?attachment_id=500" rel="attachment wp-att-500"><img class="alignnone size-full wp-image-500" src="image/史上最潮的Swing三态CheckBox.1253d12a13c3336fd52af1e3.jpg" width="284" height="425" /><p class="origImg">http://hiphotos.baidu.com/hxzon/pic/item/1253d12a13c3336fd52af1e3.jpg</p></a></p> 
 <p>如果要兼顾各种LookAndFeel，并且考虑到用户还可能采用第三方的laf，合理的解决方案就不应该有硬编码的绘制逻辑。你可以注意到当我们 Press一个CheckBox的时候其实是有个三态的呈现效果，只不过当我们松手或鼠标移开后CheckBox才恢复正常状态，想想如果我们能“欺骗”CheckBox让其觉得自己一直是在Press状态下，那么那些各种各样的laf下的**ButtonUI岂不是都能自动显示我们要的效果。</p> 
 <p>于是沿着这个思路我们想到了前面提及的ButtonModel接口，所有状态逻辑都在于此，甚至你可以将其理解为个状态机，这样如果我们构造个符合我们需求逻辑的TristateButtonModel然后通过JCheckBox#setModel(ButtonModel newModel)设置岂不就可以了。</p> 
 <p>且慢你再看一样javax.swing.ButtonModel接口有多少函数要实现，这是有同学想到可以通过 JCheckBox#getModel()的到老的Model，然后采用Decorator设计模式对oldButtonModel进行包装是否就可以了，想到这里你基本修成正果了，这里有个哥们也用了<a href="http://forums.sun.com/thread.jspa?threadID=593755">Decorator这样的方式</a>取得了真经。</p> 
 <p>在我看来Decorator设计模式是种由于语言不够灵活而产生的丑陋解决方案，如果old的实现有100个函数岂不wrapper也得一笔一划的去包装一百多个函数，Java虽然不够灵活不过还好JDK1.3就给我们留了个java.lang.reflect.Proxy类，能够让我们拦截接口的实例函数调用，以下我就不多说了，大家可以直接看代码或者直接改造到你的项目中使用，使用TWaver Java的同学比较幸运直接使用twaver.swing.TTristateCheckBox这个类即可。<br /><a href="http://twaver.servasoft.com/?attachment_id=511" rel="attachment wp-att-511"><img class="alignnone size-full wp-image-511" src="image/史上最潮的Swing三态CheckBox.abf3232da1b03e76359bf7e3.jpg" width="366" height="73" /><p class="origImg">http://hiphotos.baidu.com/hxzon/pic/item/abf3232da1b03e76359bf7e3.jpg</p></a></p>
 <pre>import java.awt.Graphics;<br />import java.lang.reflect.InvocationHandler;<br />import java.lang.reflect.Method;<br />import java.lang.reflect.Proxy;<br /> <br />import javax.swing.BoxLayout;<br />import javax.swing.ButtonModel;<br />import javax.swing.JCheckBox;<br />import javax.swing.JFrame;<br />import javax.swing.JPanel;<br /> <br />public class TristateCheckBox extends JCheckBox {<br /> <br /> public final static int SELECTED = 1;<br /> public final static int DESELECTED = 2;<br /> public final static int NOTSPECIFIED = 3;<br /> <br /> class ProxyHandler implements InvocationHandler {<br />&nbsp;&nbsp;  public Object invoke(Object proxy, Method method, Object[] args)throws Throwable {<br />&nbsp;&nbsp;&nbsp;  String methodName = method.getName();<br />&nbsp;&nbsp;&nbsp;  if (isEnabled() &amp;&amp; !isPainting &amp;&amp; methodName.equals(&quot;setPressed&quot;)) {<br />&nbsp;&nbsp;&nbsp;&nbsp;  boolean isPressed = ((Boolean) args[0]).booleanValue();<br />&nbsp;&nbsp;&nbsp;&nbsp;  if (isPressed == false &amp;&amp; buttonModel.isArmed()) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  nextState();<br />&nbsp;&nbsp;&nbsp;&nbsp;  }<br />&nbsp;&nbsp;&nbsp;  }<br />&nbsp;&nbsp;&nbsp;  if (isPainting &amp;&amp; state == NOTSPECIFIED) {<br />&nbsp;&nbsp;&nbsp;&nbsp;  if (methodName.equals(&quot;isPressed&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || methodName.equals(&quot;isArmed&quot;)) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return Boolean.TRUE;<br />&nbsp;&nbsp;&nbsp;&nbsp;  }<br />&nbsp;&nbsp;&nbsp;  }<br />&nbsp;&nbsp;&nbsp;  if (methodName.equals(&quot;isSelected&quot;)) {<br />&nbsp;&nbsp;&nbsp;&nbsp;  if (state == SELECTED || state == NOTSPECIFIED) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return Boolean.TRUE;<br />&nbsp;&nbsp;&nbsp;&nbsp;  } else {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return Boolean.FALSE;<br />&nbsp;&nbsp;&nbsp;&nbsp;  }<br />&nbsp;&nbsp;&nbsp;  }<br />&nbsp;&nbsp;&nbsp;  if (methodName.equals(&quot;setSelected&quot;)) {<br />&nbsp;&nbsp;&nbsp;&nbsp;  if (Boolean.TRUE.equals(args[0])) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  setState(SELECTED);<br />&nbsp;&nbsp;&nbsp;&nbsp;  } else {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  setState(DESELECTED);<br />&nbsp;&nbsp;&nbsp;&nbsp;  }<br />&nbsp;&nbsp;&nbsp;  }<br />&nbsp;&nbsp;&nbsp;  return method.invoke(buttonModel, args);<br />&nbsp;&nbsp;  }<br /> }<br /> <br /> private boolean isPainting = false;<br /> private ButtonModel buttonModel = null;<br /> private int state = DESELECTED;<br /> <br /> public TristateCheckBox() {<br />&nbsp;&nbsp;  this(null);<br /> }<br /> <br /> public TristateCheckBox(String text) {<br />&nbsp;&nbsp;  this(text, false);<br /> }<br /> <br /> public TristateCheckBox(String text, boolean isSelected) {<br />&nbsp;&nbsp;  this(text, isSelected ? SELECTED : DESELECTED);<br /> }<br /> <br /> public TristateCheckBox(String text, int state) {<br />&nbsp;&nbsp;  super(text, null, false);<br />&nbsp;&nbsp;  this.buttonModel = this.getModel();<br />&nbsp;&nbsp;  ButtonModel proxyModel = (ButtonModel) Proxy.newProxyInstance(<br />&nbsp;&nbsp;&nbsp;&nbsp;  TristateCheckBox.class.getClassLoader(),<br />&nbsp;&nbsp;&nbsp;&nbsp;  new Class[] { ButtonModel.class }, new ProxyHandler());<br />&nbsp;&nbsp;  this.setModel(proxyModel);<br />&nbsp;&nbsp;  this.setState(state);<br /> }<br /> <br /> public int getState() {<br />&nbsp;&nbsp;  return state;<br /> }<br /> <br /> public void nextState() {<br />&nbsp;&nbsp;  if (state == SELECTED) {<br />&nbsp;&nbsp;&nbsp;  state = NOTSPECIFIED;<br />&nbsp;&nbsp;  } else if (state == DESELECTED) {<br />&nbsp;&nbsp;&nbsp;  state = SELECTED;<br />&nbsp;&nbsp;  } else {<br />&nbsp;&nbsp;&nbsp;  state = DESELECTED;<br />&nbsp;&nbsp;  }<br />&nbsp;&nbsp;  this.fireStateChanged();<br /> }<br /> <br /> public void setState(int state) {<br />&nbsp;&nbsp;  this.state = state;<br /> }<br /> <br /> public void paintComponent(Graphics g) {<br />&nbsp;&nbsp;  isPainting = true;<br />&nbsp;&nbsp;  super.paintComponent(g);<br />&nbsp;&nbsp;  isPainting = false;<br /> }<br /> <br /> public static void main(String args[]) throws Exception {<br />&nbsp;&nbsp;  JFrame frame = new JFrame(&quot;TWaver中文社区-twaver.servasoft.com&quot;);<br />&nbsp;&nbsp;  JPanel contentPane = new JPanel();<br />&nbsp;&nbsp;  contentPane.setLayout(new BoxLayout(contentPane, BoxLayout.X_AXIS));<br />&nbsp;&nbsp;  contentPane.add(new TristateCheckBox(&quot;i am selected&quot;, SELECTED));<br />&nbsp;&nbsp;  contentPane.add(new TristateCheckBox(&quot;i am not specified&quot;, NOTSPECIFIED));<br />&nbsp;&nbsp;  contentPane.add(new TristateCheckBox(&quot;i am deselected&quot;, DESELECTED));<br />&nbsp;&nbsp;  frame.setContentPane(contentPane);<br />&nbsp;&nbsp;  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br />&nbsp;&nbsp;  frame.pack();<br />&nbsp;&nbsp;  frame.setLocation(200, 200);<br />&nbsp;&nbsp;  frame.setVisible(true);<br /> }<br /> <br />}</pre> 
 <p></p> 
 <p>另外Proxy.newProxyInstance估计大部分使用Java多年的人也未必熟悉，一方面Proxy只能代理接口无法对非接口的函数进行拦截，另外最主要的是aspect-oriented programming (AOP)的框架成出不穷，大家根本不需要知道和使用怎么古老且有诸多限制的Proxy类，不过对于Swing这种客户端使用来说，我觉得大家还是有有必要了解一下，再万不得已的情况下才引入其他第三方库来解决UI问题，否则为了些局部功能引入笨重的第三方库导致发布程序包太大反而得不偿失，这里不得不再夸一把TWaver，一个小小1m多的twaver.jar竟然包含了如此众多的易用且强大的组件。</p> 
 <p>这里附带个Proxy的使用例子，希望能帮助不熟悉的同学理解</p>
 <pre>import java.lang.reflect.InvocationHandler;<br />import java.lang.reflect.Method;<br />import java.lang.reflect.Proxy;<br />&nbsp;&nbsp;&nbsp;   <br />interface Interface_A{<br />&nbsp;&nbsp;&nbsp;   public void do_A1();<br />&nbsp;&nbsp;&nbsp;   public void do_A2();<br />&nbsp;&nbsp;&nbsp;   public void do_A3();<br />} <br />&nbsp;&nbsp;&nbsp;   <br />interface Interface_B{<br />&nbsp;&nbsp;&nbsp;   public void do_B1();<br />&nbsp;&nbsp;&nbsp;   public void do_B2();<br />&nbsp;&nbsp;&nbsp;   public void do_B3();<br />} <br />&nbsp;&nbsp;&nbsp;   <br />public class ProxyAnything implements InvocationHandler {<br />&nbsp;&nbsp;&nbsp;   <br />&nbsp;&nbsp;&nbsp;   private Interface_A businessA;<br />&nbsp;&nbsp;&nbsp;   private Interface_B businessB;<br />&nbsp;&nbsp;&nbsp;   <br />&nbsp;&nbsp;&nbsp;   public ProxyAnything(){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   this.businessA = new Interface_A(){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   public void do_A1() {<br />&nbsp;&nbsp;&nbsp;   <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   System.out.println(&quot;doing A1&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   public void do_A2() {<br />&nbsp;&nbsp;&nbsp;   <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   System.out.println(&quot;doing A2&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   public void do_A3() {<br />&nbsp;&nbsp;&nbsp;   <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   System.out.println(&quot;doing A3&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   };<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   this.businessB = new Interface_B(){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   public void do_B1() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   System.out.println(&quot;doing B1&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   public void do_B2() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   System.out.println(&quot;doing B2&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   public void do_B3() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   System.out.println(&quot;doing B3&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   };<br />&nbsp;&nbsp;&nbsp;   }<br />&nbsp;&nbsp;&nbsp;   <br />&nbsp;&nbsp;&nbsp;   public Object invoke(Object proxy, Method m, Object[] args) throws Throwable {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   if(m.getDeclaringClass() == Interface_A.class){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   if(m.getName().equals(&quot;do_A3&quot;)){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   System.out.println(&quot;you can not invoke do_A3&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }else{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   return m.invoke(this.businessA, args);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   if(m.getDeclaringClass() == Interface_B.class){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   System.out.println(m.getName() + &quot; is called.&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   return m.invoke(this.businessB, args);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br />&nbsp;&nbsp;&nbsp;   <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   return null;<br />&nbsp;&nbsp;&nbsp;   }<br />&nbsp;&nbsp;&nbsp;   <br />&nbsp;&nbsp;&nbsp;   public static void main(String[] args) throws Exception {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   ClassLoader classLoader = ProxyAnything.class.getClassLoader();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   Class[] interfaces = new Class[]{Interface_A.class, Interface_B.class};<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   InvocationHandler handler = new ProxyAnything();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   Proxy proxy = (Proxy)Proxy.newProxyInstance(classLoader, interfaces, handler);<br />&nbsp;&nbsp;&nbsp;   <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   if(proxy instanceof Interface_A){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   System.out.println(&quot;proxy instanceof Interface_A&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   if(proxy instanceof Interface_B){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   System.out.println(&quot;proxy instanceof Interface_B&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   }<br />&nbsp;&nbsp;&nbsp;   <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   Interface_A a = (Interface_A)proxy;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   Interface_B b = (Interface_B)proxy;<br />&nbsp;&nbsp;&nbsp;   <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   a.do_A1();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   a.do_A2();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   a.do_A3();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   b.do_B1();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   b.do_B2();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   b.do_B3();<br />&nbsp;&nbsp;&nbsp;   }<br />}</pre> 
 <p></p> 
 <p></p> 
 <p></p> 
 <p></p>
</div></div></body></html>