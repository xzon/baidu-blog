<html><head><title>Tapestry5.1.0.5升级到Tapestry5.2.4初体验 -hxzon</title></head><body><div id='tit'>Tapestry5.1.0.5升级到Tapestry5.2.4初体验 -hxzon</div><div id='cate'>j&middot;web</div><div id='date'>2011年01月05日 星期三 11:42 A.M.</div><div id='page'>3</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/39b5b80969998b366a60fbd3.html'>http://hi.baidu.com/hxzon/blog/item/39b5b80969998b366a60fbd3.html</a><div id='cnt'><p></p>
<p></p>
<p>Tapestry5.1.0.5升级到Tapestry5.2.4初体验 -hxzon</p>
<p>1.路径重写</p>
<p>原来的URLRewriterRule废弃，改用PageRenderLinkTransformer，<br />但前者是在AssetDispatcher之前运行，后者却在AssetDispatcher之后运行。<br />导致在PageRenderLinkTransformer重写路径不生效。<br />只能定位到一个伪页面暂时解决问题。</p> 
<pre>    public PageRenderRequestParameters decodePageRenderRequest(Request request) {<br />        String path = request.getPath();<br />        // delete whitespace<br />        path = StringUtils.deleteWhitespace(path);<br />        logger.trace(&quot;path incoming:&quot; + path);<br />        if (path.toLowerCase().contains(&quot;web-inf&quot;)) {<br />            logger.debug(&quot;path contains web-info,rewrite to root&quot;);<br />            return new PageRenderRequestParameters(Index.class.getSimpleName(), new EmptyEventContext(), false);<br />        }<br />        if (path.contains(&quot;/css/&quot;) &amp;&amp; !path.contains(&quot;/assets/&quot;)) {<br />            path = path.substring(path.indexOf(&quot;/css&quot;));<br />            logger.debug(&quot;path contains css ,rewrite to assets path:&quot; + path);<br />            return new PageRenderRequestParameters(pageName, new OneStringEventContext(path), false);<br />        }<br />        return null;<br />    }</pre>
<pre>public class StaticSourceFile {<br />    @Inject<br />    private Logger logger;<br /><br />    @OnEvent(value = EventConstants.ACTIVATE)<br />    protected Object response(String path) {<br />        InputStream targetFile = null;<br />        try {<br />            targetFile = FileUtils.openInputStream(new File(WebUtil.contextPath + &quot;/&quot; + path));<br />            return new FileStreamResponse(&quot;&quot;, targetFile);<br />        } catch (Exception e) {<br />            logger.error(&quot;文件不存在:{}&quot;, e.getMessage());<br />        }<br />        return null;<br />    }<br />}</pre>
<p>2.把自己的库加入核心库空间下：</p>
<p>2.1,把自己的核心库加入核心库，即 <br /> public static void contributeComponentClassResolver(Configuration&lt;LibraryMapping&gt; configuration) { <br /> &nbsp; configuration.add(new LibraryMapping(&quot;core&quot;, &quot;org.hxzon.tapestry5&quot;)); <br /> } <br /> 出错，因为与tapestry5.2.4的核心库包名org.apache.tapestry5.xxx共同字段少于2。 <br /> 但我的代码并非tapestry的一部分，不想改为org.apache.tapestry5.hxzon. <br /> 2.2,作为补充库，即 <br /> configuration.add(new LibraryMapping(&quot;h&quot;, &quot;org.hxzon.tapestry5&quot;)); <br /> 则原来大把模板文件都要修改，即添加h.前缀，如t:h.textfieldEx。<br />并且org.hxzon.tapestry5下的page也找不到。<br /> 2.3，configuration.add(new LibraryMapping(&quot;&quot;, &quot;org.hxzon.tapestry5&quot;)); <br /> 可解决问题，但js路径变为 <br /> /material5/assets/3//components/SplitPageBar.js <br /> 文件找不到。 <br /> 2.4，最终添加两次，即 <br /> public static void contributeComponentClassResolver(Configuration&lt;LibraryMapping&gt; configuration) { <br /> configuration.add(new LibraryMapping(&quot;h&quot;, &quot;org.hxzon.tapestry5&quot;)); <br /> configuration.add(new LibraryMapping(&quot;&quot;, &quot;org.hxzon.tapestry5&quot;)); <br /> } <br />这样js文件路径为/material5/assets/3/h/components/SplitPageBar.js ，正确。<br />而tml文件中使用库时也不必加前缀。<br />解决问题。 <br /> 不知是否有更好的方法。 </p>
<p>3.自己写的TextFieldEx类在升级时出错，</p> 
<pre>    @Parameter(required = true, allowNull = false, defaultPrefix = BindingConstants.TRANSLATE)<br />    private FieldTranslator&lt;Object&gt; translate;<br /><br />    @Parameter(defaultPrefix = BindingConstants.VALIDATE)<br />    private FieldValidator&lt;Object&gt; validate;</pre>
<p>等域为空。因为更改了defaultXXX的实现方式，</p> 
<p>加入下述代码解决：</p> 
<pre>    //hxzon:fix bug when update to tapestry 5.2,but why?<br />    final Binding defaultTranslate() {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return defaultProvider.defaultTranslatorBinding(&quot;value&quot;, resources);<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; final Binding defaultValidate() {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return defaultProvider.defaultValidatorBinding(&quot;value&quot;, resources);<br />&nbsp;&nbsp;&nbsp; }</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div></body></html>