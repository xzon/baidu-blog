<html><head><title>应聘Java笔试时可能出现问题</title></head><body><div id='tit'>应聘Java笔试时可能出现问题</div><div id='cate'>j&middot;入门</div><div id='date'>2008年08月27日 星期三 01:01 P.M.</div><div id='page'>105</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/6a2181d6fc18ea2906088b7d.html'>http://hi.baidu.com/hxzon/blog/item/6a2181d6fc18ea2906088b7d.html</a><div id='cnt'><p><font size="3">应聘Java笔试时可能出现问题</font></p> 
<p><font size="3">Java基础方面: <br /> 1、作用域public,private,protected,以及不写时的区别 <br /> Public、Protected、Private是成员访问修饰符； <br /> final、abstract、transient、synchronized、native、strictfp是非访问成员修饰符。 <br /> 可见性PublicProtectedDefaultPrivate <br /> 同一个类是是是是 <br /> 同一个包中的类是是是否 <br /> 同一个包中的子类是是是否 <br /> 同一包外的子类是是否否 <br /> 同一包外的非子类是否否否 <br /> <br /> Java的基本包 <br /> java.lang 其中包含有： <br /> 接口：Comparable、Cloneable、Runable等 <br /> 类：八个基本数据类型封装类、Math、Runtime、Object、String、StringBuffer、Thread、Exception等 <br /> <br /> 集合框架 <br /> 集合是将多个元素组成一个单元的对象。集合用于存储、检索和操纵数据。 <br /> 集合框架提供管理对象集合的接口和类。它包含几个组件，接口是表示集合的抽象数据类型，用于操纵集合；类是用于存储集合的实际数据对象；算法是用于操纵集合的。 <br /> <br /> 2、ArrayList和Vector的区别,HashMap和Hashtable的区别 <br /> 答：就ArrayList与Vector主要从二方面来说. <br /> 一.同步性:Vector是线程安全的，也就是说是同步的，而ArrayList是线程序不安全的，不是同步的 <br /> 二.数据增长:当需要增长时,Vector默认增长为原来一培，而ArrayList却是原来的一半 <br /> <br /> ArrayList,Vector, LinkedList的存储性能和特性 <br /> ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 <br /> <br /> 就HashMap与HashTable主要从三方面来说. <br /> 一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一实现 <br /> 二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 <br /> 三.值：只有HashMap允许在一个集合中有一个null键和在一个集合中有多个null值 <br /> <br /> Hashtable是HashMap的同步版本；HashMap允许有null值和一个null键，但是，Hashtable不允许有任何内容为null <br /> <br /> Hashtable类的对象必须覆盖Object类的hashCode()和equals()方法 <br /> <br /> 关于其他集合类型： <br /> 一.ArrayList 提供快速遍历和快速访问。现在设计了新的 RandomAccess 接口，它指出这种列表支持快速随机访问。Vector也实现了RandomAccess 接口。 <br /> 二.遍历HashSet与HashMap时，其顺序是未知的（但添加删除快）。LinkedHashSet和LinkedHashSet是按照元素的插入的顺序遍历的（遍历快）。 <br /> 三．TreeSet和TreeMap将保证元素按照元素的自然顺序进行排列。也可以使用一个用户自己实现的比较规则。 <br /> 四、HashSet有一个散列表支持它。它为基本操作提供固定时间性能。TreeSet它确保了排序集将按元素升序，根据自然顺序排序。 <br /> <br /> Dictionary类 <br /> 主要用于将关键字转换成值，该类接收一个关键字并返回一个值。Dictionary是一个抽象类，它是H <br /> Hashtable的超类。 <br /> Properties类 <br /> 扩展了Hashtable类，但Properties对象的关键字和值必须是String类型，并能将对象写入一个输出流并保存在一个文件中，然后可以把它读回一个输入流。 <br /> <br /> <br /> 如果需要维护和搜索一个部件列表，它们由唯一的字母数字序列号标示，其中的部件是Part类型，这时应该使用哪种集合？如果我们改变需求，你也需要能够按顺序、按它们的序列号打印出部件？ <br /> 1、应该选择HashMap <br /> 2、应该选择TreeMap <br /> <br /> 3、char型变量中能不能存贮一个中文汉字?为什么? <br /> 答：是能够定义成为一个中文的，因为java中以unicode编码，一个char占16个字节，所以放一个中文是没问题的 <br /> 4、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么? <br /> 答：多线程有两种实现方法，分别是继承Thread类与实现Runnable接口 <br /> 同步的实现方面有两种，分别是synchronized,wait与notify <br /> <br /> GC是什么? 为什么要有GC? <br /> GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。 <br /> <br /> 7、垃圾回收机制,如何优化程序? <br /> 当一个对象失去引用或者离开了作用域后，就成为垃圾而被Java运行环境自动清除，清除垃圾就是清除这些对象。 <br /> Java垃圾回收机制的特点是： <br /> 1、垃圾回收机制自动运行。系统提供一个低优先级的线程来跟踪内存的分配情况。如果发现某个内存单元不再使用，就清除它。 <br /> 2、何时清除垃圾是不可预期的。 <br /> 3、垃圾回收机制随JVM的不同而不同。 <br /> <br /> Java的垃圾搜索器为内存管理器提供一种自动解决方案。缺点是不能完全控制它什么时候执行以及什么时候不执行。 <br /> 当垃圾搜集器运行时，其目的是查找和删除不能被访问的对象。 <br /> 垃圾搜集器受JVM控制，JVM决定什么时候运行垃圾搜集器。从Java程序内可以请求JVM运行垃圾搜集器，但是，在任何情况下都无法保证JVM会答应你的请求。JVM通常会在它感到内存减少时运行垃圾搜集器。 <br /> 垃圾收集器运行时，当它发现一个对象不能被任何活线程访问时，它将认为该对象符合删除条件，它可能在某时删除该对象。 <br /> 垃圾收集器不能保证有足够的内存，它只能保证可以使用的内存将尽可能被有效的管理。 <br /> 使对象符合垃圾搜集器搜索条件的情况有：出现空引用、重新为引用变量赋值、隔离引用。 <br /> <br /> 强制执行垃圾搜集： <br /> Runtime对象为直接与虚拟机通信提供一种机制。System类可以调用与其相同的方法。 <br /> 请求垃圾收集器的最简单的方法是：System.gc(); <br /> <br /> Javac编译选项？ <br /> G产生调试信息 <br /> g:none不产生调试信息 <br /> verbose输出编译器消息，可以知道程序编译时用到了哪些Java类 <br /> Noware编译时不产生警告信息 <br /> encoding指出原文件的编码方式 <br /> D指定类文件产生的目录 <br /> classPath指出用户class文件的路径 <br /> sourcePath指出用户源文件路径 <br /> <br /> 9、介绍JAVA中的Collection FrameWork(包括如何写自己的数据结构)? <br /> 答：Collection FrameWork如下： <br /> 核心接口有： <br /> CollectionSetSorted Set <br /> ListMapSorted Map <br /> <br /> Set接口：不允许重复的元素。它对add、equals、hashCode方法增加了限制 <br /> SortedSet接口：扩展了Set接口，此接口的元素按升序排序。 <br /> List接口：一些集合具有顺序，即在一个项目后添加另一个项目。列表可以有重复元素。提供了ListIterator，允许向前或向后移动元素。 <br /> Map接口：将键映射到值得对象。Map不能包含重复键，但可以包含重复值。每个键最多都只能映射到一个值。 <br /> <br /> 核心设计类： <br /> Map 设计Set 设计List 设计 <br /> HashMapHashSetArrayList <br /> HashtableLinkedHashSetVector <br /> TreeMapTreeSetLinkedLisk <br /> LinkedHasMap <br /> <br /> 散列表是最快的数据存储结构，它是一个数组。数据存储在数组中散列函数指定的特定下标。散列函数是一组输入数据和一组整数之间的映射。 <br /> <br /> 集合类和接口层次 <br /> <br /> Collections是一个类，带有用于处理集合的静态实用方法 <br /> Collection是一个接口，带有多数集合常用的方法声明，包括add、remove、contains、size、iterator <br /> <br /> Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements） <br /> Map提供key到value的映射 <br /> <br /> 集合框架的优点： <br /> 提供一组可用的集合接口，可以方便地扩展或改写集合； <br /> 接口和算法的可重用性提高了软件的可重用性； <br /> 提供了有效的数据结构和算法，减少了编程工作。 <br /> <br /> 10、Java中异常处理机制，事件机制？ <br /> 事件代表了组件之间的交互。是一种在源对象和监听对象之间，某种状态发生变化的传递机制。 <br /> 通过事件处理机制，可以让一些组件作为事件源，发出可被组件环境或其它组件接收的事件。这样，不同的组件就可以组合在一起，组件之间通过事件传递进行通信，构成一个应用。 <br /> 在java中实现事件机制的事件模型由三个部分构成：一个事件对象用于描述事件源的状态变化；一个事件源将会产生事件，提供注册的事件监听器的方法，把事件发送到监听器；事件监听器接收事件通知，实现该事件的监听器接口。 <br /> <br /> 异常实际上是程序中错误导致中断了正常的指令流的一种事件. <br /> Java异常处理用于在方法中能检查出错误但不能处理错误的情况，在这样的方法中将抛出一个异常。如果一个异常与某个catch程序块中的参数匹配，那么就执行该catch块中的代码。指出try catch finally的工作顺序。 <br /> <br /> 运行时异常与一般异常有何异同？ <br /> 异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。 <br /> <br /> 事件有哪些？ <br /> <br /> 什么是断言机制？ <br /> 断言从JDK1.4版开始引入，它让开发期间测试假设，而没有付出为异常编写异常处理程序方面的代价，一旦程序完成开发，并全部部署，假设将从不会发生。 <br /> 主要作用：因为在开发时对自己的假设非常肯定，所以不想花费时间来编写异常处理代码。断言让在开发期间测试你的假设。 <br /> private void method（int num）{ <br /> assert(num&gt;=0）;//这里假定参数num是正数，如果不是真的将抛出一个AssertionError错误 <br /> useNum(num+x); <br /> } <br /> 断言有两种形式：简单和非常简单。 <br /> 非常简单： <br /> private void doStuff（）{ <br /> assert(y&gt;x); <br /> //其他代码 <br /> } <br /> 简单： <br /> 将通过表达式的值向错误跟踪栈中添加更多信息，提供了更多调式帮助信息。 <br /> private void doStuff（）{ <br /> assert(y&gt;x):”y is ”+y+” x is”+x; <br /> //其他代码 <br /> } <br /> 运行时启用断言： <br /> java –ea com.geeksanonymous.TestClass <br /> <br /> 运行时禁用断言： <br /> java –da com.geeksanonymous.TestClass <br /> 11、JAVA中的多形与继承？ <br /> 希望大家补上，谢谢 <br /> <br /> 对象是定义了边界的、与要解决的问题有关的概念或事物。它们用于帮助理解现实世界。 <br /> 类是拥有相同特性、共同的行为和共同的关系的一组对象。 <br /> 封装是让开发者有选择地隐藏类中的特性和方法的过程 <br /> 继承是允许通过重用现有类来构建新类的特性。] <br /> 多态性使用同一函数在不同的类上具有不同的行为。Java中的多态性是通过方法的动态绑定实现的。 <br /> <br /> 12、抽象类与接口？ <br /> 答：抽象类与接口都用于抽象，但是抽象类(JAVA中)可以有自己的部分实现，而接口则完全是一个标识(同时有多重继承的功能)。 <br /> <br /> abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized? 都不能 <br /> <br /> 接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)? <br /> 接口可以继承接口。抽象类可以实现(implements)接口，抽象类可继承实体类，但前提是实体类必须有明确的构造函数。 <br /> <br /> Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)? <br /> 可以继承其他类或完成其他接口，在swing编程中常用此方式。 <br /> <br /> IO流 <br /> 字节流：数据在存储时与传输时都是以字节为单位进行的。通常用于读写二进制数据，如图像和声音文件。 <br /> 字符流：数据在存储与传输时都是以字符为单位进行的。 <br /> 流：对数据源的一种抽象，其目的是想用统一的方式访问各种不同的数据源（文件、网络、内存的缓冲区） <br /> <br /> 文件读写的基本类：File类提供定位本地文件系统，描述文件和目录的功能。 <br /> <br /> 管道流用于在线程之间通信：PipedInputStream、PipedOutputStream、PipedReader、PipedWriter <br /> 线程1&agrave;PipedOutputStream&agrave;PipedInputStream&agrave;线程2 <br /> </font><a target="_blank" href="http://hi.baidu.com/t2bbs20930/blog/item/5c9848c4da4c50cf38db49f6.html"><font size="3">程序段</font></a></p> 
<p><font size="3">串行化的注意事项以及如何实现串行化 <br /> 对象的寿命通常随着生成该对象的程序的终止而终止。有时候，可能需要将对象的状态保存下来，在需要时再将对象恢复。我们把对象的这种能记录自己的状态以便将来再生的能力，叫做对象的持续性(persistence)。对象通过写出描述自己状态的数值来记录自己，这个过程叫对象的串行化(Serialization)。 <br /> 序列化的过程就是对象写入字节流和从字节流中读取对象。将对象状态转换成字节流之后，可以用java.io包中的各种字节流类将其保存到文件中，管道到另一线程中或通过网络连接将对象数据发送到另一主机。 <br /> 一：对象序列化可以实现分布式对象。 <br /> 二：java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。 <br /> // 序列化 today's date 到一个文件中. <br /> FileOutputStream f = new FileOutputStream(&quot;tmp&quot;); <br /> ObjectOutputStream s = new ObjectOutputStream(f); <br /> s.writeObject(&quot;Today&quot;); <br /> s.writeObject(new Date()); <br /> s.flush(); <br /> //从文件中反序列化 string 对象和 date 对象 <br /> FileInputStream in = new FileInputStream(&quot;tmp&quot;); <br /> ObjectInputStream s = new ObjectInputStream(in); <br /> String today = (String)s.readObject(); <br /> Date date = (Date)s.readObject(); <br /> 记住，对象流不序列化static或transient。 <br /> 序列化通常可以自动完成，但有时可能要对这个过程进行控制。java可以将类声明为serializable，但仍可手工控制声明为static或transient的数据成员。 <br /> 如果一个类要完全负责自己的序列化，则实现Externalizable接口而不是Serializable接口。Externalizable接口定义包括两个方法writeExternal()与readExternal()。利用这些方法可以控制对象数据成员如何写入字节流 <br /> <br /> </font><a target="_blank" href="http://hi.baidu.com/t2bbs20930/blog/item/fb8d9708ad6ddbd563d986f2.html"><font size="3">NIO的特征</font></a><font size="3"> <br /> l旧的I/O是以字节为单位进行读写的，而新的I/O是以块为单位进行读写的 <br /> l以新的Channel抽象类来配合节点类 <br /> l使用Buffer的概念来进行基本数据类型的存取 <br /> l增加更多字节编码的支持 <br /> l内存映像及数据锁定的支持 <br /> l提供非阻塞的存取机制 <br /> l提供正则表达式式的验证机制</font></p> 
<p><font size="3">14、如在COLLECTION框架中，实现比较要实现什么样的接口？ <br /> Collection框架中实现比较要实现Comparable 接口和 Comparator 接口 <br /> <br /> 什么是线程？ <br /> 线程与进程相似，是一段完成某个特定功能的代码，是程序中单个顺序的流控制；但与进程不同的是，同类的多个线程是共享一块内存空间和一组系统资源，而线程本身的数据通常只有微处理器的寄存器数据，以及一个供程序执行时使用的堆栈。所以系统在产生一个线程，或者在各个线程之间切换时，负担要比进程小的多，正因如此，线程被称为轻负荷进程（light-weight process）。一个进程中可以包含多个线程。 <br /> <br /> 一个线程是一个程序内部的顺序控制流。 <br /> 1. 进程：每个进程都有独立的代码和数据空间（进程上下文） ，进程切换的开销大。 <br /> 2. 线程：轻量的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器（PC），线程切换的开销小。 <br /> 3. 多进程：在操作系统中，能同时运行多个任务程序。 <br /> 4. 多线程：在同一应用程序中，有多个顺序流同时执行。 <br /> <br /> 同步和异步有和异同，在什么情况下分别使用他们？ <br /> 临界资源问题 <br /> 线程都是独立的，而且异步执行，也就是说每个线程都包含了运行时所需要的数据或方法，而不需要外部的资源或方法，也不必关心其它线程的状态或行为。但是经常有一些同时运行的线程需要共享数据，此时就需考虑其他线程的状态和行为，否则就不能保证程序的运行结果的正确性。 <br /> 我们需要做的是允许一个线程彻底完成其任务后，再允许下一个线程执行。必须保证一个共享的资源一次只能被一个线程使用。实现此目的的过程称为同步。 <br /> 同步是用于确保资源一次只能被一个线程使用的过程。 <br /> 同步对于单线程程序没有任何好处。使用同步比非同步的性能差三到四倍。 <br /> <br /> 线程方法介绍： <br /> 构造函数： <br /> Thread() <br /> Thread(Runable target） <br /> Thread(Runable target，String name） <br /> Thread(ThreadGroup group,Runable target） <br /> Thread(ThreadGroup group,Runable target,String name） <br /> Thread(ThreadGroup group,String name） <br /> <br /> 用于完成一个线程“实际功能”的代码放在run方法中。Run方法可以在Thread的子类中重写，也可以在Runable对象中重写。 <br /> <br /> 一旦线程死去，它就永远不能再重新启动，否则会抛出异常。用start方法启动一个已经启动的线程也会抛出异常。 <br /> <br /> isAlive、interrupt、Thread.currentThread、suspend、resume、stop <br /> <br /> Sleep方法可以使低优先级的线程得到执行的机会，Yield方法只能使同优先级的线程有执行的机会。Join方法能够使调用该方法的线程在此之前执行完毕，在该方法之后，调用join方法的线程不会产生输出了， <br /> <br /> <br /> Wait与notify使用时，需要注意的事项？ <br /> 它们只能用于synchronized同步块中； <br /> 它们需要配对使用； <br /> Wait一般出现在一个while循环中，while语句使用一个boolean标志控制。 <br /> <br /> 死锁 <br /> 当被锁定的A对象试图访问另一个被锁定的B对象，B对象同时又要访问已被锁定的A对象。这样导致两个线程都在等待另一个线程释放资源，这样就出现了死锁。 <br /> <br /> 16、JAVA多线程编程。 用JAVA写一个多线程程序，如写四个线程，二个加1，二个对一个变量减一，输出。 <br /> 17、STRING与STRINGBUFFER的区别。 <br /> 答：STRING的长度是不可变的，STRINGBUFFER的长度是可变的。如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用StringBuffer，如果最后需要String，那么使用StringBuffer的toString()方法 <br /> <br /> String s = new String(&quot;xyz&quot;);创建了几个String Object? 两个</font></p> 
<p><font size="3">JDBC调用数据库的基本步骤 <br /> <br /> </font><a target="_blank" href="http://hi.baidu.com/t2bbs20930/blog/item/430dd61686be9e4e21a4e9fd.html"><font size="3">Weblogic Server中的JDBC配置 <br /> 1、建立到指定数据库的连接池Connection Pool <br /> 2、建立基于该连接池的数据源DataSource <br /> 3、访问数据库时通过数据源的JNDI名字查找到该数据源，然后通过数据源获得数据库连接对象。得到该对象后就可以依次生成数据库语句对象和结果集对象，进行相应的数据库操作。</font></a></p> 
<p><font size="3">解析XML文件的几种方式和区别 <br /> XML解析器使用的两种基本API是: <br /> 文档对象模型DOM，一种基于树结构的API。它定义了一组java接口，用于创建、访问和操纵XML文档的内部结构。它是基于对象。整个XML文档被作为对象体系结构排列进行解析和存储，应用程序可以随机访问这些对象。 <br /> DOM主要用于：在结构上修改XML文档时；在内存中与其他应用程序共享文档时。 <br /> <br /> SAX提供一种用于解析XML文档的事件驱动模型，使用SAX接口的XML处理器并不创建数据结构，而是扫描输入的XML文档，并生成元素开始、元素结束等事件，在发生事件时，解析器会通知应用程序。 <br /> SAX优点：在解析大型文档时，不必将整个文件加载到内存中，因此占有的内存比DOM少。在只需要一个信息子集时，SAX忽略不需要的数据，而DOM无法做到这点。 <br /> SAX的缺点是：必须按到达顺序处理数据，不能对文档进行随即访问。SAX是只读的，它是设计来读取XML文档而不是写入的。文档只能遍历一次。 <br /> <br /> </font><a target="_blank" href="http://hi.baidu.com/t2bbs20930/blog/item/511a9dfab5a0f79358ee90fe.html"><font size="3">使用DOM API查找XML文档中的元素和属性 <br /> 使用DOM API显示现有XML文档内容 <br /> <br /> 使用DOM API将XML文档数据插入数据库 <br /> <br /> 使用DOM API根据数据库创建XML文档</font></a></p> 
<p><font size="3">Java的国际化 <br /> 国际化是为了将应用程序发布在多个地区（locale）而进行准备的过程。不同地区标识了各个特定的国家在信息表现上所广泛使用的语言、流通货币、字符集、日期格式及其他要素。 <br /> <br /> 支持国际化的应用程序具有以下特点： <br /> 1、不用改变代码就可以支持另外的语言。 <br /> 2、文本元素、消息和图片保存在源代码之外。 <br /> 3、将于文化背景有关的数据，比如日期和时间、十进制数值以及流通货币，根据用户所用的语言和所在地理位置进行正确格式化。 <br /> 4、支持非标准字符集。 <br /> 5、应用程序可以快速适应新的语言区域。 <br /> <br /> 为了使一个应用程序国际化，： <br /> 1、必须将用户所见到的硬编码字符（如标签、工具提示和错误信息等）替换成包含在资源包ResourceBundle中的字符。它是一个java属性文件，它将关键字映射为字符值。并且可以使用多个不同语言版本的ResourceBundle，这样将可以对于不同语言提供不同的字符串。 <br /> 2、使用Locale对象，可以使数据格式化为与地区相关的数据。 <br /> 3、国际化的应用程序还必须使用统一的字符编码标准字符集。 <br /> <br /> 应用服务器有那些？ <br /> <br /> Servlet方面 <br /> 什么是Servlet？ <br /> Servlet是J2EE应用框架中部署于Web层的Web组件，运行在支持Servlet的Web服务器或应用服务器上。Servlet为客户端和服务器端的信息处理提供了一种“请求/响应”机制。 <br /> 客户程序将请求发送到服务器；服务器将请求发送到Servlet；依据客户程序的请求，Servlet动态地构造回答信息并返回给服务器；服务器将回答返回给客户程序。 <br /> <br /> 什么是JSP？ <br /> JSP是J2EE应用框架中部署于Web层的Web组件，是对Servlet技术的扩展。它使在静态的页面中加入动态的内容变得非常容易。并且通过使用标签库可以大大节省开发时间；将JavaBean与JSP一起使用可以将数据表示和程序实现分离。 <br /> <br /> 在MVC架构模式中： <br /> 使用Servlet作为控制器，而JSP作为数据视图。 <br /> <br /> CGI与Servlet的区别？ <br /> CGI（公共网关接口）是一项标准，使WEB服务器可以与外部应用程序交互。但是该技术存在一些严重的限制： <br /> 1、CGI应用程序占用资源很多。当系统要处理来自一个用户的请求时，就会创建一个新的进程来处理该请求，一旦CGI脚本停止执行，系统就必须收回该进程。这种重量级进程的经常启动和停止非常低效。 <br /> 2、CGI很难链接于请求进程的其他阶段，因为在WEB服务器上它们运行于不同的进程。这就很难处理授权、工作流和日志记录工作。 <br /> Java Servlet技术提供了一个基于组件、与平台无关的方法来构建WEB应用程序。Servlet没有标准CGI应用程序所遇到的性能局限。 <br /> Servlet比CGI更高效是因为： <br /> Servlet应用中将只创建一个单一个重量级进程，并对每个用户请求使用更轻量级的线程来完成请求处理，并且这些线程是由JVM自动维护。每个客户端请求对应一个线程，每个Servlet类在Servlet容器中只存在一个唯一的对象（实例）。Servlet类首次加载后将常驻内存。 <br /> <br /> 1、说一说Servlet的生命周期? <br /> 答:在第一次请求Servlet时将创建Servlet实例，容器调用实例的init方法，如果容器有请求要传送给servlet，它就会调用servlet实例的Service方法。一个请求将作为一个线程。如果服务器要销毁servlet实例就会调用servlet实例的destory方法，否则该实例将会常驻内存。 <br /> <br /> 2、Servlet版本间(忘了问的是哪两个版本了)的不同? <br /> 希望大家补上，谢谢 <br /> <br /> 会话根中技术 <br /> 用户认证：使用用户名和口令进行验证来让客户端访问某些资源。 <br /> 隐藏表单字段：用于保存一个浏览器在服务器中的相关信息。 <br /> URL重写：在URL后面添加附加信息 <br /> 持久Cookie：在请求和响应头信息中添加和编辑信息 <br /> <br /> 什么是会话对象？ <br /> 会话对象用于在用户访问一个Web站点的多个页面时共享信息。任何时候用户第一次访问某个网页，系统都将创建一个会话。如果以后用户访问此网页，JSP将检索有关此会话的信息。只要服务器收到此用户的请求，则会话就会持续，如果经过一段时间没有收到此用户的新请求，会话就会终止。 <br /> <br /> 3、JAVA SERVLET API中forward() 与redirect()的区别？ <br /> 使用重定向：当调用sendRedirect方法时，Web容器就会向浏览器返回响应，指示需要新的URL。因为浏览器发出了完全崭新的请求，所以在重定向之前存储为请求属性的任何对象都会消失。 <br /> 使用转发：当为一个请求调用转发时，请求就发送给服务器上另一个资源，而无需通知客户机由不同的资源处理请求。这个过程完全在Web容器内部进行，客户机绝不知晓。与重定向不同，转发过程中，对象可以存储在请求中，并发送给下一个资源使用。 <br /> 因为转发过程完全在服务器上进行，与客户机没用通信，因此转发的性能优于重定向。 <br /> 但是如果在JSP页面上使用图形的相对路径和其他资源，转发机制就会带来问题。因为浏览器无从得知发生了转发，所以相对路径只是相对初始的Servlet，而不是所转发到的JSP页面。使用JSP自定义标签可以解决这个问题。 <br /> 如何现实servlet的单线程模式 <br /> <br /> servlet的配置 <br /> <br /> 4、Servlet的基本架构 <br /> public class ServletName extends HttpServlet { <br /> public void doPost(HttpServletRequest request, HttpServletResponse response) throws <br /> ServletException, IOException { <br /> } <br /> public void doGet(HttpServletRequest request, HttpServletResponse response) throws <br /> ServletException, IOException { <br /> } <br /> }</font></p> 
<p><font size="3">Jsp方面 <br /> 1、jsp有哪些内置对象?作用分别是什么? <br /> JSP的隐式对象 <br /> RequestJavax.servlet.ServletRequest它包含了有关浏览器请求的信息.通过该对象可以获得请求中的头信息、Cookie和请求参数。 <br /> Enumeration getHeaderNames（）String getHeader（name）Cookie[] getCookies（）Enumeration GetParameterNames（）String getParameter（name）String[] GetParametervalues（name）HttpSession getSession（flag） <br /> responseJavax.servlet.ServletResponse作为JSP页面处理结果返回给用户的响应存储在该对象中。并提供了设置响应内容、响应头以及重定向的方法（如cookies,头信息等） <br /> Void setContentType(type)String getCharacterEncoding()Void addCookie(cookie)Void sendRedirect(url) <br /> outJavax.servlet.jsp.JspWriter用于将内容写入JSP页面实例的输出流中，提供了几个方法使你能用于向浏览器回送输出结果。 <br /> pageContextJavax.servlet.jsp.PageContext描述了当前JSP页面的运行环境。可以返回JSP页面的其他隐式对象及其属性的访问，另外，它还实现将控制权从当前页面传输至其他页面的方法。 <br /> Void forward(path)PAGE_SCOPEREQUEST_SCOPESESSION_SCOPEAPPLICATION_SCOPEVoid setAtrribute(key,value,scope)Enumeration getAttributeNamesInScope(scope)Object getAttribute(key,scope)Void RemoveAttribute(key,scope)Object findAttribute(name)Int getAttributeScope(name) <br /> sessionjavax.servlet.http.HttpSession会话对象存储有关此会话的信息，也可以将属性赋给一个会话，每个属性都有名称和值。会话对象主要用于存储和检索属性值。 <br /> Void setAttribute(name,data)Object getAttribute（name） <br /> applicationjavax.servle.ServletContext存储了运行JSP页面的servlet以及在同一应用程序中的任何Web组件的上下文信息。 <br /> pageJava.lang.Object表示当前JSP页面的servlet实例 <br /> configjavax.servlet.ServletConfig该对象用于存取servlet实例的初始化参数。 <br /> Enumeration getInitParameterNames()String getInitParameter(name) <br /> ExceptionJavax.lang.Throwable在某个页面抛出异常时，将转发至JSP错误页面，提供此对象是为了在JSP中处理错误。 <br /> String getMessage()Void printStackTrace(out)&lt;%@ page errorPage=”error.jsp”%&gt;&lt;%@ page isErrorPage=”true” %&gt; <br /> <br /> <br /> 2、jsp有哪些动作?作用分别是什么? <br /> 答:JSP共有以下6种基本动作 <br /> ljsp:include：在页面被请求的时候引入一个文件。 <br /> ljsp:useBean：寻找或者实例化一个JavaBean。 <br /> ljsp:setProperty：设置JavaBean的属性。 <br /> ljsp:getProperty：输出某个JavaBean的属性。 <br /> ljsp:forward：把请求转到一个新的页面。 <br /> ljsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记 <br /> <br /> 3、JSP中动态INCLUDE与静态INCLUDE的区别？ <br /> 答：动态INCLUDE用jsp:include动作实现 <br /> &lt;jsp:include page=&quot;included.jsp&quot; flush=&quot;true&quot; /&gt;它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数 <br /> 静态INCLUDE用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面 <br /> &lt;%@ include file=&quot;included.htm&quot; %&gt; <br /> <br /> 4、两种跳转方式分别是什么?有什么区别? <br /> 答：有两种，分别为： <br /> &lt;jsp:include page=&quot;included.jsp&quot; flush=&quot;true&quot;&gt; <br /> &lt;jsp:forward page= &quot;nextpage.jsp&quot;/&gt; <br /> 前者页面不会转向include所指的页面，只是显示该页的结果，主页面还是原来的页面。执行完后还会回来，相当于函数调用。并且可以带参数.后者完全转向新页面，不会再回来。相当于go to 语句。 <br /> <br /> JSP的常用指令 <br /> &lt;%@ include file=”localURL” %&gt; <br /> &lt;%@ page attribute=”value1” %&gt; <br /> 属性值缺省值示例 <br /> contentTypeMIME类型和字符集“text/hmt”contentType=“text/html；charset=ISO-8859-1“contentType=“text/xml“ <br /> Extends类名无Extends=“com.taglib.wdjsp.MyJspPage“ <br /> Import 类名或包名无 <br /> Session布尔值TrueSession=“true” <br /> isThreadSafe布尔值True <br /> ErrorPage <br /> isErrorPage <br /> &lt;%@ taglib uri=”tagLibraryURL” prefix=”tagPrefix” %&gt;</font></p></div></body></html>