<html><head><title>ActiveObjects</title></head><body><div id='tit'>ActiveObjects</div><div id='cate'>j&middot;后端</div><div id='date'>2010年08月30日 星期一 02:20 P.M.</div><div id='page'>9</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/e39e329b731745bbc9eaf481.html'>http://hi.baidu.com/hxzon/blog/item/e39e329b731745bbc9eaf481.html</a><div id='cnt'><pre>ActiveObjects <br /><br /><br /><br /><br />Basic Concepts <br /><br />The underlying principle behind ActiveObjects is that ever-popular catch phrase: convention rather <br />than conguration. With ActiveObjects, you create the abstract Java class interfaces using standard <br />Java data object conventions (get, set, is, etc...) and ActiveObjects handles the wiring to the database. <br />In fact, ActiveObjects will even generate the database-specic schema to correspond with the specied <br />Java class model. <br />   From a developer standpoint, using ActiveObjects is as simple as the following: <br /><br />      public interface Person extends Entity { <br />           public String getFirstName(); <br />           public void setFirstName(String name); <br /><br /><br />           public String getLastName(); <br />           public void setLastName(String name); <br />      } <br /><br /><br />      // ... <br />      EntityManager manager = new EntityManager(&quot;jdbc:mysql://localhost/ao_test&quot;, &quot;user&quot;, &quot;password&quot;); <br /><br /><br />      Person frank = manager.create(Person.class); <br />      frank.setName(&quot;Frank&quot;); <br />      frank.setName(&quot;Smith&quot;); <br />      frank.save(); <br /><br />   The code specied above is fully functional; there are no unspecied conguration les. In fact, the <br />only missing step would be to create the corresponding database schema. ActiveObjects can handle <br />this step too, using a feature called migrations: <br /><br />      // ... <br />      manager.migrate(Person.class); <br /><br />   This will execute DDL something like the following (assuming MySQL as in the URI above): <br /><br />      CREATE TABLE person ( <br />           id INTEGER AUTO_INCREMENT NOT NULL, <br />           firstName VARCHAR(255), <br />           lastName VARCHAR(255), <br />           PRIMARY KEY (id) <br />      ); <br /><br />   With migrations, you don’t need to worry about making changes to your schema, or keeping your <br />schema in sync with your entity model in code. Supposing you add a getAge():int method (and its <br />corresponding setter) to the Person entity in the above example. If the person table has already been <br /><br /><br /><br /><br />                                                     1 <br /> <br />created, it probably contains data. It would be ugly and painful to write scripts to generate a new <br />version of the table, migrate the old data over and delete the old table. Instead of this mess, all that <br />is necessary is another call to the migrate method (as shown above). This time, instead of generating <br />the full table from scratch, ActiveObjects will inspect the existing schema and determine that the only <br />necessary action is the addition of the age eld. To this end, it will execute only the following DDL <br />statement: <br /><br />      ALTER TABLE person ADD COLUMN age INTEGER; <br /><br />    All of the data has been retained, no ugly scripts were written and the entity model in code is <br />once again in sync with the database schema. This powerful functionality allows for things such as <br />refactoring your entity model, adding constraints and indexes and so on all without adversely eecting <br />your database. <br />    Switching databases is as easy as changing the JDBC URI value in the EntityManager constructor. <br />There is never any need to be concerned about the ins and outs of database specics or to write any <br />SQL by hand. In fact, you can use ActiveObjects and take full advantage of database functionality <br />without ever once opening a database client or even understanding the basics of SQL or RDBMS. <br />    In fact, any Java developer can use ActiveObjects, even if they have no experience whatsoever in <br />databases or their underlying concepts. The framework is designed so that it“feels”natural to any Java <br />developer, not requiring any knowledge of relational databases. <br /><br /><br />Internals <br /><br />While the ActiveObjects API does allow for some rather unusual usage patterns (such as the construction <br />of entity denitions as pure Java interfaces), the code to support this API isn’t all that complex. Much <br />of the heart and soul of the ActiveObjects library revolves around the concept of reective instance <br />proxying. <br />    Instance proxying is a lesser known part of the Java reection API which allows a specied instance <br />of the InvocationHandler class to intercept all method calls to a contrived instance of a specied class <br />type. This is how the EntityManager can dynamically create an instance of an arbitrary Entity sub- <br />interface. In fact, the instance created by EntityManager is extremely special in that it will dynamically <br />parse all method calls, attempting to proxy the relevant calls down to the database. This is how a call <br />to an accessor within an entity instance will immediately correspond to a call to the database. <br />    The instance proxy InvocationHandler for ActiveObjects is the EntityProxy class. EntityProxy <br />has a single method - invoke - which receives all method calls to the corresponding Entity instance. <br />EntityProxy then applies a set of rules to the method name, method annotations and method parame- <br />ters to determine if it is a data accessor method. If the method should correspond to a database function, <br />EntityProxy handles the retrieval of a database connection and the execution of the appropriate SQL. <br />    For more details on ActiveObjects’s implementation, refer to the javadocs. <br /><br /><br />Example Usage <br /><br />The rst step in building an application which uses ActiveObjects is to dene the entities. This is done <br />in pure Java (no XML conguration). The entity denitions are database non-specic: <br /><br />      // Person.java <br />      public interface Person extends Entity { <br />           public String getName(); <br />           public void setName(String name); <br /><br /><br />           public int getAge(); <br />           public void setAge(int age); <br /><br /><br /><br /><br />                                                      2 <br /> <br />          @SQLType(Types.CLOB) <br />          public String getComment(); <br /><br /><br />          @SQLType(Types.CLOB) <br />          public void setComment(String comment); <br /><br /><br />          public Family getFamily(); <br />          public void setFamily(); <br /><br /><br />          @ManyToMany(PersonToPerson.class) <br />          public Person[] getPeople(); <br />     } <br /><br /><br />     // Family.java <br />     public interface Family extends Entity { <br />          public String getName(); <br />          public void setName(String name); <br /><br /><br />          @OneToMany <br />          public Person[] getPeople(); <br />     } <br /><br /><br />     // PersonToPerson.java <br />     public interface PersonToPerson extends Entity { <br />          public Person getPersonA(); <br />          public void setPersonA(Person person); <br /><br /><br />          public Person getPersonB(); <br />          public void setPersonB(Person person); <br />     } <br /><br />   Once we have the entity denitions, the DDL statements can be auto-generated for whatever <br />database you may be using. This is done using migrations. Here’s what the DDL would look like <br />as generated for the MySQL database: <br /><br />     CREATE TABLE family ( <br />          id INTEGER NOT NULL AUTO_INCREMENT, <br />          name VARCHAR(255), <br />          PRIMARY KEY (id) <br />     ) ENGINE=InnoDB; <br /><br /><br />     CREATE TABLE person ( <br />          id INTEGER NOT NULL AUTO_INCREMENT, <br />          name VARCHAR(255), <br />          age INTEGER, <br />          comment TEXT, <br />          familyID INTEGER, <br />          PRIMARY KEY (id), <br />          CONSTRAINT fk_person_familyID FOREIGN KEY (familyID) REFERENCES family(id) <br />     ) ENGINE=InnoDB; <br /><br /><br />     CREATE TABLE personToPerson ( <br />          id INTEGER NOT NULL AUTO_INCREMENT, <br />          personAID INTEGER, <br /><br /><br /><br />                                              3 <br /> <br />           personBID INTEGER, <br />           PRIMARY KEY (id), <br />           CONSTRAINT fk_personToPerson_personAID FOREIGN KEY (personAID) REFERENCES person (id), <br />           CONSTRAINT fk_personToPerson_personBID FOREIGN KEY (personBID) REFERENCES person (id) <br />     ) ENGINE=InnoDB; <br /><br />   You’ll notice the usage of convention to determine eld names, primary and foreign keys, etc... <br />   Of course, an ORM layer isn’t very useful unless you actually use it. Here’s some sample code <br />showing some basic CRUD operations with our new model: <br /><br />     // ... <br /><br /><br />     // retrieves an EntityManager relevant to the specified URI <br />     // if available (i.e. the classpath set appropriately), the connection will be pooled <br />     EntityManager manager = new EntityManager(&quot;jdbc:mysql://localhost/ao_test&quot;, &quot;user&quot;, &quot;password&quot;); <br /><br /><br />     Family family = manager.create(Family.class); <br />     family.setName(&quot;Spiewak&quot;); <br />     family.save(); <br /><br /><br />     Person me = manager.create(Person.class); <br />     me.setName(&quot;Daniel Spiewak&quot;); <br />     me.setAge(27); <br />     me.setComment(&quot;I love databasing&quot;); <br />     me.setFamily(family); <br />     me.save(); <br /><br /><br />     Person you = manager.create(Person.class); <br />     you.setName(&quot;Joe Blow&quot;); <br />     you.setAge(23); <br />     you.setComment(&quot;Guess who?&quot;); <br />     you.setFamily(family); <br />     you.save(); <br /><br /><br />     PersonToPerson relation = manager.create(PersonToPerson.class); <br />     relation.setPersonA(me); <br />     relation.setPersonB(you); <br />     relation.save(); <br /><br /><br />     family.getPeople();                 // ...returns new Person[] {you, me} <br />     you.getPeople();                    // ...returns new Person[] {me} <br /><br /><br />     /* <br />      * notice, this is the first use of SQL in the whole example, and <br />      * it’s a contrived usage at that <br />      */ <br />     Family[] families = manager.findWithSQL(Family.class, &quot;familyID&quot;, &quot;SELECT DISTINCT familyID FROM <br /><br /><br />     // returns any person with age greater than or equal to 18 <br />     Person[] overAge = manager.find(Person.class, &quot;age &gt;= ?&quot;, 18); <br /><br /><br />     /* <br />      * notice the varargs parameters, as well as the direct use of an <br />      * entity instance without worrying about the ID value <br /><br /><br /><br />                                                  4 <br /> <br />        */ <br />      Person[] inFamilyOver21 = manager.find(Person.class, &quot;age &gt;= ? AND familyID = ?&quot;, 21, family); <br /><br />   As you see, much of the framework is designed to completely encapsulate the developer from the <br />complexities of SQL and even from the precise specics of the schema. The only place where this rule <br />is broken is in the find methods, which are designed to leverage the full power of SQL, rather than <br />completely shelter the developer. .. :mode=rest: <br /><br /><br />Supported Databases <br /><br />Most major databases are currently supported by ActiveObjects. This data is only current to the 0.8 <br />stable release. <br /><br /><br /><br />    Database                  URI Protocol                           Support <br /><br />   Derby                                                           Stable <br /><br />                                jdbc:derby <br /><br />                                jdbc:derby:// <br /><br /><br />   HSQLDB                                                          Well tested and very stable <br /><br />                                jdbc:hsqldb <br /><br />                                jdbc:hsqldb:// <br /><br /><br />   MS      SQL       Server                                          Stable <br />   2005 and 2007                 jdbc:sqlserver:// <br /><br />                                jdbc:jtds:sqlserver:// <br /><br /><br />   MySQL                                                           Well tested and very stable <br /><br />                                jdbc:mysql:// <br /><br /><br />   Oracle                                                          Under development <br /><br />                                jdbc:oracle:thin <br /><br />                                jdbc:oracle:oci <br /><br /><br />   PostgreSQL                                                      Well tested and stable <br /><br />                                jdbc:postgresql:// <br /><br /><br /><br /><br />Why ActiveObjects? <br /><br />Possibily the most important question to answer regarding ActiveObjects is to explain: why another <br />ORM? The Java ORM framework genre is completely dominated by the JBoss framework, Hibernate. <br />In fact, Hibernate is so widely used and respected that it’s even been ported to .NET (NHibernate). <br />So, if there’s already a widely respected, widely used and mature framework which seems to satesfy all <br />important use-cases, why throw another into the mix? <br /><br /><br /><br /><br />                                                     5 <br /> <br />   The answer really comes back to complexity. Hibernate is an incredibly complex framework. <br />Granted, it is complex mainly because it is powerful, but sometimes - most of the time even - the <br />required use-case is very simple and doesn’t require all of Hibernate’s compexities. ActiveObjects is <br />designed from the ground up to be as easy to use as possible, with a bare minimum of conguration. In <br />fact, to date ActiveObjects doesn’t even have a single hook which takes an XML (or any other format) <br />conguration le. Any and all conguration is either guessed from code, or easily set in code through <br />the discrete use of annotations. <br />   There is an increasing trend in the industry towards “convention over conguration.” This is most <br />reected in RAD frameworks such as Ruby on Rails. Much of the accepted industry pundits agree that <br />writing 20 lines of code is much easier than 20 lines of code and 150 lines of XML conguration (go <br />gure). ActiveObjects follows this practice as much as possible in its implementation. In fact, much of <br />the inspiration for the framework comes from Rails’s excelent ActiveRecord ORM (hence, the name). <br />The exception to this inspiration would be that ActiveObjects does not impose English pluralization <br />rules by default (though it is capable of such functionality when it is desirable). <br />   In fact, ActiveObjects strives so hard to be a simple and easy-to-use persistence framework that some <br />functionality (such as distributed transactions) has been simply omitted. The reasoning behind this is <br />that 99% of use-cases do not call for such extreme measures. If your project does require such complex <br />behavior within your ORM, you should be using Hibernate. It’s as simple as that. ActiveObjects is <br />not intended to supplant Hibernate. Rather, its goal is to be an easier and lighter alternative for <br />the many common scenarios which do not call for all of Hibernate’s awsome power. <br />   In short, ActiveObjects attempts to make database development simple and fun again. It abstracts <br />the developer from the intricacies of the database schema and the particulars of how to access it. <br />Using ActiveObjects, the only thing the developer needs to worry about is the high-level concept of <br />object-oriented design and data encapsulation. <br /><br /><br /><br /><br />                                                    6</pre> 
<p>=============================<br /> https://activeobjects.dev.java.net/</p> 
<p>&nbsp;&nbsp;&nbsp; * activeobjects-0.8.2.tar.gz (463.9 kB)</p> 
<p>ActiveObjects: An Easier Java ORM<br /> http://hi.baidu.com/hxzon/blog/item/1c607dcb6d81e711bf09e6e4.html</p> 
<p>==============================<br /> <a href="http://code.google.com/p/activejdbc/wiki/GettingStarted">http://code.google.com/p/activejdbc/wiki/GettingStarted</a> active jdbc</p> 
<p><a href="https://activeobjects.dev.java.net/">https://activeobjects.dev.java.net/</a> active object</p> 
<p><a href="http://arjava.sourceforge.net/index.html">http://arjava.sourceforge.net/index.html</a> active record java</p> 
<p><a href="http://www.scooterframework.com/docs/petclinic.html">http://www.scooterframework.com/docs/petclinic.html</a></p> 
<p><a href="http://jroller.com/buggybean/date/20050710#activemapper_part_1_automatic_mapping">http://jroller.com/buggybean/date/20050710#activemapper_part_1_automatic_mapping</a></p> 
<p><a href="http://code.google.com/p/hiverecord/">http://code.google.com/p/hiverecord/</a> hive record</p> 
<p><a href="http://community.jboss.org/wiki/GenericDataAccessObjects">http://community.jboss.org/wiki/GenericDataAccessObjects</a></p> 
<p> </p></div></body></html>