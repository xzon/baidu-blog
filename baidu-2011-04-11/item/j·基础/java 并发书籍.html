<html><head><title>java 并发书籍</title></head><body><div id='tit'>java 并发书籍</div><div id='cate'>j&middot;基础</div><div id='date'>2010年09月16日 星期四 09:21 A.M.</div><div id='page'>8</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/fe80c05c593e024dfbf2c0db.html'>http://hi.baidu.com/hxzon/blog/item/fe80c05c593e024dfbf2c0db.html</a><div id='cnt'><p>java 并发书籍</p> 
<br /> http://www.briangoetz.com/pubs.html 
<br /> http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html
<br /> 
<p>http://download.oracle.com/javase/tutorial/essential/concurrency/<br /> http://download.oracle.com/javase/tutorial/essential/concurrency/highlevel.html 官方教程</p> 
<blockquote> 
 <ul> 
  <li><em>Concurrent Programming in Java: Design Principles and Pattern (2nd Edition)</em> by Doug Lea. A comprehensive work by a leading expert, who's also the architect of the Java platform's concurrency framework.</li> 
  <li><em>Java Concurrency in Practice</em> by Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea. A practical guide designed to be accessible to the novice.</li> 
  <li><em>Effective Java Programming Language Guide</em> by Joshua Bloch. Though this is a general programming guide, its chapter on threads contains essential &quot;best practices&quot; for concurrent programming.</li> 
  <li><em>Concurrency: State Models &amp; Java Programs (2nd Edition)</em>, by Jeff Magee and Jeff Kramer. An introduction to concurrent programming through a combination of modeling and practical examples.</li> 
 </ul> 
</blockquote> 
<h1>Concurrent Programming in Java: Design Principles and Patterns</h1> 
<p><strong>Second Edition, Published 11/99<br /> author </strong>Doug Lea</p> 
<p><img src="image/java 并发书籍.html.407eb51cafd985cd86d6b6ad.jpg" /><p class="origImg">http://hiphotos.baidu.com/hxzon/pic/item/407eb51cafd985cd86d6b6ad.jpg</p></p> 
<p>http://www.informit.com/articles/article.aspx?p=167821</p> 
<p>http://java.sun.com/docs/books/cp/</p> 
<p>http://gee.cs.oswego.edu/dl/cpj/index.html 内容补充<br /> This is the supplement to the book <em>Concurrent Programming in Java: Design Principles and Patterns</em> by <a href="http://gee.cs.oswego.edu/dl/">Doug Lea</a> (ISBN 0-201-31009-0). Second edition published by <a href="http://www.awl.com/">Addison-Wesley</a>, November 1999.</p> 
<p>http://gee.cs.oswego.edu/dl/cpj/errata.html 勘误表</p> 
<p>最新版第三版<br /> http://www.amazon.co.uk/Concurrent-Programming-Java-TM-Principles/dp/0321256174/ref=dp_ob_title_bk/277-8410546-0188058</p> 
<ul> 
 <li><strong>Paperback:</strong> 560 pages</li> 
 <li><strong>Publisher:</strong> Addison-Wesley Professional; 3 edition (19 May 2006)</li> 
 <li><strong>Language</strong> English</li> 
 <li><strong>ISBN-10:</strong> 0321256174</li> 
 <li><strong>ISBN-13:</strong> 978-0321256171</li> 
</ul> 
<p> </p> 
<h1 class="PageTitle">Java Concurrency in Practice</h1> 
<p>http://www.javaconcurrencyinpractice.com/</p> 
<p><img src="image/java 并发书籍.html.4caba78bad0e03399f2fb4ad.jpg" /><p class="origImg">http://hiphotos.baidu.com/hxzon/pic/item/4caba78bad0e03399f2fb4ad.jpg</p></p> 
<p>http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601</p> 
<ul> 
 <li><strong>Paperback:</strong> 384 pages</li> 
 <li><strong>Publisher:</strong> Addison-Wesley Professional (May 19, 2006)</li> 
 <li><strong>Language:</strong> English</li> 
 <li><strong>ISBN-10:</strong> 0321349601</li> 
 <li><strong>ISBN-13:</strong> 978-0321349606</li> 
</ul> 
<p>chm</p> 
<p>Java Concurrency in Practice<br /> By Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, Doug Lea<br /> ...............................................<br /> Publisher: Addison Wesley Professional<br /> Pub Date: May 09, 2006<br /> Print ISBN-10: 0-321-34960-1<br /> Print ISBN-13: 978-0-321-34960-6<br /> Pages: 384</p> 
<p>Copyright<br /> Advance Praise for Java Concurrency in Practice<br /> Listings<br /> Preface<br /> Chapter 1. Introduction<br /> Section 1.1. A (Very) Brief History of Concurrency<br /> Section 1.2. Benefits of Threads<br /> Section 1.3. Risks of Threads<br /> Section 1.4. Threads are Everywhere<br /> Part I: Fundamentals<br /> Chapter 2. Thread Safety<br /> Section 2.1. What is Thread Safety?<br /> Section 2.2. Atomicity<br /> Section 2.3. Locking<br /> Section 2.4. Guarding State with Locks<br /> Section 2.5. Liveness and Performance<br /> Chapter 3. Sharing Objects<br /> Section 3.1. Visibility<br /> Section 3.2. Publication and Escape<br /> Section 3.3. Thread Confinement<br /> Section 3.4. Immutability<br /> Section 3.5. Safe Publication<br /> Chapter 4. Composing Objects<br /> Section 4.1. Designing a Thread-safe Class<br /> Section 4.2. Instance Confinement<br /> Section 4.3. Delegating Thread Safety<br /> Section 4.4. Adding Functionality to Existing Thread-safe Classes<br /> Section 4.5. Documenting Synchronization Policies<br /> Chapter 5. Building Blocks<br /> Section 5.1. Synchronized Collections<br /> Section 5.2. Concurrent Collections<br /> Section 5.3. Blocking Queues and the Producer-consumer Pattern<br /> Section 5.4. Blocking and Interruptible Methods<br /> Section 5.5. Synchronizers<br /> Section 5.6. Building an Efficient, Scalable Result Cache<br /> Summary of Part I<br /> Part II: Structuring Concurrent Applications<br /> Chapter 6. Task Execution<br /> Section 6.1. Executing Tasks in Threads<br /> Section 6.2. The Executor Framework<br /> Section 6.3. Finding Exploitable Parallelism<br /> Summary<br /> Chapter 7. Cancellation and Shutdown<br /> Section 7.1. Task Cancellation<br /> Section 7.2. Stopping a Thread-based Service<br /> Section 7.3. Handling Abnormal Thread Termination<br /> Section 7.4. JVM Shutdown<br /> Summary<br /> Chapter 8. Applying Thread Pools<br /> Section 8.1. Implicit Couplings Between Tasks and Execution Policies<br /> Section 8.2. Sizing Thread Pools<br /> Section 8.3. Configuring ThreadPoolExecutor<br /> Section 8.4. Extending ThreadPoolExecutor<br /> Section 8.5. Parallelizing Recursive Algorithms<br /> Summary<br /> Chapter 9. GUI Applications<br /> Section 9.1. Why are GUIs Single-threaded?<br /> Section 9.2. Short-running GUI Tasks<br /> Section 9.3. Long-running GUI Tasks<br /> Section 9.4. Shared Data Models<br /> Section 9.5. Other Forms of Single-threaded Subsystems<br /> Summary<br /> Part III: Liveness, Performance, and Testing<br /> Chapter 10. Avoiding Liveness Hazards<br /> Section 10.1. Deadlock<br /> Section 10.2. Avoiding and Diagnosing Deadlocks<br /> Section 10.3. Other Liveness Hazards<br /> Summary<br /> Chapter 11. Performance and Scalability<br /> Section 11.1. Thinking about Performance<br /> Section 11.2. Amdahl's Law<br /> Section 11.3. Costs Introduced by Threads<br /> Section 11.4. Reducing Lock Contention<br /> Section 11.5. Example: Comparing Map Performance<br /> Section 11.6. Reducing Context Switch Overhead<br /> Summary<br /> Chapter 12. Testing Concurrent Programs<br /> Section 12.1. Testing for Correctness<br /> Section 12.2. Testing for Performance<br /> Section 12.3. Avoiding Performance Testing Pitfalls<br /> Section 12.4. Complementary Testing Approaches<br /> Summary<br /> Part IV: Advanced Topics<br /> Chapter 13. Explicit Locks<br /> Section 13.1. Lock and ReentrantLock<br /> Section 13.2. Performance Considerations<br /> Section 13.3. Fairness<br /> Section 13.4. Choosing Between Synchronized and ReentrantLock<br /> Section 13.5. Read-write Locks<br /> Summary<br /> Chapter 14. Building Custom Synchronizers<br /> Section 14.1. Managing State Dependence<br /> Section 14.2. Using Condition Queues<br /> Section 14.3. Explicit Condition Objects<br /> Section 14.4. Anatomy of a Synchronizer<br /> Section 14.5. AbstractQueuedSynchronizer<br /> Section 14.6. AQS in Java.util.concurrent Synchronizer Classes<br /> Summary<br /> Chapter 15. Atomic Variables and Nonblocking Synchronization<br /> Section 15.1. Disadvantages of Locking<br /> Section 15.2. Hardware Support for Concurrency<br /> Section 15.3. Atomic Variable Classes<br /> Section 15.4. Nonblocking Algorithms<br /> Summary<br /> Chapter 16. The Java Memory Model<br /> Section 16.1. What is a Memory Model, and Why would I Want One?<br /> Section 16.2. Publication<br /> Section 16.3. Initialization Safety<br /> Summary<br /> Appendix A. Annotations for Concurrency<br /> Section A.1. Class Annotations<br /> Section A.2. Field and Method Annotations<br /> Bibliography<br /> Index</p> 
<p> 中文版</p> 
<h1>JAVA并发编程实践</h1> 
<p> <span><span>代码清单<br /> 序<br /> 第1章 介绍<br /> 1.1 并发的（非常）简短历史<br /> 1.2 线程的优点<br /> 1.3 线程的风险<br /> 1.4 线程无处不在<br /> 第1部分 基础<br /> 第2章 线程安全<br /> 2.1 什么是线程安全性<br /> 2.2 原子性<br /> 2.3 锁<br /> 2.4 用锁来保护状态<br /> 2.5 活跃度与性能<br /> 第3章 共享对象<br /> 3.1 可见性<br /> 3.2 发布和逸出<br /> 3.3 线程封闭<br /> 3.4 不可变性<br /> 3.5 安全发布<br /> 第4章 组合对象<br /> 4.1 设计线程安全的类<br /> 4.2 实例限制<br /> 4.3 委托线程安全<br /> 4.4 向已有的线程安全类添加功能<br /> 4.5 同步策略的文档化<br /> 第5章 构建块<br /> 5.1 同步容器<br /> 5.2 发容器<br /> 5.3 阻塞队列和生产者一消费者模式<br /> 5.4 阻塞和可中断的方法<br /> 5.5 Synchronizer<br /> 5.6 为计算结果建立高效、可伸缩的高速缓存<br /> 第2部分 构建并发应用程序<br /> 第6章 任务执行<br /> 6.1 在线程中执行任务<br /> 6.2 Executor 框架<br /> 6.3 寻找可强化的并行性<br /> 第7章 取消和关闭<br /> 7.1 任务取消<br /> 7.2 停止基于线程的服务<br /> 7.3 处理反常的线程终止<br /> 7.4 JVM关闭<br /> 第8章 应用线程池<br /> 8.1 任务与执行策略问的隐性耦合<br /> 8.2 定制线程池的大小<br /> 8.3 配置ThreadPoolExecutor<br /> 8.4 扩展ThreadPoolExecutor<br /> 8.5 并行递归算法<br /> 第9章 GUI应用程序<br /> 9.1 为什么GUI是单线程化的<br /> 9.2 短期的GUI任务<br /> 9.3 耗时GUI任务<br /> 9.4 共享数据模型<br /> 9.5 其他形式的单线程子系统<br /> 第3部分 活跃度，性能和测试<br /> 第10章 避免活跃度危险<br /> 第11章 性能和可伸缩性<br /> 第12章 测试并发程序<br /> 第4部分 高级主题<br /> 第13章 显示锁<br /> 第14章 构建自定义的同步工具<br /> 第15章 原子变量与非阻塞同步机制<br /> 第16章 Java存储模型<br /> 附录A 同步Annotation<br /> 参考文献<br /> 索引</span></span></p> 
<p> </p> 
<p> </p> 
<p> </p></div></body></html>