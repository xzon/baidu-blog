<html><head><title>框架设计（第2版）：CLR Via C# 第10章 事件（续2）</title></head><body><div id='tit'>框架设计（第2版）：CLR Via C# 第10章 事件（续2）</div><div id='cate'>异域</div><div id='date'>2008年03月08日 星期六 01:46 P.M.</div><div id='page'>161</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/75a36d633e72d3640d33fa62.html'>http://hi.baidu.com/hxzon/blog/item/75a36d633e72d3640d33fa62.html</a><div id='cnt'><p><a href="http://book.csdn.net/bookfiles/154"><font color="#666699">框架设计（第2版）：CLR Via C#</font></a></p> 
<h3><span>10.4 </span><span>事件与线程安全</span></h3> 
<p style="text-indent: 21pt" class="MsoNormal"><span>10.3</span><span>节示范了</span><span>C#</span><span>编译器如何为事件的</span><span>add</span><span>和</span><span>remove</span><span>方法增加</span><span>[MethodImpl (MethodImplOptions.Synchronized)]</span><span>属</span><span>性。这个属性的目的是为了确保在操作实例的事件成员时，对于任何一个对象，在</span><span>同一时刻只能有一个</span><span>add</span><span>方法或者</span><span>remove</span><span>方法可以执行。该属性同样确保在操作静态事件成员时，同一时刻也只能有一个</span><span>add</span><span>方法或者</span><span>remove</span><span>方法可以执行。这里需要线</span><span>程同步，以免委托对象的链表被破坏。但应注意，</span><span>CLR</span><span>实现线程同步的方式中存在许多问题。</span></p> 
<p style="text-indent: 21pt" class="MsoNormal"><span>对实例</span><span>(</span><span>非静态</span><span>)</span><span>方法应用</span><span>MethodImpl</span><span>属性时，</span><span>CLR</span><span>使用对象本身作为线程同步锁。这意味着如果类定义了许多事件，那么所有</span><span>的</span><span>add</span><span>和</span><span>remove</span><span>方法</span><span>都将使用相同的锁，这种情况下，如果有多个线程同时订阅和注销不同的事件，则会损害可扩展性。但这种情况非常少见，而且对于大多数应用程序，这并不是一个问题。但是，线程同步的指导方针中规定方法不应在对象本身上加同步锁，因为同步锁将对所有的代码公开。这意味着任何人都可以编写代码锁住这个对象，从而可能导致其他线程死锁。如果希望自己编写的类型防御措施好，更加健壮，那么应使用不同的对象来完成加锁功能。</span><span>10.5</span><span>节将示范如何实现这个</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>功能。</span></p> 
<p style="text-indent: 21pt" class="MsoNormal"><span>在静态方法上应用</span><span>[</span><span>MethodImpl(MethodImplOptions.Synchronized)]</span><span>属性时，</span><span>CLR</span><span>使用类型对象作为线程同步锁。这又意味着如果类定义了许多静态事件，那么所有的</span><span>add</span><span>和</span><span>remove</span><span>方</span><span>法都将使用相同的锁，这种情况下，如果有多个线程同时订阅和注销不同的事件，则会损害代码的性能。但是这种情况也非常少见。</span></p> 
<p style="text-indent: 21pt" class="MsoNormal"><span>但还有一个严重的问题：线程同步指导方针指出，方法永远不要在类型对象上加锁，因为这个锁将对所有的代码公开。另外，当类型加载与域无关时，</span><span>CLR</span><span>中还有一个错误。这种情况会导致同步锁被使用该类型的所有应用程序域共享，如此一来，一个程序域中的代码会影响另一个应用程序域中运行的代码。实际中，</span><span>C#</span><span>编译器在实</span><span>现静态</span><span>add</span><span>和</span><span>remove</span><span>方</span><span>法的线程安全时应采用完全不同的方法。</span><span>10.5</span><span>节将讨论一种修正</span><span>C#</span><span>编译器这一缺陷的</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>机制。</span></p> 
<p style="text-indent: 21pt" class="MsoNormal"><span>C#</span><span>和</span><span>CLR</span><span>允许定义一个有一个或者多个实例</span><span>(</span><span>非静态</span><span>)</span><span>事件成员的值类型</span><span>(</span><span>结构</span><span>)</span><span>。但必须意识到，在上述情况下，</span><span>C#</span><span>编译器根本不会保证线程安全。因为拆箱</span><span>(</span><span>unboxing</span><span>)</span><span>的值类型没有与其相关联的锁对象。实际上，</span><span>C#</span><span>编译器不为</span><span>add</span><span>和</span><span>remove</span><span>方法</span><span>生成</span><span>[MethodImpl (MethodImplOptions.Synchronized)]</span><span>属</span><span>性，因为该属性对值类型的实例方法没有效果。遗憾的是，当实例事件定义为值类型的成员时，的确没有更好的方式为它们保证线程安全。因此，建议大家尽量避免这样做。注意，在值类型中定义的静态事件</span><span>(</span><span>加上前面讨论的限制</span><span>)</span><span>可以保证线程安全，因为静态事件对类型对象</span><span>(</span><span>引用类型</span><span>)</span><span>本身加锁。但是，如果要使代码健壮，应采用</span><span>10.5</span><span>节讨论的机制。</span></p> 
<span> <h3><span>10.5 </span><span>显式控制事件的订阅与注销</span></h3> <p style="text-indent: 21pt" class="MsoNormal"><span>有时我们会感到编译器</span><span>生成的</span><span>add</span><span>和</span><span>remove</span><span>方法</span><span>不是那么理想。例如</span><span>10.4</span><span>节中讨论的使用</span><span>MicrosoftC#</span><span>编译器时遇到的所有线程安全问题。实际上，</span><span>Microsoft</span><span>的</span><span>C#</span><span>编译器在安全编程</span><span>(defensive coding)</span><span>和健壮性方面永远不是最安全的。为了创建一个坚固的组件，建议经常采用本节介绍的技术，该技术可以用于解决与线程安全相关的所有问题。而且该技术同样也可以应用于其他目的。例如，显式实</span><span>现</span><span>add</span><span>和</span><span>remove</span><span>方</span><span>法的普遍原因就是类型定义了许多事件，而且又需要高效地进行存储。有关详情请参见</span><span>10.6</span><span>节。</span></p> <p style="text-indent: 21pt" class="MsoNormal"><span>幸亏</span><span>C#</span><span>编译器以及其他许多编译器都允许开发</span><span>人员显式地实现</span><span>add</span><span>和</span><span>remove</span><span>访问器方法。为了保证</span><span>MailManager</span><span>对象上事件的订阅和注销的线程安全，我们修改了</span><span>MailManager</span><span>类的代码，修改后的代码</span><span>如下所示：</span></p> <p style="text-indent: 21pt" class="af0"> </p> <p style="margin-left: 21pt" class="ab"><span>internal class MailManager {</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; //</span><span>创建一个作为线程同步锁的私有实例字段</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; private readonly Object m_eventLock = new Object();</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; //</span><span>增加一个引用委托链表头部的私有字段</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; private EventHandler&lt;NewMailEventArgs&gt; m_NewMail;</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; //</span><span>为类增加一个事件成员</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; public event EventHandler&lt;NewMailEventArgs&gt; NewMail {</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span>显式实现</span><span>'add'</span><span>方法</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add {</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span>加私有锁，并向委托链表增加一个处理程序</span><span>(</span><span>以</span><span>'value'</span><span>为参数</span><span>)</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock (m_eventLock) { m_NewMail += value; } </span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span>显式实现</span><span>'remove'</span><span>方法</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove {</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span>加私有锁，并从委托链表从中移除处理程序</span><span>(</span><span>以</span><span>'value'</span><span>为参数</span><span>)</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock (m_eventLock) { m_NewMail -= value; }</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; }</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; //</span><span>第三步：定义一个负责引发事件的方法，来通知已订阅事件的对象事件已经发生。如果类是封装的，</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; //</span><span>则需要将方法声明为</span><span>private</span><span>和</span><span>non-virtual</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; protected virtual void OnNewMail(NewMailEventArgs e) {</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //</span><span>出于线程安全的考虑，将委托字段保存到一个临时字段中</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EventHandler&lt;NewMailEventArgs&gt; temp = m_NewMail;</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span>通知所有已订阅事件的对象</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (temp != null) temp(this, e);</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; }</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; //</span><span>第四步：定义一个方法，将输入转化为期望事件</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; public void SimulateNewMail(String from, String to, String subject) {</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span>构建一个对象来存放我们希望传递给通知接收者的信息</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NewMailEventArgs e = new NewMailEventArgs(from, to, subject);</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span>调用虚方法以通知对象事件已经发生。如果没有对象重写该方法，那么该对象将通知所有订阅</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span>该事件的对象</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnNewMail(e);</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; }</span></p> <p style="margin-left: 21pt" class="ab"><span>}</span></p> <p style="text-indent: 21pt" class="af0"> </p> <p style="text-indent: 21pt" class="MsoNormal"><span>在新版的</span><span>MailManager</span><span>中，必须显式地定义引用委托链表的私有字段</span><span>m_NewMail</span><span>。</span><span>在原来的事件语法中，</span><span>C#</span><span>编译器自动地将字</span><span>段定义为</span><span>private</span><span>。在使用新版的事件语法时，开发人员在显式提供</span><span>add</span><span>和</span><span>remove</span><span>访问</span><span>器方法实现时，必须同样显式地声明字段。</span></p> <p style="text-indent: 21pt" class="MsoNormal"><span>m_NewMail</span><span>字段只是一个</span><span>EventHandler&lt;NewMailEventArgs&gt;</span><span>委托的引用。该字段还不能成为一个事件。关键字</span><span>event</span><span>后新的扩展事件语法实际上就是类型中定义事件的内容。</span><span>add</span><span>和</span><span>remove</span><span>块中的代码提供了访问器方法的实现。注意，每个方法都接受一个称为</span><span>value</span><span>的隐藏参数，该参数的类型为</span><span>EventHandler&lt;NewMailEventArgs&gt;</span><span>。方法内部，方法或者实现向委托链表中增加一个委托所需的代码，或者从委托链表中移除一个委托所需的代码。和属性不同，属性可以有一个</span><span>get</span><span>访问器方法，也可以有一个</span><span>set</span><span>访问器方法，还可以同时拥有这两个访问器方法，但是事件必须同时拥有</span><span>add</span><span>和</span><span>remove</span><span>访</span><span>问器方法。</span></p> <p style="text-indent: 21pt" class="MsoNormal"><span>以上示例中</span><span>的显式实现除了省略</span><span> [MethodImpl(MethodImplOptions. Synchronized)]</span><span>特性之外，其他地方和</span><span>C#</span><span>编译器为方法提供的实现拥有相同的行为，相反，</span><span>C#</span><span>的</span><span>lock</span><span>语句和一个被私下定义为</span><span>Object </span><span>(</span><span>m_eventLock</span><span>)</span><span>对象的引用一起使用。这就是在</span><span>10.4</span><span>节提到的修正线程安全问题的方法。由于</span><span>m_eventLock</span><span>字段被声明为</span><span>private</span><span>，所以</span><span>MailManager</span><span>类外面的代码无法访问这个字段，这将使</span><span>MailManager</span><span>类更加健</span><span>壮。</span></p> <p style="text-indent: 21pt" class="MsoNormal"><span>事件可以被声</span><span>明为</span><span>static</span><span>成员，这将使</span><span>add</span><span>和</span><span>remove</span><span>访问器方法也被声明为</span><span>static</span><span>。当然，私有字段</span><span>m_NewMail</span><span>也变为</span><span>static</span><span>。然后，为了获得正确的线程安全，</span><span>m_eventLock</span><span>字段也应声明为</span><span>static</span><span>。对于希望以线程安全的方式对外提供静态事件的引用类型或者值</span><span>类型来说，这种方法是可行的。然而，正如</span><span>10.4</span><span>节所述，因为没有好的方法初始化值类型中的实例字段</span><span>(</span><span>具体原因请参见第</span><span>5</span><span>章</span><span>)</span><span>，所以也没有好的方法保证值类型实例事件的线程</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>安全。</span></p> <p style="text-indent: 21pt" class="MsoNormal"><span>实现事件订阅或者注销的代码</span><span>不能判断事件的</span><span>add</span><span>和</span><span>remove</span><span>方法是</span><span>由编译器自动创建的还是由编程人员显式实现的。实际上，订阅和注销事件的代码仍然可以使用</span><span>+=</span><span>和</span><span>-</span><span>=</span><span>操作符，而且编译器在遇到这两个操作符时会自动地生成显式定义方法的调用。</span></p> <p style="text-indent: 21pt" class="MsoNormal"><span>最后需要指出的</span><span>是</span><span>OnNewMail</span><span>方法。从语义上讲，这个</span><span>OnNewMail</span><span>方法与前一版本中</span><span>OnNewMail</span><span>方法相</span><span>同。两者惟一的差别就是事件的名称</span><span>(</span><span>NewMail</span><span>)</span><span>被替换为委托字段的名称</span><span>(</span><span>m_NewMail</span><span>)</span><span>。</span></p> <span> <h3><span>10.6 </span><span>设计一个定义多个事件的类型</span></h3> <p style="text-indent: 21pt" class="MsoNormal"><span>10.5</span><span>节讨论了如何为一个事件显式提供</span><span>add</span><span>和</span><span>remove</span><span>访</span><span>问器方法。但是，在显式地实现这些访问器方法时，可以在具体的实现上有所创新。下面来看如何显式地实现这些方法以减少应用程序使用的内存资源。</span></p> <p style="text-indent: 21pt" class="MsoNormal"><span>System.Windows.Forms.Control</span><span>类</span><span>型定义了大约</span><span>70</span><span>个事件。如</span><span>果</span><span>Control</span><span>类</span><span>型在实现这些事件时允许编译器来自动</span><span>生成</span><span>add</span><span>和</span><span>remove</span><span>访问器</span><span>方法以及委托字段，那</span><span>么每个</span><span>Control</span><span>对</span><span>象仅仅因为事件就是</span><span>70</span><span>个委托字段。因为对象大多数时候订阅的事件都很少，因此为每个对象一一创建继承</span><span>自</span><span>Control</span><span>类</span><span>型的实例会浪费大量的内存。顺便</span><span>说一下，</span><span>System.Web.UI.Control</span><span>类型也使</span><span>用下述技巧来减少未使用事件对内存的浪费。</span></p> <p style="text-indent: 21pt" class="MsoNormal"><span>通过创造性地显式实</span><span>现事件的</span><span>add</span><span>和</span><span>remove</span><span>方法，</span><span>我们可以极大地减少对象由于定义多个事件而造成的内存浪费。本节将示范如何高效地定义一个对外提供多个事件的类型。</span></p> <p style="text-indent: 21pt" class="MsoNormal"><span>我们的基本思路是让每个对象都保存一个集合</span><span>(</span><span>通常是字典</span><span>)</span><span>，这个集合由一些事件标识符作为主键</span><span>(key)</span><span>，委托列表作为键值。一个新的对象被构建时，该集合是空的。有事件被订阅时，在集合中查找事件的标识符。如果集合中存在该事件的标识符，那么新的委托实例将被组合到表示该事件的委托链表上。如果集合中没有该事件的标识符，那么事件的标识符将被添加到委托链表上。</span></p> <p style="text-indent: 21pt" class="MsoNormal"><span>对象需要引发事件时，首先在集合中查找事件标识符。如果集合中没有事件标识符的条目，也就是说该事件没有被订阅，就没有委托被回调。如果在集合中查找到事件标识符，那么与事件标识符对应的委托链表将被调用。这种设计模式的实现是设计定义多个事件的类型的开发人员的责任，使用事件的开发人员则无需知道事件内部是如何实现的。</span></p> <p style="text-indent: 21pt" class="MsoNormal"><span>范例</span><span>TypeWithLotsOfEvents</span><span>的应用程序可以从</span><em><span>http://wintellect.com</span></em><span>下载，该范例演示了如何设计一个定义多个事件的类型。代码中有详细的注释说明，如果理解了本章所讨论的一切内容，那么理解该应用程序中的代码就不会有任何问题，而且还可以把它应用到自己的应用程序中去。</span></p> <p class="MsoList2"><sub><span><img width="18" height="27" src="image/框架设计（第2版）：CLR Via C#.image005.jpg" /><p class="origImg">http://book.csdn.net/bookfiles/154/00/image005.jpg</p></span></sub><span> </span><span>注意</span><span>&nbsp;&nbsp;&nbsp; </span><span>本章中的代码使用了一个可重用的称为</span><span>EventSet</span><span>的辅助类，该类存放着事件标识符的字典，包括主键和委托值两部分。</span><span>FLC</span><span>中定义了一个名为</span><span>System.ComponentModel.EventHandlerList</span><span>的类型，该类型与我们自己定义的</span><span>EventSet</span><span>类型所做的事情基本上一样。</span><span>System.Windows.Forms.Control</span><span>和</span><span>System.Web.UI.Control</span><span>类型内部使用</span><span>EventHandlerList</span><span>类型来存放它们各自的稀疏事件集合。大家完全可以根据自己的意愿使用</span><span>FCL</span><span>中的</span><span>EventHandlerList</span><span>类型。</span><span>EventHandlerList</span><span>类型与我们自己定义的</span><span>EventSet</span><span>类型之间的区别就是</span><span>EventHandlerList</span><span>使用了一个链表，而不是哈希表</span><span>(</span><span>hash table</span><span>)</span><span>。这意味着访问</span><span>EventHandlerList</span><span>托管的元素比访问</span><span>EventSet</span><span>托管的元素要慢一些。另外，</span><span>EventHandlerList</span><span>类型没有提供任何线程安全的访问方式，如果需要线程安全的访问，只能自行实现一个对</span><span>EventHandlerList</span><span>类型线程安全的密封，而我们自己定义的</span><span>EventSet</span><span>类型则完全支持线程安全。</span></p> </span></span></div></body></html>