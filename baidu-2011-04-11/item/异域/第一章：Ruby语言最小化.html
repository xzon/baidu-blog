<html><head><title>第一章：Ruby语言最小化</title></head><body><div id='tit'>第一章：Ruby语言最小化</div><div id='cate'>异域</div><div id='date'>2008年04月05日 星期六 02:11 P.M.</div><div id='page'>143</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/5ca0364ed2fb6cced0c86af0.html'>http://hi.baidu.com/hxzon/blog/item/5ca0364ed2fb6cced0c86af0.html</a><div id='cnt'><div> 
 <p>第一章：Ruby语言最小化</p> 
 <p><br /> 谈及Ruby语言，这里只是简单解释了理解第一部分所需的知识。这里并没有完全指出编程中需要注意的地方，本章的目的在于读，而非写Ruby程序。有Ruby经验的人可以放心的跳过这一章。</p> 
</div> 
<div> 
</div> 
<div>
 关于语法，在第二部分中，我们会一直谈到令人厌倦，所以，本章就不做详尽的讨论了。只有那些用得最多的，比如hash文字量，会谈到一些变化。原则上，不省略那些可能省略的东西。因为这样会让语法规则变得简单，不必到处去写“此处省略”。
</div> 
<div> 
</div> 
<div>
 对象
 <br /> 字符串
 <br /> Ruby程序中可操作的东西都是对象，没有像Java的int和long这样的基本类型（primitive）。比如，下面这样写就是一个内容为“content”的字符串对象（String对象）。
</div> 
<div> 
</div> 
<div>
 &quot;content&quot;
</div> 
<div> 
</div> 
<div>
 简单的说，这是调用了一个字符串对象，更准确的说法是，这是一个产生字符串对象的“表达式”。因此，如果你写了多次，那么每次都会生成一个字符串对象。
</div> 
<div> 
</div> 
<div>
 &quot;content&quot; 
 <br /> &quot;content&quot; 
 <br /> &quot;content&quot;
</div> 
<div> 
</div> 
<div>
 这里生成了三个内容同为“content”的对象。
</div> 
<div> 
</div> 
<div>
 对了，仅仅这样，程序员是无法看到对象的。下面是在终端上显示对象的方法。
</div> 
<div> 
</div> 
<div>
 p(&quot;content&quot;)&nbsp;&nbsp; # 显示&quot;content&quot;
</div> 
<div> 
</div> 
<div>
 “#”之后是注释。今后，结果都以注释给出。
</div> 
<div> 
</div> 
<div>
 “p(……)”表示调用函数p，任何对象都可以显示出来，基本上，它就是一个调试函数。
</div> 
<div> 
</div> 
<div>
 严格说来，Ruby没有函数，不过，可以把它认为是函数。这个“函数”可以用在任何可以用的地方。
</div> 
<div> 
</div> 
<div>
 各种各样的文字量（literal）
 <br /> 接下来，稍微说明一下可以直接生成对象的表达式（文字量）。先来看一下整数和小数。
</div> 
<div> 
</div> 
<div>
 # 整数
 <br /> 1
 <br /> 2
 <br /> 100
 <br /> 9999999999999999999999999&nbsp;&nbsp; # 多大的数都能用
</div> 
<div> 
</div> 
<div>
 # 小数
 <br /> 1.0
 <br /> 99.999
 <br /> 1.3e4&nbsp;&nbsp;&nbsp;&nbsp; # 1.3&times;10^4
</div> 
<div> 
</div> 
<div>
 不要忘了，这些都是生成对象的表达式。重复一下，Ruby中没有“基本类型”。
</div> 
<div> 
</div> 
<div>
 下面的表达式生成数组对象。
</div> 
<div> 
</div> 
<div>
 [1, 2, 3]
</div> 
<div> 
</div> 
<div>
 这段程序生成了一个数组，它按顺序包含1、2、3三个整数作为其元素。数组元素可以使用任意对象，这样也可以。
</div> 
<div> 
</div> 
<div>
 [1, &quot;string&quot;, 2, [&quot;nested&quot;, &quot;array&quot;]]
</div> 
<div> 
</div> 
<div>
 下面的表达式生成hash表。
</div> 
<div> 
</div> 
<div>
 {&quot;key&quot;=&gt;&quot;value&quot;, &quot;key2&quot;=&gt;&quot;value2&quot;, &quot;key3&quot;=&gt;&quot;value3&quot;}
</div> 
<div> 
</div> 
<div>
 hash表是一种在任意对象间建立一一对应关系的结构。像上面表达的是下面这样关系的一个表。
</div> 
<div> 
</div> 
<div>
 &quot;key&quot;&nbsp;&nbsp; → &quot;value&quot; 
 <br /> &quot;key2&quot; → &quot;value2&quot; 
 <br /> &quot;key3&quot; → &quot;value3&quot;
</div> 
<div> 
</div> 
<div>
 对这样创建出的一个hash表对象，这样问，“什么与‘key’对应？”，如果能听的话，“是‘value’。” 怎么听？使用方法。
</div> 
<div> 
</div> 
<div>
 方法调用
 <br /> 方法可以通过对象调用。C++术语称之为成员函数。何为方法，没有必要深入解释，这里只简单解释一下记法。
</div> 
<div> 
</div> 
<div>
 &quot;content&quot;.upcase()
</div> 
<div> 
</div> 
<div>
 这表示对字符串对象（其内容为“content”）调用upcase方法。upcase是这样一个方法，它返回一个新的字符串对象，将小写字母转换为大写字母，其结果如下：
</div> 
<div> 
</div> 
<div>
 p(&quot;content&quot;.upcase())&nbsp;&nbsp; # 显示&quot;CONTENT&quot;
</div> 
<div> 
</div> 
<div>
 方法可以连续调用。
</div> 
<div> 
</div> 
<div>
 &quot;content&quot;.upcase().downcase()
</div> 
<div> 
</div> 
<div>
 在这里，对&quot;content&quot;.upcase()的返回值对象调用downcase方法。
</div> 
<div> 
</div> 
<div>
 然而，不像Java或C++那样有公有的字段（成员变量），对象的接口只有方法。
</div> 
<div> 
</div> 
<div>
 程序
 <br /> 顶层（top level）
 <br /> 直接写出Ruby表达式就是程序，不必像Java或C++那样定义main()。
</div> 
<div> 
</div> 
<div>
 p(&quot;content&quot;)
</div> 
<div> 
</div> 
<div>
 这就是一个完整的程序了。把这段代码放到一个名为first.rb的文件中，可以在命令行中这样执行：
</div> 
<div> 
</div> 
<div>
 % ruby first.rb
 <br /> &quot;content&quot;
</div> 
<div> 
</div> 
<div>
 如果使用ruby的-e选项，连创建文件都省了。
</div> 
<div> 
</div> 
<div>
 % ruby -e 'p(&quot;content&quot;)'
 <br /> &quot;content&quot;
</div> 
<div> 
</div> 
<div>
 对了，p所写的地方在程序的嵌套层次上是最低的，也就是说，它位于程序的最上层，称为“顶层”。拥有顶层是Ruby作为脚本语言的一大特征。
</div> 
<div> 
</div> 
<div>
 在Ruby中，基本上一行就是一条语句，最后面无需分号。因此，下面的程序可以解释为三条语句。
</div> 
<div> 
</div> 
<div>
 p(&quot;content&quot;)
 <br /> p(&quot;content&quot;.upcase())
 <br /> p(&quot;CONTENT&quot;.downcase())
</div> 
<div> 
</div> 
<div>
 如果执行的话，结果是这样。
</div> 
<div> 
</div> 
<div>
 % ruby second.rb
 <br /> &quot;content&quot; 
 <br /> &quot;CONTENT&quot; 
 <br /> &quot;content&quot;
</div> 
<div> 
</div> 
<div>
 局部变量
 <br /> 在Ruby中，无论是变量还是常量，全都保持着引用（reference）。因此，当一个变量对另一个变量赋值时，不会发生复制。可以考虑Java的对象类型变量、C++的对象指针。然而，无法修改指针自身的值。
</div> 
<div> 
</div> 
<div>
 Ruby变量的头表示了变量的类型（作用域）。以小写字母或下划线开头的表示局部变量。 “=”表示赋值。
</div> 
<div> 
</div> 
<div>
 str = &quot;content&quot; 
 <br /> arr = [1,2,3]
</div> 
<div> 
</div> 
<div>
 最初的赋值同时表示变量声明，因此无需声明。变量是无类型的，无论是何种类型，都可以无差别的赋值。下面的程序完全合法。
</div> 
<div> 
</div> 
<div>
 lvar = &quot;content&quot; 
 <br /> lvar = [1,2,3]
 <br /> lvar = 1
</div> 
<div> 
</div> 
<div>
 虽说可以，不过没有必要。把不同类型的变量赋值给一个变量通常只是增加阅读的难度。实际的Ruby程序中很少这样做。这里的做法完全是为了举例。
</div> 
<div> 
</div> 
<div>
 访问变量是一种常见的记法。
</div> 
<div> 
</div> 
<div>
 str = &quot;content&quot; 
 <br /> p(str)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 显示&quot;content&quot;
</div> 
<div> 
</div> 
<div>
 随后是一个变量保持引用的例子。
</div> 
<div> 
</div> 
<div>
 a = &quot;content&quot; 
 <br /> b = a
 <br /> c = b
</div> 
<div> 
</div> 
<div>
 程序执行后，a、b、c三个局部变量指向同一个对象——第一行生成的字符串对象“content”，如图1所示。
</div> 
<div> 
</div> 
<div>
 <br /> Figure 1: Ruby变量保持对象引用
</div> 
<div> 
</div> 
<div>
 对了，这里的“局部”是某种程度上的局部，暂且还无法解释它的范围。先要说一下，顶层只是一种“局部”作用域。
</div> 
<div> 
</div> 
<div>
 常量
 <br /> 变量名以大写字母开头的是常量。因为是常量，只能对它进行一次（第一次）赋值。
</div> 
<div> 
</div> 
<div>
 Const = &quot;content&quot; 
 <br /> PI = 3.1415926535
</div> 
<div> 
</div> 
<div>
 p(Const)&nbsp;&nbsp; # 显示&quot;content&quot;
</div> 
<div> 
</div> 
<div>
 再次赋值会造成错误。说实话，只是警告，不是错误。这么做是为了让一些操作Ruby程序本身的应用程序，比如开发环境，在加载两次文件的时候，不会报错。也就是说，这是为实用而做的妥协，本来应该报错。实际上，直到1.1版本都会报错。
</div> 
<div> 
</div> 
<div>
 C = 1
 <br /> C = 2&nbsp;&nbsp; # 实际中只是给出警告，理论上应该报错
</div> 
<div> 
</div> 
<div>
 很多人为“常量”这个词的欺骗，认为常量就是“所指对象一旦被记住，便不再改变”。实际上，并不是常量所指的对象不再改变。如果用英语表达的话，read only比constant更能表现其意图（图2）。顺便说一下，另有一个名为freeze的方法用于让对象本身不变。
</div> 
<div> 
</div> 
<div>
 <br /> Figure 2: 常量read only的含义
</div> 
<div> 
</div> 
<div>
 实际上，常量的作用域还没有谈到。在下一节中，我们会结合类来谈一下。
</div> 
<div> 
</div> 
<div>
 控制结构
 <br /> Ruby的控制结构很丰富，单单罗列出来就很困难了。先来谈谈if和while。
</div> 
<div> 
</div> 
<div>
 if i &lt; 10 then
 <br /> # 主体
 <br /> end
</div> 
<div> 
</div> 
<div>
 while i &lt; 10 do
 <br /> # 主体
 <br /> end
</div> 
<div> 
</div> 
<div>
 对于条件表达式，只有两个对象——false和nil——为假，其余所有对象都是真。 0和空字符串也是真。
</div> 
<div> 
</div> 
<div>
 顺便说一下，当然不会只有false，还有true。它当然是真。
</div> 
<div> 
</div> 
<div>
 类与方法
 <br /> 类
 <br /> 本来在面向对象系统中，方法属于对象。但那完全是理想世界的事。在普通的程序中，会有大量拥有相同方法集合的程序，坦率的说，以对象为单位去记忆其所拥有的方法并不是件容易的事。通常是用类或多方法（multi method）这样的结构来减少方法的重复定义。
</div> 
<div> 
</div> 
<div>
 在Ruby中，将对象与方法连在一起的机制采用了传统的”类”的概念。也就是说，所有对象都属于某个类，由类决定可以调用的方法。这时，就称对象是“某某类的实例（instance）”。
</div> 
<div> 
</div> 
<div>
 比如，字符串“str”是String类的一个实例。并且，String类定义了upcase、downcase、string，以及其它一些方法，所有字符串对象都可以响应这些方法。
</div> 
<div> 
</div> 
<div>
 # 因为全都属于字符串类，所以定义了同样的方法
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;content&quot;.upcase()
 <br /> &quot;This is a pen.&quot;.upcase()
 <br /> &nbsp;&nbsp;&nbsp; &quot;chapter II&quot;.upcase()
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;content&quot;.length()
 <br /> &quot;This is a pen.&quot;.length()
 <br /> &nbsp;&nbsp;&nbsp; &quot;chapter II&quot;.length()
</div> 
<div> 
</div> 
<div>
 不过，如果调用的方法没有定义怎么办？静态语言的话，会造成编译错误，而Ruby则会成为运行时异常。实际试一下。这种长度的程序还是用-e运行比较方便。
</div> 
<div> 
</div> 
<div>
 % ruby -e '&quot;str&quot;.bad_method()'
 <br /> -e:1: undefined method `bad_method' for &quot;str&quot;:String (NoMethodError)
</div> 
<div> 
</div> 
<div>
 如果找不到方法，就会造成一个名为NoMethodError的错误。
</div> 
<div> 
</div> 
<div>
 最后，为那个一遍遍说的令人厌烦的“String的upcase方法”准备了一个专用的记法。 “String#upcase”表示“定义在String类中的upcase方法”。
</div> 
<div> 
</div> 
<div>
 顺便说一下，写成“String.upcase”在Ruby世界里有完全不同的意思。至于是什么意思？下节分解。
</div> 
<div> 
</div> 
<div>
 类的定义
 <br /> 迄今为止，都是已经定义的类。当然，可以定义自己的类。类可以用class语句定义。
</div> 
<div> 
</div> 
<div>
 class C
 <br /> end
</div> 
<div> 
</div> 
<div>
 这里定义了一个新的类C。定义后，可以如下这样用。
</div> 
<div> 
</div> 
<div>
 class C
 <br /> end
 <br /> c = C.new()&nbsp;&nbsp; # 生成C的实例，赋值给变量c
</div> 
<div> 
</div> 
<div>
 请注意，生成实例用的不是new C。敏锐的读者可能注意到了，C.new()的记法像是一个方法调用。在Ruby中，生成对象的表达式只是一个方法调用。
</div> 
<div> 
</div> 
<div>
 首先，Ruby的类名与常量名是等价的。那么，与类名同名的常量是什么呢？实际上，就是这个类。在Ruby中，所有能操作的东西都是对象。类自然也是对象。这种对象称为类对象。所有的类对象都是Class类的实例。
</div> 
<div> 
</div> 
<div>
 也就是说，创建新类对象的class语句，其动作是将类对象赋值给一个与类同名的常量。另一方面，生成实例的操作是，访问这个常量，通过该对象调用方法（通常是new）。看看下面的例子就可以知道，实例生成同普通的方法调用没有区别。
</div> 
<div> 
</div> 
<div>
 S = &quot;content&quot; 
 <br /> class C
 <br /> end
</div> 
<div> 
</div> 
<div>
 S.upcase() # 得到常量S表示的对象，调用upcase方法
 <br /> C.new()&nbsp;&nbsp;&nbsp;&nbsp; # 得到常量C表示的对象，调用new方法
</div> 
<div> 
</div> 
<div>
 正是因为这样，Ruby中没有new这个保留字。
</div> 
<div> 
</div> 
<div>
 接下来，可以用p将生成的类实例显示出来。
</div> 
<div> 
</div> 
<div>
 class C
 <br /> end
</div> 
<div> 
</div> 
<div>
 c = C.new()
 <br /> p(c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # #&lt;C:0x2acbd7e4&gt;
</div> 
<div> 
</div> 
<div>
 不过，它到底无法像字符串和整数那样表示得那么漂亮，显示的是类名和所属的内部ID。这个ID表示的是指向该对象指针的值。
</div> 
<div> 
</div> 
<div>
 是的是的，可能你已经完全忘了方法名的记法。 “Object.new”表示通过类对象Object本身调用new方法。因此，“Object#new”和“Object.new”完全是两码事，需要严格区分。
</div> 
<div> 
</div> 
<div>
 obj = Object.new()&nbsp;&nbsp; # Object.new
 <br /> obj.new()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Object#new
</div> 
<div> 
</div> 
<div>
 实际上，Object#new并没有定义，像这个程序的第二行会造成错误。希望你只把它当作一个例子。
</div> 
<div> 
</div> 
<div>
 方法的定义
 <br /> 即便定义了类，没有定义方法也是没有意义的。让我们试着在类C中定义方法。
</div> 
<div> 
</div> 
<div>
 class C
 <br /> def myupcase( str )
 <br /> &nbsp;&nbsp;&nbsp; return str.upcase()
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 定义方法用def语句。这个例子中定义了myupcase方法。有一个名为str的参数。同变量一样，参数和返回值都不需要写类型。而且可以有多个参数。
</div> 
<div> 
</div> 
<div>
 试着用一下定义的方法。缺省情况下，方法可以在外部调用。
</div> 
<div> 
</div> 
<div>
 c = C.new()
 <br /> result = c.myupcase(&quot;content&quot;)
 <br /> p(result)&nbsp;&nbsp; # 显示&quot;CONTENT&quot;
</div> 
<div> 
</div> 
<div>
 当然，习惯之后便无需一个个的赋值了。下面的写法也是一样的。
</div> 
<div> 
</div> 
<div>
 p(C.new().myupcase(&quot;content&quot;))&nbsp;&nbsp; # 同样显示&quot;CONTENT&quot;
</div> 
<div> 
</div> 
<div>
 self
 <br /> 在方法执行过程中，通常会保留自己（方法调用的实例）是谁的信息，这个信息可以通过self得到。类似于C++或Java中的this。我们来确认一下。
</div> 
<div> 
</div> 
<div>
 class C
 <br /> def get_self()
 <br /> &nbsp;&nbsp;&nbsp; return self
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 c = C.new()
 <br /> p(c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # #&lt;C:0x40274e44&gt;
 <br /> p(c.get_self())&nbsp;&nbsp; # #&lt;C:0x40274e44&gt;
</div> 
<div> 
</div> 
<div>
 如你所见，两个表达式返回的是同样的对象。可以确认，对c调用方法，其self就是c。
</div> 
<div> 
</div> 
<div>
 那么，通过自身调用方法该怎么做才好呢？首先要考虑通过self进行调用。
</div> 
<div> 
</div> 
<div>
 class C
 <br /> def my_p( obj )
 <br /> &nbsp;&nbsp;&nbsp; self.real_my_p(obj)&nbsp;&nbsp; # 通过自身调用方法
 <br /> end
</div> 
<div> 
</div> 
<div>
 def real_my_p( obj )
 <br /> &nbsp;&nbsp;&nbsp; p(obj)
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 C.new().my_p(1)&nbsp;&nbsp; # 显示1
</div> 
<div> 
</div> 
<div>
 不过，调用“自己的”方法还要特意指定，太麻烦。因此，对self的调用可以省略调用方法的目标对象（接收者，receiver）。
</div> 
<div> 
</div> 
<div>
 class C
 <br /> def my_p( obj )
 <br /> &nbsp;&nbsp;&nbsp; real_my_p(obj)&nbsp;&nbsp; # 可以不指定调用的接收者
 <br /> end
</div> 
<div> 
</div> 
<div>
 def real_my_p( obj )
 <br /> &nbsp;&nbsp;&nbsp; p(obj)
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 C.new().my_p(1)&nbsp;&nbsp; # 显示1
</div> 
<div> 
</div> 
<div>
 实例变量
 <br /> 还有一种说法，对象是数据 + 代码，所以，仅仅定义方法还是没什么用。有必要以对象为单位来记住数据，也就是实例变量，在C++中称为成员变量。
</div> 
<div> 
</div> 
<div>
 根据Ruby的变量命名规则，第一个字母决定类型。实例变量是“@”。
</div> 
<div> 
</div> 
<div>
 class C
 <br /> def set_i(value)
 <br /> &nbsp;&nbsp;&nbsp; @i = value
 <br /> end
</div> 
<div> 
</div> 
<div>
 def get_i()
 <br /> &nbsp;&nbsp;&nbsp; return @i
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 c = C.new()
 <br /> c.set_i(&quot;ok&quot;)
 <br /> p(c.get_i())&nbsp;&nbsp; # 显示&quot;ok&quot;
</div> 
<div> 
</div> 
<div>
 实例变量不同于前面介绍的变量，即便不赋值（甚至不定义）也一样可以访问。这种情况下会变成怎样呢……接着前面的代码继续尝试。
</div> 
<div> 
</div> 
<div>
 c = C.new()
 <br /> p(c.get_i())&nbsp;&nbsp; # 显示nil
</div> 
<div> 
</div> 
<div>
 没有set就get，结果显示nil。nil表示一个“没有”的对象。存在对象却“没有”，很不可思议，没办法，它就是这样。
</div> 
<div> 
</div> 
<div>
 nil也可以作为一个文字量使用。
</div> 
<div> 
</div> 
<div>
 p(nil)&nbsp;&nbsp; # 显示nil
</div> 
<div> 
</div> 
<div>
 initialize
 <br /> 正如我们看到的，即便是刚刚定义的类也可以调用new方法创建实例。的确如此，不过，有时需要对一个类进行特定的初始化。这时要修改的不是new方法，而是一个名为initialize的方法。它会在new的过程中调用。
</div> 
<div> 
</div> 
<div>
 class C
 <br /> def initialize()
 <br /> &nbsp;&nbsp;&nbsp; @i = &quot;ok&quot; 
 <br /> end
 <br /> def get_i()
 <br /> &nbsp;&nbsp;&nbsp; return @i
 <br /> end
 <br /> end
 <br /> c = C.new()
 <br /> p(c.get_i())&nbsp;&nbsp; # 显示&quot;ok&quot;
</div> 
<div> 
</div> 
<div>
 严格说来，这只是new方法的设计，而非语言的设计。
</div> 
<div> 
</div> 
<div>
 继承
 <br /> 类可以继承自其它类。比如，String类继承自Object类。在本书中，用图3那样的纵向箭头表示这种关系。
</div> 
<div> 
</div> 
<div>
 <br /> Figure 3: 继承
</div> 
<div> 
</div> 
<div>
 在这副图中，被继承类（Object）称为超类，继承类（String)称为子类。请注意，这里的术语不同于C++，而与Java相同。
</div> 
<div> 
</div> 
<div>
 总之，先试试。我们建立的类也可以继承自其它类。创建继承类（指定超类）要这样写。
</div> 
<div> 
</div> 
<div>
 class C &lt; SuperClassName
 <br /> end
</div> 
<div> 
</div> 
<div>
 像迄今为止这样省略超类的写法，隐含着Object就是超类。
</div> 
<div> 
</div> 
<div>
 为什么需要继承呢？当然是为了继承方法。继承的运作方式就像在子类中重复定义超类中的方法。让我们来试试看。
</div> 
<div> 
</div> 
<div>
 class C
 <br /> def hello()
 <br /> &nbsp;&nbsp;&nbsp; return &quot;hello&quot; 
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 class Sub &lt; C
 <br /> end
</div> 
<div> 
</div> 
<div>
 sub = Sub.new()
 <br /> p(sub.hello())&nbsp;&nbsp; # 显示&quot;hello&quot;
</div> 
<div> 
</div> 
<div>
 hello是定义在类C中的方法，Sub的实例也可以调用它。当然，这次也没有必要赋值给一个变量。下面这样写也是一样的。
</div> 
<div> 
</div> 
<div>
 p(Sub.new().hello())
</div> 
<div> 
</div> 
<div>
 如果定义同名的方法，就会“改写”（override）。 C++和Object Pascal（Delphi）通过保留字virtual指明方法改写，但在Ruby中，所有方法都可以无条件改写。
</div> 
<div> 
</div> 
<div>
 class C
 <br /> def hello()
 <br /> &nbsp;&nbsp;&nbsp; return &quot;Hello&quot; 
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 class Sub &lt; C
 <br /> def hello()
 <br /> &nbsp;&nbsp;&nbsp; return &quot;Hello from Sub&quot; 
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 p(Sub.new().hello())&nbsp;&nbsp; # 显示&quot;Hello from Sub&quot; 
 <br /> p(C.new().hello())&nbsp;&nbsp;&nbsp;&nbsp; # 显示&quot;Hello&quot;
</div> 
<div> 
</div> 
<div>
 类可以有许多级继承。比如，像图4那样。在这种情况下， Fixnum继承了Object、Numeric和Integer的全部方法。方法同名时，优先考虑更接近的类的方法。由于没有类型，重载（overload）之类的东西，一切条件都变得非常简单。（TO BE VERIFIED）
</div> 
<div> 
</div> 
<div>
 <br /> Figure 4: 多级继承
</div> 
<div> 
</div> 
<div>
 在C++中，可以有什么都不继承的类。而在Ruby中，必然是直接或间接的继承自Object。总之，如果画出继承关系图，就是一棵以Object为顶点的一棵树。比如，把基本程序库中重要类的继承关系画成一棵树的话，就像图5的感觉。
</div> 
<div> 
</div> 
<div>
 <br /> Figure 5: Ruby的类树
</div> 
<div> 
</div> 
<div>
 超类一旦（定义的时候）确定，之后就无法改变。也就是说，在类树中增加新的类，其位置是不会改变或删除的。
</div> 
<div> 
</div> 
<div>
 变量的继承……？
 <br /> 在Ruby中，变量（实例变量）是不能继承的。即便可以继承，类中不包含这个变量的使用信息。
</div> 
<div> 
</div> 
<div>
 只有方法可以继承，只要调用继承方法（通过子类实例），就会发生实例变量赋值。也就是说，它被定义出来。这样的话，实例变量的命名空间就完全变平，哪个类的方法都可以访问得到。
</div> 
<div> 
</div> 
<div>
 class A
 <br /> def initialize()&nbsp;&nbsp; # 在new的过程中调用
 <br /> &nbsp;&nbsp;&nbsp; @i = &quot;ok&quot; 
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 class B &lt; A
 <br /> def print_i()
 <br /> &nbsp;&nbsp;&nbsp; p(@i)
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 B.new().print_i()&nbsp;&nbsp; # 显示&quot;ok&quot;
</div> 
<div> 
</div> 
<div>
 如果不能理解这个行为的话，抛开类和继承来考虑就好了。如果有一个类C的实例obj，首先，类C超类的方法都定义在C中。当然，要适当考虑一下改写规则。这样，C的方法就附着在obj上了（图6）。强烈的“”是Ruby面向对象的特征。（TO BE VERIFIED）
</div> 
<div> 
</div> 
<div>
 <br /> Figure 6: Ruby对象图
</div> 
<div> 
</div> 
<div>
 模块
 <br /> 只能指定一个超类。看起来Ruby似乎是单一继承。但是，因为模块的存在让它拥有了与多重继承同等的能力。下面就来讨论一下模块。
</div> 
<div> 
</div> 
<div>
 一言以蔽之，模块就是“无法指定超类，无法生成实例”的类。定义可以这样写。
</div> 
<div> 
</div> 
<div>
 module M
 <br /> end
</div> 
<div> 
</div> 
<div>
 这样就定义了模块M。方法定义与类完全相同。
</div> 
<div> 
</div> 
<div>
 module M
 <br /> def myupcase( str )
 <br /> &nbsp;&nbsp;&nbsp; return str.upcase()
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 然而它无法直接调用，因此不能创建实例。那么该怎么做呢？应该由其它类“include”这个模块。这样一来，就好像类继承自这个模块一样。
</div> 
<div> 
</div> 
<div>
 module M
 <br /> def myupcase( str )
 <br /> &nbsp;&nbsp;&nbsp; return str.upcase()
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 class C
 <br /> include M
 <br /> end
</div> 
<div> 
</div> 
<div>
 p(C.new().myupcase(&quot;content&quot;)) # &quot;CONTENT&quot;と表示される
</div> 
<div> 
</div> 
<div>
 即便类C没有定义myupcase方法也一样可以调用。也就是说，“继承”了模块的方法。在功能上，include与继承完全相同。方法定义和实例变量的访问也不受什么限制。
</div> 
<div> 
</div> 
<div>
 前面说过，模块不能指定超类，不过，它可以包含其它模块。
</div> 
<div> 
</div> 
<div>
 module M
 <br /> end
</div> 
<div> 
</div> 
<div>
 module M2
 <br /> include M
 <br /> end
</div> 
<div> 
</div> 
<div>
 也就是说，这在功能上与指定超类相同。只是哪个类在上面并不确定。只是模块之上只能是模块。
</div> 
<div> 
</div> 
<div>
 下面是一个包含方法继承的例子。
</div> 
<div> 
</div> 
<div>
 module OneMore
 <br /> def method_OneMore()
 <br /> &nbsp;&nbsp;&nbsp; p(&quot;OneMore&quot;)
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 module M
 <br /> include OneMore
</div> 
<div> 
</div> 
<div>
 def method_M()
 <br /> &nbsp;&nbsp;&nbsp; p(&quot;M&quot;)
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 class C
 <br /> include M
 <br /> end
</div> 
<div> 
</div> 
<div>
 C.new().method_M()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 显示&quot;M&quot; 
 <br /> C.new().method_OneMore()&nbsp;&nbsp; # 显示&quot;OneMore&quot;
</div> 
<div> 
</div> 
<div>
 如果以类继承的方式来表现的话，就是图7这样。
</div> 
<div> 
</div> 
<div>
 <br /> Figure 7: 多重包含
</div> 
<div> 
</div> 
<div>
 如果类有超类，那么它与模块的关系又是怎样的呢？考虑下面的情况。
</div> 
<div> 
</div> 
<div>
 # modcls.rb
</div> 
<div> 
</div> 
<div>
 class Cls
 <br /> def test()
 <br /> &nbsp;&nbsp;&nbsp; return &quot;class&quot; 
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 module Mod
 <br /> def test()
 <br /> &nbsp;&nbsp;&nbsp; return &quot;module&quot; 
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 class C &lt; Cls
 <br /> include Mod
 <br /> end
</div> 
<div> 
</div> 
<div>
 p(B.new().test())&nbsp;&nbsp; # “class”? “module”?
</div> 
<div> 
</div> 
<div>
 C继承自Cls，包含了Mod。在这种情况下，究竟是显示&quot;class&quot;还是&quot;module&quot;呢？也就是说，模块和类哪边更“近”呢？Ruby的事要听Ruby的看法，执行一下。
</div> 
<div> 
</div> 
<div>
 % ruby modcls.rb
 <br /> &quot;module&quot;
</div> 
<div> 
</div> 
<div>
 模块似乎比超类的优先级更高。
</div> 
<div> 
</div> 
<div>
 一般说来，在Ruby中，如果包含了模块的话，就像夹在类和超类“之间”那样的继承。画出来的话，就像图8一样。
</div> 
<div> 
</div> 
<div>
 <br /> Figure 8: 类与模块的相互关系
</div> 
<div> 
</div> 
<div>
 如果考虑模块包含模块的情况，就如图9所示。
</div> 
<div> 
</div> 
<div>
 <br /> Figure 9: 类与模块的相互关系(2)
</div> 
<div> 
</div> 
<div>
 程序(II)
 <br /> 注意。这一节非常重要，而且，提到了一些只熟悉静态语言的程序很少接触的元素。其它的可以随便翻翻，但这里希望你可以仔细阅读。因此，本节也比较详尽。
</div> 
<div> 
</div> 
<div>
 常量的嵌套
 <br /> 首先复习一下常量。常量以大写字母开头，可以像下面这样定义。
</div> 
<div> 
</div> 
<div>
 Const = 3
</div> 
<div> 
</div> 
<div>
 访问常量可以这样做。
</div> 
<div> 
</div> 
<div>
 p(Const)&nbsp;&nbsp; # 显示3
</div> 
<div> 
</div> 
<div>
 实际上，也可以这样写。
</div> 
<div> 
</div> 
<div>
 p(::Const)&nbsp;&nbsp; # 同样显示3
</div> 
<div> 
</div> 
<div>
 开头加上::，表示“这是一个定义在顶层的常量”。就像文件系统的路径一样。假设根目录下有个叫vmunix的文件。在/下只写vmunix就可以访问它。而在全路径下就要写/vmunix。Const和::Const就是同样的关系。在顶层下，可以只写Const，也可以按照全路径写::Const。
</div> 
<div> 
</div> 
<div>
 那么文件系统中的目录在Ruby中相当于什么呢？答案是类定义语句和模块定义语句。因为有两个显得冗长而麻烦，以后都归结为类定义来表示。如果是在类定义，那么常量的层次就要会提升（进入目录）。
</div> 
<div> 
</div> 
<div>
 class SomeClass
 <br /> Const = 3
 <br /> end
</div> 
<div> 
</div> 
<div>
 p(::SomeClass::Const)&nbsp;&nbsp; # 显示3
 <br /> p( SomeClass::Const)&nbsp;&nbsp; # 同样显示3
</div> 
<div> 
</div> 
<div>
 SomeClass是定义在顶层的类，所以，常量仅仅写成SomeClass也可以，写成::SomeClass也可以。嵌套在类定义中的常量Const是“SomeClass中的常量”，它变成了::SomeClass::Const。
</div> 
<div> 
</div> 
<div>
 同在目录中可以创建新目录一样，类中同样可以定义新类。比如这样。
</div> 
<div> 
</div> 
<div>
 class C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # ::C
 <br /> class C2&nbsp;&nbsp;&nbsp;&nbsp; # ::C::C2
 <br /> &nbsp;&nbsp;&nbsp; class C3&nbsp;&nbsp; # ::C::C2::C3
 <br /> &nbsp;&nbsp;&nbsp; end
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 在类定义中定义的常量必须写全路径吗？当然没有这种事。等同于文件系统的比喻，在同级的类定义语句“中”，可以不用::。也就是这样。
</div> 
<div> 
</div> 
<div>
 class SomeClass
 <br /> Const = 3
 <br /> p(Const)&nbsp;&nbsp; # 显示3
 <br /> end
</div> 
<div> 
</div> 
<div>
 没想到这样吧！在类定义语句中写可执行的程序。我想，这对于只熟悉静态语言的人来说，相当意外。我第一次见的时候，也是大吃一惊。
</div> 
<div> 
</div> 
<div>
 多说几句，当然在方法定义中常量也是可见的。访问规则等同于类定义语句。
</div> 
<div> 
</div> 
<div>
 class C
 <br /> Const = &quot;ok&quot; 
 <br /> def test()
 <br /> &nbsp;&nbsp;&nbsp; p(Const)
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 C.new().test()&nbsp;&nbsp; # 显示&quot;ok&quot;
</div> 
<div> 
</div> 
<div>
 全部执行
 <br /> 盯住这里所写的全部。在Ruby中，程序的大部分都是“可执行的”。常量定义、类定义语句、方法定义语句，几乎看到的所有东西都是按顺序执行。
</div> 
<div> 
</div> 
<div>
 比如，看看下面的代码。迄今为止的结构在这里都用到了。
</div> 
<div> 
</div> 
<div>
 1: p(&quot;first&quot;)
 <br /> 2:
 <br /> 3: class C &lt; Object
 <br /> 4:&nbsp;&nbsp;&nbsp; Const = &quot;in C&quot; 
 <br /> 5:
 <br /> 6:&nbsp;&nbsp;&nbsp; p(Const)
 <br /> 7:
 <br /> 8:&nbsp;&nbsp;&nbsp; def myupcase(str)
 <br /> 9:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return str.upcase()
 <br /> 10:&nbsp;&nbsp;&nbsp; end
 <br /> 11: end
 <br /> 12:
 <br /> 13: p(C.new().myupcase(&quot;content&quot;))
</div> 
<div> 
</div> 
<div>
 这个程序按以下顺序执行。
</div> 
<div> 
</div> 
<div>
 1: p(&quot;first&quot;) 显示&quot;first&quot;。 
 <br /> 3: &lt; Object 访问常量Object，得到类对象Object 
 <br /> 3: class C 以Object为超类生成一个新的类，带入常量C中 
 <br /> 4: Const = &quot;in C&quot; 定义::C::Const。其值为&quot;in C&quot; 
 <br /> 6: p(Const) 显示::C::Const。显示为&quot;in C&quot;。 
 <br /> 8: def myupcase(...)...end 定义方法C#myupcase。 
 <br /> 13: C.new().myupcase(...) 访问常量C，调用其new，进而调用myupcase。 
 <br /> 9: return str.upcase() 返回&quot;CONTENT&quot;。 
 <br /> 13: p(...) 显示&quot;CONTENT&quot;。
</div> 
<div> 
</div> 
<div>
 局部变量的作用域
 <br /> 终于要来讨论局部变量的作用域了。
</div> 
<div> 
</div> 
<div>
 顶层、类定义语句内、模块定义语句内、方法主体内，都有各自完全独立的局部变量作用域。也就是说，下面程序中的Ivar互不相同，互不冲突。
</div> 
<div> 
</div> 
<div>
 lvar = 'toplevel'
</div> 
<div> 
</div> 
<div>
 class C
 <br /> lvar = 'in C'
 <br /> def method()
 <br /> &nbsp;&nbsp;&nbsp; lvar = 'in C#method'
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 p(lvar)&nbsp;&nbsp; # 显示&quot;toplevel&quot;
</div> 
<div> 
</div> 
<div>
 module M
 <br /> lvar = 'in M'
 <br /> end
</div> 
<div> 
</div> 
<div>
 p(lvar)&nbsp;&nbsp; # 显示&quot;toplevel&quot;
</div> 
<div> 
</div> 
<div>
 作为上下文的self
 <br /> 之前说过，在方法执行中，可以通过self调用自己（调用方法的对象）。这话对，但只是一半。其实，Ruby程序执行过程中，到处设置了self。就连顶层和类定义语句中都有self。
</div> 
<div> 
</div> 
<div>
 比如，顶层甚至也有self。顶层的self称为main。没什么奇怪的，它就是Object的实例。 main仅仅是为了设置self而准备的，没有什么更深层的含义。
</div> 
<div> 
</div> 
<div>
 因为顶层的self，也就是main，是Object的实例，所以，即便是在顶层也可以调用Object的方法。而且Object包含了一个称为Kernel模块，其中定义了“函数风格的方法”，像p、puts。（图10）。因此，即便在顶层也可以调用p和puts。
</div> 
<div> 
</div> 
<div>
 <br /> Figure 10: main、Object和Kernel
</div> 
<div> 
</div> 
<div>
 其实，p不是一个函数，而是一个方法。只是因为它定义在Kernel中，无论self的类是什么，都就可以像“自己的”方法一样调用。 Ruby中并不存在真正意义的“函数”。有的只是方法。
</div> 
<div> 
</div> 
<div>
 顺便说一下，函数风格的方法除了p、puts之外，还有print、puts、printf、sprintf、gets、fork、exec等等，很多名称似曾相似的方法。看到这里选择的名称，Ruby的性格就不难想象了。
</div> 
<div> 
</div> 
<div>
 不管在哪里，self都会设置，即便在类定义语句中，这一事实也不会改变。类定义中的self就那个是类（类对象）。因此会变成这样。
</div> 
<div> 
</div> 
<div>
 class C
 <br /> p(self)&nbsp;&nbsp; # C
 <br /> end
</div> 
<div> 
</div> 
<div>
 这个到底有什么用呢？其实这个例子非常有用。是这样。
</div> 
<div> 
</div> 
<div>
 module M
 <br /> end
 <br /> class C
 <br /> include M
 <br /> end
</div> 
<div> 
</div> 
<div>
 其实，include是对对象C的方法调用。还没有说到，Ruby的方法调用可以省略括号。类定义的话题还没有结束，为了让它看上去不那么像方法调用，所以，这里去掉了括号。
</div> 
<div> 
</div> 
<div>
 加载
 <br /> Ruby对于程序库的加载也全都是在执行时进行的。通常这样写。
</div> 
<div> 
</div> 
<div>
 require(&quot;library_name&quot;)
</div> 
<div> 
</div> 
<div>
 同看到的一样，require是一个方法。根本没有保留字。这样写的话，就在其所写的地方执行加载，执行就转移到那个程序库（的代码）。因为Ruby中没有Java中包的概念，如果希望划分程序库名称的名字空间，就将文件分开放置到目录里。
</div> 
<div> 
</div> 
<div>
 require(&quot;somelib/file1&quot;)
 <br /> require(&quot;somelib/file2&quot;)
</div> 
<div> 
</div> 
<div>
 程序库中也是使用普通的class语句和module语句定义类和模块。顶层的常量其作用域是平的，与文件无关，最初在一个文件里定义的类在另一个文件里也可以看见。为了划分类名的名字空间，可以像下面这样明确的嵌套在模块中。
</div> 
<div> 
</div> 
<div>
 # net程序库的名字空间划分的例子
 <br /> module Net
 <br /> class SMTP
 <br /> &nbsp;&nbsp;&nbsp; # ...
 <br /> end
 <br /> class POP
 <br /> &nbsp;&nbsp;&nbsp; # ...
 <br /> end
 <br /> class HTTP
 <br /> &nbsp;&nbsp;&nbsp; # ...
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 类的进阶
 <br /> 继续探讨常量
 <br /> 之前，我们以文件系统比喻常量的作用域，不过，希望你从这里开始完全忘记这个比喻。
</div> 
<div> 
</div> 
<div>
 常量还有很多结构。首先，“外部”的类可以看到常量。
</div> 
<div> 
</div> 
<div>
 Const = &quot;ok&quot; 
 <br /> class C
 <br /> p(Const)&nbsp;&nbsp; # 显示&quot;ok&quot; 
 <br /> end
</div> 
<div> 
</div> 
<div>
 为什么是这样呢？这是为了便于使用模块作为名字空间。怎么回事呢？用前面的net程序库作为例子追加说明一下。
</div> 
<div> 
</div> 
<div>
 module Net
 <br /> class SMTP
 <br /> &nbsp;&nbsp;&nbsp; # 使用Net::SMTPHelper的方法
 <br /> end
 <br /> class SMTPHelper&nbsp;&nbsp; # Net::SMTP的辅助类
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 在这种情况下，SMTP能访问SMTPHelper的话就方便多了。于是便可以得到“外部类可以访问会很方便”的结论。
</div> 
<div> 
</div> 
<div>
 无论嵌套多少层，“外部”类都可以访问。如果多个嵌套层次中都定义了相同的常量名，访问的就是从内向外按顺序找到的第一个。
</div> 
<div> 
</div> 
<div>
 Const = &quot;far&quot; 
 <br /> class C
 <br /> Const = &quot;near&quot; # 这个Const比上一个近
 <br /> class C2
 <br /> &nbsp;&nbsp;&nbsp; class C3
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p(Const)&nbsp;&nbsp; # 显示&quot;near&quot; 
 <br /> &nbsp;&nbsp;&nbsp; end
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 此外，常量还有一个查找路径。一直往外层的类查找常量，如果直到顶层还没找到，就会进一步搜索自己超类的常量。
</div> 
<div> 
</div> 
<div>
 class A
 <br /> Const = &quot;ok&quot; 
 <br /> end
 <br /> class B &lt; A
 <br /> p(Const)&nbsp;&nbsp; # 显示&quot;ok&quot; 
 <br /> end
</div> 
<div> 
</div> 
<div>
 完全没有那么复杂。
</div> 
<div> 
</div> 
<div>
 总结一下。查找常量的时候，先搜外部类，然后是超类。比如，虽然另类，但假设有下面这个类层次结构。
</div> 
<div> 
</div> 
<div>
 class A1
 <br /> end
 <br /> class A2 &lt; A1
 <br /> end
 <br /> class A3 &lt; A2
 <br /> class B1
 <br /> end
 <br /> class B2 &lt; B1
 <br /> end
 <br /> class B3 &lt; B2
 <br /> &nbsp;&nbsp;&nbsp; class C1
 <br /> &nbsp;&nbsp;&nbsp; end
 <br /> &nbsp;&nbsp;&nbsp; class C2 &lt; C1
 <br /> &nbsp;&nbsp;&nbsp; end
 <br /> &nbsp;&nbsp;&nbsp; class C3 &lt; C2
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p(Const)
 <br /> &nbsp;&nbsp;&nbsp; end
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 在C3中访问常量Const，按照图11的顺序进行查找。
</div> 
<div> 
</div> 
<div>
 <br /> Figure 11: 常量的查找顺序
</div> 
<div> 
</div> 
<div>
 有一点要注意。完全不会查找外部类的超类，比如A1和B2。如果向外查找，就是彻底向外的方向，如果查找超类，就纯粹的超类方向。如果不这样，就会有多条的类查找路径，行为会复杂到难以预测。
</div> 
<div> 
</div> 
<div>
 元类（Meta Class）
 <br /> 之前说过，如果是对象的话，就可以调用其方法。也说过，对象的类决定了能够调用的方法。那么类对象是否也有个“类”呢？（图12）
</div> 
<div> 
</div> 
<div>
 <br /> Figure 12: 类的类是？
</div> 
<div> 
</div> 
<div>
 这样的时候，最好在Ruby中实际确认一下。有一个Object#class方法，它是一个“返回自己所属类（类对象）的方法”。
</div> 
<div> 
</div> 
<div>
 p(&quot;string&quot;.class())&nbsp;&nbsp; # 显示String
 <br /> p(String.class())&nbsp;&nbsp;&nbsp;&nbsp; # 显示Class
 <br /> p(Object.class())&nbsp;&nbsp;&nbsp;&nbsp; # 显示Class
</div> 
<div> 
</div> 
<div>
 看来，String属于Class类。那么进一步，Class的类是什么呢？
</div> 
<div> 
</div> 
<div>
 p(Class.class())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Class显示
</div> 
<div> 
</div> 
<div>
 看来还是Class。也就是说，不管什么对象，只要.class().class().class()……，这样一路下去，一定会得到Class，最后就是一个环（图13）。
</div> 
<div> 
</div> 
<div>
 <br /> Figure 13: 类的类的类的……
</div> 
<div> 
</div> 
<div>
 Class是类的类。这种有“某某的某某”的递归结构的东西称为“元（meta）某某”， Class就是“元类”。
</div> 
<div> 
</div> 
<div>
 元对象（Meta Object）
 <br /> 这次的目标变为对象，考虑一下模块。模块也是对象，和类一样，它也应该有个“类”。试一下。
</div> 
<div> 
</div> 
<div>
 module M
 <br /> end
 <br /> p(M.class())&nbsp;&nbsp; # 显示Module
</div> 
<div> 
</div> 
<div>
 看来，模块对象的类是Module。那么Module的类是什么呢？
</div> 
<div> 
</div> 
<div>
 p(Module.class())&nbsp;&nbsp; # Class
</div> 
<div> 
</div> 
<div>
 还是Class。
</div> 
<div> 
</div> 
<div>
 这次改变一下方向，调查一下继承关系。Class和Module的超类都是什么呢？在Ruby中，可以用Class#superclass来检查。
</div> 
<div> 
</div> 
<div>
 p(Class.superclass())&nbsp;&nbsp;&nbsp; # Module
 <br /> p(Module.superclass())&nbsp;&nbsp; # Object
 <br /> p(Object.superclass())&nbsp;&nbsp; # nil
</div> 
<div> 
</div> 
<div>
 哎呀！Class居然是Module的子类。根据这些事实，画出Ruby几个重要类之间的关系，如图14所示。
</div> 
<div> 
</div> 
<div>
 <br /> Figure 14: Ruby的重要类之间的关系
</div> 
<div> 
</div> 
<div>
 迄今位置，没有对用了多次的new和include进行说明，这里终于可以解释一下了。 new实际上是Class类定义的方法。因此，任何类（都是Class的实例）都可以直接使用new。 Module中没有定义new方法，所以，无法创建它的实例。而Module定义了include方法，所以，模块和类都可以调用include。
</div> 
<div> 
</div> 
<div>
 Object、Module、Class是支撑Ruby的根基。这三个对象就可以将Ruby的对象世界本身描述出来。换句话说，它们是描述对象的对象。所以，Object Module Class是Ruby的“元对象”。
</div> 
<div> 
</div> 
<div>
 singleton方法（singleton method）
 <br /> 对象可以调用方法。可以调用的方法由对象的类决定。但是理想情况下，方法是属于对象的。至于类，它的存在是为了省去多次同样方法的时间。
</div> 
<div> 
</div> 
<div>
 实际上，Ruby有一种机制，可以为对象（实例）单独定义方法，无论它们的类是什么。这样写。
</div> 
<div> 
</div> 
<div>
 obj = Object.new()
 <br /> def obj.my_first()
 <br /> puts(&quot;My first singleton method&quot;)
 <br /> end
 <br /> obj.my_first()&nbsp;&nbsp; # 显示My first singleton method
</div> 
<div> 
</div> 
<div>
 众所周知，Object是所有类的超类。在这么重要的类中，不可能定义一个像my_first名称这样怪异的方法。 obj是Object的实例。但是，obj却可以调用my_first方法。也就是说，肯定在哪定义了这个与所属类完全没有关系的方法。这样为某个对象定义的方法称为singleton方法（singleton method）。
</div> 
<div> 
</div> 
<div>
 什么时候用singleton方法呢？首先是定义类似于Java和C++静态方法的时候。也就是不生成实例也可以调用的方法。这样的方法在Ruby中表现为类对象的singleton方法。
</div> 
<div> 
</div> 
<div>
 比如，UNIX中有一个名为unlink的系统调用。它可以从文件系统中删掉一个文件。在Ruby中，可以通过File类的singleton方法unlink来使用。尝试用一下。
</div> 
<div> 
</div> 
<div>
 File.unlink(&quot;core&quot;) # 删除core文件
</div> 
<div> 
</div> 
<div>
 每次都说“File对象的singleton方法unlink”很麻烦，以后把它写作“File.unlink。别写成“File#unlink”了，“File.write”表示“File类定义的write方法”。
</div> 
<div> 
</div> 
<div>
 ▼ 方法记法总结
</div> 
<div> 
</div> 
<div>
 記法 调用对象 调用示例 
 <br /> File.unlink File类本身 File.unlink(&quot;core&quot;) 
 <br /> File#write File的实例 f.write(&quot;str&quot;)
</div> 
<div> 
</div> 
<div>
 类变量
 <br /> 类变量是ruby 1.6加入的，是一项比较新的功能。它同常量一样，都属于某个类，它可以在类和实例中赋值和访问。看看下面的例子。变量名以@@开头的就是类变量。
</div> 
<div> 
</div> 
<div>
 class C
 <br /> @@cvar = &quot;ok&quot; 
 <br /> p(@@cvar)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 显示&quot;ok&quot;
</div> 
<div> 
</div> 
<div>
 def print_cvar()
 <br /> &nbsp;&nbsp;&nbsp; p(@@cvar)
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 C.new().print_cvar() # 显示&quot;ok&quot;
</div> 
<div> 
</div> 
<div>
 类变量最初的赋值兼有定义的作用，像下面这样在赋值前访问就会造成运行时错误。虽然前面都有@，但其行为与实例变量完全不同。
</div> 
<div> 
</div> 
<div>
 % ruby -e '
 <br /> class C
 <br /> @@cvar
 <br /> end
 <br /> '
 <br /> -e:3: uninitialized class variable @@cvar in C (NameError)
</div> 
<div> 
</div> 
<div>
 这里稍微偷了下懒，给了程序一个-e选项。'和'之间的三行是程序。
</div> 
<div> 
</div> 
<div>
 再有，类变量是可继承的。子类方法可以对超类的类变量进行赋值和访问。
</div> 
<div> 
</div> 
<div>
 class A
 <br /> @@cvar = &quot;ok&quot; 
 <br /> end
</div> 
<div> 
</div> 
<div>
 class B &lt; A
 <br /> p(@@cvar)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 显示&quot;ok&quot; 
 <br /> def print_cvar()
 <br /> &nbsp;&nbsp;&nbsp; p(@@cvar)
 <br /> end
 <br /> end
</div> 
<div> 
</div> 
<div>
 B.new().print_cvar()&nbsp;&nbsp; # 显示&quot;ok&quot;
</div> 
<div> 
</div> 
<div>
 全局变量
 <br /> 最后，还有全局变量。在程序的任何位置都可以对全局变量进行赋值和访问。变量名的第一个字符为$的就是全局变量。
</div> 
<div> 
</div> 
<div>
 $gvar = &quot;global variable&quot; 
 <br /> p($gvar)&nbsp;&nbsp; # 显示&quot;global variable&quot;
</div> 
<div> 
</div> 
<div>
 可以把全局变量看作是实例变量，所有的名称在访问之前就已经定义好了。也就是说，赋值前的访问会返回nil而不是造成错误。
</div> 
<div> 
</div> 
<div>
 <br /> --------------------------------------------------------------------------------
 <br /> The original work is Copyright &copy; 2002 - 2004 Minero AOKI.
 <br /> Translated by RK, Ye Zheng
</div> 
<div> 
</div> 
<div>
 This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike2.5 License.
</div></div></body></html>