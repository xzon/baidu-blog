<html><head><title>xWork DefaultActionInvocation and Interceptor -hxzon</title></head><body><div id='tit'>xWork DefaultActionInvocation and Interceptor -hxzon</div><div id='cate'>源码品读</div><div id='date'>2010年06月25日 星期五 04:39 P.M.</div><div id='page'>13</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/ff0258df07f4861e49540399.html'>http://hi.baidu.com/hxzon/blog/item/ff0258df07f4861e49540399.html</a><div id='cnt'><div> 
 <p>xWork DefaultActionInvocation and Interceptor -hxzon</p> 
 <p> </p> 
 <p>xWork源码品读 xWork 拦截器</p> 
 <p>---------------------------------------------------------------</p> 
 <pre>defaultActionInvocation.invoke(){<br /> if(hasNextInterceptor){<br />  nextInterceptor.intercept(DefaultActionInvocation.this);<br /> }<br /> excuteAction;<br /> excuteResult;<br />}<br />interceptor.intercept(actionInvocation){<br /> before;<br /> actionInvocation.invoke();<br /> after;<br />}</pre> 
 <h3>ActionInvocation</h3> 
 <pre>/**<br /> * An {@link ActionInvocation} represents the execution state of an {@link Action}. It holds the Interceptors and the Action instance.<br /> * By repeated re-entrant execution of the &lt;code&gt;invoke()&lt;/code&gt; method, initially by the {@link ActionProxy}, then by the Interceptors, the<br /> * Interceptors are all executed, and then the {@link Action} and the {@link Result}.<br /> *<br /> * @author Jason Carreira<br /> * @see com.opensymphony.xwork2.ActionProxy<br /> */<br />public interface ActionInvocation extends Serializable {<br /><br />    /**<br />     * Get the Action associated with this ActionInvocation.<br />     *<br />     * @return the Action<br />     */<br />    Object getAction();<br /><br />    /**<br />     * Gets whether this ActionInvocation has executed before.<br />     * This will be set after the Action and the Result have executed.<br />     *<br />     * @return &lt;tt&gt;true&lt;/tt&gt; if this ActionInvocation has executed before.<br />     */<br />    boolean isExecuted();<br /><br />    /**<br />     * Gets the ActionContext associated with this ActionInvocation. The ActionProxy is<br />     * responsible for setting this ActionContext onto the ThreadLocal before invoking<br />     * the ActionInvocation and resetting the old ActionContext afterwards.<br />     *<br />     * @return the ActionContext.<br />     */<br />    ActionContext getInvocationContext();<br /><br />    /**<br />     * Get the ActionProxy holding this ActionInvocation.<br />     *<br />     * @return the ActionProxy.<br />     */<br />    ActionProxy getProxy();<br /><br />    /**<br />     * If the ActionInvocation has been executed before and the Result is an instance of {@link ActionChainResult}, this method<br />     * will walk down the chain of &lt;code&gt;ActionChainResult&lt;/code&gt;s until it finds a non-chain result, which will be returned. If the<br />     * ActionInvocation's result has not been executed before, the Result instance will be created and populated with<br />     * the result params.<br />     *<br />     * @return the result.<br />     * @throws Exception can be thrown.<br />     */<br />    Result getResult() throws Exception;<br /><br />    /**<br />     * Gets the result code returned from this ActionInvocation.<br />     *<br />     * @return the result code<br />     */<br />    String getResultCode();<br /><br />    /**<br />     * Sets the result code, possibly overriding the one returned by the<br />     * action.<br />     * &lt;p/&gt;<br />     * The &quot;intended&quot; purpose of this method is to allow PreResultListeners to<br />     * override the result code returned by the Action.<br />     * &lt;p/&gt;<br />     * If this method is used before the Action executes, the Action's returned<br />     * result code will override what was set. However the Action could (if<br />     * specifically coded to do so) inspect the ActionInvocation to see that<br />     * someone &quot;upstream&quot; (e.g. an Interceptor) had suggested a value as the<br />     * result, and it could therefore return the same value itself.<br />     * &lt;p/&gt;<br />     * If this method is called between the Action execution and the Result<br />     * execution, then the value set here will override the result code the<br />     * action had returned.  Creating an Interceptor that implements<br />     * {@link PreResultListener} will give you this oportunity.<br />     * &lt;p/&gt;<br />     * If this method is called after the Result has been executed, it will<br />     * have the effect of raising an IllegalStateException.<br />     *<br />     * @param resultCode  the result code.<br />     * @throws IllegalStateException if called after the Result has been executed.<br />     * @see #isExecuted()<br />     */<br />    void setResultCode(String resultCode);<br /><br />    /**<br />     * Gets the ValueStack associated with this ActionInvocation.<br />     *<br />     * @return the ValueStack<br />     */<br />    ValueStack getStack();<br /><br />    /**<br />     * Register a {@link PreResultListener} to be notified after the Action is executed and<br />     * before the Result is executed.<br />     * &lt;p/&gt;<br />     * The ActionInvocation implementation must guarantee that listeners will be called in<br />     * the order in which they are registered.<br />     * &lt;p/&gt;<br />     * Listener registration and execution does not need to be thread-safe.<br />     *<br />     * @param listener the listener to add.<br />     */<br />    void addPreResultListener(PreResultListener listener);<br /><br />    /**<br />     * Invokes the next step in processing this ActionInvocation.<br />     * &lt;p/&gt;<br />     * If there are more Interceptors, this will call the next one. If Interceptors choose not to short-circuit<br />     * ActionInvocation processing and return their own return code, they will call invoke() to allow the next Interceptor<br />     * to execute. If there are no more Interceptors to be applied, the Action is executed.<br />     * If the {@link ActionProxy#getExecuteResult()} method returns &lt;tt&gt;true&lt;/tt&gt;, the Result is also executed.<br />     *<br />     * @throws Exception can be thrown.<br />     * @return the return code.<br />     */<br />    String invoke() throws Exception;<br /><br />    /**<br />     * Invokes only the Action (not Interceptors or Results).<br />     * &lt;p/&gt;<br />     * This is useful in rare situations where advanced usage with the interceptor/action/result workflow is<br />     * being manipulated for certain functionality.<br />     *<br />     * @return the return code.<br />     * @throws Exception can be thrown.<br />     */<br />    String invokeActionOnly() throws Exception;<br /><br />    /**<br />     * Sets the action event listener to respond to key action events.<br />     *<br />     * @param listener the listener.<br />     */<br />    void setActionEventListener(ActionEventListener listener);<br /><br />    void init(ActionProxy proxy) ;<br /><br />}</pre> 
 <p> </p> 
 <p>ActionInvocation默认实现</p> 
 <h3>public class DefaultActionInvocation implements ActionInvocation</h3> 
 <pre>/**<br />     * @throws ConfigurationException If no result can be found with the returned code<br />     */<br />    public String invoke() throws Exception {<br />        String profileKey = &quot;invoke: &quot;;<br />        try {<br />            UtilTimerStack.push(profileKey);<br /><br />            if (executed) {<br />                throw new IllegalStateException(&quot;Action has already executed&quot;);<br />            }<br /><br />            if (interceptors.hasNext()) {<br />                final InterceptorMapping interceptor = (InterceptorMapping) interceptors.next();<br />                String interceptorMsg = &quot;interceptor: &quot; + interceptor.getName();<br />                UtilTimerStack.push(interceptorMsg);<br />                try {<br />                                resultCode = interceptor.getInterceptor().intercept(DefaultActionInvocation.this);<br />                            }<br />                finally {<br />                    UtilTimerStack.pop(interceptorMsg);<br />                }<br />            } else {<br />                resultCode = invokeActionOnly();<br />            }<br /><br />            // this is needed because the result will be executed, then control will return to the Interceptor, which will<br />            // return above and flow through again<br />            if (!executed) {<br />                if (preResultListeners != null) {<br />                    for (Object preResultListener : preResultListeners) {<br />                        PreResultListener listener = (PreResultListener) preResultListener;<br /><br />                        String _profileKey = &quot;preResultListener: &quot;;<br />                        try {<br />                            UtilTimerStack.push(_profileKey);<br />                            listener.beforeResult(this, resultCode);<br />                        }<br />                        finally {<br />                            UtilTimerStack.pop(_profileKey);<br />                        }<br />                    }<br />                }<br /><br />                // now execute the result, if we're supposed to<br />                if (proxy.getExecuteResult()) {<br />                    executeResult();<br />                }<br /><br />                executed = true;<br />            }<br /><br />            return resultCode;<br />        }<br />        finally {<br />            UtilTimerStack.pop(profileKey);<br />        }<br />    }<br /><br />    public String invokeActionOnly() throws Exception {<br />        return invokeAction(getAction(), proxy.getConfig());<br />    }<br /><br />    /**<br />     * Uses getResult to get the final Result and executes it<br />     *<br />     * @throws ConfigurationException If not result can be found with the returned code<br />     */<br />    private void executeResult() throws Exception {<br />        result = createResult();<br /><br />        String timerKey = &quot;executeResult: &quot; + getResultCode();<br />        try {<br />            UtilTimerStack.push(timerKey);<br />            if (result != null) {<br />                result.execute(this);<br />            } else if (resultCode != null &amp;&amp; !Action.NONE.equals(resultCode)) {<br />                throw new ConfigurationException(&quot;No result defined for action &quot; + getAction().getClass().getName()<br />                        + &quot; and result &quot; + getResultCode(), proxy.getConfig());<br />            } else {<br />                if (LOG.isDebugEnabled()) {<br />                    LOG.debug(&quot;No result returned for action &quot; + getAction().getClass().getName() + &quot; at &quot; + proxy.getConfig().getLocation());<br />                }<br />            }<br />        } finally {<br />            UtilTimerStack.pop(timerKey);<br />        }<br />    }

    protected String invokeAction(Object action, ActionConfig actionConfig) throws Exception {<br />        String methodName = proxy.getMethod();<br /><br />        if (LOG.isDebugEnabled()) {<br />            LOG.debug(&quot;Executing action method = &quot; + actionConfig.getMethodName());<br />        }<br /><br />        String timerKey = &quot;invokeAction: &quot; + proxy.getActionName();<br />        try {<br />            UtilTimerStack.push(timerKey);<br /><br />            boolean methodCalled = false;<br />            Object methodResult = null;<br />            Method method = null;<br />            try {<br />                method = getAction().getClass().getMethod(methodName, new Class[0]);<br />            } catch (NoSuchMethodException e) {<br />                // hmm -- OK, try doXxx instead<br />                try {<br />                    String altMethodName = &quot;do&quot; + methodName.substring(0, 1).toUpperCase() + methodName.substring(1);<br />                    method = getAction().getClass().getMethod(altMethodName, new Class[0]);<br />                } catch (NoSuchMethodException e1) {<br />                    // well, give the unknown handler a shot<br />                    if (unknownHandlerManager.hasUnknownHandlers()) {<br />                        try {<br />                            methodResult = unknownHandlerManager.handleUnknownMethod(action, methodName);<br />                            methodCalled = true;<br />                        } catch (NoSuchMethodException e2) {<br />                            // throw the original one<br />                            throw e;<br />                        }<br />                    } else {<br />                        throw e;<br />                    }<br />                }<br />            }<br /><br />            if (!methodCalled) {<br />                methodResult = method.invoke(action, new Object[0]);<br />            }<br /><br />            if (methodResult instanceof Result) {<br />                this.explicitResult = (Result) methodResult;<br /><br />                // Wire the result automatically<br />                container.inject(explicitResult);<br />                return null;<br />            } else {<br />                return (String) methodResult;<br />            }<br />        } catch (NoSuchMethodException e) {<br />            throw new IllegalArgumentException(&quot;The &quot; + methodName + &quot;() is not defined in action &quot; + getAction().getClass() + &quot;&quot;);<br />        } catch (InvocationTargetException e) {<br />            // We try to return the source exception.<br />            Throwable t = e.getTargetException();<br /><br />            if (actionEventListener != null) {<br />                String result = actionEventListener.handleException(t, getStack());<br />                if (result != null) {<br />                    return result;<br />                }<br />            }<br />            if (t instanceof Exception) {<br />                throw (Exception) t;<br />            } else {<br />                throw e;<br />            }<br />        } finally {<br />            UtilTimerStack.pop(timerKey);<br />        }<br />    }</pre> 
 <pre>public Result createResult() throws Exception {<br /><br />        if (explicitResult != null) {<br />            Result ret = explicitResult;<br />            explicitResult = null;<br /><br />            return ret;<br />        }<br />        ActionConfig config = proxy.getConfig();<br />        Map&lt;String, ResultConfig&gt; results = config.getResults();<br /><br />        ResultConfig resultConfig = null;<br /><br />        try {<br />            resultConfig = results.get(resultCode);<br />        } catch (NullPointerException e) {<br />            // swallow<br />        }<br />        <br />        if (resultConfig == null) {<br />            // If no result is found for the given resultCode, try to get a wildcard '*' match.<br />            resultConfig = results.get(&quot;*&quot;);<br />        }<br /><br />        if (resultConfig != null) {<br />            try {<br />                return objectFactory.buildResult(resultConfig, invocationContext.getContextMap());<br />            } catch (Exception e) {<br />                LOG.error(&quot;There was an exception while instantiating the result of type &quot; + resultConfig.getClassName(), e);<br />                throw new XWorkException(e, resultConfig);<br />            }<br />        } else if (resultCode != null &amp;&amp; !Action.NONE.equals(resultCode) &amp;&amp; unknownHandlerManager.hasUnknownHandlers()) {<br />            return unknownHandlerManager.handleUnknownResult(invocationContext, proxy.getActionName(), proxy.getConfig(), resultCode);<br />        }<br />        return null;<br />    }<br /><br />    protected void createAction(Map&lt;String, Object&gt; contextMap) {<br />        // load action<br />        String timerKey = &quot;actionCreate: &quot; + proxy.getActionName();<br />        try {<br />            UtilTimerStack.push(timerKey);<br />            action = objectFactory.buildAction(proxy.getActionName(), proxy.getNamespace(), proxy.getConfig(), contextMap);<br />        } catch (InstantiationException e) {<br />            throw new XWorkException(&quot;Unable to intantiate Action!&quot;, e, proxy.getConfig());<br />        } catch (IllegalAccessException e) {<br />            throw new XWorkException(&quot;Illegal access to constructor, is it public?&quot;, e, proxy.getConfig());<br />        } catch (Exception e) {<br />            String gripe = &quot;&quot;;<br /><br />            if (proxy == null) {<br />                gripe = &quot;Whoa!  No ActionProxy instance found in current ActionInvocation.  This is bad ... very bad&quot;;<br />            } else if (proxy.getConfig() == null) {<br />                gripe = &quot;Sheesh.  Where'd that ActionProxy get to?  I can't find it in the current ActionInvocation!?&quot;;<br />            } else if (proxy.getConfig().getClassName() == null) {<br />                gripe = &quot;No Action defined for '&quot; + proxy.getActionName() + &quot;' in namespace '&quot; + proxy.getNamespace() + &quot;'&quot;;<br />            } else {<br />                gripe = &quot;Unable to instantiate Action, &quot; + proxy.getConfig().getClassName() + &quot;,  defined for '&quot; + proxy.getActionName() + &quot;' in namespace '&quot; + proxy.getNamespace() + &quot;'&quot;;<br />            }<br /><br />            gripe += (((&quot; -- &quot; + e.getMessage()) != null) ? e.getMessage() : &quot; [no message in exception]&quot;);<br />            throw new XWorkException(gripe, e, proxy.getConfig());<br />        } finally {<br />            UtilTimerStack.pop(timerKey);<br />        }<br /><br />        if (actionEventListener != null) {<br />            action = actionEventListener.prepare(action, stack);<br />        }<br />    }<br /><br />    protected Map&lt;String, Object&gt; createContextMap() {<br />        Map&lt;String, Object&gt; contextMap;<br /><br />        if ((extraContext != null) &amp;&amp; (extraContext.containsKey(ActionContext.VALUE_STACK))) {<br />            // In case the ValueStack was passed in<br />            stack = (ValueStack) extraContext.get(ActionContext.VALUE_STACK);<br /><br />            if (stack == null) {<br />                throw new IllegalStateException(&quot;There was a null Stack set into the extra params.&quot;);<br />            }<br /><br />            contextMap = stack.getContext();<br />        } else {<br />            // create the value stack<br />            // this also adds the ValueStack to its context<br />            stack = valueStackFactory.createValueStack();<br /><br />            // create the action context<br />            contextMap = stack.getContext();<br />        }<br /><br />        // put extraContext in<br />        if (extraContext != null) {<br />            contextMap.putAll(extraContext);<br />        }

        //put this DefaultActionInvocation into the context map
        contextMap.put(ActionContext.ACTION_INVOCATION, this);
        contextMap.put(ActionContext.CONTAINER, container);

        return contextMap;
    }

    public void init(ActionProxy proxy) {
        this.proxy = proxy;
        Map&lt;String, Object&gt; contextMap = createContextMap();

        // Setting this so that other classes, like object factories, can use the ActionProxy and other
        // contextual information to operate
        ActionContext actionContext = ActionContext.getContext();

        if (actionContext != null) {
            actionContext.setActionInvocation(this);
        }

        createAction(contextMap);

        if (pushAction) {
            stack.push(action);
            contextMap.put(&quot;action&quot;, action);
        }

        invocationContext = new ActionContext(contextMap);
        invocationContext.setName(proxy.getActionName());

        // get a new List so we don't get problems with the iterator if someone changes the list
        List&lt;InterceptorMapping&gt; interceptorList = new ArrayList&lt;InterceptorMapping&gt;(proxy.getConfig().getInterceptors());
        interceptors = interceptorList.iterator();
    }</pre> 
 <p>一些拦截器的实现：</p> 
 <h3>AnnotationParameterFilterIntereptor</h3> 
 <pre>/**<br /> * Annotation based version of {@link ParameterFilterInterceptor}.<br /> * &lt;p/&gt;<br /> * This {@link Interceptor} must be placed in the stack before the {@link ParametersInterceptor}<br /> * When a parameter matches a field that is marked {@link Blocked} then it is removed from<br /> * the parameter map.<br /> * &lt;p/&gt;<br /> * If an {@link Action} class is marked with {@link BlockByDefault} then all parameters are<br /> * removed unless a field on the Action exists and is marked with {@link Allowed}<br /> *<br /> * @author martin.gilday<br /> */<br />public class AnnotationParameterFilterIntereptor extends AbstractInterceptor {<br /><br />    /* (non-Javadoc)<br />      * @see com.opensymphony.xwork2.interceptor.AbstractInterceptor#intercept(com.opensymphony.xwork2.ActionInvocation)<br />      */<br />    @Override public String intercept(ActionInvocation invocation) throws Exception {<br /><br />        final Object action = invocation.getAction();<br />        Map&lt;String, Object&gt; parameters = invocation.getInvocationContext().getParameters();<br /><br />        boolean blockByDefault = action.getClass().isAnnotationPresent(BlockByDefault.class);<br />        List&lt;Field&gt; annotatedFields = new ArrayList&lt;Field&gt;();<br />        HashSet&lt;String&gt; paramsToRemove = new HashSet&lt;String&gt;();<br /><br />        if (blockByDefault) {<br />            AnnotationUtils.addAllFields(Allowed.class, action.getClass(), annotatedFields);<br /><br />            for (String paramName : parameters.keySet()) {<br />                boolean allowed = false;<br /><br />                for (Field field : annotatedFields) {<br />                    //TODO only matches exact field names.  need to change to it matches start of ognl expression<br />                    //i.e take param name up to first . (period) and match against that<br />                    if (field.getName().equals(paramName)) {<br />                        allowed = true;<br />                    }<br />                }<br /><br />                if (!allowed) {<br />                    paramsToRemove.add(paramName);<br />                }<br />            }<br />        } else {<br />            AnnotationUtils.addAllFields(Blocked.class, action.getClass(), annotatedFields);<br /><br />            for (String paramName : parameters.keySet()) {<br /><br />                for (Field field : annotatedFields) {<br />                    //TODO only matches exact field names.  need to change to it matches start of ognl expression<br />                    //i.e take param name up to first . (period) and match against that<br />                    if (field.getName().equals(paramName)) {<br />                        paramsToRemove.add(paramName);<br />                    }<br />                }<br />            }<br />        }<br /><br />        for (String aParamsToRemove : paramsToRemove) {<br />            parameters.remove(aParamsToRemove);<br />        }<br /><br />        return invocation.invoke();<br />    }<br /><br />}</pre> 
 <h3>public class ParametersInterceptor extends MethodFilterInterceptor</h3> 
 <pre>//hxzon 父类MethodFilterInterceptor方法</pre> 
 <pre>public String intercept(ActionInvocation invocation) throws Exception {<br />        if (applyInterceptor(invocation)) {<br />            return doIntercept(invocation);<br />        } <br />        return invocation.invoke();<br />    }</pre> 
 <pre>/**<br />     * Compares based on number of '.' characters (fewer is higher)<br />     */<br />    static final Comparator&lt;String&gt; rbCollator = new Comparator&lt;String&gt;() {<br />        public int compare(String s1, String s2) {<br />            int l1 = 0, l2 = 0;<br />            for (int i = s1.length() - 1; i &gt;= 0; i--) {<br />                if (s1.charAt(i) == '.') l1++;<br />            }<br />            for (int i = s2.length() - 1; i &gt;= 0; i--) {<br />                if (s2.charAt(i) == '.') l2++;<br />            }<br />            return l1 &lt; l2 ? -1 : (l2 &lt; l1 ? 1 : s1.compareTo(s2));<br />        }<br /><br />    };<br /><br />    @Override<br />    public String doIntercept(ActionInvocation invocation) throws Exception {<br />        Object action = invocation.getAction();<br />        if (!(action instanceof NoParameters)) {<br />            ActionContext ac = invocation.getInvocationContext();<br />            final Map&lt;String, Object&gt; parameters = retrieveParameters(ac);<br /><br />            if (LOG.isDebugEnabled()) {<br />                LOG.debug(&quot;Setting params &quot; + getParameterLogMap(parameters));<br />            }<br /><br />            if (parameters != null) {<br />                Map&lt;String, Object&gt; contextMap = ac.getContextMap();<br />                try {<br />                    ReflectionContextState.setCreatingNullObjects(contextMap, true);<br />                    ReflectionContextState.setDenyMethodExecution(contextMap, true);<br />                    ReflectionContextState.setReportingConversionErrors(contextMap, true);<br /><br />                    ValueStack stack = ac.getValueStack();<br />                    setParameters(action, stack, parameters);<br />                } finally {<br />                    ReflectionContextState.setCreatingNullObjects(contextMap, false);<br />                    ReflectionContextState.setDenyMethodExecution(contextMap, false);<br />                    ReflectionContextState.setReportingConversionErrors(contextMap, false);<br />                }<br />            }<br />        }<br />        return invocation.invoke();<br />    }<br /><br />    protected void setParameters(Object action, ValueStack stack, final Map&lt;String, Object&gt; parameters) {<br />        ParameterNameAware parameterNameAware = (action instanceof ParameterNameAware)<br />                ? (ParameterNameAware) action : null;<br /><br />        Map&lt;String, Object&gt; params;<br />        Map&lt;String, Object&gt; acceptableParameters;<br />        if (ordered) {<br />            params = new TreeMap&lt;String, Object&gt;(getOrderedComparator());<br />            acceptableParameters = new TreeMap&lt;String, Object&gt;(getOrderedComparator());<br />            params.putAll(parameters);<br />        } else {<br />            params = new TreeMap&lt;String, Object&gt;(parameters);<br />            acceptableParameters = new TreeMap&lt;String, Object&gt;();<br />        }<br /><br />        for (Map.Entry&lt;String, Object&gt; entry : params.entrySet()) {<br />            String name = entry.getKey();<br /><br />            boolean acceptableName = acceptableName(name)<br />                    &amp;&amp; (parameterNameAware == null<br />                    || parameterNameAware.acceptableParameterName(name));<br /><br />            if (acceptableName) {<br />                acceptableParameters.put(name, entry.getValue());<br />            }<br />        }<br /><br />        ValueStack newStack = valueStackFactory.createValueStack(stack);<br />        boolean clearableStack = newStack instanceof ClearableValueStack;<br />        if (clearableStack) {<br />            //if the stack's context can be cleared, do that to prevent OGNL<br />            //from having access to objects in the stack, see XW-641<br />            ((ClearableValueStack)newStack).clearContextValues();<br />            Map&lt;String, Object&gt; context = newStack.getContext();<br />            ReflectionContextState.setCreatingNullObjects(context, true);<br />            ReflectionContextState.setDenyMethodExecution(context, true);<br />            ReflectionContextState.setReportingConversionErrors(context, true);<br /><br />            //keep locale from original context<br />            context.put(ActionContext.LOCALE, stack.getContext().get(ActionContext.LOCALE));<br />        }<br /><br />        boolean memberAccessStack = newStack instanceof MemberAccessValueStack;<br />        if (memberAccessStack) {<br />            //block or allow access to properties<br />            //see WW-2761 for more details<br />            MemberAccessValueStack accessValueStack = (MemberAccessValueStack) newStack;<br />            accessValueStack.setAcceptProperties(acceptParams);<br />            accessValueStack.setExcludeProperties(excludeParams);<br />        }<br /><br />        for (Map.Entry&lt;String, Object&gt; entry : acceptableParameters.entrySet()) {<br />            String name = entry.getKey();<br />            Object value = entry.getValue();<br />            try {<br />                newStack.setValue(name, value);<br />            } catch (RuntimeException e) {<br />                if (devMode) {<br />                    String developerNotification = LocalizedTextUtil.findText(ParametersInterceptor.class, &quot;devmode.notification&quot;, ActionContext.getContext().getLocale(), &quot;Developer Notification:\n{0}&quot;, new Object[]{<br />                             &quot;Unexpected Exception caught setting '&quot; + name + &quot;' on '&quot; + action.getClass() + &quot;: &quot; + e.getMessage()<br />                    });<br />                    LOG.error(developerNotification);<br />                    if (action instanceof ValidationAware) {<br />                        ((ValidationAware) action).addActionMessage(developerNotification);<br />                    }<br />                }<br />            }<br />        }<br /><br />        if (clearableStack &amp;&amp; (stack.getContext() != null) &amp;&amp; (newStack.getContext() != null))<br />            stack.getContext().put(ActionContext.CONVERSION_ERRORS, newStack.getContext().get(ActionContext.CONVERSION_ERRORS));<br /><br />        addParametersToContext(ActionContext.getContext(), acceptableParameters);<br />    }</pre> 
 <h3>public class TimerInterceptor extends AbstractInterceptor</h3> 
 <pre>public String intercept(ActionInvocation invocation) throws Exception {<br />        if (! shouldLog()) {<br />            return invocation.invoke();<br />        } else {<br />            return invokeUnderTiming(invocation);<br />        }<br />    }<br /><br />    /**<br />     * Is called to invoke the action invocation and time the execution time.<br />     *<br />     * @param invocation  the action invocation.<br />     * @return the result of the action execution.<br />     * @throws Exception  can be thrown from the action.<br />     */<br />    protected String invokeUnderTiming(ActionInvocation invocation) throws Exception {<br />        long startTime = System.currentTimeMillis();<br />        String result = invocation.invoke();<br />        long executionTime = System.currentTimeMillis() - startTime;<br /><br />        StringBuilder message = new StringBuilder(100);<br />        message.append(&quot;Executed action [&quot;);<br />        String namespace = invocation.getProxy().getNamespace();<br />        if ((namespace != null) &amp;&amp; (namespace.trim().length() &gt; 0)) {<br />            message.append(namespace).append(&quot;/&quot;);<br />        }<br />        message.append(invocation.getProxy().getActionName());<br />        message.append(&quot;!&quot;);<br />        message.append(invocation.getProxy().getMethod());<br />        message.append(&quot;] took &quot;).append(executionTime).append(&quot; ms.&quot;);<br /><br />        doLog(getLoggerToUse(), message.toString());<br /><br />        return result;<br />    }</pre> 
 <p><span style="font-size: medium"><br /> </span></p> 
</div></div></body></html>