<html><head><title>sniffer技术资料</title></head><body><div id='tit'>sniffer技术资料</div><div id='cate'>硬件&middot;网络</div><div id='date'>2007年11月13日 星期二 10:40 A.M.</div><div id='page'>205</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/791dd6a20a4b95aecaefd009.html'>http://hi.baidu.com/hxzon/blog/item/791dd6a20a4b95aecaefd009.html</a><div id='cnt'><p><font size="3">sniffer技术资料 <br /> </font></p> 
<p><font size="3">sniffer中文翻译过来就是嗅探器。是一中威胁性极大的被动攻击工具！使用在个攻击可以监视网络的状态。数据流动情况以及网络上传输的信息，便可以用网络监听到方式来进行攻击，截获网上的信息。所以黑客常常喜欢用他来截获用户口令！<br /> sniffer可以分为两类一个是硬件的一个软件的，今天给大家讲的主要是软件的sniffer.sniffer只能抓取一个物理网段的包，就是说你和监听的目标中间不能有路由（交换）或其他屏蔽广播包的设备，这一点很重要。所以对一般拨号上网的用户来说，是不可能利用sniffer来窃听到其他人的通信内容的！<br /> sniffer属于第二层次的攻击。就是说只有在攻击者已经进入了目标系统的情况下，才能使用sniffer这中攻击手段，以便得到更多的信息。sniffer除了能得到口令或用户名外，还能得到更多的其他的信息，比如一个其他重要的信息，在网上转送的金融信息等等。sniffer几乎能得到任何在以太网上转送的数据包。sniffer是一中比较复杂的攻击手段，一般只有黑客老手才有能力使用他（其实只要了解了也可以去试试我就是常常练习才知道！）而对于一个网络新手来说，即使在一台主机上成功地编译并运行了sinffer，一般也不会得到什么有用的信息。因为通常网络上的信息流量是相当大的，如果不加选绎的接收所有的包，然后要从中找到所需要的信息是非常的困难的，而且如果长时间地进行监听，还有可能把放置sniffer的机器的硬盘撑爆！<br /> 现在给大家看一个C程序，它可以完成一般的监听功能，【**】是注解！<br /> 【*下面是包含进行调试用系统和网络的函数的头文件*】<br /> #include<br /> #include<br /> #include<br /> 【*下面是IP和TCP包头结构*】<br /> structip{<br /> unsigendintip_length:4;【*定义IP头的长度*】<br /> unsigendintip_version:4;【*IP版本，IPV4*】<br /> unsigendcharip_tos;【*服务类型*】<br /> unsigendshortip_total_length;【*IP数据包的总长度*】<br /> unsigendshortip_id;【*鉴定域*】<br /> unsigendshortip_flags;【*IP标志*】<br /> unsigendcharip_ttl;【*IP包的存活期*】<br /> unsigendcharip_protocol;【*IP上层的协议*】<br /> unsigendshortip_sksum;【*IP头校研和*】<br /> unsigendintip_source;【*源IP地址*】<br /> unsigendintip_dest;【*目的IP地址*】<br /> }<br /> structtcp{<br /> unsigendshorttcp_s<br /> ource_port;【*定义TCP源端口*】<br /> unsigendshorttcp_dest_port【*TCP目的的端口*】<br /> unsigendinttcp_seqno;【*TCP序列号*】<br /> unsigendinttcp_ackno;【*发送者期望的下一个序列号*】<br /> unsigendinttcp_resl:4;【*下面几个是TCP的标志*】<br /> tcp_hlen:4,<br /> tcp_fin:1,<br /> tcp_syn:1,<br /> tcp_rst:1,<br /> tcp_psh:1,<br /> tcp_ack:1,<br /> tcp_urg:1,<br /> tcp_res:2,<br /> unsigendshorttcp_w<br /> insize;【*能接收的最大字节数*】<br /> unsigendshorttcp_cksum;【*TCP校研和*】<br /> unsigendshorttcp_urgent;【*紧急事件标志*】<br /> }<br /> 【*主函数*】<br /> intmain()<br /> {<br /> intsock,bytes_recieved,fromlen;<br /> charbuffer[65535];<br /> structsockaddr_infrom;【*定义socket结构*】<br /> structipip;【*定义IP和TCP结构*】<br /> structtcp*tcp<br /> sock=socket(AF_INET,SOCK,IPPROTO_TCP)<br /> 【*上面是建立socket连接，第一个参数是地址族类型，用INTERNET类型*】<br /> 【*第二个参数是socket类型，这里用了SOCK--RAW，它可以绕过传输层，*】<br /> 【*直接访问IP层的包，为了调用SOCK--RAW，需要有ROOT权限*】<br /> 【*第三个参数是协议，选IPPROTO--TCP指定可接收TCP层的内容*】<br /> while(1)<br /> {<br /> fromlen=sizeoffrom;<br /> bytes_recieved=recvfrom(sock,buf<br /> sockaddr*)&amp;from,&amp;fromlen);<br /> fer,sizeofbuffer,0,(struct<br /> 【*上面这个函数是从建立的socket连接中接收数据*】<br /> 【*因为recvfrom（）需要一个sockaddr数据类型，所以我们用一个强制类型转换*】<br /> printf(&quot;\nByetsreceived:::%4d\n&quot;,bytes_recieved);【*显示出接收的数据字节数*】<br /> printf(&quot;Sourceaddress:::%s\n&quot;,inet_ntoa(ftom.sin_addr);【*显示出源地址*】<br /> ip=(structip*)buffer;【*把接收的数据转换为我们预先定义的结构，便于查看*】<br /> printf(&quot;IPheaderlength:::%d\n&quot;,ip-&gt;ip_length);【*显示IP头的长度*】<br /> printf(&quot;Protocol:::%d\n&quot;,ip-&gt;ip_potocol);【*显示协议类型，6是TCP，17是UDP*】<br /> tcp=(structtcp*)(buffer+(4*ip-&gt;ip_length);【*上面这句需要详细解释一下，因为接收到的包头数据中，IP头的大小是固定的4字节*】<br /> 【*所以我们用IP长度乘以4，指向TCP头部分*】<br /> printf(&quot;Sourcepotr:::%d\n&quot;,ntohs(tcp-&gt;tcp_source_port)【*显示出源端口*】<br /> prinft(&quot;Destpotr:::%d\n&quot;,ntohs(tcp-&gt;tcp_dest_port)【*显示出目标端口*】<br /> }<br /> 以上这个C程序是为了说明sniffer的接收原理而列举的一个最简单的列子，它这是完成了sniffer的接收功能，在运行之前我们还需要手工把网卡设置为混杂模式，在root权限下用命令设置：<br /> ifconfigeth0promisc<br /> 假设eth0是你的以太网设备接口，然后运行编译好的程序清单（就是上面的C程序）就可以看到接受的数据包了！（重要消息：这个程序的功能太简单，只能显示源地址，目标地址和源端口，目标端口等极为简单的信息，对于你来说没有用但是你可以改一下）<br /> 现在来看看**的sniffer程序<br /> sniffit可以运行在linuxSolarisSGINT等各种平台运行的网络监听软件，他主要针对的是TCP/IP协议的不安全性，对运行该协议的计算机进行监听。<br /> 安装<br /> 跟我来一步一步走别跑掉了嘻嘻！跑掉了别怪我呀！<br /> 1。用tatzvfxsniffit.*.*.*.tgz将下载的sniffit.*.*.*.tgz解压缩到你想要的目的文件夹，如果版本是。0。3。7的话，你会看到该目录下出现一个sniffit。0。3。7的目录。<br /> 2。打开sniffit。0。3。7的目录<br /> 3。执行/configure&amp;&amp;make命令，只要在个过程中终端上没有意外的错误提示信息出现，就算编译成功了，然后就可以得到一个二进制的sniffit文件，直接运行他即可！<br /> 4。最后使用makeclean命令清除掉临时文件。<br /> sniffit的使用方法<br /> sniffit的命令<br /> 选项作用<br /> -V显示版本信息<br /> -t让程序去监听指定流向某IP的数据<br /> -s让程序去监听从某IP流出的IP数据包，可以使用@统配符如-t192.168.@<br /> -i显示出窗口界面，能查出当前在所属网络上进行连接的机器<br /> -l扩展的交互模式，忽略所以其他选项，比-L强大的多<br /> -c利用脚本来运行程序<br /> -F强制使程序使用网络硬盘<br /> -n显示出假的数据包，如果使用ARP，RARP或者其他不是IP的数据包也会显示出来<br /> -N只运行plugin时的选项，使其他选项失效<br /> 使用示列<br /> 假设在一个子网中有两台主机，一台运行了sniffit，为sniffit.com另一台的IP地址是192.168.0.1我把他称为xxx.com按下列步骤操作！<br /> 1，检查sniffit能否运行；<br /> sniffit~/#sniffit-d-p7-t192.168.0.1<br /> 并且打开另外一个窗口；<br /> sniffit~/$telnetxxx.com<br /> sniffit~/#sniffit-p21-l0-t192.168.0.1<br /> 应该可以看到sniffit将远程登陆到对方7号端口echo服务的包捕获。<br /> 2，截获xxx.com上的用户密码<br /> sniffit:~/#sniffit-p23-t192.168.0.1<br /> 意思就是监听23端口包<br /> 3，如果xxx.com主机的根用户声称有陌生的FTP连接并且希望记录其动作<br /> sniffit:~/3sniffit-p21-l0-t192.168.0.1<br /> 4，阅读所有进出xxx.com的信件<br /> sniffit:~/#sniffit-p25-l0-b-t192.168.0.1&amp;<br /> 或者sniffit:~/#-sniffit-p25-l0-b-s192.168.0.1&amp;<br /> 5,监听所以从192.168.0.1进出的包，对其行完全监视<br /> sniffit:~/#sniffit-Pipicmptcp-p0-b-a-d-x-s192.168.0.1<br /> 6,用more192*命令读取用下列方式记录的密码：<br /> sniffit:~/#sniffit-p23-A.-t192.168.0.1<br /> 哎好难写呀！现在改给大家一个WIN下的嗅探器了呀！因为win普遍是的吗HOHO<br /> NetXRay<br /> NetXRay的功能主要分为三大类<br /> 1，接收并分析数据包<br /> 2，传送数据包功能<br /> 3，网路管理监看的功能<br /> NetXRay的第三个功能是网络管理监看，网络管理功能中一共有7个按钮。现在给大家介绍一下把！<br /> DashBoard按钮：将子网下的流量以简要的形式显示出来<br /> HostTable按钮：观察子网下每台主机的网络流量情况<br /> Matrix按钮：观察子网下主机与主机之间的流量情况<br /> History按钮：将网络上的数据以图表的方式显示<br /> ProtocalDistribution按钮：分析网络上各种通信协议的分布情况<br /> AlarmLOG按钮：设定网络状况警告<br /> AddreeBook按钮：设定主机资料<br /> 由于时间的问题我就在这里介绍一下DashBoard按钮的用法，（哇绝对又有用说我偷懒了，请大家原谅我还是学生没很多时间接触计算机所以就……等我放假了给大家更好的教材行不！）<br /> 对于其他的按钮的详细资料大家可以去http://216.239.33.102找找！<br /> DashBoard按钮用来以简要的形式显示子网上的流量，单击后会出现一个图形界面很像汽车的油门表一样的东西（没时间给大家抓图了请原谅）<br /> 其中，Packets行表示到目前为止共有多少数据包，Broadcasts行标称有多少个广播的数据包，Multucasts行表示有多少个播数据包，Bytes行表示共有多少字节的数据在你的子网中传输，Errors行表示网络中错误发生的次数。<br /> 哎写了这么多关于sniffer的介绍情况，现在大家应该对sniffer有些了解了把！</font></p></div></body></html>