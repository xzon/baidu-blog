<html><head><title>JUnit 4 Vs TestNG – Comparison</title></head><body><div id='tit'>JUnit 4 Vs TestNG – Comparison</div><div id='cate'>细节</div><div id='date'>2009年10月14日 星期三 05:15 P.M.</div><div id='page'>27</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/46ba07e966447735b80e2d9e.html'>http://hi.baidu.com/hxzon/blog/item/46ba07e966447735b80e2d9e.html</a><div id='cnt'><h1><a title="JUnit 4 Vs TestNG – Comparison" href="http://www.mkyong.com/unittest/junit-4-vs-testng-comparison/" rel="bookmark">JUnit 4 Vs TestNG – Comparison </a></h1> 
<p>JUnit 4 and TestNG are both very popular unit test framework in Java. Both frameworks look very similar in functionality. Which one is better? Which unit test framework should i use in Java project?</p> 
<p>Here i did a feature comparison between JUnit 4 and TestNG.</p> 
<h3>1) Annotation Support</h3> 
<p>The annotation supports are implemented in both JUnit 4 and TestNG look similar.</p> 
<p> </p>
<table border="1"> 
 <tbody> 
  <tr> 
   <td>Feature</td> 
   <td>JUnit 4</td> 
   <td>TestNG</td> 
  </tr> 
  <tr> 
   <td>test annotation</td> 
   <td>@Test</td> 
   <td>@Test</td> 
  </tr> 
  <tr> 
   <td>run before all tests in this suite have run</td> 
   <td>–</td> 
   <td>@BeforeSuite</td> 
  </tr> 
  <tr> 
   <td>run after all tests in this suite have run</td> 
   <td>–</td> 
   <td>@AfterSuite</td> 
  </tr> 
  <tr> 
   <td>run before the test</td> 
   <td>–</td> 
   <td>@BeforeTest</td> 
  </tr> 
  <tr> 
   <td>run after the test</td> 
   <td>–</td> 
   <td>@AfterTest</td> 
  </tr> 
  <tr> 
   <td>run before the first test method that belongs to any of these groups is invoked</td> 
   <td>–</td> 
   <td>@BeforeGroups</td> 
  </tr> 
  <tr> 
   <td>run after the last test method that belongs to any of these groups is invoked</td> 
   <td>–</td> 
   <td>@AfterGroups</td> 
  </tr> 
  <tr> 
   <td>run before the first test method in the current class is invoked</td> 
   <td>@BeforeClass</td> 
   <td>@BeforeClass</td> 
  </tr> 
  <tr> 
   <td>run after all the test methods in the current class have been run</td> 
   <td>@AfterClass</td> 
   <td>@AfterClass</td> 
  </tr> 
  <tr> 
   <td>run before each test method</td> 
   <td>@Before</td> 
   <td>@BeforeMethod</td> 
  </tr> 
  <tr> 
   <td>run after each test method</td> 
   <td>@After</td> 
   <td>@AfterMethod</td> 
  </tr> 
  <tr> 
   <td>ignore test</td> 
   <td>@ignore</td> 
   <td>@Test(enbale=false)</td> 
  </tr> 
  <tr> 
   <td>expected exception</td> 
   <td>@Test(expected = ArithmeticException.class)</td> 
   <td>@Test(expectedExceptions = ArithmeticException.class)</td> 
  </tr> 
  <tr> 
   <td>timeout</td> 
   <td>@Test(timeout = 1000)</td> 
   <td>@Test(timeout = 1000)</td> 
  </tr> 
 </tbody> 
</table>  
<p>The main annotation differences between JUnit4 and TestNG are</p> 
<p>1) In JUnit 4, we have to declare “@BeforeClass” and “@AfterClass” method as static method. TestNG is more flexible in method declaration, it does not have this constraints.</p> 
<p>2) 3 additional setUp/tearDown level: suite and group (@Before/AfterSuite, @Before/AfterTest, @Before/AfterGroup). See more <a href="http://testng.org/doc/documentation-main.html#annotations" target="_blank">detail here.</a></p> 
<p>JUnit 4</p> 
<div> 
 <div> 
  <pre>@BeforeClass
    public static void oneTimeSetUp() {
        // one-time initialization code   
     System.out.println(&quot;@BeforeClass - oneTimeSetUp&quot;);
    }</pre> 
 </div> 
</div> 
<p>TestNG</p> 
<div> 
 <div> 
  <pre>@BeforeClass
    public void oneTimeSetUp() {
        // one-time initialization code   
     System.out.println(&quot;@BeforeClass - oneTimeSetUp&quot;);
}</pre> 
 </div> 
</div> 
<p>2) In JUnit 4, the annotation naming convention is a bit confusing, e.g “Before”, “After” and “Expected”, we do not really understand what is “Before” and “After” do, and what we “Expected” from test method? TestNG is easier to understand, it using “BeforeMethod”, “AfterMethod” and “ExpectedException” instead.</p> 
<h3>2) Exception Test</h3> 
<p>The “exception testing” means what exception throw from the unit test, this feature are implemented in both JUnit 4 and TestNG.</p> 
<p>JUnit 4</p> 
<div> 
 <div> 
  <pre>@Test(expected = ArithmeticException.class)  
 public void divisionWithException() {  
   int i = 1/0;
 }</pre> 
 </div> 
</div> 
<p>TestNG</p> 
<div> 
 <div> 
  <pre>@Test(expectedExceptions = ArithmeticException.class)  
 public void divisionWithException() {  
   int i = 1/0;
 }</pre> 
 </div> 
</div> 
<h3>3) Ignore Test</h3> 
<p>The “Ignored” means whether it should ignore the unit test, this feature are implemented in both JUnit 4 and TestNG .</p> 
<p>JUnit 4</p> 
<div> 
 <div> 
  <pre>@Ignore(&quot;Not Ready to Run&quot;)  
 @Test
 public void divisionWithException() {  
   System.out.println(&quot;Method is not ready yet&quot;);
 }</pre> 
 </div> 
</div> 
<p>TestNG</p> 
<div> 
 <div> 
  <pre>@Test(enabled=false)
 public void divisionWithException() {  
   System.out.println(&quot;Method is not ready yet&quot;);
 }</pre> 
 </div> 
</div> 
<h3>4) Time Test</h3> 
<p>The “Time Test” means if an unit test takes longer than the specified number of milliseconds to run, the test will terminated and mark as fails, this feature is implemented in both JUnit 4 and TestNG .</p> 
<p>JUnit 4</p> 
<div> 
 <div> 
  <pre>@Test(timeout = 1000)  
 public void infinity() {  
  while (true);  
 }</pre> 
 </div> 
</div> 
<p>TestNG</p> 
<div> 
 <div> 
  <pre>@Test(timeOut = 1000)  
 public void infinity() {  
  while (true);  
 }</pre> 
 </div> 
</div> 
<h3>5) Suite Test</h3> 
<p>The “Suite Test” means bundle a few unit test and run it together. This feature is implemented in both JUnit 4 and TestNG. However both are using very different method to implement it.</p> 
<p>JUnit 4</p> 
<p>The “@RunWith” and “@Suite” are use to run the suite test. The below class means both unit test “JunitTest1” and “JunitTest2” run together after JunitTest5 executed. All the declaration is define inside the class.</p> 
<div> 
 <div> 
  <pre>@RunWith(Suite.class)
@Suite.SuiteClasses({
        JunitTest1.class,
        JunitTest2.class
})
public class JunitTest5 {
}</pre> 
 </div> 
</div> 
<p>TestNG</p> 
<p>XML file is use to run the suite test. The below XML file means both unit test “TestNGTest1” and “TestNGTest2” will run it together.</p> 
<div> 
 <div> 
  <pre>&lt;!DOCTYPE suite SYSTEM &quot;http://beust.com/testng/testng-1.0.dtd&quot; &gt;
&lt;suite name=&quot;My test suite&quot;&gt;
  &lt;test name=&quot;testing&quot;&gt;
    &lt;classes&gt;
       &lt;class name=&quot;com.fsecure.demo.testng.TestNGTest1&quot; /&gt;
       &lt;class name=&quot;com.fsecure.demo.testng.TestNGTest2&quot; /&gt;
    &lt;/classes&gt;
  &lt;/test&gt;
&lt;/suite&gt;</pre> 
 </div> 
</div> 
<p>TestNG can do more than bundle class testing, it can bundle method testing as well. With TestNG unique “Grouping” concept, every method is tie to a group, it can categorize tests according to features. For example,</p> 
<p>Here is a class with four methods, three groups (method1, method2 and method3)</p> 
<div> 
 <div> 
  <pre>@Test(groups=&quot;method1&quot;)
 public void testingMethod1() {  
   System.out.println(&quot;Method - testingMethod1()&quot;);
 }  
 
 @Test(groups=&quot;method2&quot;)
 public void testingMethod2() {  
  System.out.println(&quot;Method - testingMethod2()&quot;);
 }  
 
 @Test(groups=&quot;method1&quot;)
 public void testingMethod1_1() {  
  System.out.println(&quot;Method - testingMethod1_1()&quot;);
 }  
 
 @Test(groups=&quot;method4&quot;)
 public void testingMethod4() {  
  System.out.println(&quot;Method - testingMethod4()&quot;);
 }</pre> 
 </div> 
</div> 
<p>With the following XML file, we can execute the unit test with group “method1” only.</p> 
<div> 
 <div> 
  <pre>&lt;!DOCTYPE suite SYSTEM &quot;http://beust.com/testng/testng-1.0.dtd&quot; &gt;
&lt;suite name=&quot;My test suite&quot;&gt;
  &lt;test name=&quot;testing&quot;&gt;
   &lt;groups&gt;
      &lt;run&gt;
        &lt;include name=&quot;method1&quot;/&gt;
      &lt;/run&gt;
    &lt;/groups&gt;
    &lt;classes&gt;
       &lt;class name=&quot;com.fsecure.demo.testng.TestNGTest5_2_0&quot; /&gt;
    &lt;/classes&gt;
  &lt;/test&gt;
&lt;/suite&gt;</pre> 
 </div> 
</div> 
<p>With “Grouping” test concept, the integration test possibility is unlimited. For example, we can only test the “DatabaseFuntion” group from all of the unit test classes.</p> 
<h3>6) Parameterized Test</h3> 
<p>The “Parameterized Test” means vary parameter value for unit test. This feature is implemented in both JUnit 4 and TestNG. However both are using very different method to implement it.</p> 
<p>JUnit 4</p> 
<p>The “@RunWith” and “@Parameter” is use to provide parameter value for unit test, @Parameters have to return List[], and the parameter will pass into class constructor as argument.</p> 
<div> 
 <div> 
  <pre>@RunWith(value = Parameterized.class)
public class JunitTest6 {
 
  private int number;
 
  public JunitTest6(int number) {
     this.number = number;
  }
 
  @Parameters
  public static Collection&lt;Object[]&gt; data() {
    Object[][] data = new Object[][] { { 1 }, { 2 }, { 3 }, { 4 } };
    return Arrays.asList(data);
  }
 
  @Test
  public void pushTest() {
    System.out.println(&quot;Parameterized Number is : &quot; + number);
  }
}</pre> 
 </div> 
</div> 
<p>It has many limitations here; we have to follow the “JUnit” way to declare the parameter, and the parameter has to pass into constructor in order to initialize the class member as parameter value for testing. The return type of parameter class is “List []”, data has been limited to String or a primitive value for testing.</p> 
<p>TestNG</p> 
<p>XML file or “@DataProvider” is use to provide vary parameter for testing.</p> 
<p>XML file for parameterized test.<br /> Only “@Parameters” declares in method which needs parameter for testing, the parametric data will provide in TestNG’s XML configuration files. By doing this, we can reuse a single test case with different data sets and even get different results. In addition, even end user, QA or QE can provide their own data in XML file for testing.</p> 
<p>Unit Test</p> 
<div> 
 <div> 
  <pre>public class TestNGTest6_1_0 {
 
    @Test
    @Parameters(value=&quot;number&quot;)
    public void parameterIntTest(int number) {
       System.out.println(&quot;Parameterized Number is : &quot; + number);
    }
 
      }</pre> 
 </div> 
</div> 
<p>XML File</p> 
<div> 
 <div> 
  <pre>&lt;!DOCTYPE suite SYSTEM &quot;http://beust.com/testng/testng-1.0.dtd&quot; &gt;
&lt;suite name=&quot;My test suite&quot;&gt;
  &lt;test name=&quot;testing&quot;&gt;
 
    &lt;parameter name=&quot;number&quot; value=&quot;2&quot;/&gt;  
 
    &lt;classes&gt;
       &lt;class name=&quot;com.fsecure.demo.testng.TestNGTest6_0&quot; /&gt;
    &lt;/classes&gt;
  &lt;/test&gt;
&lt;/suite&gt;</pre> 
 </div> 
</div> 
<p>@DataProvider for parameterized test.</p> 
<p>While pulling data values into an XML file can be quite handy, tests occasionally require complex types, which can’t be represented as a String or a primitive value. TestNG handles this scenario with its @DataProvider annotation, which facilitates the mapping of complex parameter types to a test method.</p> 
<p>@DataProvider for Vector, String or Integer as parameter</p> 
<div> 
 <div> 
  <pre>@Test(dataProvider = &quot;Data-Provider-Function&quot;)
 public void parameterIntTest(Class clzz, String[] number) {
    System.out.println(&quot;Parameterized Number is : &quot; + number[0]);
    System.out.println(&quot;Parameterized Number is : &quot; + number[1]);
 }
 
 //This function will provide the patameter data
 @DataProvider(name = &quot;Data-Provider-Function&quot;)
 public Object[][] parameterIntTestProvider() {
  return new Object[][]{
       {Vector.class, new String[] {&quot;java.util.AbstractList&quot;, 
&quot;java.util.AbstractCollection&quot;}},
       {String.class, new String[] {&quot;1&quot;, &quot;2&quot;}},
       {Integer.class, new String[] {&quot;1&quot;, &quot;2&quot;}}
      };
 }</pre> 
 </div> 
</div> 
<p>@DataProvider for object as parameter<br /> P.S “TestNGTest6_3_0” is an simple object with just get set method for demo.</p> 
<div> 
 <div> 
  <pre>@Test(dataProvider = &quot;Data-Provider-Function&quot;)
 public void parameterIntTest(TestNGTest6_3_0 clzz) {
    System.out.println(&quot;Parameterized Number is : &quot; + clzz.getMsg());
    System.out.println(&quot;Parameterized Number is : &quot; + clzz.getNumber());
 }
 
 //This function will provide the patameter data
 @DataProvider(name = &quot;Data-Provider-Function&quot;)
 public Object[][] parameterIntTestProvider() {
 
  TestNGTest6_3_0 obj = new TestNGTest6_3_0();
  obj.setMsg(&quot;Hello&quot;);
  obj.setNumber(123);
 
  return new Object[][]{
       {obj}
  };
 }</pre> 
 </div> 
</div> 
<p>TestNG’s parameterized test is very user friendly and flexible (either in XML file or inside the class). It can support many complex data type as parameter value and the possibility is unlimited. As example above, we even can pass in our own object (TestNGTest6_3_0) for parameterized test</p> 
<h3>7) Dependency Test</h3> 
<p>The “Parameterized Test” means methods are test base on dependency, which will execute before a desired method. If the dependent method fails, then all subsequent tests will be skipped, not marked as failed.</p> 
<p>JUnit 4</p> 
<p>JUnit framework is focus on test isolation; it did not support this feature at the moment.</p> 
<p>TestNG</p> 
<p>It use “dependOnMethods “ to implement the dependency testing as following</p> 
<div> 
 <div> 
  <pre>@Test
 public void method1() {
    System.out.println(&quot;This is method 1&quot;);
 }
 
 @Test(dependsOnMethods={&quot;method1&quot;})
 public void method2() {
  System.out.println(&quot;This is method 2&quot;);
 }</pre> 
 </div> 
</div> 
<p>The “method2()” will execute only if “method1()” is run successfully, else “method2()” will skip the test.</p> 
<p>TestNG’s trick of skipping, rather than failing, can really take the pressure off in large test suites. Rather than trying to figure out why 50 percent of the test suite failed, we can concentrate on why 50 percent of it was skipped! Better yet, TestNG complements its dependency testing setup with a mechanism for rerunning only failed tests.</p> 
<h2>Conclusion</h2> 
<p>After go thought all the features comparison, i suggest to use TestNG as core unit test framework for Java project, because TestNG is more advance in parameterize testing, dependency testing and suite testing (Grouping concept). TestNG is meant for high-level testing and complex integration test. Its flexibility is especially useful with large test suites. In addition, TestNG also cover the entire core JUnit4 functionality. It’s just no reason for me to use JUnit anymore.</p> 
<h3>Reference</h3> 
<p>TestNG<br /> ————<br /> <a href="http://en.wikipedia.org/wiki/TestNG" target="_blank">http://en.wikipedia.org/wiki/TestNG</a><br /> <a href="http://www.ibm.com/developerworks/java/library/j-testng/" target="_blank">http://www.ibm.com/developerworks/java/library/j-testng/</a><br /> <a href="http://testng.org/doc/index.html" target="_blank">http://testng.org/doc/index.html</a><br /> <a href="http://beust.com/weblog/" target="_blank">http://beust.com/weblog/</a></p> 
<p>JUnit<br /> ———–<br /> <a href="http://en.wikipedia.org/wiki/JUnit" target="_blank">http://en.wikipedia.org/wiki/JUnit</a><br /> <a href="http://www.ibm.com/developerworks/java/library/j-junit4.html" target="_blank">http://www.ibm.com/developerworks/java/library/j-junit4.html</a><br /> <a href="http://junit.sourceforge.net/doc/faq/faq.htm" target="_blank">http://junit.sourceforge.net/doc/faq/faq.htm</a><br /> <a href="http://www.devx.com/Java/Article/31983/0/page/3" target="_blank">http://www.devx.com/Java/Article/31983/0/page/3</a><br /> <a href="http://ourcraft.wordpress.com/2008/08/27/writing-a-parameterized-junit-test/" target="_blank">http://ourcraft.wordpress.com/2008/08/27/writing-a-parameterized-junit-test/</a></p> 
<p>TestNG VS JUnit<br /> ——————<br /> <a href="http://docs.codehaus.org/display/XPR/Migration+to+JUnit4+or+TestNG" target="_blank">http://docs.codehaus.org/display/XPR/Migration+to+JUnit4+or+TestNG</a><br /> <a href="http://www.ibm.com/developerworks/java/library/j-cq08296/index.html" target="_blank">http://www.ibm.com/developerworks/java/library/j-cq08296/index.html</a><br /> <a href="http://www.cavdar.net/2008/07/21/junit-4-in-60-seconds/" target="_blank">http://www.cavdar.net/2008/07/21/junit-4-in-60-seconds/</a></p></div></body></html>