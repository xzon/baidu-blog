<html><head><title>XCB (X protocol C-language Binding)</title></head><body><div id='tit'>XCB (X protocol C-language Binding)</div><div id='cate'>细节</div><div id='date'>2010年04月29日 星期四 07:05 P.M.</div><div id='page'>16</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/498cc9fcad530d8eb901a098.html'>http://hi.baidu.com/hxzon/blog/item/498cc9fcad530d8eb901a098.html</a><div id='cnt'><p>XCB (X protocol C-language Binding)<br /> <a href="http://en.wikipedia.org/wiki/XCB">http://en.wikipedia.org/wiki/XCB</a><br /> <a href="http://xcb.freedesktop.org/">http://xcb.freedesktop.org/</a><br /> <a href="http://xcb.freedesktop.org/tutorial/">http://xcb.freedesktop.org/tutorial/</a><br /> <a href="http://xcb.freedesktop.org/XcbUtil/api/">http://xcb.freedesktop.org/XcbUtil/api/</a><br /> <a href="http://en.wikipedia.org/wiki/XCB">http://en.wikipedia.org/wiki/XCB</a></p> 
<h1>Introduction</h1> 
<p>This tutorial is intended for people who want to program with the XCB library. Keep in mind that XCB, like the Xlib library, isn't what most programmers wanting to write X applications are looking for. Rather, most application developers will want to use a much higher-level GUI toolkit, like Motif, LessTiff, GTK, QT, EWL, or ETK or perhaps use the higher-level drawing library Cairo. However, the basics of XCB are not all that complicated, and knowing about the layers those other libraries are built on top of is not a bad idea.</p> 
<p>After reading this tutorial, one should be able to write very simple graphical programs but not write programs with decent user interfaces (at least easily). For real applications, the previously mentioned libraries are much more appropriate.</p> 
<h1>What is XCB and why does it exist?</h1> 
<p>XCB (&quot;X C Binding&quot;) is an low-level API for the X window server. XCB is an alternative to Xlib, which has been the standard C binding for the X Window System protocol for many years now. Xlib is an excellent piece of work, but there are applications for which it is not ideal, for example:</p> 
<ul> 
 <li><strong>Small platforms</strong>: Xlib is a large piece of code, and it's difficult to make it smaller</li> 
 <li><strong>Latency hiding</strong>: Xlib requests requiring a reply are effectively synchronous: they block until the reply appears, whether the result is needed immediately or not.</li> 
 <li><strong>Direct access to the protocol</strong>: Xlib does quite a bit of caching, layering, and similar optimizations. While this is normally a feature, it makes it difficult to simply emit specified X protocol requests and process specific responses.</li> 
 <li><strong>Threaded applications</strong>: While Xlib does attempt to support multithreading, the API makes this difficult and error-prone.</li> 
 <li><strong>New extensions</strong>: The Xlib infrastructure provides limited support for the new creation of X extension client side code.</li> 
</ul> 
<p>XCB has been designed to solve the above problems and thus provide a base for:</p> 
<ul> 
 <li>Toolkit implementation.</li> 
 <li>Direct protocol-level programming.</li> 
 <li>Lightweight emulation of commonly used portions of the Xlib API.</li> 
</ul> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>=================================</p> 
<p>XLib<br /> <a href="http://tronche.com/gui/x/xlib/">http://tronche.com/gui/x/xlib/</a><br /> <a href="http://www.sbin.org/doc/Xlib/">http://www.sbin.org/doc/Xlib/</a><br /> <a href="http://en.wikipedia.org/wiki/Xlib">http://en.wikipedia.org/wiki/Xlib</a></p> 
<p> </p> 
<p><font size="4">Xlib 函数库简介<br /> -----------------------------------------------------------<br /> &nbsp;&nbsp;&nbsp; X Window 系统是 UNIX 世界中标准的图形操作介面，它是在 1984 年由麻省理工资讯科学系与迪吉多公司合作开发的一个专案计划，其目是要发展一个兼具可移植性与网路通透性的视窗系统。该专案计划首度发表的是第十版的视窗系统 (X10)，到了 1987 年发表了第十一版 (X11)，历经多年的开发演进，到了 1994 年发表了 X11R6，也就是目前 UNIX 系统上通行的版本。而原本负责此专案计划的成员，也在 1996 底组成了一个称为 X Consortium 的组织，持续 X11R6 的开发与维护，而其最新的改进版是去年才问世的 X11R6.5。<br /> <br /> &nbsp;&nbsp;&nbsp; 由于 X Window 专案计划的出现，使得各 UNIX 厂商与软体开发组织可以以 X Consortium 所发展的程序码为蓝本，在他们的系统上建立图形化视窗环境。为了达到完整的可移植性与网路通透性，各厂商与软体开发组织所实作出来的 X Window 版本都遵守相同的协定，即 X 协定，同时也采用同样的函数库呼叫介面。因此，只要是 X Window 环境下开发出来的程序，原则上都可以不需修改而移植到其他平台的 X Window 环境 (只要它的 X Window 版本与原开发环境的版本相同或更早即可) 编译执行。<br /> <br /> &nbsp;&nbsp;&nbsp; 而在 GNU/Linux、FreeBSD 等 x86 平台的自由 UNIX 作业系统中，其 X Window 系统是来自 XFree86 计划，顾名思议，该计划的主要目的是提供一个免费、自由的 X Window 系统给 x86 个人电脑上的 UNIX 使用。而原先 GNU/Linux、FreeBSD 等是在 x86 电脑下开发的，但近年来它们已逐渐移植到 DEC Alpha, Sparc .... 等高阶的电脑系统上去，因此 XFree86 也顺应做了移植，可以在那些非 x86 的硬体系统上执行了。该计划也是依照 X Consortium 的标准而开发的，例如这两三年来通行的 XFree86-3.3.X 系列，主要就是以 X11R6.3 为蓝本。<br /> <br /> &nbsp;&nbsp;&nbsp; 但到了近一两年来情况稍有改变，由于 GNU/Linux 平台上的多国语言与 Unicode 支援的需求日益迫切，同时为了顺应近年来新的软应体技术，使得传统的 X11R6 实作方式已渐渐不缚使用。然而 X Consortium 在这些部分的开发脚步却不够快，或甚至仍未起步，故到了 XFree86-4.0.X 系列，除了遵循 X11R6.4 的标准以外，同时更进一步地开发了 Unicode 的支援、TrueType 字型支援、模组化显示卡驱动程序、高速绘图介面、并逐步修正过去 X Consortium 所发表的程序码中的错误 .... 等。可以这么说，XFree86-4.0.X 系列比起过去的版本有著相当长足的进步。而这些改进，未来也许会逐步出现在 X Consortium 新版的 X11R6 中。<br /> <br /> &nbsp;&nbsp;&nbsp; X Window 系统采取的是 Server/Client 的模型而运作。所谓的 Server 指的是 X Server, 它通常掌管一个完整的 Display。根据定义，一个传统的 Display 包含一个显示器、一个键盘、及一个滑鼠，或者还有其他选择性的输出入装置，换句话说，它就是一个完整的图型桌面装置。而 Client 指的是在此 Display 中执行的所有 X Window 应用程序，它们需要在萤幕上绘图、需要接收滑鼠、键盘等输入 .... 等，都必须向 X Server 发出请求，由 X Server 代为完成。而 X Server 与 Client 之间的沟通协定就称之为 X 协定。此 X 协定不仅可用于本机的 Display (亦即 X Server 与 Client 都在同一部机器上执行)，它更具备了网路的通透性，也就是 X Server 与 Client 可以在不同机器上执行，例如将远端的 Client 视窗显示到本地的 X Server 上，而本地的使用者在使用时就和操作本机执行的 Client 一样，不会有分别。此网路的通透性正是 X Window 系统最强大的特点之一。<br /> <br /> &nbsp;&nbsp;&nbsp; 由 X Server 掌控的 Display 只是图形介面的底层平台而已，它还不是我们平常所接触到的桌面环境。我们所用的桌面环境是由「<u><font color="#800000">桌面管理程序 (Window Manager)</font></u>」所提供，它拥有方便的功能表选单、启动应用程序的按扭图示、可以帮我们放漂亮的底图、及管理桌面上所有的视窗 .... 等等的功能，事实上，<u><font color="#800000">「桌面管理程序」在 X Server 的眼中，也不过是一个 X Client 而已，只是它的功能比较特殊，专门负责管理整个工作桌面。</font></u>由于 X Window 系统并不将桌面管理程序内建在 X Server 或 Display 中，因而给我们一个弹性: 我们可以依自己的喜好挑选桌面管理程序来用。这类的桌面管理程序可以说形形色色，有功能小巧阳春的 twm 与 fvwm、有长得很像 Windows 95 介面的 fvwm95、有相当眩丽的 enlightment、而<u><font color="#800000">有的功能甚至超越了单纯的桌面管理程序，还同时提供了一组程序库与应用程序、管理工具等等，让我们的桌面更加好用，如 KDE 或 Gnome 等。</font></u><br /> <br /> &nbsp;&nbsp;&nbsp; 而这些形形色色的 X 应用程序 (Client) 与 X Server 之间的沟通管道，就是实作并传输 X 协定的 X Window 底层函数库: Xlib。Xlib 在 X Window 中的地位，就好像 libc 在整个作业系统中的地位一样。若要做进一步的类比，X Server 的角色就如同作业系统的核心，libc 提供了系统核心系统呼叫的窗口，同样的 Xlib 可以直接与 X Server 连系传送讯息。若要撰写 X Window 的应用程序，则最底层可用的函数库就是 Xlib。<br /> <br /> <br /> <br /> Xlib 函数库功能简介<br /> </font><font color="#000000">-----------------------------------------------------------</font><br /> <font color="#000000" size="4">&nbsp;&nbsp;&nbsp; 在 X Window 的世界里，可以说所有的动作都是由「事件 (Event) 」所触发并完成的，不论是对 X Client 或是 X Server 都是一样。从 X Client 的角度来看，每个 X 应用程序内部都有一个处理事件的回圈 (event loop)，程序静静地等待事件的发生，一旦 Xlib 截获一个属于该应用程序的事件并传送给它时，该事件就会在事件处理回圈中产生相应的动作，处理完后，又会回到原点，等待下一个事件的发生。可能发生的事件有很多种，像是其他的视窗传来讯息、键盘滑鼠有了动作、桌面管理程序要求改变视窗的大小状态 ....<br /> <br /> &nbsp;&nbsp;&nbsp; 同样的，在 X Server 这边也是等待事件发生，以提供适当的服务。它同时还监控著整个 Display 的所有装置，如果有任何信号输入 (如来自键盘或滑鼠的输入) 时，它会将该信号打包成「事件」的包裹，经由 Xlib 传送给等待接收信号的 Client (即前景视窗)。由于 X Window 具备网路的通透性，故在设计时特别考虑到网路传输效率的问题。如果网路速度不够快时，每次 Client 一有服务请求就要求 X Server 马上回应，显然太缺乏效率了。因此在 Xlib 中有一个事件的缓冲区，当 Client 提出一连串的服务请求时，这些请求并没有马上送往 X Server，而是暂时保留在缓冲区中，等到必须要送出的时间点时，才会一口气送出，而让 X Server 将这一连串的服务请求一口气处理完毕。通常这个时间点是发生在 Client 送完了一连串的请求后，停下来等待下一个属于它的事件时，或者 Client 呼叫了 Xlib 中特定的函数要求 Xlib 马上将它的请求发送给 X Server。<br /> <br /> &nbsp;&nbsp;&nbsp; 此种以「事件处理」为基础的运作模式，使得 X Window 的程序写起来，与一般的程序有些不一样。同时一个视窗的程序由于牵涉到许多可调整的细节，像是视窗大小、颜色、底图样式、线条粗细、字型 .... 等等，因而使得程序内部会用到的数据结构与函数呼叫往往会很复杂。但大体而言，一个标准的 X Window 程序其内部的基本执行程序大致如下:<br /> <br /> &nbsp;&nbsp; 1. 呼叫函数 XOpenDisplay() 与 X Server 取得连系。<br /> &nbsp;&nbsp; 2. 初始化自己的视窗，包括一切属性设定，同时要将一些视窗属性的「提示」告诉桌面管理程序。注意这里只是「提示」而已，因为桌面管理程序管理所有的视窗，在某些情况下它可能无法完全按照应用程序的要求来执行 (例如应用程序要求了超过桌面范围的视窗位置) ，故它多少会自行调整一下。但大体而言它会尽可能按照应用程序的「提示」做到。<br /> &nbsp;&nbsp; 3. 设定应用程序视窗欲接收的「事件」种类，依应用程序的不同，其希望接收的事件也不同，若程序不需要的事件就不用接收，如此就可以省下不必要的效率浪费。<br /> &nbsp;&nbsp; 4. 进入事件回圈，等待事件，处理事件，直到程序结束。<br /> <br /> &nbsp;&nbsp;&nbsp; 程序大部分的工作都是在事件回圈中运作，包括重画视窗本身，因为自己的视窗可能会被别的视窗遮住，当别的视窗移开时，桌面管理程序就会送一个「要求视窗重画」的事件过来。因此，Xlib 内部的函数中，除了用在应用程序初始化与其他特殊用途以外，其馀几乎都是用在处理事件回圈中。这些函数群大至可分类如下:<br /> &nbsp;&nbsp; 1. 与 X Server 连系、取得 X Server 内部可用资源与相关资讯等。<br /> &nbsp;&nbsp; 2. 视窗的产生、属性设定、与桌面管理程序沟通及发送「提示」等。<br /> &nbsp;&nbsp; 3. 绘图函数群与绘图属性设定。其中绘图属性指的是 Graphics Context (GC)，它是一个大型的资料结构，可用来指定线条粗细、字型与点数、颜色、底图 .... 等等。<br /> &nbsp;&nbsp; 4. 颜色处理与色板 (即可用的颜色数与颜色种类) 设定。<br /> &nbsp;&nbsp; 5. 事件种类与各事件的处理方式，包括取得键盘的输入与滑鼠的动作等。<br /> &nbsp;&nbsp; 6. 程序国际化。在旧版 X11R5 的时候，已开始有程序国际化的□型，但在某些方面还不够完整，直到 X11R6 才接近成熟。这里的程序国际化包括 FontSet 的概念、X Locale 的设定、国际化文字输出 (绘图)、输入 (输入法程序与 XIM 协定)、复合字串 (Compond Text) 的处理 .... 等等。而在 XFree86-4.0.X 系列，还多了一组 Unicode/UTF-8 的处理函数，内容相当丰富。<br /> &nbsp;&nbsp; 7. 各视窗应用程序之间的通讯机制。主要有三种，由简单到复杂依序为「讯息事件」的发送、使用视窗的 property 通讯、以及使用 Selection 机制通讯。越复杂者所能通讯的资料量越大、能处理的资料型态可以越多样、同时也越可靠。<br /> &nbsp;&nbsp; 8. 资源管理与使用者设定。前面我们已说过一个 X Window 的程序可调整的部分相当多，而这些可调的部分可以以一个特别的格式存在特定的「资源档」中，如使用者 HOME 目录下的 .Xdefaults 或 .Xresources 档中。因此，Xlib 提供了一组特别的函数用来取得这些资源档的资料。<br /> &nbsp;&nbsp; 9. 桌面管理程序专用的函数群与相当协定，这些函数赋与程序管理桌面与其他应用程序视窗的能力。</font></p> 
<p> </p> 
<p> </p> 
<p> </p></div></body></html>