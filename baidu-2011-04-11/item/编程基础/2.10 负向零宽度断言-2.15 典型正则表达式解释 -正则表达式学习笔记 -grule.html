<html><head><title>2.10 负向零宽度断言-2.15 典型正则表达式解释 -正则表达式学习笔记 -grule</title></head><body><div id='tit'>2.10 负向零宽度断言-2.15 典型正则表达式解释 -正则表达式学习笔记 -grule</div><div id='cate'>编程基础</div><div id='date'>2008年10月10日 星期五 01:33 P.M.</div><div id='page'>92</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/d63f0c7b84aeaef20bd1873c.html'>http://hi.baidu.com/hxzon/blog/item/d63f0c7b84aeaef20bd1873c.html</a><div id='cnt'><p>2.10 负向零宽度断言-2.15 典型正则表达式解释 -正则表达式学习笔记 -grule</p> 
<p><a href="http://blog.csdn.net/wlzhengzebiaodashi/archive/2008/03/24/2213165.aspx"><font color="#336699">2.10 负向零宽度断言</font></a> <a href="http://blog.csdn.net/wlzhengzebiaodashi/archive/2008/03/24/2213041.aspx">http://blog.csdn.net/wlzhengzebiaodashi/archive/2008/03/24/2213041.aspx</a></p> 
<div>
  零宽度断言只能指定或匹配一个位置。而负向零宽度断言与零宽度断言恰恰相反，它能够指定或匹配不是一个位置，即所说的“反义”。特别是在匹配字符串中不包含指定的字符时，负向零宽度断言特别有用。以下正则表达式中的表达式a(?!b)将断言字符“a”之后不能为字符“b”。
</div> 
<div>
 <font size="2">\b\w*a(?!b)\w*\b<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>（75）</font>
</div> 
<div>
  因此，正则表达式\b\w*a(?!b)\w*\b匹配单词字符串，且该字符串中的字符“a”之后不能为字符“b”。
</div> 
<div>
  表达式(?!experssion)又称为负向零宽度断言或者零宽度负预测先行断言，它断言自身位置的后面不能匹配字符串experssion。以下正则表达式首先匹配长度为3的单词字符串，该字符串之后不能是数字字符串。
</div> 
<div>
 <font size="2">\b\w{3}(?!\d+)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>（76）</font>
</div> 
<div>
  使用工具Regex Tester测试正则表达式（76），结果如图所示。
</div> 
<div> 
</div> 
<div> 
</div> 
<div align="center">
 <font size="2"><img src="image/2.10 负向零宽度断言-2.15 典型.2.10.1.jpg" /><p class="origImg">http://p.blog.csdn.net/images/p_blog_csdn_net/wlzhengzebiaodashi/2.10.1.jpg</p></font>
</div> 
<div>
  表达式(?&lt;!experssion)又称为零宽度负回顾后发断言，它断言自身位置的前面不能匹配字符串experssion。以下正则表达式匹配不能以数字开头的字符串，该字符串只能包括大写字母或小写字母或下划线。
</div> 
<div>
 <font size="2">(?&lt;!\d+)[a-z_A-Z]+<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>（77）</font>
</div> 
<div>
  使用工具Regex Tester测试正则表达式（77），结果如图所示。
</div> 
<div> 
</div> 
<div> 
</div> 
<div align="center">
 <font size="2"><img src="image/2.10 负向零宽度断言-2.15 典型.2.10.2.jpg" /><p class="origImg">http://p.blog.csdn.net/images/p_blog_csdn_net/wlzhengzebiaodashi/2.10.2.jpg</p></font>
</div> 
<div>
 <a href="http://blog.csdn.net/wlzhengzebiaodashi/archive/2008/03/24/2213139.aspx"><font color="#336699">2.11 匹配选项</font></a>
</div> 
<div>
  匹配选项可以指定正则表达式匹配中的行为，如忽略大小写、处理多行、处理单行、从右到左开始执行匹配等。
</div> 
<div>
 注意：本小节中下面介绍的匹配选项为.NET Framework所支持。
</div> 
<div>
  .NET Framework的正则表达式中的常用匹配选项说明如表2-11所示。
</div> 
<div align="center">
 <font size="2">表2-11常用匹配选项</font>
</div> 
<div align="center"> 
 <table border="1" cellspacing="0" cellpadding="0"> 
  <tbody> 
   <tr> 
    <td valign="top" width="139"> 
     <div>
      <font size="2">选项</font>
     </div> </td> 
    <td valign="top" width="67"> 
     <div>
      <font size="2">内联字符</font>
     </div> </td> 
    <td valign="top" width="349"> 
     <div>
      <font size="2">说明</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="139"> 
     <div>
      <font size="2">None</font>
     </div> </td> 
    <td valign="top" width="67"> 
     <div>
      <font size="2">N/A</font>
     </div> </td> 
    <td valign="top" width="349"> 
     <div>
      <font size="2">指定不设置任何选项。</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="139"> 
     <div>
      <font size="2">IgnoreCase</font>
     </div> </td> 
    <td valign="top" width="67"> 
     <div>
      <font size="2">i</font>
     </div> </td> 
    <td valign="top" width="349"> 
     <div>
      <font size="2">指定不区分大小写。</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="139"> 
     <div>
      <font size="2">Multiline</font>
     </div> </td> 
    <td valign="top" width="67"> 
     <div>
      <font size="2">m</font>
     </div> </td> 
    <td valign="top" width="349"> 
     <div>
      <font size="2">指定多行模式，即修改^和$的含义，以使它们分别与任何行的开头和结尾匹配。</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="139"> 
     <div>
      <font size="2">ExplicitCapture</font>
     </div> </td> 
    <td valign="top" width="67"> 
     <div>
      <font size="2">n</font>
     </div> </td> 
    <td valign="top" width="349"> 
     <div>
      <font size="2">指定必须指定分组的名称或组号。</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="139"> 
     <div>
      <font size="2">Compiled</font>
     </div> </td> 
    <td valign="top" width="67"> 
     <div>
      <font size="2">N/A</font>
     </div> </td> 
    <td valign="top" width="349"> 
     <div>
      <font size="2">指定正则表达式将被编译为程序集。</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="139"> 
     <div>
      <font size="2">Singleline</font>
     </div> </td> 
    <td valign="top" width="67"> 
     <div>
      <font size="2">s</font>
     </div> </td> 
    <td valign="top" width="349"> 
     <div>
      <font size="2">指定单行模式。</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="139"> 
     <div>
      <font size="2">IgnorePatternWhitespace</font>
     </div> </td> 
    <td valign="top" width="67"> 
     <div>
      <font size="2">x</font>
     </div> </td> 
    <td valign="top" width="349"> 
     <div>
      <font size="2">指定消除表达式中空白字符，并启用字符(#)后面的注释。</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="139"> 
     <div>
      <font size="2">RightToLeft</font>
     </div> </td> 
    <td valign="top" width="67"> 
     <div>
      <font size="2">N/A</font>
     </div> </td> 
    <td valign="top" width="349"> 
     <div>
      <font size="2">指定匹配是从右向左而不是从左向右进行的。</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="139"> 
     <div>
      <font size="2">ECMAScript</font>
     </div> </td> 
    <td valign="top" width="67"> 
     <div>
      <font size="2">N/A</font>
     </div> </td> 
    <td valign="top" width="349"> 
     <div>
      <font size="2">指定已为表达式启用了符合ECMAScript的行为。</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="139"> 
     <div>
      <font size="2">CultureInvariant</font>
     </div> </td> 
    <td valign="top" width="67"> 
     <div>
      <font size="2">N/A</font>
     </div> </td> 
    <td valign="top" width="349"> 
     <div>
      <font size="2">指定忽略语言中的区域性差异。</font>
     </div> </td> 
   </tr> 
  </tbody> 
 </table> 
</div> 
<div> 
</div> 
<div>
 <a href="http://blog.csdn.net/wlzhengzebiaodashi/archive/2008/03/24/2213135.aspx"><font color="#336699">2.12 注释</font></a>
</div> 
<div>
  正则表达式中除了表达式的基本内容之外，还可以包括注释。其中，注释一般通过表达式(?#注释)是实现。以下正则表达式在第一个分组中中添加了注释“不能以数字开头”。
</div> 
<div>
 <font size="2">(?&lt;!\d+(?#不能以数字开头))[a-z_A-Z]+<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; </span>（78）</font>
</div> 
<div>
 注意：如果要在正则表达式中包含注释，最好打开IgnorePatternWhitespace选项，即忽略模式里的空白字符。因此，此时可以在注释中添加空格、换行符号、制表符号等。一旦启用了该选项，则字符#之后的内容全部被忽略。
</div> 
<div>
  正则表达式(?&lt;!\d+)[a-z_A-Z]+可以写成以下形式：
</div> 
<div>
 <font size="2">(?&lt;!<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # </span>断言要不能匹配该组中的表达式<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>（79）</font>
</div> 
<div>
 <font size="2">\d+<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # </span>长度至少为1的数字字符串</font>
</div> 
<div>
 <font size="2">)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # </span>表达式结束</font>
</div> 
<div>
 <font size="2">[a-z_A-Z]+<span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # </span>只能包括大写字母或小写字母或下划线的长度至少为1的字符串</font>
</div> 
<div>
 <a href="http://blog.csdn.net/wlzhengzebiaodashi/archive/2008/03/24/2213132.aspx"><font color="#336699">2.13 优先级顺序</font></a>
</div> 
<div>
  正则表达式存在元字符、转义符、限定符、|等操作或表达式。在匹配过程中，正则表达式都事先规定了这些操作或表达式的优先级。正则表达式也可以象数学表达式一样来求值。也就是说，正则表达式可以从左至右、并按照一个给定的优先级来求值。表2-12按照从最高优先级到最低优先级列出了正则表达式操作符的优先级顺序。
</div> 
<div align="center">
 <font size="2">表2-12优先级顺序表</font>
</div> 
<div align="center"> 
 <table border="1" cellspacing="0" cellpadding="0"> 
  <tbody> 
   <tr> 
    <td valign="top" width="212"> 
     <div>
      <font size="2">操作符或表达式</font>
     </div> </td> 
    <td valign="top" width="343"> 
     <div>
      <font size="2">说明</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="212"> 
     <div>
      <font size="2">\</font>
     </div> </td> 
    <td valign="top" width="343"> 
     <div>
      <font size="2">转义符</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="212"> 
     <div>
      <font size="2">()、(?:)、(?=)、[]</font>
     </div> </td> 
    <td valign="top" width="343"> 
     <div>
      <font size="2">圆括号和方括号</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="212"> 
     <div>
      <font size="2">*、+、?、{n}、{n,}、{n,m}</font>
     </div> </td> 
    <td valign="top" width="343"> 
     <div>
      <font size="2">限定符</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="212"> 
     <div>
      <font size="2">^、$、\（元字符）</font>
     </div> </td> 
    <td valign="top" width="343"> 
     <div>
      <font size="2">位置和顺序</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="212"> 
     <div>
      <font size="2">|</font>
     </div> </td> 
    <td valign="top" width="343"> 
     <div>
      <font size="2">“或”操作</font>
     </div> </td> 
   </tr> 
  </tbody> 
 </table> 
</div> 
<div>
 <a href="http://blog.csdn.net/wlzhengzebiaodashi/archive/2008/03/24/2213122.aspx"><font color="#336699">2.14 递归匹配</font></a>
</div> 
<div>
 递归匹配在匹配具有嵌套结构的字符串时特别有效。给定算术表达式((1+2)*(3+4))，该表达式具有嵌套结构。如果需要使用正则表达式检查该表达式的结构是否正确，则使用递归匹配能够解决该问题。
</div> 
<div>
 注意：本小节中下面介绍的递归匹配为.NET Framework所支持。
</div> 
<div align="left">
  在.NET Framework中，正则表达式用于递归匹配的表达式说明如表2-13所示。
</div> 
<div align="center">
 <font size="2">表2-13优先级顺序表</font>
</div> 
<div align="center"> 
 <table border="1" cellspacing="0" cellpadding="0"> 
  <tbody> 
   <tr> 
    <td valign="top" width="136"> 
     <div>
      <font size="2">操作符或表达式</font>
     </div> </td> 
    <td valign="top" width="426"> 
     <div>
      <font size="2">说明</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="136"> 
     <div>
      <font size="2">(?&lt;name&gt;expression)</font>
     </div> </td> 
    <td valign="top" width="426"> 
     <div>
      <font size="2">把匹配的内容命名为name，并压入堆栈。</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="136"> 
     <div>
      <font size="2">(?&lt;-name&gt;expression')</font>
     </div> </td> 
    <td valign="top" width="426"> 
     <div>
      <font size="2">从堆栈中弹出最后压入的命名为name的匹配内容。如果堆栈为空，则当前组匹配失败。</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="136"> 
     <div>
      <font size="2">(?(name)yes|no)</font>
     </div> </td> 
    <td valign="top" width="426"> 
     <div>
      <font size="2">如果堆栈上存在命名为name的匹配的内容，则继续匹配yes部分的表达式，否则继续匹配no部分。</font>
     </div> </td> 
   </tr> 
   <tr> 
    <td valign="top" width="136"> 
     <div>
      <font size="2">(?!)</font>
     </div> </td> 
    <td valign="top" width="426"> 
     <div>
      <font size="2">零宽负向先行断言。由于没有后缀表达式，匹配总是失败。</font>
     </div> </td> 
   </tr> 
  </tbody> 
 </table> 
</div> 
<div>
  以下正则表达式能够匹配算术表达式((1+2)*(3+4))。
</div> 
<div>
 <font size="2">\([^()]*(((?&lt;bracket&gt;\()[^()]*)+((?&lt;-bracket&gt;\))[^()]*)+)*(?(bracket)(?!))\) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （80）</font>
</div> 
<div>
  下面是对该正则表达式（80）进行详细分析。
</div> 
<div>
 <font size="2">\(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 匹配最外层的左括号；</font>
</div> 
<div>
 <font size="2">&nbsp;&nbsp;&nbsp; [^()]*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 匹配最外层左括号后面的、不是括号“()”的内容；</font>
</div> 
<div>
 <font size="2">&nbsp;&nbsp;&nbsp; (</font>
</div> 
<div>
 <font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (</font>
</div> 
<div>
 <font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (?&lt;bracket&gt;\() &nbsp;&nbsp;&nbsp;&nbsp; # 如果匹配到左括号，则命名为bracket，并压入堆栈；</font>
</div> 
<div>
 <font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [^()]*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 匹配当前左括号后面的、不是括号“()”的内容；</font>
</div> 
<div>
 <font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )+</font>
</div> 
<div>
 <font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (</font>
</div> 
<div>
 <font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (?&lt;-bracket&gt;\()&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 如果匹配到右括号，则弹出命名为bracket的内容；</font>
</div> 
<div>
 <font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [^()]*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 匹配右括号后面不是括号的内容</font>
</div> 
<div>
 <font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )+</font>
</div> 
<div>
 <font size="2">&nbsp;&nbsp;&nbsp; )*</font>
</div> 
<div>
 <font size="2">&nbsp;&nbsp;&nbsp; (?(bracket)(?!))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; #如果匹配到最外层的右括号前面，则检查堆栈内容是否为空。如果不为空，则匹配失败。</font>
</div> 
<div>
 <font size="2">\)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #匹配最外层的右括号</font>
</div> 
<div>
  使用工具Regex Tester测试正则表达式（80），结果如图所示。
</div> 
<div align="center">
 <font size="2"><img src="image/2.10 负向零宽度断言-2.15 典型.2.14.jpg" /><p class="origImg">http://p.blog.csdn.net/images/p_blog_csdn_net/wlzhengzebiaodashi/2.14.jpg</p></font>
</div> 
<div>
 <a href="http://blog.csdn.net/wlzhengzebiaodashi/archive/2008/03/24/2213094.aspx"><font color="#336699">2.15 典型正则表达式解释（1）</font></a>
</div> 
<div>
  本小节解释基于正则表达式的基础理论的典型正则表达式，如匹配Windows操作系统的名称、匹配HTML标记、匹配HTML标记之间的内容。
</div> 
<div>
 <strong> 1．匹配Windows操作系统的名称</strong>
</div> 
<div>
  Windows操作系统存在很多版本，如Windows 95、Windows 98、Windows 2000、Windows ME、Windows XP、Windows 2003等。以下正则表达式能够精确匹配Windows操作系统的名称。
</div> 
<div>
 <font size="2">Windows\s*((95)|(98)|(2000)|(2003)|(ME)|(XP))<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>（81）</font>
</div> 
<div>
  上述表达式能够精确匹配Windows 95、Windows 98、Windows 2000、Windows ME、Windows XP、Windows 2003等操作系统的名称。然而，精确匹配Windows操作系统的名称的正则表达式比较冗长。以下 正则表达式能够简单匹配Windows操作系统的名称。
</div> 
<div>
 <font size="2">Windows\s\w+<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>（82）</font>
</div> 
<div>
 <strong> 2．匹配HTML标记</strong>
</div> 
<div>
  HTML标记一般被尖括号包围，如&lt;a&gt;、&lt;table&gt;、&lt;br&gt;、&lt;input&gt;等。以下正则表达式能够匹配HTML标记。
</div> 
<div>
 <font size="2">&lt;[a-zA-Z][^&gt;]*&gt;<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>（83）</font>
</div> 
<div>
  正则表达式（83）解释：
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>&lt;匹配HTML标记的左尖括号。
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>字符类[a-zA-Z]可以匹配一个英文字母，它匹配HTML标记中第一个字符（除去左尖括号）。
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>字符类[^&gt;]可以匹配除右尖括号的之外的任何字符。
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>[^&gt;]*可以匹配空字符串，或者由除右尖括号的之外的任何字符组成的字符串。
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>&gt;匹配HTML标记的右尖括号。
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>[a-zA-Z][^&gt;]*匹配HTML标记的名称。
</div> 
<div>
  使用工具Regex Tester测试正则表达式（83），结果如图所示。
</div> 
<div> 
</div> 
<div> 
</div> 
<div align="center">
 <font size="2"><img src="image/2.10 负向零宽度断言-2.15 典型.2.15.jpg" /><p class="origImg">http://p.blog.csdn.net/images/p_blog_csdn_net/wlzhengzebiaodashi/2.15.jpg</p></font>
</div> 
<div>
 <a href="http://blog.csdn.net/wlzhengzebiaodashi/archive/2008/03/24/2213041.aspx"><font color="#336699">2.15 典型正则表达式解释（2）</font></a>
</div> 
<div>
 <strong> 3．匹配HTML标记之间的内容</strong>
</div> 
<div>
  HTML标记一般被尖括号包围，如&lt;a&gt;、&lt;table&gt;、&lt;br&gt;、&lt;input&gt;等。以下正则表达式能够匹配HTML标记。
</div> 
<div>
 <font size="2">(?&lt;=&lt;(?&lt;tag&gt;\w+)&gt;).*(?=&lt;\/\k&lt;tag&gt;&gt;)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>（84）</font>
</div> 
<div>
  正则表达式（84）解释：
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>(?&lt;tag&gt;\w+)是一个分组，它的名称为“tag”。在该正则表表达式匹配过程，它将保存被匹配的内容。
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>&lt;(?&lt;tag&gt;\w+)&gt;匹配HTML标记的开头标记，如&lt;a&gt;、&lt;table&gt;等。
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>(?&lt;=&lt;(?&lt;tag&gt;\w+)&gt;)是一个零宽度正回顾后发断言，它断言自身位置的前面能够匹配&lt;(?&lt;tag&gt;\w+)&gt;所匹配的内容。在此，该表达式断言被匹配的字符串的开头部分是HTML标记的开头标记。
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>\k&lt;tag&gt;后向引用名称为“tag”的分组，即被匹配到的HTML标记的名称。
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>\/匹配字符/。
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>&lt;\/\k&lt;tag&gt;&gt;匹配HTML标记的结尾标记，如&lt;/a&gt;、&lt;/table&gt;等。
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>(?=&lt;\/\k&lt;tag&gt;&gt;)是一个零宽度正预测先行断言。在此，该表达式断言被匹配的字符串的结尾部分是HTML标记的结尾标记。
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>.*匹配HTML标记之间的任何字符。
</div> 
<div>
  使用工具Regex Tester测试正则表达式（84），结果如图所示。
</div> 
<div> 
</div> 
<div> 
</div> 
<div forimg="1" align="center">
 <img src="image/2.10 负向零宽度断言-2.15 典型.2.15.1.jpg" />
 <p class="origImg">http://p.blog.csdn.net/images/p_blog_csdn_net/wlzhengzebiaodashi/2.15.1.jpg</p>
</div> 
<div>
 <strong> 4．匹配CSV文件内容</strong>
</div> 
<div>
  CSV文件是非常特殊的一种文件，它的内容满足以下4个条件：
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>数据被逗号（,）分割。在此，设被分割后的数据称为单个数据。
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>单个数据的长度不能为0。
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>如果某单个数据中包含逗号（,），那么该单个内容被双引号（&quot;）包围。
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>如果单个数据中包含双引号（&quot;），则用两个双引号表示一个双引号。
</div> 
<div>
  如下内容就是某个CSV文件的一部分。
</div> 
<div>
 <font size="2">aaa,bbb,ccc,ddd,&quot;ab,de&quot;,eee,fff,ggg,&quot;this is &quot;&quot;aa&quot;,hhhf</font>
</div> 
<div>
  以下正则表达式能够匹配不包含逗号（,）或者双引号（&quot;）的单个数据。
</div> 
<div>
 <font size="2">[^&quot;,]+<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; </span>（85）</font>
</div> 
<div>
  如果单个数据包含逗号（,）或者双引号（&quot;）时，那么该单个数据被双引号（&quot;）包围。因此，匹配该类型单个数据的正则表达式形式如下：
</div> 
<div>
 <font size="2">&quot;[匹配单个数据内容的正则表达式]&quot;<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; </span>（86）</font>
</div> 
<div>
  该类型单个数据要么是两个连续双引号（&quot;&quot;），要么是除单个双引号（&quot;&quot;）的任意字符。因此，以下正则表达式能够匹配包含逗号（,）或者双引号（&quot;）的单个数据。
</div> 
<div>
 <font size="2">&quot;(?:([^&quot;]|&quot;&quot;))+&quot;<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </span>（87）</font>
</div> 
<div>
  综合上述，以下正则表达式能够匹配CSV文件中的单个数据。
</div> 
<div>
 <font size="2">[^&quot;,]+|(&quot;(?:([^&quot;]|&quot;&quot;))+&quot;)<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </span>（90）</font>
</div> 
<div>
  以下正则表达式能够匹配CSV文件的内容。
</div> 
<div>
 <font size="2">([^&quot;,]+|(&quot;(?:([^&quot;]|&quot;&quot;))+&quot;))(\s*,\s*([^&quot;,]+|(&quot;(?:([^&quot;]|&quot;&quot;))+&quot;)))* （91）</font>
</div> 
<div>
  正则表达式（91）解释：
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>[^&quot;,]+|(&quot;(?:([^&quot;]|&quot;&quot;))+&quot;)匹配CSV文件中的单个数据。
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp; </span></span>\s*匹配逗号（,）两边的空白字符。
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>\s*,\s*([^&quot;,]+|(&quot;(?:([^&quot;]|&quot;&quot;))+&quot;))匹配“逗号（,）＋单个数据”组成的字符串，并且还包含逗号（,）两边的空白字符。
</div> 
<div>
 <span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>(\s*,\s*([^&quot;,]+|(&quot;(?:([^&quot;]|&quot;&quot;))+&quot;)))*匹配0个或多个“逗号（,）＋单个数据”组成的字符串。同样，也包含逗号（,）两边的空白字符。
</div> 
<div>
  使用工具Regex Tester测试正则表达式（91），结果如图所示。
</div> 
<div> 
</div> 
<div> 
</div> 
<div align="center">
 <font size="2"><img src="image/2.10 负向零宽度断言-2.15 典型.2.15.2.jpg" /><p class="origImg">http://p.blog.csdn.net/images/p_blog_csdn_net/wlzhengzebiaodashi/2.15.2.jpg</p></font>
</div></div></body></html>