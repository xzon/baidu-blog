<html><head><title>UML 2.0和统一过程（原书第2版）-hxzon爱读书</title></head><body><div id='tit'>UML 2.0和统一过程（原书第2版）-hxzon爱读书</div><div id='cate'>编程基础</div><div id='date'>2008年03月30日 星期日 10:28 P.M.</div><div id='page'>146</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/5ca0364e216a79ced0c86a40.html'>http://hi.baidu.com/hxzon/blog/item/5ca0364e216a79ced0c86a40.html</a><div id='cnt'><div>
 UML 2.0和统一过程（原书第2版）-爱读书
</div> 
<div> 
</div> 
<div>
 •目录
</div> 
<div> 
</div> 
<div>
 <br /> 译者序.
 <br /> 前言
 <br /> 第一部分UML和UP介绍
 <br /> 第1章 什么是UML1
 <br /> 1.1 章节指示图1
 <br /> 1.2 什么是UML3
 <br /> 1.3 UML的诞生3
 <br /> 1.4 MDA—UML的未来4
 <br /> 1.5 为什么“统一”6
 <br /> 1.6 对象和UML6
 <br /> 1.7 UML结构6
 <br /> 1.8 UML构造块7
 <br /> 1.8.1 物件7
 <br /> 1.8.2 关系7
 <br /> 1.8.3 图8
 <br /> 1.9 UML公共机9
 <br /> 1.9.1 规格说明10
 <br /> 1.9.2 修饰10
 <br /> 1.9.3 公共分类11
 <br /> 1.9.4 扩展机制12
 <br /> 1.10 构架14
 <br /> 1.11 小结15
 <br /> 第2章 什么是统一过程17
 <br /> 2.1 章节指示图17
 <br /> 2.2 什么是UP18
 <br /> 2.3 UP的诞生18
 <br /> 2.4 UP和RUP20
 <br /> 2.5 为项目定制UP21
 <br /> 2.6 UP公理21
 <br /> 2.7 UP是迭代和增量过程22
 <br /> 2.7.1 迭代工作流22
 <br /> 2.7.2 基线和增量23
 <br /> 2.8 UP结构23
 <br /> 2.9 UP阶段25
 <br /> 2.9.1 初始—目标25
 <br /> 2.9.2 初始—焦点25
 <br /> 2.9.3 初始—里程碑：生命期目标25
 <br /> 2.9.4 细化—目标25
 <br /> 2.9.5 细化—焦点26
 <br /> 2.9.6 细化—里程碑：生命期构架26
 <br /> 2.9.7 构造—目标26
 <br /> 2.9.8 构造—焦点26
 <br /> 2.9.9 构造—里程碑：初始运作功能27
 <br /> 2.9.10 移交—目标27
 <br /> 2.9.11 移交—焦点27
 <br /> 2.9.12 移交—里程碑：产品发布28
 <br /> 2.10 小结28
 <br /> 第二部分需求
 <br /> 第3章 需求工作流29
 <br /> 3.1 章节指示图29
 <br /> 3.2 需求工作流31
 <br /> 3.3 软件需求—元模型31
 <br /> 3.4 需求工作流细节32
 <br /> 3.5 需求的重要性34
 <br /> 3.6 定义需求34
 <br /> 3.6.1 需求模型34
 <br /> 3.6.2 形式良好的需求34
 <br /> 3.6.3 功能性和非功能性需求35
 <br /> 3.6.4 组织需求35
 <br /> 3.6.5 需求属性36
 <br /> 3.7 找出需求37
 <br /> 3.7.1 需求抽取37
 <br /> 3.7.2 访谈38
 <br /> 3.7.3 问卷调查39
 <br /> 3.7.4 需求会议39
 <br /> 3.8 小结39
 <br /> 第4章 用例建模41
 <br /> 4.1 章节指示图41
 <br /> 4.2 用例建模43
 <br /> 4.3 UP活动：找出参与者和用例43
 <br /> 4.3.1 主体（系统边界）44
 <br /> 4.3.2 什么是参与者44
 <br /> 4.3.3 什么是用例45
 <br /> 4.3.4 项目词汇表47
 <br /> 4.4 UP活动：细化用例48
 <br /> 4.5 用例规格说明48
 <br /> 4.5.1 用例名称49
 <br /> 4.5.2 用例ID50
 <br /> 4.5.3 简要描述50
 <br /> 4.5.4 参与者50
 <br /> 4.5.5 前置条件和后置条件50
 <br /> 4.5.6 主流50
 <br /> 4.5.7 建模附流54
 <br /> 4.6 需求跟踪57
 <br /> 4.7 何时适用用例建模57
 <br /> 4.8 小结58
 <br /> 第5章 高级用例建模60
 <br /> 5.1 章节指示图60
 <br /> 5.2 参与者泛化61
 <br /> 5.3 用例泛化62
 <br /> 5.4 莍nclude?65
 <br /> 5.5 莈xtend?67
 <br /> 5.5.1 扩展用例68
 <br /> 5.5.2 多重插入片段69
 <br /> 5.5.3 条件扩展70
 <br /> 5.6 何时使用高级特征70
 <br /> 5.7 书写用例的技巧71
 <br /> 5.7.1 保持用例简短71
 <br /> 5.7.2 关注“什么”,而不是“如何”71
 <br /> 5.7.3 避免功能分解72
 <br /> 5.8 小结73
 <br /> 第三部分分析
 <br /> 第6章 分析工作流75
 <br /> 6.1 章节指示图75
 <br /> 6.2 分析工作流75
 <br /> 6.3 分析制品—元模型76
 <br /> 6.4 分析工作流细节77
 <br /> 6.5 分析模型—经验法则77
 <br /> 6.6 小结78第7章 对象和类80
 <br /> 7.1 章节指示图80
 <br /> 7.2 什么是对象82
 <br /> 7.2.1 封装83
 <br /> 7.2.2 消息机制84
 <br /> 7.3 UML韵蠓 ?84
 <br /> 7.3.1 对象属性值85
 <br /> 7.4 什么是类85
 <br /> 7.4.1 类和对象86
 <br /> 7.4.2 对象实例化87
 <br /> 7.5 UML类符号87
 <br /> 7.5.1 名称分栏88
 <br /> 7.5.2 属性分栏89
 <br /> 7.5.3 操作分栏91
 <br /> 7.5.4 类构造型语法94
 <br /> 7.6 范围94
 <br /> 7.6.1 实例范围和类范围95
 <br /> 7.6.2 范围决定访问95
 <br /> 7.7 对象构造和销毁95
 <br /> 7.7.1 构造函数—示例ClubMember类96
 <br /> 7.7.2 析构函数—示例ClubMember类97
 <br /> 7.8 小结97
 <br /> 第8章 找出分析类100
 <br /> 8.1 章节指示图100
 <br /> 8.2 UP活动：分析用例102
 <br /> 8.3 什么是分析类102
 <br /> 8.3.1 分析类剖析103
 <br /> 8.3.2 如何产生良好的分析类104
 <br /> 8.3.3 分析类经验法则105
 <br /> 8.4 找出类105
 <br /> 8.4.1 使用名词／动词分析找出类106
 <br /> 8.4.2 使用CRC分析找出类107
 <br /> 8.4.3 采用RUP构造型找出类108
 <br /> 8.4.4 从其他来源找出类109
 <br /> 8.5 产生初步分析模型110
 <br /> 8.6 小结111
 <br /> 第9章 关系113
 <br /> 9.1 章节指示图113
 <br /> 9.2 什么是关系115
 <br /> 9.3 什么是链接115
 <br /> 9.3.1 对象图115
 <br /> 9.3.2 路径116
 <br /> 9.4 什么是关联117
 <br /> 9.4.1 关联语法117
 <br /> 9.4.2 多重性118
 <br /> 9.4.3 导航性121
 <br /> 9.4.4 关联和属性122
 <br /> 9.4.5 关联类124
 <br /> 9.4.6 受限关联125
 <br /> 9.5 什么是依赖125
 <br /> 9.5.1 使用依赖126
 <br /> 9.5.2 抽象依赖127
 <br /> 9.5.3 授权依赖128
 <br /> 9.6 小结129
 <br /> 第10章 继承和多态132
 <br /> 10.1 章节指示图132
 <br /> 10.2 泛化133
 <br /> 10.2.1 类泛化133
 <br /> 10.3 类继承133
 <br /> 10.3.1 覆写134
 <br /> 10.3.2 抽象操作和类135
 <br /> 10.3.3 抽象层次135
 <br /> 10.3.4 多重继承136
 <br /> 10.4 多态136
 <br /> 10.4.1 多态示例136
 <br /> 10.5 高级泛化138
 <br /> 10.5.1 泛化集合138
 <br /> 10.5.2 强类型139
 <br /> 10.6 小结141
 <br /> 第11章 分析包143
 <br /> 11.1 章节指示图143
 <br /> 11.2 什么是包143
 <br /> 11.3 包和命名空间145
 <br /> 11.4 嵌套包145
 <br /> 11.5 包依赖146
 <br /> 11.5.1 传递性147
 <br /> 11.6 包泛化147
 <br /> 11.7 构架分析148
 <br /> 11.7.1 找出分析包149
 <br /> 11.7.2 循环包依赖149
 <br /> 11.8 小结150
 <br /> 第12章 用例实现153
 <br /> 12.1 章节指示图153
 <br /> 12.2 UP活动：分析用例155
 <br /> 12.3 什么是用例实现156
 <br /> 12.4 用例实现—元素156
 <br /> 12.5 交互157
 <br /> 12.6 生命线157
 <br /> 12.7 消息157
 <br /> 12.7.1 同步.异步和返回消息158
 <br /> 12.7.2 创建和销毁消息159
 <br /> 12.7.3 发现和丢失消息159
 <br /> 12.8 交互图159
 <br /> 12.9 顺序图160
 <br /> 12.9.1 生命线和消息160
 <br /> 12.9.2 激活162
 <br /> 12.9.3 注释顺序图163
 <br /> 12.9.4 状态常量和约束163
 <br /> 12.10 组合区和操作符164
 <br /> 12.10.1 采用opt和alt分支166
 <br /> 12.10.2 采用loop和break迭代168..
 <br /> 12.11 通信图170
 <br /> 12.11.1 迭代171
 <br /> 12.11.2 分支172
 <br /> 12.12 小结173
 <br /> 第13章 高级用例实现176
 <br /> 13.1 章节指示图176
 <br /> 13.2 交互重现176
 <br /> 13.2.1 参数178
 <br /> 13.2.2 门179
 <br /> 13.3 接续181
 <br /> 13.4 小结182
 <br /> 第14章 活动图183
 <br /> 14.1 章节指示图183
 <br /> 14.2 什么是活动图183
 <br /> 14.3 活动图与UP184
 <br /> 14.4 活动185
 <br /> 14.5 活动的语义186
 <br /> 14.6 活动分区188
 <br /> 14.7 动作节点189
 <br /> 14.7.1 调用动作节点190
 <br /> 14.7.2 接受时间事件的动作节点191
 <br /> 14.8 控制节点192
 <br /> 14.8.1 初始节点和终止节点192
 <br /> 14.8.2 判决节点和汇合节点192
 <br /> 14.8.3 派生节点和会聚节点—并发193
 <br /> 14.9 对象节点194
 <br /> 14.9.1 对象节点缓冲区的语义194
 <br /> 14.9.2 用状态展示对象195
 <br /> 14.9.3 活动参数195
 <br /> 14.10 别针197
 <br /> 14.11 小结197
 <br /> 第15章 高级活动图200
 <br /> 15.1 章节指示图200
 <br /> 15.2 连接器202
 <br /> 15.3 可中断活动区202
 <br /> 15.4 异常处理202
 <br /> 15.5 扩展节点203
 <br /> 15.6 发送信号和接受事件204
 <br /> 15.7 流化206
 <br /> 15.8 高级对象流特性206
 <br /> 15.8.1 输入和输出效果206
 <br /> 15.8.2 莝election?207
 <br /> 15.8.3 莟ransformation?207
 <br /> 15.9 广播和广收207
 <br /> 15.10 参数集合208
 <br /> 15.11 莄entralBuffer冉诘?209
 <br /> 15.12 交互概图210
 <br /> 15.13 小结211
 <br /> 第四部分设计
 <br /> 第16章 设计工作流213
 <br /> 16.1 章节指示图213
 <br /> 16.2 设计工作流213
 <br /> 16.3 设计制品—元模型214
 <br /> 16.3.1 制品跟踪关系215
 <br /> 16.3.2 需要维护两个模型吗216
 <br /> 16.4 设计工作流细节217
 <br /> 16.5 UP活动：构架设计218
 <br /> 16.6 小结218
 <br /> 第17章 设计类220
 <br /> 17.1 章节指示图220
 <br /> 17.2 UP活动：类设计221
 <br /> 17.3 什么是设计类222
 <br /> 17.4 设计类剖析223
 <br /> 17.5 形式良好的设计类223
 <br /> 17.5.1 完整性和充分性224
 <br /> 17.5.2 原始性224
 <br /> 17.5.3 高内聚225
 <br /> 17.5.4 低耦合225
 <br /> 17.6 继承226
 <br /> 17.6.1 聚合与继承226
 <br /> 17.6.2 多重继承227
 <br /> 17.6.3 继承与接口实现227
 <br /> 17.7 模板类228
 <br /> 17.8 嵌套类229
 <br /> 17.9 小结230
 <br /> 第18章 精化分析关系233
 <br /> 18.1 章节指示图233
 <br /> 18.2 设计关系235
 <br /> 18.3 聚合和组合235
 <br /> 18.4 聚合语义236
 <br /> 18.5 组合语义237
 <br /> 18.5.1 组合与属性238
 <br /> 18.6 如何精化分析关系238
 <br /> 18.7 一对一关联239
 <br /> 18.8 多对一关联239
 <br /> 18.9 一对多关联240
 <br /> 18.10 列集240
 <br /> 18.10.1 映射表240
 <br /> 18.11 具体化关系242
 <br /> 18.11.1 多对多关联242
 <br /> 18.11.2 双向关联243
 <br /> 18.11.3 关联类244
 <br /> 18.12 结构化类的组合244
 <br /> 18.12.1 结构化类元244
 <br /> 18.12.2 结构化类245
 <br /> 18.13 小结247
 <br /> 第19章 接口和组件252
 <br /> 19.1 章节指示图252
 <br /> 19.2 UP活动：子系统设计254
 <br /> 19.3 什么是接口254
 <br /> 19.4 已供接口和必需接口255
 <br /> 19.5 接口实现与继承257
 <br /> 19.6 端口260
 <br /> 19.7 接口和基于组件的开发261
 <br /> 19.8 什么是组件261
 <br /> 19.9 组件构造型262
 <br /> 19.10 子系统262
 <br /> 19.11 发现接口263
 <br /> 19.12 采用接口进行设计263
 <br /> 19.12.1 外观模式264
 <br /> 19.12.2 物理构架和分层模式264
 <br /> 19.13 接口的优点和缺点265
 <br /> 19.14 小结266
 <br /> 第20章 用例实现（设计）269
 <br /> 20.1 章节指示图269
 <br /> 20.2 UP活动：用例设计271
 <br /> 20.3 用例实现（设计）272
 <br /> 20.4 交互图（设计）272
 <br /> 20.5 建模并发274
 <br /> 20.5.1 活动类274
 <br /> 20.5.2 顺序图中的并发276
 <br /> 20.5.3 通信图中的并发278
 <br /> 20.6 子系统交互279
 <br /> 20.7 时序图279
 <br /> 20.8 用例实现（设计）示例282
 <br /> 20.9 小结284
 <br /> 第21章 状态机288
 <br /> 21.1 章节指示图288
 <br /> 21.2 状态机290
 <br /> 21.2.1 行为状态机和协议状态机290
 <br /> 21.2.2 状态机与类291
 <br /> 21.3 状态机和UP291
 <br /> 21.4 状态图291
 <br /> 21.5 状态292
 <br /> 21.5.1 状态语法293
 <br /> 21.6 迁移293
 <br /> 21.6.1 连接迁移—交叉伪状态294
 <br /> 21.6.2 分支迁移—选择伪状态295
 <br /> 21.7 事件296
 <br /> 21.7.1 调用事件296
 <br /> 21.7.2 信号事件297
 <br /> 21.7.3 改变事件298
 <br /> 21.7.4 时间事件299
 <br /> 21.8 小结299
 <br /> 第22章 高级状态机301
 <br /> 22.1 章节指示图301
 <br /> 22.2 复合状态301
 <br /> 22.2.1 简单复合状态302
 <br /> 22.2.2 正交复合状态304
 <br /> 22.3 子状态机状态306
 <br /> 22.4 子状态机通信307
 <br /> 22.5 历史308
 <br /> 22.5.1 浅度历史308
 <br /> 22.5.2 深度历史309
 <br /> 22.6 小结310
 <br /> 第五部分实现
 <br /> 第23章 实现工作流311
 <br /> 23.1 章节指示图311
 <br /> 23.2 实现工作流311
 <br /> 23.3 实现制品—元模型312
 <br /> 23.4 实现工作流细节313
 <br /> 23.5 制品314
 <br /> 23.6 小结314
 <br /> 第24章 部署315
 <br /> 24.1 章节指示图315
 <br /> 24.2 UP活动：构架实现315
 <br /> 24.3 部署图316
 <br /> 24.4 节点317
 <br /> 24.5 制品318
 <br /> 24.6 部署321
 <br /> 24.7 小结322
 <br /> 第六部分补充材料
 <br /> 第25章 OCL介绍325
 <br /> 25.1 章节指示图325
 <br /> 25.2 什么是OCL327
 <br /> 25.3 为什么采用OCL327
 <br /> 25.4 OCL表达式语法327
 <br /> 25.5 包语境和路径名329
 <br /> 25.6 表达式语境329
 <br /> 25.7 OCL表达式类型330
 <br /> 25.8 表达式主体331
 <br /> 25.8.1 注释.关键字和优先级规则331
 <br /> 25.8.2 OCL类型系统332
 <br /> 25.8.3 原始类型333
 <br /> 25.8.4 Tuple335
 <br /> 25.8.5 中缀操作符335
 <br /> 25.8.6 OCL列集335
 <br /> 25.8.7 迭代操作340
 <br /> 25.9 OCL导航343
 <br /> 25.9.1 语境实例内导航343
 <br /> 25.9.2 通过关联导航343
 <br /> 25.9.3 通过多重关联导航345
 <br /> 25.10 OCL表达式类型细节346
 <br /> 25.10.1 inv：346
 <br /> 25.10.2 pre:.post:和@pre347
 <br /> 25.10.3 body：348
 <br /> 25.10.4 init：349
 <br /> 25.10.5 def：349
 <br /> 25.10.6 let表达式350
 <br /> 25.10.7 derive：351
 <br /> 25.11 其他图中的OCL352
 <br /> 25.11.1 交互图中的OCL352
 <br /> 25.11.2 活动图中的OCL354
 <br /> 25.11.3 状态图中的OCL354
 <br /> 25.12 高级主题356
 <br /> 25.12.1 关联类的双向导航356
 <br /> 25.12.2 通过受限关联导航357
 <br /> 25.12.3 继承的关联357
 <br /> 25.12.4 OCL消息359
 <br /> 25.13 小结360
 <br /> 附录1 用例模型举例365
 <br /> 附录2 XML和用例370
 <br /> 参考书目376
 <br /> 索引378...
</div> 
<div> 
</div> 
<div> 
</div></div></body></html>