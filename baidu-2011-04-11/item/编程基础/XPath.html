<html><head><title>XPath</title></head><body><div id='tit'>XPath</div><div id='cate'>编程基础</div><div id='date'>2009年07月30日 星期四 10:40 P.M.</div><div id='page'>40</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/82fe0f238961d1479258078d.html'>http://hi.baidu.com/hxzon/blog/item/82fe0f238961d1479258078d.html</a><div id='cnt'><p>XPath</p> 
<div> 
 <h2>选取节点</h2> 
 <p>XPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。</p> 
 <h3>下面列出了最有用的路径表达式：</h3> 
 <table class="dataintable FCK__ShowTableBorders"> 
  <tbody> 
   <tr> 
    <th>表达式</th> 
    <th>描述</th> 
   </tr> 
   <tr> 
    <td>nodename</td> 
    <td>选取此节点的所有子节点</td> 
   </tr> 
   <tr> 
    <td>/</td> 
    <td>从根节点选取</td> 
   </tr> 
   <tr> 
    <td>//</td> 
    <td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置</td> 
   </tr> 
   <tr> 
    <td>.</td> 
    <td>选取当前节点</td> 
   </tr> 
   <tr> 
    <td>..</td> 
    <td>选取当前节点的父节点</td> 
   </tr> 
   <tr> 
    <td>@</td> 
    <td>选取属性</td> 
   </tr> 
  </tbody> 
 </table> 
 <h3>实例</h3> 
 <p>在下面的表格中，我们已列出了一些路径表达式以及表达式的结果：</p> 
 <table class="dataintable FCK__ShowTableBorders"> 
  <tbody> 
   <tr> 
    <th>路径表达式</th> 
    <th>结果</th> 
   </tr> 
   <tr> 
    <td>bookstore</td> 
    <td>选取 bookstore 元素的所有子节点</td> 
   </tr> 
   <tr> 
    <td>/bookstore</td> 
    <td> <p>选取根元素 bookstore</p> <p>注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</p> </td> 
   </tr> 
   <tr> 
    <td>bookstore/book</td> 
    <td>选取所有属于 bookstore 的子元素的 book 元素。</td> 
   </tr> 
   <tr> 
    <td>//book</td> 
    <td>选取所有 book 子元素，而不管它们在文档中的位置。</td> 
   </tr> 
   <tr> 
    <td>bookstore//book</td> 
    <td>选择所有属于 bookstore 元素的后代的 book 元素，而不管它们位于 bookstore 之下的什么位置。</td> 
   </tr> 
   <tr> 
    <td>//@lang</td> 
    <td>选取所有名为 lang 的属性。</td> 
   </tr> 
  </tbody> 
 </table> 
</div> 
<div> 
 <h2>谓语（Predicates）</h2> 
 <p>谓语用来查找某个特定的节点或者包含某个指定的值的节点。</p> 
 <p>谓语被嵌在方括号中。</p> 
 <h3>实例</h3> 
 <p>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：</p> 
 <table class="dataintable FCK__ShowTableBorders"> 
  <tbody> 
   <tr> 
    <th>路径表达式</th> 
    <th>结果</th> 
   </tr> 
   <tr> 
    <td>/bookstore/book[1]</td> 
    <td>选取属于 bookstore 子元素的第一个 book 元素。</td> 
   </tr> 
   <tr> 
    <td>/bookstore/book[last()]</td> 
    <td>选取属于 bookstore 子元素的最后一个 book 元素。</td> 
   </tr> 
   <tr> 
    <td>/bookstore/book[last()-1]</td> 
    <td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td> 
   </tr> 
   <tr> 
    <td>/bookstore/book[position()&lt;3]</td> 
    <td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td> 
   </tr> 
   <tr> 
    <td>//title[@lang]</td> 
    <td>选取所有拥有名为 lang 的属性的 title 元素。</td> 
   </tr> 
   <tr> 
    <td>//title[@lang='eng']</td> 
    <td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td> 
   </tr> 
   <tr> 
    <td>/bookstore/book[price&gt;35.00]</td> 
    <td>选取所有 bookstore 元素的 book 元素，且其中的 price 元素的值须大于 35.00。</td> 
   </tr> 
   <tr> 
    <td>/bookstore/book[price&gt;35.00]/title</td> 
    <td>选取所有 bookstore 元素中的 book 元素的 title 元素，且其中的 price 元素的值须大于 35.00。</td> 
   </tr> 
  </tbody> 
 </table> 
</div> 
<div> 
 <h2>选取未知节点</h2> 
 <p>XPath 通配符可用来选取未知的 XML 元素。</p> 
 <table class="dataintable FCK__ShowTableBorders"> 
  <tbody> 
   <tr> 
    <th>通配符</th> 
    <th>描述</th> 
   </tr> 
   <tr> 
    <td>*</td> 
    <td>匹配任何元素节点</td> 
   </tr> 
   <tr> 
    <td>@*</td> 
    <td>匹配任何属性节点</td> 
   </tr> 
   <tr> 
    <td>node()</td> 
    <td>匹配任何类型的节点</td> 
   </tr> 
  </tbody> 
 </table> 
 <h3>实例</h3> 
 <p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p> 
 <table class="dataintable FCK__ShowTableBorders"> 
  <tbody> 
   <tr> 
    <th>路径表达式</th> 
    <th>结果</th> 
   </tr> 
   <tr> 
    <td>/bookstore/*</td> 
    <td>选取 bookstore 元素的所有子节点</td> 
   </tr> 
   <tr> 
    <td>//*</td> 
    <td>选取文档中的所有元素</td> 
   </tr> 
   <tr> 
    <td>//title[@*]</td> 
    <td>选取所有带有属性的 title 元素。</td> 
   </tr> 
  </tbody> 
 </table> 
</div> 
<div> 
 <h2>选取若干路径</h2> 
 <p>通过在路径表达式中使用“|”运算符，您可以选取若干个路径。</p> 
 <h3>实例</h3> 
 <p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p> 
 <table class="dataintable FCK__ShowTableBorders"> 
  <tbody> 
   <tr> 
    <th>路径表达式</th> 
    <th>结果</th> 
   </tr> 
   <tr> 
    <td>//book/title | //book/price</td> 
    <td>选取所有 book 元素的 title 和 price 元素。</td> 
   </tr> 
   <tr> 
    <td>//title | //price</td> 
    <td>选取所有文档中的 title 和 price 元素。</td> 
   </tr> 
   <tr> 
    <td>/bookstore/book/title | //price</td> 
    <td>选取所有属于 bookstore 元素的 book 元素的 title 元素，以及文档中所有的 price 元素。</td> 
   </tr> 
  </tbody> 
 </table> 
</div> 
<p>==================================</p> 
<div> 
 <h2>XPath 轴</h2> 
 <p>轴可定义某个相对于当前节点的节点集。</p> 
 <table class="dataintable FCK__ShowTableBorders"> 
  <tbody> 
   <tr> 
    <th>轴名称</th> 
    <th>结果</th> 
   </tr> 
   <tr> 
    <td>ancestor</td> 
    <td>选取当前节点的所有先辈（父、祖父等）</td> 
   </tr> 
   <tr> 
    <td>ancestor-or-self</td> 
    <td>选取当前节点的所有先辈（父、祖父等）以及当前节点本身</td> 
   </tr> 
   <tr> 
    <td>attribute</td> 
    <td>选取当前节点的所有属性</td> 
   </tr> 
   <tr> 
    <td>child</td> 
    <td>选取当前节点的所有子元素。</td> 
   </tr> 
   <tr> 
    <td>descendant</td> 
    <td>选取当前节点的所有后代元素（子、孙等）。</td> 
   </tr> 
   <tr> 
    <td>descendant-or-self</td> 
    <td>选取当前节点的所有后代元素（子、孙等）以及当前节点本身。</td> 
   </tr> 
   <tr> 
    <td>following</td> 
    <td>选取文档中当前节点的结束标签之后的所有节点。</td> 
   </tr> 
   <tr> 
    <td>namespace</td> 
    <td>选取当前节点的所有命名空间节点</td> 
   </tr> 
   <tr> 
    <td>parent</td> 
    <td>选取当前节点的父节点。</td> 
   </tr> 
   <tr> 
    <td>preceding</td> 
    <td>选取文档中当前节点的开始标签之前的所有节点。</td> 
   </tr> 
   <tr> 
    <td>preceding-sibling</td> 
    <td>选取当前节点之前的所有同级节点。</td> 
   </tr> 
   <tr> 
    <td>self</td> 
    <td>选取当前节点。</td> 
   </tr> 
  </tbody> 
 </table> 
</div> 
<div> 
 <h2>位置路径表达式</h2> 
 <p>位置路径可以是绝对的，也可以是相对的。</p> 
 <p>绝对路径起始于正斜杠( / )，而相对路径不会这样。在两种情况中，位置路径均包括一个或多个步，每个步均被斜杠分割：</p> 
 <h3>绝对位置路径：</h3> 
 <pre>/step/step/...</pre> 
 <h3>相对位置路径：</h3> 
 <pre>step/step/...</pre> 
 <p>每个步均根据当前节点集之中的节点来进行计算。</p> 
 <h3>步（step）包括：</h3> 
 <dl class="define">
  <dt>
   轴（axis） 
  </dt>
  <dd>
   定义所选节点与当前节点之间的树关系 
  </dd>
  <dt>
   节点测试（node-test） 
  </dt>
  <dd>
   识别某个轴内部的节点 
  </dd>
  <dt>
   零个或者更多谓语（predicate） 
  </dt>
  <dd>
   更深入地提炼所选的节点集
  </dd>
 </dl> 
 <h3>步的语法：</h3> 
 <pre>轴名称::节点测试[谓语]</pre> 
 <h3>实例</h3> 
 <table class="dataintable FCK__ShowTableBorders"> 
  <tbody> 
   <tr> 
    <th>例子</th> 
    <th>结果</th> 
   </tr> 
   <tr> 
    <td>child::book</td> 
    <td>选取所有属于当前节点的子元素的 book 节点</td> 
   </tr> 
   <tr> 
    <td>attribute::lang</td> 
    <td>选取当前节点的 lang 属性</td> 
   </tr> 
   <tr> 
    <td>child::*</td> 
    <td>选取当前节点的所有子元素</td> 
   </tr> 
   <tr> 
    <td>attribute::*</td> 
    <td>选取当前节点的所有属性</td> 
   </tr> 
   <tr> 
    <td>child::text()</td> 
    <td>选取当前节点的所有文本子节点</td> 
   </tr> 
   <tr> 
    <td>child::node()</td> 
    <td>选取当前节点的所有子节点</td> 
   </tr> 
   <tr> 
    <td>descendant::book</td> 
    <td>选取当前节点的所有 book 后代</td> 
   </tr> 
   <tr> 
    <td>ancestor::book</td> 
    <td>选择当前节点的所有 book 先辈</td> 
   </tr> 
   <tr> 
    <td>ancestor-or-self::book</td> 
    <td>选取当前节点的所有book先辈以及当前节点（假如此节点是book节点的话）</td> 
   </tr> 
   <tr> 
    <td>child::*/child::price</td> 
    <td>选取当前节点的所有 price 孙。</td> 
   </tr> 
  </tbody> 
 </table> 
</div> 
<p>==============================</p> 
<h2>XPath 运算符</h2> 
<p>下面列出了可用在 XPath 表达式中的运算符：</p> 
<p> </p>
<table class="dataintable FCK__ShowTableBorders"> 
 <tbody> 
  <tr> 
   <th>运算符</th> 
   <th>描述</th> 
   <th>实例</th> 
   <th>返回值</th> 
  </tr> 
  <tr> 
   <td>|</td> 
   <td>计算两个节点集</td> 
   <td>//book | //cd</td> 
   <td>返回所有带有 book 和 ck 元素的节点集</td> 
  </tr> 
  <tr> 
   <td>+</td> 
   <td>加法</td> 
   <td>6 + 4</td> 
   <td>10</td> 
  </tr> 
  <tr> 
   <td>-</td> 
   <td>减法</td> 
   <td>6 - 4</td> 
   <td>2</td> 
  </tr> 
  <tr> 
   <td>*</td> 
   <td>乘法</td> 
   <td>6 * 4</td> 
   <td>24</td> 
  </tr> 
  <tr> 
   <td>div</td> 
   <td>除法</td> 
   <td>8 div 4</td> 
   <td>2</td> 
  </tr> 
  <tr> 
   <td>=</td> 
   <td>等于</td> 
   <td>price=9.80</td> 
   <td> <p>如果 price 是 9.80，则返回 true。</p> <p>如果 price 是 9.90，则返回 fasle。</p> </td> 
  </tr> 
  <tr> 
   <td>!=</td> 
   <td>不等于</td> 
   <td>price!=9.80</td> 
   <td> <p>如果 price 是 9.90，则返回 true。</p> <p>如果 price 是 9.80，则返回 fasle。</p> </td> 
  </tr> 
  <tr> 
   <td>&lt;</td> 
   <td>小于</td> 
   <td>price&lt;9.80</td> 
   <td> <p>如果 price 是 9.00，则返回 true。</p> <p>如果 price 是 9.90，则返回 fasle。</p> </td> 
  </tr> 
  <tr> 
   <td>&lt;=</td> 
   <td>小于或等于</td> 
   <td>price&lt;=9.80</td> 
   <td> <p>如果 price 是 9.00，则返回 true。</p> <p>如果 price 是 9.90，则返回 fasle。</p> </td> 
  </tr> 
  <tr> 
   <td>&gt;</td> 
   <td>大于</td> 
   <td>price&gt;9.80</td> 
   <td> <p>如果 price 是 9.90，则返回 true。</p> <p>如果 price 是 9.80，则返回 fasle。</p> </td> 
  </tr> 
  <tr> 
   <td>&gt;=</td> 
   <td>大于或等于</td> 
   <td>price&gt;=9.80</td> 
   <td> <p>如果 price 是 9.90，则返回 true。</p> <p>如果 price 是 9.70，则返回 fasle。</p> </td> 
  </tr> 
  <tr> 
   <td>or</td> 
   <td>或</td> 
   <td>price=9.80 or price=9.70</td> 
   <td> <p>如果 price 是 9.80，则返回 true。</p> <p>如果 price 是 9.50，则返回 fasle。</p> </td> 
  </tr> 
  <tr> 
   <td>and</td> 
   <td>与</td> 
   <td>price&gt;9.00 and price&lt;9.90</td> 
   <td> <p>如果 price 是 9.80，则返回 true。</p> <p>如果 price 是 8.50，则返回 fasle。</p> </td> 
  </tr> 
  <tr> 
   <td>mod</td> 
   <td>计算除法的余数</td> 
   <td>5 mod 2</td> 
   <td>1</td> 
  </tr> 
 </tbody> 
</table> ============================== 
<h1>XPath、XQuery 以及 XSLT 函数</h1> 
<p> </p></div></body></html>