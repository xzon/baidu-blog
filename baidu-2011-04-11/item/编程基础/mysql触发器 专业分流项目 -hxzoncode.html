<html><head><title>mysql触发器 专业分流项目 -hxzoncode</title></head><body><div id='tit'>mysql触发器 专业分流项目 -hxzoncode</div><div id='cate'>编程基础</div><div id='date'>2009年03月27日 星期五 10:02 P.M.</div><div id='page'>59</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/c48e44a7394a8a9dd0435848.html'>http://hi.baidu.com/hxzon/blog/item/c48e44a7394a8a9dd0435848.html</a><div id='cnt'><p> </p> 
<p>mysql触发器 专业分流项目 -hxzoncode</p> 
<p>成功。<br /> create trigger hs.deleteDep<br /> after delete<br /> on hs.department<br /> for each row<br /> update student set department_id=null ,isOk=false where department_id=OLD.id ;<br /> ==========================</p> 
<pre><span>mysql&gt; <span><strong>delimiter //</strong></span></span></pre> 
<pre><span>mysql&gt; <span><strong>CREATE TRIGGER upd_check BEFORE UPDATE ON account</strong></span></span></pre> 
<pre><span>&nbsp;&nbsp;&nbsp;    -&gt; <span><strong>FOR EACH ROW</strong></span></span></pre> 
<pre><span>&nbsp;&nbsp;&nbsp;    -&gt; <span><strong>BEGIN</strong></span></span></pre> 
<pre><span>&nbsp;&nbsp;&nbsp;    -&gt;  &nbsp;&nbsp;&nbsp;<span><strong>IF NEW.amount &lt; 0 THEN</strong></span></span></pre> 
<pre><span>&nbsp;&nbsp;&nbsp;    -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    &nbsp;&nbsp;<span><strong>SET NEW.amount = 0;</strong></span></span></pre> 
<pre><span>&nbsp;&nbsp;&nbsp;    -&gt;&nbsp;&nbsp;&nbsp;&nbsp;    <span><strong>ELSEIF NEW.amount &gt; 100 THEN</strong></span></span></pre> 
<pre><span>&nbsp;&nbsp;&nbsp;    -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    &nbsp;&nbsp;<span><strong>SET NEW.amount = 100;</strong></span></span></pre> 
<pre><span>&nbsp;&nbsp;&nbsp;    -&gt;&nbsp;&nbsp;&nbsp;&nbsp;    <span><strong>END IF;</strong></span></span></pre> 
<pre><span>&nbsp;&nbsp;&nbsp;    -&gt; <span><strong>END;//</strong></span></span></pre> 
<pre><span>mysql&gt; <span><strong>delimiter ;</strong></span></span></pre> 
<p><br /> ==========================</p> 
<p><font color="#0000cc">Syntax 语法<br /> <wbr /><wbr /><br /> 1. Syntax: Name <wbr />语法: 命名规则 <wbr /><wbr /><br /> <wbr />CREATE TRIGGER &lt;触发器名称&gt; <wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><br /> <wbr /><wbr /><wbr />{ BEFORE | AFTER } <wbr /><wbr /><br /> <wbr /><wbr /><wbr />{ INSERT | UPDATE | DELETE } <wbr /><wbr /><br /> <wbr /><wbr />ON &lt;表名称&gt; <wbr /><wbr /><br /> <wbr /><wbr /><wbr />FOR EACH ROW <wbr /><wbr /><br /> <wbr /><wbr /><wbr />&lt;触发器SQL语句&gt; <wbr /><wbr /><br /> <wbr /><wbr /><br /> 触发器必须有名字，最多64个字符，可能后面会附有分隔符. 它和MySQL中其他对象的命名方式<br /> 基本相象. <wbr /><wbr /><br /> <wbr /><wbr /><br /> 这里通常有个习惯：就是用表的名字＋'_'＋触发器类型的缩写. 因此如果是表 <wbr />t26，触发器是在事件<br /> UPDATE （参考下面的点（2）和（3））之前（BEFORE）的，那么它的名字就是t26_bu 。 <wbr /><wbr /></font></p> 
<p><font color="#0000cc">2. Syntax: Time 语法: 触发时间<br /> <wbr /><br /> CREATE TRIGGER &lt;触发器名称&gt; <wbr /><wbr /><br /> <wbr /><wbr /><wbr />{ BEFORE | AFTER } <wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><br /> <wbr /><wbr /><wbr />{ INSERT | UPDATE | DELETE } <wbr /><wbr /><br /> <wbr /><wbr />ON &lt;表名称&gt; <wbr /><wbr /><br /> <wbr /><wbr /><wbr />FOR EACH ROW <wbr /><wbr /><br /> <wbr /><wbr /><wbr />&lt;触发的SQL语句&gt; <wbr /><wbr /><br /> <wbr /><wbr /><br /> 触发器有执行的时间设置：可以设置为事件发生前或后。</font></p> 
<p><font color="#0000cc">3. Syntax: Event语法: 事件<br /> <wbr /><br /> CREATE TRIGGER &lt;触发器名称&gt; <wbr /><wbr /><br /> <wbr /><wbr /><wbr />{ BEFORE | AFTER } <wbr /><wbr /><br /> <wbr /><wbr /><wbr />{ INSERT | UPDATE | DELETE } <wbr /><br /> <wbr /><wbr />ON &lt;表名称&gt; <wbr /><wbr /><br /> <wbr /><wbr /><wbr />FOR EACH ROW <wbr /><wbr /><br /> <wbr /><wbr /><wbr />&lt;触发的SQL语句&gt; <wbr /><wbr /><br /> <wbr /><wbr /><br /> 同样也能设定触发的事件：它们可以在执行insert、update或delete的过程中触发。<br /> <wbr /><br /> 4. Syntax: Table 语法: 表<br /> <wbr /><br /> CREATE TRIGGER &lt;触发器名称&gt; <wbr /><wbr /><br /> <wbr /><wbr /><wbr />{ BEFORE | AFTER } <wbr /><wbr /><br /> <wbr /><wbr /><wbr />{ INSERT | UPDATE | DELETE } <wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><br /> <wbr /><wbr />ON &lt;表名称&gt; <wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><br /> <wbr /><wbr /><wbr />FOR EACH ROW <wbr /><wbr /><br /> <wbr /><wbr /><wbr />&lt;触发的SQL语句&gt; <wbr /><wbr /><br /> <wbr /><wbr /><br /> 触发器是属于某一个表的: 当在这个表上执行插入<br /> 不能给同一张表的同一个事件安排两个触发器。</font></p> 
<p><font color="#0000cc">5. Syntax: Granularity 语法：（步长）触发间隔<br /> <wbr /><br /> CREATE TRIGGER &lt;触发器名称&gt; <wbr /><wbr /><br /> <wbr /><wbr /><wbr />{ BEFORE | AFTER } <wbr /><wbr /><br /> <wbr /><wbr /><wbr />{ INSERT | UPDATE | DELETE } <wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><br /> <wbr /><wbr />ON &lt;表名称&gt; <wbr /><wbr /><br /> <wbr /><wbr /><wbr />FOR EACH ROW<br /> <wbr /><wbr /><wbr />&lt;触发的SQL语句&gt; <wbr /><wbr /><br /> <wbr /><wbr /><br /> 触发器的执行间隔：FOR EACH ROW 子句通知触发器每隔一行执行一次动作，而不是对整个表<br /> 执行一次。</font></p> 
<p><font color="#0000cc">6. Syntax: Statement 语法: 语句<br /> <wbr /><br /> CREATE TRIGGER &lt;触发器名称&gt; <wbr /><wbr /><br /> <wbr /><wbr /><wbr />{ BEFORE | AFTER } <wbr /><wbr /><br /> <wbr /><wbr /><wbr />{ INSERT | UPDATE | DELETE } <wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><br /> <wbr /><wbr />ON &lt;表名称&gt; <wbr /><wbr /><br /> <wbr /><wbr /><wbr />FOR EACH ROW <wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><br /> <wbr /><wbr /><wbr />&lt;触发的SQL语句&gt;<br /> <wbr /><wbr /><br /> 触发器包含所要触发的SQL语句：这里的语句可以是任何合法的语句，包括复合语句，<br /> 但是这里的语句受的限制和函数的一样。</font></p> 
<p><wbr /></p> 
<p><font color="#0000cc">Privileges权限</font></p> 
<p><br /> <font color="#0000cc">你必须拥有相当大的权限才能创建触发器（CREATE TRIGGER）。如果你已经是Root用户，那么就足够<br /> 了。这跟SQL的标准有所不同，我也希望能尽快改成标准的。 <wbr /><wbr /><br /> <wbr /><wbr /><br /> 因此在下一个版本的MySQL中，你完全有可能看到有一种叫做CREATE TRIGGER的新权限。然后通过这<br /> 样的方法赋予：<br /> <wbr /><br /> GRANT CREATE TRIGGER ON &lt;表名称&gt; TO &lt;用户或用户列表&gt;; <wbr /><wbr /><br /> <wbr /><wbr /><br /> 也可以通过这样收回权限：<br /> <wbr /><wbr /><br /> REVOKE CREATE TRIGGER ON &lt;表名称&gt; FROM &lt;用户或用户列表&gt;; <wbr /><wbr /></font></p> 
<p><font color="#0000cc">Referring to OLD and NEW columns 关于旧的和新创建的列的标识</font></p> 
<p><font color="#0000cc">在触发器的SQL语句中，你可以关联表中的任意列。但你不能仅仅使用列的名称去标识，那会使<br /> 系统混淆，因为那里可能会有列的新名（这可能正是你要修改的，你的动作可能正是要修改列名），<br /> 还有列的旧名存在。因此你必须用这样的语法来标识：<br /> &quot;NEW . column_name&quot; 或者 <wbr />&quot;OLD . column_name&quot;. 这样在技术上处理（NEW | OLD . column_name）<br /> 新和旧的列名属于创建了过渡变量（&quot;transition variables&quot;）。<br /> <wbr /><wbr /><br /> 对于INSERT语句, 只有NEW是合法的；对于DELETE语句，只有OLD才合法；而UPDATE语句可以在<br /> 和NEW以及OLD同时使用。下面是一个UPDATE中同时使用NEW和OLD的例子。</font></p> 
<p><font color="#0000cc">CREATE TRIGGER t21_au <wbr /><wbr /><br /> BEFORE UPDATE ON t22 <wbr /><wbr /><br /> FOR EACH ROW <wbr /><wbr /><br /> BEGIN <wbr /><wbr /><br /> <wbr /><wbr /><wbr />SET @old = OLD . s1; <wbr /><wbr /><br /> <wbr /><wbr /><wbr />SET @new = NEW.s1; <wbr /><wbr /><br /> END;// <wbr /><wbr /><br /> <wbr /><wbr /><br /> 现在如果t21表中的s1列的值是55，那么执行了&quot;UPDATE t21 SET s1 = s1 + 1&quot;之后@old的值会变成<br /> 55，而@new的值将会变成56。</font></p> 
<p><br /> <font color="#0000cc">Example of CREATE and INSERT <wbr /><wbr /><wbr />CREATE和INSERT的例子<br /> <wbr /><br /> CREATE table with trigger 创建有触发器的表 创建有触发器的表 创建有触发器的表 创建有触发器的表<br /> <wbr /><wbr /><br /> 这里所有的例程中我都假定大家的分隔符已经设置成//（DELIMITER //）。 <wbr /><wbr /><br /> <wbr /><wbr /><br /> CREATE TABLE t22 (s1 INTEGER)// <wbr /><wbr /><br /> <wbr /><wbr /><br /> CREATE TRIGGER t22_bi <wbr /><wbr /><br /> BEFORE INSERT ON t22 <wbr /><wbr /><br /> FOR EACH ROW <wbr /><wbr /><br /> BEGIN <wbr /><wbr /><br /> <wbr /><wbr /><wbr />SET @x = 'Trigger was activated!'; <wbr /><wbr /><br /> <wbr /><wbr /><wbr />SET NEW.s1 = 55; <wbr /><wbr /><br /> END;// <wbr /><wbr /><br /> <wbr /><wbr /><br /> 在最开始我创建了一个名字为t22的表，然后在表t22上创建了一个触发器t22_bi，当我们要向<br /> 表中的行插入时，触发器就会被激活，执行将s1列的值改为55的动作。</font></p> 
<p><br /> <font color="#0000cc">INSERT on table w ith a trigger <wbr /><wbr />使用触发器执行插入动作</font></p> 
<p><font color="#0000cc">mysql&gt; INSERT INTO t22 VALUES (1)// <wbr /><wbr /><br /> <wbr /><wbr /><br /> 让我们看如果向表t2中插入一行数据触发器对应的表会怎么样？<br /> <wbr /><wbr /><br /> 这里的插入的动作是很常见的，我们不需要触发器的权限来执行它。甚至不需要知道是否有触发器关联。<br /> <wbr /><wbr /><br /> mysql&gt; SELECT @x, t22.* FROM t22// <wbr /><wbr /><br /> +------------------------+------+ <wbr /><wbr /><br /> | @x <wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr />| s1 <wbr /><wbr /><wbr /><wbr /><wbr />| <wbr /><wbr /><br /> +------------------------+------+ <wbr /><wbr /><br /> | Trigger was activated! | <wbr /><wbr /><wbr /><wbr /><wbr />55 | <wbr /><wbr /><br /> +------------------------+------+ <wbr /><wbr /><br /> 1 row in set (0.00 sec) <wbr /><wbr /></font></p> 
<p><font color="#0000cc">大家可以看到INSERT动作之后的结果,和我们预期的一样,x标记被改动了,同时这里插入的数据不是我们开始输入的插入数据,而是触发器自己的数据。</font></p> 
<p><font color="#0000cc">Example of a “check” constraint “check”完整性约束例子</font></p> 
<p><font color="#0000cc">what's “check” constraint <wbr />什么是“check”约束<br /> 在标准的SQL评议中，我们可以在（CREATE TABLE）创建表的过程中使用“CHECK（condition）”，例如：<br /> <wbr /><wbr /><br /> <wbr /><wbr />CREATE TABLE t25 <wbr /><wbr /><br /> <wbr /><wbr /><wbr />(s1 INT, s2 CHAR(5), PRIMARY KEY (s1), <wbr /><wbr /><br /> <wbr /><wbr />CHECK (LEFT(s2,1)='A')) <wbr /><wbr /><br /> <wbr /><wbr />ENGINE=INNODB; <wbr /><br /> 这里的CHECK的意思是“当s2列的最左边的字符不是‘A’时，insert和update语句都会非法”，MYSQL的视图不支持CHECK，但如果你很需要在表中使用这样的功能，建议大家使用触发器实现。</font></p> 
<p><font color="#0000cc">CREATE TABLE t25 <wbr /><wbr /><br /> (s1 INT, s2 CHAR(5), <wbr /><wbr /><br /> PRIMARY KEY (s1)) <wbr /><wbr /><br /> ENGINE=INNODB// <wbr /><wbr /><br /> <wbr /><wbr /><br /> CREATE TRIGGER t25_bi <wbr /><wbr /><br /> BEFORE INSERT ON t25 <wbr /><wbr /><br /> FOR EACH ROW <wbr /><wbr /><br /> IF LEFT(NEW.s2,1)&lt;&gt;'A' THEN SET NEW.s1=0; END IF;// <wbr /><wbr /><br /> <wbr /><wbr /><br /> CREATE TRIGGER t25_bu <wbr /><wbr /><br /> BEFORE UPDATE ON t25 <wbr /><wbr /><br /> FOR EACH ROW <wbr /><wbr /><br /> IF LEFT(NEW.s2,1)&lt;&gt;'A' THEN SET NEW.s1=0; END IF;// <wbr /><wbr /><br /> <wbr /><wbr /><br /> 我只需要使用BEFORE INSERT和BEFORE UPDATE语句就行了，删除了触发器不会对表有影响，同时<br /> AFTER的触发器也不能修改NEW的过程变量（transition variables）。为了激活触发器，我执行了向表中<br /> 的行插入s1＝0的数据，之后只要执行符合LEFT(s2,1) <wbr /><wbr /><wbr />&lt;&gt; 'A'条件的动作都会失败：</font></p> 
<p><font color="#0000cc">INSERT INTO t25 VALUES (0,'a') <wbr /><wbr /><wbr /><wbr /><wbr />// <wbr /><wbr /><br /> INSERT INTO t25 VALUES (5,'b') // <wbr /></font></p></div></body></html>