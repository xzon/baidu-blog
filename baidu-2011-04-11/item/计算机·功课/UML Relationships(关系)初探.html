<html><head><title>UML Relationships(关系)初探</title></head><body><div id='tit'>UML Relationships(关系)初探</div><div id='cate'>计算机&middot;功课</div><div id='date'>2008年05月28日 星期三 08:04 P.M.</div><div id='page'>130</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/fe50e0cde7fb1f540eb34546.html'>http://hi.baidu.com/hxzon/blog/item/fe50e0cde7fb1f540eb34546.html</a><div id='cnt'><p>UML Relationships(关系)初探</p> 
<p>在程序设计中，</p> 
<p><br /> </p> 
<p>&nbsp;&nbsp;&nbsp; 内聚度：程序中操作之间联系紧密的程度，反应一个子程序内部成份相互联系的强度</p> 
<p><br /> </p> 
<p>&nbsp;&nbsp;&nbsp; 耦合度：两子程序之间联系的强度</p> 
<p><br /> </p> 
<p>显然，程序设计的目标是强内聚和松耦合（子程序内部完整性强，与其他子程序的联系灵活，程度小）。</p> 
<p><br /> </p> 
<p>功能分解是面向过程设计时很自然的一种处理复杂问题的方法，它的基本思想是把问题拆分成多个功能步骤。，由于“需求总会发生变化”，因此不可避免的程序设计时要处理变化。对此功能分解的对策是模块化设计，但是模块化设计的一大缺点是低聚合和紧耦合，“牵一发而动全身”。</p> 
<p><br /> </p> 
<p>UML Relationships(关系)初探<br /> <br /> 基本关系有四种:依赖(Dependency), 关联(Association), 泛化(Generalization),实现(Realization)<br /> 每种都可以细化为变体。<br /> <br /> 依赖关系(Dependency) <br /> &nbsp;&nbsp;&nbsp; 是事物(Thing)之间的关系, 因此包括类之间的关系、包之间的关系、用例之间的关系、对象之间的关系、建模元素与模型之间的关系等。<br /> &nbsp;&nbsp;&nbsp; 依赖关系用虚线加普通箭头表示,由客户(源*)指向供应(目标*)</p> 
<p><br /> </p> 
<p>&nbsp;&nbsp;&nbsp; 两个类之间的依赖关系可以是：<br /> &nbsp;&nbsp;&nbsp; 客户类访问定义在供应者类内部的数据值<br /> &nbsp;&nbsp;&nbsp; 客户类的操作调用了定义在供应者类内部的操作<br /> &nbsp;&nbsp;&nbsp; 客户类的返回类或参数是供应者类的实例<br /> &nbsp;&nbsp;&nbsp; 如果在顺序图中的两个对象存在消息的传送，而且它们之间没有结构方面的连接，可以在类图上用依赖关系建模。<br /> &nbsp;&nbsp;&nbsp; <br /> 类之间依赖关系的细化：<br /> a.友元依赖&lt;
 <friend></friend>&gt;<br /> &nbsp;&nbsp;&nbsp; 目标类视源类为友元，允许源类访问目标类的所有私有属性和操作<br /> &nbsp;&nbsp;&nbsp; 例: 目标类：二叉树，源类：迭代器<br /> b.导出依赖&lt;
 <derive></derive>&gt;<br /> &nbsp;&nbsp;&nbsp; 源类可以从目标类通过计算得出。<br /> &nbsp;&nbsp;&nbsp; 例: 源类: 年龄Age&nbsp;&nbsp; 目标类: 出生日期<br /> c.细化依赖&lt;
 <refine></refine>&gt;<br /> &nbsp;&nbsp;&nbsp; 在类图中表示同一模型的不同详细程度的规格说明，源类比目标类更为详细.<br /> d.实例化依赖&lt;
 <instantiate></instantiate>&gt;<br /> &nbsp;&nbsp;&nbsp; 一个类的对象是由另一个的对象创建，则称为实例化依赖。源类创建了目标的一个实例<br /> &nbsp;&nbsp;&nbsp; 例：源类: Array&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 目标类: Stack <br /> e.使用依赖&lt;
 <use></use>&gt;<br /> &nbsp;&nbsp;&nbsp; 不加任何修饰的依赖即为使用依赖。<br /> &nbsp;&nbsp;&nbsp; 如Binary Search Tree类使用依赖于Binary Tree类<br /> f.绑定(Binding)依赖<br /> &nbsp;&nbsp;&nbsp; 目标类是模板类，源类是模板实例化后的类<br /> &nbsp;&nbsp;&nbsp; <br /> 包(package)之间依赖关系的细化:<br /> a.访问依赖&lt;
 <access></access>&gt;<br /> &nbsp;&nbsp;&nbsp; 源包被授予了可访问目标包的权限<br /> b.导入依赖&lt;&gt;<br /> &nbsp;&nbsp;&nbsp; 它表明了源包可以访问目标包里的元素，但各个包有自己独立的命名空间，这意味着属于不同包的两个元素可以重名。导入<br /> &nbsp;&nbsp;&nbsp; 依赖可以使目标包内的公共可见元素进入源包的命名空间。<br /> <br /> 用例(use case)之间依赖关系的细化:<br /> a.包含依赖&lt;
 <include></include>&gt;<br /> &nbsp;&nbsp;&nbsp; 源用例显式的包含目标用例作为其行为的一部分。此时源用例称为基用例，目标用例称为内含用例<br /> &nbsp;&nbsp;&nbsp; 如果两个用例存在包含依赖关系，则说明基用例的动作序列中含有特定的步骤把内含用例的动作序列包含进来<br /> b.扩展依赖&lt;
 <extend></extend>&gt;<br /> &nbsp;&nbsp;&nbsp; 它表明源用例扩展了目标用例的行为。此时，源用例称为基用例，目标用例称为扩展用例。<br /> &nbsp;&nbsp;&nbsp; 扩展用例在特定条件下为基用例提供附加的动态行为。<br /> &nbsp;&nbsp;&nbsp; 例如，在人机交互过程(基用例)中出现差错时进行的异常处理即为扩展动作。<br /> &nbsp;&nbsp;&nbsp; 扩展依赖与包含依赖的区别在于，如果仅将扩展从基用例地动作序列中去除，基用例仍然是语义完备的，<br /> &nbsp;&nbsp;&nbsp; 即它的执行仍将产生有意义的结果。而包含依赖则不然。<br /> <br /> 对象之间依赖关系的细化:<br /> a.转换依赖&lt;
 <become></become>&gt;<br /> &nbsp;&nbsp;&nbsp; 当需要在交互图上表示对象状态的转换时可以用转换依赖。主要强调由于消息而导致对象状态的改变。<br /> &nbsp;&nbsp;&nbsp; 转换依赖连接的目标对象和源对象是同一个对象。<br /> b.调用依赖&lt;
 <call></call>&gt;<br /> &nbsp;&nbsp;&nbsp; 当需要在交互图或对象图上显式强调对象之间或操作之间的调用关系时要用调用依赖。<br /> &nbsp;&nbsp;&nbsp; 它表明源对象引用了目标对象的操作，或源操作引用了目标操作。<br /> c.复制依赖&lt;
 <copy></copy>&gt;<br /> &nbsp;&nbsp; 为了在交互图或活动图上描述对象复制的动作可以采用复制依赖。它连接两个对象，目标对象是源对象的完全相同而又独立的副本。<br /> d.发送依赖&lt;
 <send></send>&gt;<br /> &nbsp;&nbsp;&nbsp; 它连接一个对象（在源端）和一个消息（在目标端），表明源对象在交互过程中发送了一个消息，可以用在状态机的描述中。<br /> &nbsp;&nbsp;&nbsp; 它针对内嵌有状态机的对象，可用来描述如何通过发送信号以产生某种事件的动作。<br /> &nbsp;&nbsp;&nbsp; <br /> 建模元素与模型之间的依赖关系：<br /> a.回溯依赖&lt; 
 <trace> 
 </trace> &gt;<br /> &nbsp;&nbsp;&nbsp; 它连接两个模型元素，表明目标是源的历史上的前驱。如交互和协作就是从用例导出的。<br /> &nbsp;&nbsp;&nbsp; <br /> 关联关系(association)<br /> &nbsp;&nbsp;&nbsp; 关联是一种结构关系, 它描述一组链，这些链是类之间或类与接口之间的连接。<br /> &nbsp;&nbsp;&nbsp; 通过这种连接，一个对象可以访问另一个对象的属性或调用另一个对象的操作。<br /> &nbsp;&nbsp;&nbsp; 关联是双向的，其中的角色代表一个类的对象在另一个类中的存在。<br /> &nbsp;&nbsp;&nbsp; 例: 两个类Employee, Employer存在关联关系<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; 聚合(aggregation)是一种特殊类型的关联, 它描述整体与部分的结构关系。整体端有一个菱形作为标记<br /> &nbsp;&nbsp;&nbsp; 复合聚合(composite aggregation)是一种特殊的聚合关系, 又称组合，它表明整体对象与部分对象有相同的生存周期。<br /> &nbsp;&nbsp;&nbsp; 角色的复杂度(Multiplicity)指角色在关联关系中出现的次数,如1, 0..1, 1..*, *等</p> 
<p><br /> </p> 
<p>&nbsp;&nbsp;&nbsp; 例如，对应于现实中的飞机场Airport, 可以说它聚合了0..*架飞机Aircraft，同样的，一架Aircraft被0..1个Airport包容(可能处于飞行状态),此时Airport与Aircraft的关系是聚合。</p> 
<p><br /> </p> 
<p>&nbsp;&nbsp;&nbsp; 又如，一辆汽车Car，用于4~5个轮胎Tire(可能有备用胎)，Car和Tire是密不可分的，Tire是Car的一部分，因此用组合来表示二者之间的关系。一个Car组合了4..5个Tire，一个Tire属于1辆Car</p> 
<p><br /> </p> 
<p>&nbsp;&nbsp;&nbsp; 聚合和组合都可以说是一种has-a关系，“拥有”，Airport“拥有”Aircraft，Car“拥有”Tire，二者的区别在于组合强调的“拥有”是真正意义的部分与整体的关系，从程序设计角度来看组合关系双方生存期一致，同生共死；聚合的“拥有”则更多强调部分的一个集合与整体有从属关系，部分集合内部各元素是独立的。</p></div></body></html>