<html><head><title>《电脑网络教育与Web教育服务-计算机密码》-计算机密码： 01计算数论与代数、大整数计算</title></head><body><div id='tit'>《电脑网络教育与Web教育服务-计算机密码》-计算机密码： 01计算数论与代数、大整数计算</div><div id='cate'>计算机&middot;功课</div><div id='date'>2008年01月02日 星期三 02:51 A.M.</div><div id='page'>178</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/f6c753fbfc9762126c22eb7f.html'>http://hi.baidu.com/hxzon/blog/item/f6c753fbfc9762126c22eb7f.html</a><div id='cnt'><div>
 《电脑网络教育与Web教育服务-计算机密码》
 <br /> E'education Laboratory And Web'Education Services美国GeneChiu基金资助Supported by USA GeneChiu Foundation
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 计算机密码： 计算数论与代数、大整数计算
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 信息安全的核心是密码技术；数字签名、身份鉴别等都是由密码学派生出来的新技术和应用；密码技术除了提供信息的加密解密外，还提供对信息来源的鉴别、保证信息的完整和不可否认等功能，而这三种功能都是通过数字签名实现；自公钥加密问世以来，学者们提出了许多种公钥加密方法，它们的安全性都是基于复杂的数学难题。根据所基于的数学难题来分类，有以下三类系统目前被认为是安全和有效的：大整数因子分解系统(代表性的有RSA)、椭园曲线离散对数系统(ECC)和离散对数系统 (代表性的有DSA)；可以说，大整数技术是现代信息安全技术的核心之一。
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 00 大整数--信息安全的核心
</div> 
<div> 
</div> 
<div>
 03 数论简介
</div> 
<div> 
</div> 
<div>
 04 大整数因式分解
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 1、有关数论的算法（参看：01 有关数论的算法）：
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 数论的基本知识 —— 数论的基本概念，例如可除性、模等价和唯一因子分解等。
</div> 
<div> 
</div> 
<div>
 最大公约数 —— 很古老的算法：关于计算两个整数的最大公因数的欧几里德算法。
</div> 
<div> 
</div> 
<div>
 模运算 —— 模运算的概念。
</div> 
<div> 
</div> 
<div>
 求解模线性方程 —— 讨论了一个已知数a的倍数模n所得到的集合，并说明如何利用欧儿里德算法来求出方程ax=b(modn)的所有解。
</div> 
<div> 
</div> 
<div>
 中国余数定理 —— 阐述了中国余数定理和一些应用。
</div> 
<div> 
</div> 
<div>
 元素的幂 —— 考察了已知数a的幂模n所得的结果，并阐述了一种已知a，b和n，可以有效地计算ab模 n的反复平方算法。这一运算是有效地进行素数测试的中心问题。
</div> 
<div> 
</div> 
<div>
 RSA公开密钥加密系统 —— 当今数论最有价值的应用领域。
</div> 
<div> 
</div> 
<div>
 素数的测试 —— 主要讨论了随机性素数测试，它可以用于有效地找出大素数，这是我们为RSA加密系统构造密钥的过程中所必须完成的基本任务。
</div> 
<div> 
</div> 
<div>
 整数的因子分解 —— RSA系统的安全性取决于对大整数进行因子分解的困难程度。
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; 05 大整数的乘法
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; 06 大整數的除法
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; 07 分解质因数的程序
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; 08 素数表生成程序
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; 081_如何产生概率素数
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; 082_制作素数库
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 2、有关（有限）群、环、域的算法
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 参看：
</div> 
<div> 
</div> 
<div>
 02_数论与代数的计算导引-500页
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp; 一本有一定深度的市和研究生学习研究的很好的教材！
</div> 
<div> 
</div> 
<div>
 09 组合群论在密码学和电子商务的安全性中的应用
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个大学生写的论文
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 3、非大整数数论算法的C++语言实现：
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 这是一组数论算法（仅适用于通常的整数类型）的C/C++程序(可下载：10_数论算法库C语言实现.rar)，内容如下：
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 算法库：010_number theory.h
</div> 
<div> 
</div> 
<div>
 算法库的使用(作业：014有问题，请修改)：
</div> 
<div> 
</div> 
<div>
 欧几里德算法求最大公约数---011_EUCLID.CPP
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int euclid(int a,int b)
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 扩展欧几里德算法求gcd(a,b)=ax+by
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ext_euclid(int a,int b,int &amp;x,int &amp;y)
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 随机素数测试算法---012_Miller_Rabin.CPP
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int Witness(int a,int n)
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int Miller_Rabin(int n,int s)
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 模取幂运算计算a^b mod n---013_Modular_Expoent.CPP
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int Modular_Expoent(int a,int b,int n)
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 求解模线性方程 ax=b (mod n) ,n&gt;0---014_modular_linear_equation_solver.CPP
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void modular_linear_equation_solver(int a,int b,int n)
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 求解模线性方程组 (中国余数定理)---015_modular_linear_equation_group.CPP
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a=B[1] (mod W[1])
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a=B[2] (mod W[2])
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ........
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a=B[n] (mod W[n])
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp; 其中W,B已知，W[i]&gt;0且W[i]与W[j]互质, 求a
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 int China(int B[],int W[],int k)
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 在Win32平台下用VC++6编译方法如下：
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp; 在C:\000下建一个名为dos的空工程，将输入文件拷贝进c:\000\dos
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp; 即可加入源代码编译运行
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp; 今后可将可执行程序与输入文件放到（任何）同一目录下使用
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 5 高精度计算的C语言实现
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; 圆周率小数点后2000位
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; 自然对数底e2000位
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 （1）计算机算法的正确性：写出算法流程说明（证明）算法正确；通过特别样例运行测试正确性。
</div> 
<div> 
</div> 
<div>
 （2）计算机算法的时间复杂性：记录在机器上运行的时间；分析算法执行指令的次数，一般耗费在循环上。例如：对于整数n，算法要执行2n次除法运算，一个整数n是一个要用2^n个二进位表示，所以每次除法运算在机器上是：c*2^n次机器运算（c为常数），故时间复杂性大约在：c*n*2^n
</div> 
<div> 
</div> 
<div>
 （3）计算机算法的空间复杂性：程序的数据占用内存或外存，例如，解1万个未知数的线性方程组，要一个1万x1万的数组，对于整数，这个数组要：4*1万*1万=400兆的存储（或内存）空间；因此，要考虑压缩存储
</div> 
<div> 
</div> 
<div>
 （4）高精度算法：由于计算机字长的限制，大整数、高精度小数的算法要进行特殊设计，可在单机、计算机集群或Internet分布式上考虑进行
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 例1（01.cpp）、在1000000000—2000000000间找最小素数：
</div> 
<div> 
</div> 
<div>
 #include&lt;iostream.h&gt;
</div> 
<div> 
</div> 
<div>
 #include&lt;time.h&gt;
</div> 
<div> 
</div> 
<div>
 clock_t start_time,end_time; //时间变量
</div> 
<div> 
</div> 
<div>
 void main(){
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long temp=0;//存放结果
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start_time=clock();cout&lt;&lt;&quot;计算开始时间：&quot;&lt;&lt;start_time&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //计算开始
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(long i=1000000000;i&lt;=2000000000;i++){//
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(temp&gt;0)break;&nbsp;&nbsp;&nbsp;&nbsp; // 素数已求到，for&nbsp;&nbsp;&nbsp;&nbsp;
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(long j=2;j&lt;i;j++){
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(i%j==0)break;&nbsp;&nbsp; // i不是素数，退出for&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(j&gt;=i/2)temp=i;&nbsp;&nbsp; // i是素数
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//计算结束
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end_time=clock();
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;&quot;OK!计算已完成,运行时间为&quot;&lt;&lt;end_time-start_time&lt;&lt;&quot;毫秒&quot;&lt;&lt;endl; //60076
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;temp&lt;&lt;endl; //打印结果:1000000007
</div> 
<div> 
</div> 
<div>
 }
</div> 
<div> 
</div> 
<div>
 《作业1》：（1）将上述程序改为找最大素数；（2）找一个随机素数；（3）找一个12位的素数；
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 例2 (02_100.cpp)：计算2^100（用数组a[100]）: 1267 6506 0022 8229 4014 9670 3205 376
</div> 
<div> 
</div> 
<div>
 #include&lt;iostream.h&gt;
</div> 
<div> 
</div> 
<div>
 #include&lt;time.h&gt;
</div> 
<div> 
</div> 
<div>
 #define x 100 //定义指数
</div> 
<div> 
</div> 
<div>
 clock_t start_time,end_time; //时间变量
</div> 
<div> 
</div> 
<div>
 void main(){
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a[x]; //数组的每个单元存放的十进制的一位
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b1=0; //进位
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int temp=0;//存放中间结果
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; a[0]=1;for(int i=1;i&lt;x;i++)a[i]=0;//初始化数组
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start_time=clock();cout&lt;&lt;&quot;计算开始时间：&quot;&lt;&lt;start_time&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //计算开始
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=0;i&lt;=x-1;i++){//用2乘以数组的每一位，共x次
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j=0;j&lt;=i;j++){
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp=a[j]*2+b1;
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(temp&lt;10){a[j]=temp; b1=0;} //无进位
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {a[j]=temp%10;b1=1;}&nbsp;&nbsp;&nbsp;&nbsp; //有进位
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//计算结束
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end_time=clock();cout&lt;&lt;&quot;OK!计算已完成,运行时间为&quot;&lt;&lt;end_time-start_time&lt;&lt;&quot;毫秒&quot;&lt;&lt;endl;
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=30;i&gt;=0;i--)cout&lt;&lt;a[i];cout&lt;&lt;endl;//printf(&quot;%d&quot;,a[i]); //打印结果
</div> 
<div> 
</div> 
<div>
 }
</div> 
<div> 
</div> 
<div>
 《作业2》：（1）计算并显示2^10000，将程序设计为计算2^n并显示其中的1-100位；（2）将数组每个单元存放十进制的4位，改造上面例子，并进行复杂性分析；（3）考虑用位运算设计
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 例3、大整数的加法&nbsp;&nbsp; 多位数与多位数的加运算，数组法：
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp; 把多位数按每4位为一个段，依次顺序地分别存储在下标变量中，并进行相加运算。
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a[0]&nbsp;&nbsp;&nbsp; a[1]&nbsp;&nbsp;&nbsp; a[2]&nbsp;&nbsp;&nbsp; a[3]&nbsp;&nbsp;&nbsp; a[4]
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1999&nbsp;&nbsp;&nbsp; 4444&nbsp;&nbsp;&nbsp; 7777&nbsp;&nbsp;&nbsp; 2222&nbsp;&nbsp;&nbsp; 9999
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b[0]&nbsp;&nbsp;&nbsp; b[1]&nbsp;&nbsp;&nbsp; b[2]&nbsp;&nbsp;&nbsp; b[3]&nbsp;&nbsp;&nbsp; b[4]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + 0111&nbsp;&nbsp;&nbsp; 6666&nbsp;&nbsp;&nbsp; 3333&nbsp;&nbsp;&nbsp; 8888&nbsp;&nbsp;&nbsp; 1111
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —————————————————————
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c[0]&nbsp;&nbsp;&nbsp; c[1]&nbsp;&nbsp;&nbsp; c[2 ]&nbsp;&nbsp; c[3]&nbsp;&nbsp;&nbsp; c[4]
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2111&nbsp;&nbsp;&nbsp; 1111&nbsp;&nbsp;&nbsp; 1111&nbsp;&nbsp;&nbsp; 1111&nbsp;&nbsp;&nbsp; 1110
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 计算由低段到高段在同下标的下标变量之间逐个进行，当低段对应相加有进位（大于等于10000）时，要向相邻的高段进1。下面是述两多位数相加的C++程序。
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 #include&lt;iostream.h&gt;
</div> 
<div> 
</div> 
<div>
 #define KETA 22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //十进位数
</div> 
<div> 
</div> 
<div>
 #define N (KETA-1)/4+1 //数组大小
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 int a[N+1]={19,9999,9999,9999,9999,9999},//加数
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; b[N+1]={0,0,0,0,1,1},//被加数
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; c[N+1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //和
</div> 
<div> 
</div> 
<div>
 void main(){
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; void madd();
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; extern int a[],b[],c[];
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; madd();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //调用多位数加函数
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; for(int i=0;i&lt;N;i++)cout&lt;&lt;c[i]&lt;&lt;&quot; &quot;;&nbsp;&nbsp;&nbsp; //打印结果：20 0 0 0 1 0
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; cout&lt;&lt;endl;
</div> 
<div> 
</div> 
<div>
 }
</div> 
<div> 
</div> 
<div>
 void madd(){
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; int cy=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 进位变量
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; extern int a[],b[],c[];
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp; for(int i=N;i&gt;=0;i--){&nbsp;&nbsp;&nbsp; //从低位开始相加
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c[i]=a[i]+b[i]+cy;
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(c[i]&gt;=10000){c[i]-=10000;cy=1;}
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else cy=0;
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</div> 
<div> 
</div> 
<div>
 }
</div> 
<div> 
</div> 
<div>
 例4（见04.cpp）、大整数与通常整数的除法
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 《作业3》：设计大整数四则运算，并用它来计算：12345678901234567890^999并显示前100位
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 例5（见05.cpp）使用大整数加与除，求e到第1000位的C++程序。
</div> 
<div> 
</div> 
<div>
 按照泰勒展开式: e=1+1/1!+1/2!+1/3!+...+1/n!+....
</div> 
<div> 
</div> 
<div>
 当n很大时，可用多位数除法求每一项，并用多位数加法将各项相加。由于(Sterning公式)
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 449!&lt;10^1000&lt;450!
</div> 
<div> 
</div> 
<div>
 考虑一定余度，求到第451项时可得到有1000位的e;于是求1000位e的算法细化为求451个大整数相加。
</div> 
<div> 
</div> 
<div>
 使用计算多项式的Horner方法：将e的展开式写为：
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e=1+1/1*(1+1/2*(1+1/3*(1+...(1+1/451)...))) =(((...(1/451+1)/450...+1)/3+1)/2+1)+1
</div> 
<div> 
</div> 
<div>
 按照 Homer方法，求e的迭代算法为：
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e=1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int i=451;i&gt;=1;i--)e=e/i+1
</div> 
<div> 
</div> 
<div>
 为得到1000位的e,首先将它放在大小为N的数组e[]中，并令&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e[0]=1
</div> 
<div> 
</div> 
<div>
 然后调用多位除函数除以项数，每除一次进行一次迭代&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e[0]=e[0]/I+1
</div> 
<div> 
</div> 
<div>
 //e= 2.718 281 828 459 045 235 360 287 475 352 662 ………
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 微机随机大素数的概率生成与应用（1985级研究生宋荣功编写）
</div> 
<div> 
</div> 
<div>
 算法实现求解m的n次方幂(结果为十进制整数)的C语言程序-1999-研究生杨武
</div> 
<div> 
</div> 
<div>
 圆周率计算-2003硕士研究生 钟进
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 《作业4》：用命令行输入：n；计算2^n并将结果存盘；求圆周率pi到1000位。
</div> 
<div> 
</div> 
<div>
 《研究1》\大整数模\Mode1.cpp（用OOP写）：大整数(&lt;=200位)计算：s1^s2 mod s3，写出流程，分析算法，测试验证程序的正确性(用2^100的结果)，用这个程序计算：2^1000的结果并存盘；将结果与您的计算结果比较；将算法运算时间加入；研究程序中特别的算法，写一篇读书报告
</div> 
<div> 
</div> 
<div>
 《研究2》\meson数：有关大素数的Internet分布式求解，写一篇读书报告
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 6、大整数数论算法的C++语言实现：高精度计算算法库NTL
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 在《面向对象技术》中，我们已经介绍过NTL，这里，介绍NTL在密码算法的C++实现中的应用.
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 （1） NTL（Numbery Theory Library）是特别涉及到任意精度大整数与实数的计算数论与计算代数（有限群、环、域、多项式）的算法库，由美国纽约大学的Victor Shoup (
 <a href="mailto:victor@shoup.net">victor@shoup.net</a>)开发并维护的开放源码的自由软件（free software），于1990年开始进行开发，目前已经发布到5_3_2版，并有Windows版与Unix/Linux版；访问
 <a href="http://www.shoup.net/">www.shoup.net</a>可以下载有关源代码、详细的使用说明和有关利用NTL进行的开发工作；此外，还有Victor Shoup写的书：《A Computational Introduction to Number Theory and Algebra (BETA version 5)》，这是一本很好的关于计算数论与计算代数的著作，全书超过500页，内容详细，是计算数论与计算代数方面的好的入门书，特别对与密码学有兴趣的读者更是不可多得。
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2） NTL是面向对象设计的，可将算法库编译为静态库使用（见：01_基于任意精度计算类库NTL的VC++6.0程序设计.DOC）；由于有全部源代码，做为一个很好的学习，可以将有关部分的代码（例如：大整数）抽出来独立使用
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （3）NTL的基本环类有:
</div> 
<div> 
</div> 
<div>
 ZZ: big integers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZZ_p: big integers modulo p
</div> 
<div> 
</div> 
<div>
 zz_p: integers mod &quot;single precision&quot; p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GF2: integers mod 2
</div> 
<div> 
</div> 
<div>
 ZZX: univariate polynomials over ZZ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZZ_pX: univariate polynomials over ZZ_p
</div> 
<div> 
</div> 
<div>
 zz_pX: univariate polynomials over zz_p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GF2X: polynomials over GF2
</div> 
<div> 
</div> 
<div>
 ZZ_pE: ring/field extension over ZZ_p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zz_pE: ring/field extension over zz_p
</div> 
<div> 
</div> 
<div>
 GF2E: ring/field extension over GF2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZZ_pEX: univariate polynomials over ZZ_pE
</div> 
<div> 
</div> 
<div>
 zz_pEX: univariate polynomials over zz_pE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GF2EX: univariate polynomials over GF2E
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （4）示例1-my01.cpp：计算并显示2^10000，录入代码为my01.cpp并存盘到C:\WinNTL-5_3_2\mycpp（子目录mycpp为新建）；运行VC++6.0，打开控制台工程myntl，将my01.cpp加入工程，编译运行即可
</div> 
<div> 
</div> 
<div>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 示例2-my02.cpp：（使用C/C++与NTL的混合编程）计算2^100000，并记录运算时间（2140毫秒）；在控制台工程myntl中去掉文件my01.cpp，将my02.cpp加入，编译运行，my02.cpp（//这个程序很不好，请用2分法思想改进，并用来计算2^1百万，2^1千万）
</div> 
<div> 
</div> 
<div>
 示例011- my011.cpp 迭代计算99!
</div> 
<div> 
</div> 
<div>
 示例3-my03.cpp：使用类RR，进行任意精确的小数运算
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 6、作业与研究：
</div> 
<div> 
</div> 
<div>
 （1）用NTL全部解决《水仙化数问题》；
</div> 
<div> 
</div> 
<div>
 （2）分析类ZZ与ZZ_p，将其独立出来；
</div> 
<div> 
</div> 
<div>
 （3）阅读\03_RSA的材料，用NTL找两个516位的概率素数，实现一个RSA公钥系统；
 <br /> 
 <a href="http://210.40.7.188/E ojc/MIMA/01/000.asp">http://210.40.7.188/E'ojc/MIMA/01/000.asp</a>
</div></div></body></html>