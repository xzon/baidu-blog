<html><head><title>计算机系统结构精髓-hxzon爱读书</title></head><body><div id='tit'>计算机系统结构精髓-hxzon爱读书</div><div id='cate'>计算机&middot;功课</div><div id='date'>2008年03月16日 星期日 08:56 P.M.</div><div id='page'>156</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/5f44f61f3ef2e6f1e1fe0bee.html'>http://hi.baidu.com/hxzon/blog/item/5f44f61f3ef2e6f1e1fe0bee.html</a><div id='cnt'><div>
 计算机系统结构精髓-hxzon爱读书
</div> 
<div> 
</div> 
<div>
 作者：方存正
 <br /> 出版社：清华大学出版社
 <br /> 版本：2006年1月 ISBN：7302122717
 <br /> 开本：16包装：
</div> 
<div> 
</div> 
<div>
 定价：29.00 精诚价：26.10 积分：23 VIP价：23.20
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 计算机系统结构精髓 介绍
</div> 
<div> 
</div> 
<div>
  本书缘于我被安排去救场本科生的一门计算机系统结构课程。该课程多年来未受到应有的重视：它经由好几位教授讲授，绝大多数都是访问学者，他们对数字硬件缺乏兴趣，甚至毫无这方面的背景，因而这门课程被开设成了一个与硬件体系结构不大搭界的大杂烩。有几个学期，整门课程都在讲布尔代数，与硬件一点关系都没有；还有几个学期，仅仅是死抠某个汇编语言的具体细节，根本没有提升到对比选择、取舍评估的高度。 
 <br /> 难道是计算机系统结构这门课程不值得认真对待吗？绝对值得！在许多计算机科学（Computer Science）的教学计划中，计算机系统结构是惟一一门能让学生接触到与编程相关的计算机结构方面基本概念的课程。实际上，懂得硬件可以把程序构造得更加高效、更少出错。从广义上讲，有了计算机系统结构方面的知识，程序员就能理解程序设计中不同选择和取舍所带来的影响，有助于提高程序的效率；另一方面，知道硬件工作原理，还可以改善编程的过程，因为这使得程序员能够更迅速地查明故障来源。此外，毕业生为了顺利通过像英特尔（Intel）和微软（Microsoft）这些公司的求职申请考试，也需要掌握基本的体系结构知识。 
 <br /> 拯救这门课程的措施之一，就是找一本合适的教材。寻找过程中笔者发现，这方面的教材大体上可以分为两类：一类面向工程专业低年级学生，他们毕业后会去设计硬件；另一类则是针对计算机应用专业学生，这类教材试图覆盖编译程序、操作系统，甚至因特网协议工作原理方面的内容。这两类教材似乎都不适合用作这种单纯的、导引性课程的教材。我们需要的是这样一本教材： 
 <br /> （1）注重在概念，而不是工程细节（因为我们学生的学习目标不是硬件设计）； 
 <br /> （2）从程序员的观点阐明问题，重点在于计算机系统结构对程序员编程的影响； 
 <br /> （3）几门课程相关知识的有机结合，而不是简单罗列。 
 <br /> 我们找不到这样的教材，所以只好自己动手编写一本。 
 <br /> 本书分为5部分。第1部分介绍数字逻辑、门和数据表示基础，重点放在数据表示这一章，因为补码运算的概念和整数值的范围在程序设计中极其重要。第2、第3和第4部分涵盖计算机系统结构的3个主要领域：处理器、存储器和输入输出系统，在这3部分，每一章都给学生介绍了足够的背景知识，帮助他们了解计算机各主要部件的工作原理以及对程序设计的影响。第5部分则介绍了一些高级话题，如并行性、流水线技术和性能评估等。 
 <br /> 附录是课程教学的一个重要方面：实验，让学生通过动手操作来强化学习。虽然大多数实验偏重编程，但开始几周学生要在实验室的实验电路板上进行门的连接。 
 <br /> 为配合本书学习，英文版原书作者建立了一个专用网站，其地址为： 
 <br /> 
 <a href="http://www.eca.cs.purdue.edu/">http://www.eca.cs.purdue.edu</a> 
 <br /> Rajesh Subraman负责网站管理。网站上包含由本书作者和Rajesh创作的授课材料。我们欢迎其他各位老师贡献自己的材料。 
 <br /> 本书理论部分和实验练习都已在美国普渡（Purdue）大学使用，深受学生欢迎。我们收到很多对本书和本课程的感谢信。对许多学生来说，实验是他们对硬件的第一次体验，反应很是热烈。 
 <br /> 感谢为本书作过贡献的所有人。Bernd Wolfinger通览了全书，并对写作论题和方向提出了不少宝贵意见。Dan Ardelean、James Cernak和Tim Korb对许多章提出了具体建议。Dave Capka审阅了前几章。Rajesh Subraman用本书进行授课，并对内容提出一些有益建议。普渡大学CS 250级的一些学生发现了原稿中的一个或多个打字错误，他们是：Nitin Alreja、Alex Cox、David Ehrmann、Roger Maurice Elion、Andrew Lee、Stan Luban、Andrew L. Soderstrom和Brandon Wuest。 
 <br /> 最后，我要感谢我的妻子Chris，她耐心、细致的编辑工作和宝贵的建议，使本书大为增色。 
 <br /> Douglas E. Comer 
 <br /> 2004年6月 
 <br /> 本书是美国普渡大学资深教授Douglas E. Comer从计算机系统结构对编程影响的角度为计算机科学、技术、应用类学生精心编写的计算机系统结构教材。最大特点是重概念，轻细节，从程序员的观点阐明计算机系统结构对程序设计、优化和调试的影响。 
 <br /> 本书分为5部分。第1部分介绍数字逻辑、门和数据表示基础，重点放在数据表示这一章。第2、第3和第4部分涵盖计算机系统结构的3个主要领域：处理器、存储器和输入输出系统，在这3部分，每一章都给学生介绍了足够的背景知识，帮助他们了解计算机各主要部件的工作原理以及对程序设计的影响。第5部分则介绍了一些高级话题，如并行性、流水线技术和性能评估等。附录中给出了11个实验，让学生通过动手操作来切实学懂和掌握这门课程。 
 <br /> 本书的主要读者对象是高等院校计算机科学、技术、应用专业的学生，也可供程序开发人员学习参考。
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 计算机系统结构精髓 目录
 <br /> 目 录 
 <br /> 第1章 引言和纵览 1 
 <br /> 1.1 系统结构的重要性 1 
 <br /> 1.2 学习要旨 1 
 <br /> 1.3 本书的组织 1 
 <br /> 1.4 省略的内容 2 
 <br /> 1.5 术语：系统结构和设计 2 
 <br /> 1.6 小结 2
</div> 
<div> 
</div> 
<div>
  第1部分 数字逻辑与数据表示基础
</div> 
<div> 
</div> 
<div>
  第2章 数字逻辑基础 4 
 <br /> 2.1 引言 4 
 <br /> 2.2 有关电的术语：电压和电流 4 
 <br /> 2.3 晶体管 4 
 <br /> 2.4 逻辑门 5 
 <br /> 2.5 逻辑门的符号表示 7 
 <br /> 2.6 用晶体管构建门 7 
 <br /> 2.7 门和门互连的例子 8 
 <br /> 2.8 多门集成电路 10 
 <br /> 2.9 不只需要组合电路 10 
 <br /> 2.10 能保持状态的电路 11 
 <br /> 2.11 状态转换图 11 
 <br /> 2.12 二进制计数器 12 
 <br /> 2.13 时钟和顺序 12 
 <br /> 2.14 反馈的重要概念 15 
 <br /> 2.15 启动的一个动作序列 16 
 <br /> 2.16 软件重复与硬件副本的比较 16 
 <br /> 2.17 门和芯片的极小化 17 
 <br /> 2.18 利用空闲的门 17 
 <br /> 2.19 供电和散热 18 
 <br /> 2.20 定时 18 
 <br /> 2.21 物理尺寸和处理工艺 19 
 <br /> 2.22 电路板和多层印刷 20 
 <br /> 2.23 抽象的层次 20 
 <br /> 2.24 小结 21
</div> 
<div> 
</div> 
<div>
  第3章 数据和程序的表示 22 
 <br /> 3.1 引言 22 
 <br /> 3.2 数字逻辑和抽象 22 
 <br /> 3.3 位和字节 22 
 <br /> 3.4 字节大小和可能表示的值 23 
 <br /> 3.5 二进制运算 23 
 <br /> 3.6 十六进制表示法 24 
 <br /> 3.7 十六进制常数和二进制常数表示法 25 
 <br /> 3.8 字符集 26 
 <br /> 3.9 Unicode 27 
 <br /> 3.10 无符号整数、上溢和下溢 27 
 <br /> 3.11 位和字节的编号 28 
 <br /> 3.12 带符号整数 29 
 <br /> 3.13 一个补码表示的数的例子 29 
 <br /> 3.14 符号扩展 30 
 <br /> 3.15 浮点 31 
 <br /> 3.16 特殊值 32 
 <br /> 3.17 IEEE浮点值的范围 32 
 <br /> 3.18 数据聚集 33 
 <br /> 3.19 程序的表示 33 
 <br /> 3.20 小结 33 
 <br /> 习题 34
</div> 
<div> 
</div> 
<div>
  第2部分 处 理 器
</div> 
<div> 
</div> 
<div>
  第4章 各种处理器和计算引擎 36 
 <br /> 4.1 引言 36 
 <br /> 4.2 冯?诺依曼体系结构 36 
 <br /> 4.3 处理器的定义 37 
 <br /> 4.4 处理器的类别 37 
 <br /> 4.5 分层结构和计算引擎 38 
 <br /> 4.6 常规处理器的结构 39 
 <br /> 4.7 算术逻辑部件（ALU）的定义 40 
 <br /> 4.8 处理器的类别及作用 40 
 <br /> 4.9 处理器工艺技术 41 
 <br /> 4.10 存储程序 42 
 <br /> 4.11 读取-执行周期 42 
 <br /> 4.12 时钟速率和指令速率 43 
 <br /> 4.13 控制：启动和停止 43 
 <br /> 4.14 启动读取-执行周期 44 
 <br /> 4.15 小结 44 
 <br /> 习题 45
</div> 
<div> 
</div> 
<div>
  第5章 处理器类型和指令系统 46 
 <br /> 5.1 引言 46 
 <br /> 5.2 数学功能、方便性和代价 46 
 <br /> 5.3 指令系统及表示 47 
 <br /> 5.4 操作码、操作数和结果 47 
 <br /> 5.5 典型的指令格式 47 
 <br /> 5.6 可变长度指令和固定长度指令 48 
 <br /> 5.7 通用寄存器 48 
 <br /> 5.8 浮点寄存器和寄存器标识 49 
 <br /> 5.9 利用寄存器编程 49 
 <br /> 5.10 寄存器组 50 
 <br /> 5.11 复杂指令系统和简化指令系统 51 
 <br /> 5.12 RISC设计和执行流水线 51 
 <br /> 5.13 流水线和指令阻塞 53 
 <br /> 5.14 流水线阻塞的另外一些原因 54 
 <br /> 5.15 对程序员的影响 54 
 <br /> 5.16 编程、阻塞及空操作 55 
 <br /> 5.17 提前传递 55 
 <br /> 5.18 操作的类型 55 
 <br /> 5.19 程序计数器、读取-执行及转移 56 
 <br /> 5.20 子程序调用、变量及寄存器窗口 57 
 <br /> 5.21 指令系统的一个例子 58 
 <br /> 5.22 最低限度指令系统 60 
 <br /> 5.23 正交性原则 60 
 <br /> 5.24 条件码和条件转移 61 
 <br /> 5.25 小结 61 
 <br /> 习题 62
</div> 
<div> 
</div> 
<div>
  第6章 操作数寻址和指令表示 63 
 <br /> 6.1 引言 63 
 <br /> 6.2 零地址、一地址、二地址及三地址设计 63 
 <br /> 6.3 零操作数指令 64 
 <br /> 6.4 单操作数指令 64 
 <br /> 6.5 双操作数指令 64 
 <br /> 6.6 三操作数指令 65 
 <br /> 6.7 操作数源和立即值 65 
 <br /> 6.8 冯?诺依曼瓶颈 66 
 <br /> 6.9 显式和隐式操作数编码 66 
 <br /> 6.9.1 隐式操作数编码 67 
 <br /> 6.9.2 显式操作数编码 67 
 <br /> 6.10 组合多个值的操作数 68 
 <br /> 6.11 操作数选择的权衡 68 
 <br /> 6.12 存储器中的数值和间接引用 69 
 <br /> 6.13 操作数寻址方式 70 
 <br /> 6.14 小结 70 
 <br /> 习题 71
</div> 
<div> 
</div> 
<div>
  第7章 CPU：微代码、保护及处理器模式 72 
 <br /> 7.1 引言 72 
 <br /> 7.2 中央处理器 72 
 <br /> 7.3 CPU的复杂性 72 
 <br /> 7.4 执行模式 73 
 <br /> 7.5 向后兼容 73 
 <br /> 7.6 改变模式 74 
 <br /> 7.7 特权和保护 75 
 <br /> 7.8 多级保护 75 
 <br /> 7.9 微代码指令 76 
 <br /> 7.10 微代码的变体 77 
 <br /> 7.11 微代码的优点 77 
 <br /> 7.12 让程序员看到微代码 78 
 <br /> 7.13 纵向微代码 78 
 <br /> 7.14 横向微代码 79 
 <br /> 7.15 例示横向微代码 80 
 <br /> 7.16 一个横向微代码的例子 81 
 <br /> 7.17 要求多个周期的操作 82 
 <br /> 7.18 横向微代码和并行执行 82 
 <br /> 7.19 高性能执行 83 
 <br /> 7.20 并行性和执行次序 84 
 <br /> 7.21 指令的乱序执行 84 
 <br /> 7.22 条件转移和转移预测 84 
 <br /> 7.23 对程序员的影响 85 
 <br /> 7.24 小结 85 
 <br /> 习题 86
</div> 
<div> 
</div> 
<div>
  第8章 汇编语言和程序设计范例 87 
 <br /> 8.1 引言 87 
 <br /> 8.2 高级程序设计语言的特征 87 
 <br /> 8.3 低级程序设计语言的特征 88 
 <br /> 8.4 汇编语言 88 
 <br /> 8.5 汇编语言语法和操作码 89 
 <br /> 8.5.1 语句格式 89 
 <br /> 8.5.2 操作码命名 89 
 <br /> 8.5.3 注释约定 90 
 <br /> 8.6 操作数的次序 90 
 <br /> 8.7 寄存器命名 91 
 <br /> 8.8 操作数类型 92 
 <br /> 8.9 汇编语言程序设计范式和风格 92 
 <br /> 8.10 用于条件执行的汇编代码 93 
 <br /> 8.11 用于可选条件执行的汇编代码 93 
 <br /> 8.12 用于限定循环的汇编代码 94 
 <br /> 8.13 用于未限定循环的汇编代码 94 
 <br /> 8.14 用于过程调用的汇编代码 95 
 <br /> 8.15 用于参数化过程调用的汇编代码 95 
 <br /> 8.16 对程序员的影响 96 
 <br /> 8.17 用于函数调用的汇编代码 96 
 <br /> 8.18 汇编语言和高级语言之间的交互作用 97 
 <br /> 8.19 用于变量和存储的汇编代码 97 
 <br /> 8.20 二次扫描汇编程序 98 
 <br /> 8.21 汇编语言宏指令 99 
 <br /> 8.22 小结 101
</div> 
<div> 
</div> 
<div>
  第3部分 存 储 器
</div> 
<div> 
</div> 
<div>
  第9章 存储器和存储 104 
 <br /> 9.1 引言 104 
 <br /> 9.2 定义 104 
 <br /> 9.3 存储器的两个关键方面 104 
 <br /> 9.4 存储器工艺的特性 105 
 <br /> 9.4.1 存储器的易失性 105 
 <br /> 9.4.2 存储器访问范式 105 
 <br /> 9.4.3 数值的持久性 105 
 <br /> 9.4.4 主存储器和辅助存储器 106 
 <br /> 9.5 重要的存储器分级概念 106 
 <br /> 9.6 指令和数据的储存 106 
 <br /> 9.7 读写范式 107 
 <br /> 9.8 小结 107
</div> 
<div> 
</div> 
<div>
  第10章 物理存储器和物理寻址 108 
 <br /> 10.1 引言 108 
 <br /> 10.2 计算机存储器的特性 108 
 <br /> 10.3 静态和动态RAM的工艺技术 108 
 <br /> 10.4 存储器工艺技术的度量 110 
 <br /> 10.5 密度 110 
 <br /> 10.6 读性能和写性能的分离 110 
 <br /> 10.7 等待时间和存储器控制器 110 
 <br /> 10.8 同步存储器技术 111 
 <br /> 10.9 多倍数据速率存储器技术 112 
 <br /> 10.10 存储器工艺技术的例子 112 
 <br /> 10.11 存储器组织结构 112 
 <br /> 10.12 存储器存取和存储器总线 113 
 <br /> 10.13 存储器的传输容量 113 
 <br /> 10.14 物理地址和字 113 
 <br /> 10.15 物理存储器操作 114 
 <br /> 10.16 字长和其他数据类型 114 
 <br /> 10.17 一个极端情况：字节寻址 114 
 <br /> 10.18 以字传输的字节寻址 115 
 <br /> 10.19 利用2的幂 116 
 <br /> 10.20 字节对齐和程序设计 116 
 <br /> 10.21 存储器容量和地址空间 117 
 <br /> 10.22 用字寻址程序设计 117 
 <br /> 10.23 存储器容量的量度 118 
 <br /> 10.24 指针和数据结构 118 
 <br /> 10.25 存储器转储 119 
 <br /> 10.26 间接性和间接操作数 120 
 <br /> 10.27 存储体和交叉存取 120 
 <br /> 10.28 按内容存取存储器 121 
 <br /> 10.29 三元CAM 122 
 <br /> 10.30 小结 122 
 <br /> 习题 123
</div> 
<div> 
</div> 
<div>
  第11章 虚拟存储器技术和虚拟寻址 124 
 <br /> 11.1 引言 124 
 <br /> 11.2 定义 124 
 <br /> 11.3 一个虚拟的例子：字节寻址 124 
 <br /> 11.4 虚拟存储器术语 124 
 <br /> 11.5 对多个物理存储器系统的接口 125 
 <br /> 11.6 地址转换或地址映射 126 
 <br /> 11.7 避免算术运算 127 
 <br /> 11.8 不连续地址空间 127 
 <br /> 11.9 其他的存储器组织 128 
 <br /> 11.10 采用虚拟存储器的动机 129 
 <br /> 11.11 多虚拟空间和多道程序设计 129 
 <br /> 11.12 多级的虚拟化 130 
 <br /> 11.13 动态地创建虚拟空间 130 
 <br /> 11.14 起点-界限寄存器 131 
 <br /> 11.15 改变虚拟空间 132 
 <br /> 11.16 虚存、起点-界限和保护 132 
 <br /> 11.17 分段 132 
 <br /> 11.18 请求式分页 133 
 <br /> 11.19 用于请求式分页的硬件和软件 133 
 <br /> 11.20 页面替换 134 
 <br /> 11.21 分页的术语和数据结构 134 
 <br /> 11.22 分页系统中的地址转换 135 
 <br /> 11.23 利用2的幂 136 
 <br /> 11.24 存在位、使用位和修改位 137 
 <br /> 11.25 页表的存储 137 
 <br /> 11.26 分页效率和快速转换旁视缓冲器 138 
 <br /> 11.27 对程序员的影响 138 
 <br /> 11.28 小结 139 
 <br /> 习题 140
</div> 
<div> 
</div> 
<div>
  第12章 高速缓存和高速缓存技术 141 
 <br /> 12.1 引言 141 
 <br /> 12.2 定义 141 
 <br /> 12.3 高速缓存的特性 142 
 <br /> 12.4 高速缓存技术的重要性 142 
 <br /> 12.5 高速缓存技术的例子 143 
 <br /> 12.6 高速缓存术语 143 
 <br /> 12.7 高速缓存性能的最好情况和最坏情况 144 
 <br /> 12.8 对一个典型序列的高速缓存性能 145 
 <br /> 12.9 高速缓存的替换策略 145 
 <br /> 12.10 LRU替代策略 146 
 <br /> 12.11 多级高速缓存结构 146 
 <br /> 12.12 预装高速缓存 147 
 <br /> 12.13 存储器使用高速缓存 147 
 <br /> 12.14 TLB作为高速缓存 148 
 <br /> 12.15 请求式分页作为一种高速缓存形式 148 
 <br /> 12.16 物理存储器高速缓存 148 
 <br /> 12.17 直写和写回 149 
 <br /> 12.18 高速缓存的相关性 149 
 <br /> 12.19 L1，L2和L3高速缓存 150 
 <br /> 12.20 L1，L2和L3高速缓存的大小 151 
 <br /> 12.21 指令高速缓存和数据高速缓存 151 
 <br /> 12.22 虚拟存储器高速缓存技术和高速缓存排空 152 
 <br /> 12.23 存储器高速缓存技术的实现 153 
 <br /> 12.24 直接映射存储器高速缓存 153 
 <br /> 12.25 为提高效率而采用2的幂 154 
 <br /> 12.26 组相联存储器高速缓存 155 
 <br /> 12.27 对程序员的影响 156 
 <br /> 12.28 小结 156 
 <br /> 习题 157
</div> 
<div> 
</div> 
<div>
  第4部分 输入和输出
</div> 
<div> 
</div> 
<div>
  第13章 输入输出概念和术语 160 
 <br /> 13.1 引言 160 
 <br /> 13.2 输入和输出设备 160 
 <br /> 13.3 外部设备的控制 160 
 <br /> 13.4 数据传送 161 
 <br /> 13.5 串行和并行数据传送 162 
 <br /> 13.6 自同步数据 162 
 <br /> 13.7 全双工交互和半双工交互 163 
 <br /> 13.8 接口的等待时间和吞吐量 163 
 <br /> 13.9 多路传输的基本思想 163 
 <br /> 13.10 每个外部接口连接多个设备 164 
 <br /> 13.11 处理器的I/O视图 165 
 <br /> 13.12 小结 165
</div> 
<div> 
</div> 
<div>
  第14章 总线和总线体系结构 166 
 <br /> 14.1 引言 166 
 <br /> 14.2 总线的定义 166 
 <br /> 14.3 处理器、I/O设备与总线 166 
 <br /> 14.4 专有总线和标准化总线 167 
 <br /> 14.5 共享总线和存取协议 167 
 <br /> 14.6 多个总线 167 
 <br /> 14.7 并行、无源机制 167 
 <br /> 14.8 物理连接 168 
 <br /> 14.9 总线接口 168 
 <br /> 14.10 地址线、控制线和数据线 169 
 <br /> 14.11 读取-存储范式 170 
 <br /> 14.12 总线上的读取-存储 170 
 <br /> 14.13 总线的宽度 171 
 <br /> 14.14 多路传输 171 
 <br /> 14.15 总线宽度和数据项的大小 172 
 <br /> 14.16 总线地址空间 172 
 <br /> 14.17 潜在的错误 173 
 <br /> 14.18 地址配置和插座 174 
 <br /> 14.19 多个总线还是一个总线 175 
 <br /> 14.20 设备所用的读取-存储 175 
 <br /> 14.21 一个使用读取-存储的设备控制例子 175 
 <br /> 14.22 接口的操作 176 
 <br /> 14.23 不对称指派 176 
 <br /> 14.24 统一的存储器和设备寻址 177 
 <br /> 14.25 地址空间里的空洞 178 
 <br /> 14.26 地址映射 178 
 <br /> 14.27 对总线的程序接口 179 
 <br /> 14.28 两个总线间的桥接 180 
 <br /> 14.29 主总线和辅助总线 180 
 <br /> 14.30 对程序员的影响 181 
 <br /> 14.31 切换组构网 182 
 <br /> 14.32 小结 183 
 <br /> 习题 183
</div> 
<div> 
</div> 
<div>
  第15章 程序控制I/O和中断驱动I/O 184 
 <br /> 15.1 引言 184 
 <br /> 15.2 I/O范式 184 
 <br /> 15.3 程序控制I/O 184 
 <br /> 15.4 同步 185 
 <br /> 15.5 轮询 185 
 <br /> 15.6 用于轮询的代码 185 
 <br /> 15.7 控制和状态寄存器 187 
 <br /> 15.8 处理器使用和轮询 187 
 <br /> 15.9 第一代、第二代和第三代计算机 188 
 <br /> 15.10 中断驱动I/O 188 
 <br /> 15.11 硬件中断机制 189 
 <br /> 15.12 中断和读取-执行周期 189 
 <br /> 15.13 中断的处理 189 
 <br /> 15.14 中断向量 190 
 <br /> 15.15 初始化和中断的允许及禁止 191 
 <br /> 15.16 防止中断代码被中断 191 
 <br /> 15.17 多级中断 191 
 <br /> 15.18 中断向量和优先权的指派 192 
 <br /> 15.19 动态总线连接和可插入的设备 193 
 <br /> 15.20 中断的优点 193 
 <br /> 15.21 灵巧的设备和改进的I/O性能 193 
 <br /> 15.22 直接存储器存取（DMA） 194 
 <br /> 15.23 缓冲链接 195 
 <br /> 15.24 分散读和集中写操作 195 
 <br /> 15.25 操作链接 196 
 <br /> 15.26 小结 196 
 <br /> 习题 197
</div> 
<div> 
</div> 
<div>
  第16章 程序员眼中的设备、I/O和缓冲 198 
 <br /> 16.1 引言 198 
 <br /> 16.2 设备驱动器的定义 198 
 <br /> 16.3 设备无关性、密封和隐藏 198 
 <br /> 16.4 设备驱动器的概念性部件 199 
 <br /> 16.5 两种类型的设备 200 
 <br /> 16.6 一个设备驱动器的操作流程的例子 200 
 <br /> 16.7 队列的输出操作 201 
 <br /> 16.8 强制中断 202 
 <br /> 16.9 队列的输入操作 203 
 <br /> 16.10 支持双向传送的设备 203 
 <br /> 16.11 异步还是同步编程范式 204 
 <br /> 16.12 异步性、灵巧设备和互斥 204 
 <br /> 16.13 应用程序所见的I/O 205 
 <br /> 16.14 运行时I/O程序库 205 
 <br /> 16.15 程序库和操作系统的两分法 206 
 <br /> 16.16 操作系统支持的I/O操作 207 
 <br /> 16.17 I/O操作的代价 207 
 <br /> 16.18 降低系统调用开销 208 
 <br /> 16.19 缓冲的重要概念 208 
 <br /> 16.20 缓冲的实现 209 
 <br /> 16.21 排空缓冲器 210 
 <br /> 16.22 输入的缓冲 211 
 <br /> 16.23 缓冲的效能 211 
 <br /> 16.24 操作系统中的缓冲 212 
 <br /> 16.25 与高速缓存的关系 212 
 <br /> 16.26 一个例子：Unix标准I/O库 212 
 <br /> 16.27 小结 212 
 <br /> 习题 213
</div> 
<div> 
</div> 
<div>
  第5部分 高 级 课 题
</div> 
<div> 
</div> 
<div>
  第17章 并行性 216 
 <br /> 17.1 引言 216 
 <br /> 17.2 并行和流水线体系结构 216 
 <br /> 17.3 并行性的特征 216 
 <br /> 17.4 微观并行性与宏观并行性 217 
 <br /> 17.5 微观并行性的例子 217 
 <br /> 17.6 宏观并行性的例子 218 
 <br /> 17.7 对称并行性与非对称并行性 218 
 <br /> 17.8 细粒并行性与粗粒并行性 219 
 <br /> 17.9 显式的与隐式的并行性 219 
 <br /> 17.10 并行体系结构 219 
 <br /> 17.11 并行体系结构的类型（弗林分类法） 219 
 <br /> 17.12 单指令单数据流（SISD） 220 
 <br /> 17.13 单指令多数据流（SIMD） 220 
 <br /> 17.14 多指令多数据流（MIMD） 222 
 <br /> 17.15 通信、协调和争用 224 
 <br /> 17.16 多处理器的性能 225 
 <br /> 17.17 对程序员的影响 226 
 <br /> 17.17.1 锁和互斥 226 
 <br /> 17.17.2 显式和隐式并行计算机的编程 228 
 <br /> 17.17.3 对称多处理器和非对称多处理器的编程 228 
 <br /> 17.18 冗余并行体系结构 228 
 <br /> 17.19 分布计算机和群集计算机 229 
 <br /> 17.20 小结 229 
 <br /> 习题 230
</div> 
<div> 
</div> 
<div>
  第18章 流水线技术 231 
 <br /> 18.1 引言 231 
 <br /> 18.2 流水线技术的概念 231 
 <br /> 18.3 软件流水线技术 233 
 <br /> 18.4 软件流水线的性能和开销 233 
 <br /> 18.5 硬件流水线技术 234 
 <br /> 18.6 硬件流水线技术怎样提高性能 234 
 <br /> 18.7 流水线的使用时机 236 
 <br /> 18.8 处理的概念性分割 237 
 <br /> 18.9 流水线体系结构 237 
 <br /> 18.10 流水线的建立时间、阻塞时间和排空时间 238 
 <br /> 18.11 超级流水线体系结构的定义 238 
 <br /> 18.12 小结 239 
 <br /> 习题 239
</div> 
<div> 
</div> 
<div>
  第19章 性能评估 240 
 <br /> 19.1 引言 240 
 <br /> 19.2 能力和性能的测量 240 
 <br /> 19.3 计算能力的测量 241 
 <br /> 19.4 使用专门的指令计数 242 
 <br /> 19.5 指令混合比 242 
 <br /> 19.6 标准化的基准测试程序 243 
 <br /> 19.7 I/O和存储器瓶颈 243 
 <br /> 19.8 软、硬件之间的分界 244 
 <br /> 19.9 选择要优化的项目 244 
 <br /> 19.10 艾姆德尔法则和并行系统 245 
 <br /> 19.11 小结 245 
 <br /> 习题 245
</div> 
<div> 
</div> 
<div>
  第20章 体系结构的层次和例子 246 
 <br /> 20.1 引言 246 
 <br /> 20.2 体系结构的层次 246 
 <br /> 20.3 系统级体系结构：个人计算机 247 
 <br /> 20.4 总线互连和桥接 247 
 <br /> 20.5 控制器芯片和物理体系结构 248 
 <br /> 20.6 虚拟总线 249 
 <br /> 20.7 连接速度 250 
 <br /> 20.8 桥接功能和虚拟总线 251 
 <br /> 20.9 电路板级体系结构 251 
 <br /> 20.10 芯片级体系结构 252 
 <br /> 20.11 芯片上功能部件的结构 253 
 <br /> 20.12 小结 254 
 <br /> 20.13 计算机系统结构之外的分级 254
</div> 
<div> 
</div> 
<div>
  附录A 计算机系统结构课程实验 255 
 <br /> A.1 引言 255 
 <br /> A.2 实验所用的数字硬件 255 
 <br /> A.3 免焊实验电路板 255 
 <br /> A.4 免焊实验电路板的使用 256 
 <br /> A.5 测试 256 
 <br /> A.6 电源和接地连接 257 
 <br /> A.7 实验练习题 258
</div> 
<div> 
</div> 
<div>
  实验1 入门和账号配置 259 
 <br /> 实验2 数字逻辑：实验电路板的使用 260 
 <br /> 实验3 数字逻辑：用门电路构建一个加法器 262 
 <br /> 实验4 数字逻辑：时钟和多路分配 264 
 <br /> 实验5 表示法：测试大端法与小端法 266 
 <br /> 实验6 表示法：一个用C编写的十六进制转储程序 268 
 <br /> 实验7 处理器：学习RISC汇编语言 270 
 <br /> 实验8 处理器：能被C程序调用的函数 272 
 <br /> 实验9 存储器：数组的行主序存储和列主序存储 273 
 <br /> 实验10 输入输出：一个缓冲I/O库 275 
 <br /> 实验11 用汇编语言编写的十六进制转储程序 277 
 <br /> 参考书目 278
</div></div></body></html>