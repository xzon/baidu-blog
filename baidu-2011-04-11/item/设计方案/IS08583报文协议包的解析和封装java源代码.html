<html><head><title>IS08583报文协议包的解析和封装java源代码</title></head><body><div id='tit'>IS08583报文协议包的解析和封装java源代码</div><div id='cate'>设计方案</div><div id='date'>2009年08月10日 星期一 04:37 P.M.</div><div id='page'>39</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/1fad33fa939edc809f514663.html'>http://hi.baidu.com/hxzon/blog/item/1fad33fa939edc809f514663.html</a><div id='cnt'><p><a class="postTitle2" href="http://www.cnblogs.com/dengzhaozhe/archive/2009/05/09/1453251.html">IS08583报文协议包的解析和封装java源代码</a></p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前段时间做了一个涉及到IS08583报文协议的项目，自己总结写了这篇附有java源代码的文章，希望能给大家提供一些帮助，本文分四个部分介绍IS08583报文协议包的处理及如何解析请求包及怎样封装返回包，</p> 
<p><strong>一：IS08583包介绍：</strong></p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; ISO8583包（简称8583包）是一个国际标准的包格式，最多由128个字段域组成，每个域都有统一的规定，并有定长与变长之分。<br /> 8583包前面一段为位图，用来确定包的字段域组成情况。其中位图是8583包的灵魂，它是打包解包确定字段域的关键， 而了解每个字段域的属性则是填写数据的基础。&nbsp;&nbsp;&nbsp;</p> 
<p>1：位图说明：</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; 位置：在8583包的第1 位<br /> &nbsp;&nbsp;&nbsp;&nbsp; 格式：定长 <br /> &nbsp;&nbsp;&nbsp;&nbsp; 类型：B16（二进制16位，16*8=128bit） <br /> &nbsp;&nbsp;&nbsp;&nbsp; 描述：&nbsp;&nbsp;<br /> &nbsp;&nbsp;&nbsp;&nbsp; 如将位图的第一位设为'1'，表示使用扩展位图（128个域），否则表示只使用基本位图（64个域）。&nbsp;&nbsp;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如使用某数据域，应在位图中将相应的位设位'1'，如使用41域，需将位图的41位设为'1'。&nbsp;&nbsp;<br /> &nbsp;&nbsp;&nbsp;&nbsp; 选用条件：如使用65到128域，需设位图域第一位为'1'&nbsp;&nbsp;<br /> 2：域的定义： <br /> typedef struct ISO8583 <br /> { <br /> int bit_flag;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*域数据类型0 -- string, 1 -- int, 2 -- binary*/ <br /> char *data_name; /*域名*/ <br /> int length;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*数据域长度*/ <br /> int length_in_byte;/*实际长度（如果是变长）*/ <br /> int variable_flag; /*是否变长标志0：否 2：2位变长, 3：3位变长*/ <br /> int datatyp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*0 -- string, 1 -- int, 2 -- binary*/ <br /> char *data;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*存放具体值*/ <br /> int attribute;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*保留*/ <br /> } ISO8583;<br /> <br /> <strong>二：定义BitMap类</strong></p> 
<p>类说明：根据ISO8583 包的域定义，定义BitMap类存储每个域的信息。例如：</p> 
<p>package com.lottery.pos.model;</p> 
<p>public class BitMap {<br /> private int bit; //位<br /> private int bittype; //数据类型 1 ascii 2 binary<br /> private int variable; //是否变长0 不是 2 两位变长 3 三位变长<br /> private int len; //数据长度<br /> private byte[] dat; //数据<br /> <br /> public int getBit() {<br /> &nbsp;&nbsp; return bit;<br /> }<br /> public void setBit(int bit) {<br /> &nbsp;&nbsp; this.bit = bit;<br /> }<br /> public int getBittype() {<br /> &nbsp;&nbsp; return bittype;<br /> }<br /> public void setBittype(int bittype) {<br /> &nbsp;&nbsp; this.bittype = bittype;<br /> }<br /> public int getVariable() {<br /> &nbsp;&nbsp; return variable;<br /> }<br /> public void setVariable(int variable) {<br /> &nbsp;&nbsp; this.variable = variable;<br /> }<br /> public byte[] getDat() {<br /> &nbsp;&nbsp; return dat;<br /> }<br /> public void setDat(byte[] dat) {<br /> &nbsp;&nbsp; this.dat = dat;<br /> }<br /> public int getLen() {<br /> &nbsp;&nbsp; return len;<br /> }<br /> public void setLen(int len) {<br /> &nbsp;&nbsp; this.len = len;<br /> }</p> 
<p><br /> }</p> 
<p> </p> 
<p><strong>三：定义PortConfig类</strong></p> 
<p>类说明：定义配置信息类。根据此类解析和封装数据。例如：</p> 
<p>package com.lottery.pos.model;</p> 
<p>public class PortConfig {<br /> /**<br /> * 存放所有接口的配置信息<br /> * [][0] bit&nbsp;&nbsp;&nbsp;&nbsp; 位:在Map中的位<br /> * [][1] type&nbsp;&nbsp; 类型:1 ascii 2 binary<br /> * [][2] len&nbsp;&nbsp;&nbsp; 长度:(对定长有效)<br /> * [][3] varLen 变长:0非变长 2位变长 3位变长<br /> */<br /> // 定义一个二位数组存放配置信息。<br /> public static final int[][] config= { <br /> &nbsp;&nbsp;&nbsp; {11,1,6,0}, <br /> &nbsp;&nbsp;&nbsp; {12,1,6,0},<br /> &nbsp;&nbsp;&nbsp; {13,1,4,0}, <br /> &nbsp;&nbsp;&nbsp; {32,1,11,0},<br /> &nbsp;&nbsp;&nbsp; {37,1,12,0},<br /> &nbsp;&nbsp;&nbsp; {39,1,2,0},<br /> &nbsp;&nbsp;&nbsp; {40,2,50,2},<br /> &nbsp;&nbsp;&nbsp; {41,1,8,0},<br /> &nbsp;&nbsp;&nbsp; {48,1,52,3},<br /> &nbsp;&nbsp;&nbsp; {120,2,128,3},<br /> &nbsp;&nbsp;&nbsp; };</p> 
<p>｝</p> 
<p><strong>四：定义BitMapiso类</strong></p> 
<p>类说明：此类提供解析请求包和封装信息包两个方法，例如：</p> 
<p>package com.lottery.pos.utils;</p> 
<p>import java.util.ArrayList;<br /> import java.util.List;</p> 
<p>import com.lottery.pos.model.BitMap;</p> 
<p>public class BitMapiso {</p> 
<p>/**<br /> * 解析请求包<br /> * @param body<br /> * @param config<br /> * @return List<br /> */<br /> @SuppressWarnings(&quot;unchecked&quot;)<br /> public static List unpackRequest(byte[] body, int[][] config) {<br /> &nbsp;&nbsp; List outList = new ArrayList();<br /> &nbsp;&nbsp; // 取得除信息类型以外的包信息。也就是取得位图的初始位置。<br /> &nbsp;&nbsp; byte[] realbody = new byte[body.length - 4];<br /> &nbsp;&nbsp; System.arraycopy(body, 4, realbody, 0, realbody.length);<br /> &nbsp;&nbsp; // 取得位图<br /> &nbsp;&nbsp; byte[] map = null;<br /> &nbsp;&nbsp; byte[] map8 = new byte[8];<br /> &nbsp;&nbsp; System.arraycopy(realbody, 0, map8, 0, 8);<br /> &nbsp;&nbsp; boolean[] bmap8 = LoUtils.getBinaryFromByte(map8);<br /> &nbsp;&nbsp; if (bmap8[1]) {<br /> &nbsp;&nbsp; // 如果第一位为1，则是可扩展位图，设为16字节长度。<br /> &nbsp;&nbsp;&nbsp; map = new byte[16];<br /> &nbsp;&nbsp;&nbsp; System.arraycopy(realbody, 0, map, 0, 16);<br /> &nbsp;&nbsp; } else {<br /> &nbsp;&nbsp;&nbsp; map = map8;<br /> &nbsp;&nbsp; }<br /> &nbsp;&nbsp; boolean[] bmap = LoUtils.getBinaryFromByte(map);</p> 
<p>&nbsp;&nbsp; int tmplen = map.length;<br /> &nbsp;&nbsp; for (int i = 2; i &lt; bmap.length; i++) {<br /> &nbsp;&nbsp;&nbsp; if (bmap[i]) {<br /> &nbsp;&nbsp;&nbsp;&nbsp; //BitMap bitMap = null;<br /> &nbsp;&nbsp;&nbsp;&nbsp; // 寻找位图中的1对应的数据<br /> &nbsp;&nbsp;&nbsp;&nbsp; int bit=-1;<br /> &nbsp;&nbsp;&nbsp;&nbsp; for (int j = 0; j &lt; config.length; j++) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (config[j][0] == i) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit=j;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp; BitMap outBitMap = new BitMap();<br /> &nbsp;&nbsp;&nbsp;&nbsp; outBitMap.setBit(i);<br /> &nbsp;&nbsp;&nbsp;&nbsp; outBitMap.setBittype(config[bit][1]);<br /> &nbsp;&nbsp;&nbsp;&nbsp; //len对变长是无用的。<br /> &nbsp;&nbsp;&nbsp;&nbsp; outBitMap.setLen(config[bit][2]);<br /> &nbsp;&nbsp;&nbsp;&nbsp; outBitMap.setVariable(config[bit][3]);<br /> &nbsp;&nbsp;&nbsp;&nbsp; byte[] nextData = null;<br /> &nbsp;&nbsp;&nbsp;&nbsp; if (config[bit][3] &gt; 0) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //取出变长部分的值。<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int varLen = config[bit][3];<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (config[bit][1] == 2) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; varLen = varLen - 1;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] varValue = new byte[varLen];<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.arraycopy(realbody, tmplen, varValue, 0, varValue.length);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int datLen = 0;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (config[bit][1] == 2) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datLen = LoUtils.bcdToint(varValue);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datLen = byteToInt(varValue);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmplen += varLen;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 取出变长部分后带的值。<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextData = new byte[datLen];</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.arraycopy(realbody, tmplen, nextData, 0,nextData.length);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmplen += nextData.length;<br /> &nbsp;&nbsp;&nbsp;&nbsp; } else {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextData = new byte[config[bit][2]];<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.arraycopy(realbody, tmplen, nextData, 0,nextData.length);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmplen += config[bit][2];<br /> &nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp; outBitMap.setDat(nextData);<br /> &nbsp;&nbsp;&nbsp;&nbsp; outList.add(outBitMap);<br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp; }</p> 
<p>&nbsp;&nbsp; return outList;<br /> }</p> 
<p> </p> 
<p>/**<br /> * 打包响应包,不包括消息类型<br /> * @param list<br /> * @return byte[]<br /> */<br /> @SuppressWarnings(&quot;unchecked&quot;)<br /> public static byte[] PackResponse(List list) {<br /> &nbsp;&nbsp; int len = 16;<br /> &nbsp;&nbsp; for (int i = 0; i &lt; list.size(); i++) {<br /> &nbsp;&nbsp;&nbsp; BitMap bitMap = (BitMap) list.get(i);<br /> &nbsp;&nbsp;&nbsp; // 计算请求包总长度<br /> &nbsp;&nbsp;&nbsp; if (bitMap.getBittype() == 2) {<br /> &nbsp;&nbsp;&nbsp;&nbsp; if (bitMap.getVariable() &gt; 0) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len += bitMap.getVariable() - 1 + bitMap.getDat().length;<br /> &nbsp;&nbsp;&nbsp;&nbsp; } else {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len += bitMap.getVariable() + bitMap.getDat().length;<br /> &nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; } else {<br /> &nbsp;&nbsp;&nbsp;&nbsp; len += bitMap.getVariable() + bitMap.getDat().length;<br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp; }<br /> &nbsp;&nbsp; byte[] body = new byte[len];<br /> &nbsp;&nbsp; // 位图<br /> &nbsp;&nbsp; boolean[] bbitMap = new boolean[129];<br /> &nbsp;&nbsp; bbitMap[1] = true;<br /> &nbsp;&nbsp; int temp = (bbitMap.length - 1) / 8;<br /> &nbsp;&nbsp; for (int j = 0; j &lt; list.size(); j++) {<br /> &nbsp;&nbsp;&nbsp; BitMap bitMap = (BitMap) list.get(j);<br /> &nbsp;&nbsp;&nbsp; bbitMap[bitMap.getBit()] = true;<br /> &nbsp;&nbsp;&nbsp; byte[] bitmap = LoUtils.getByteFromBinary(bbitMap);<br /> &nbsp;&nbsp;&nbsp; System.arraycopy(bitmap, 0, body, 0, bitmap.length);<br /> &nbsp;&nbsp;&nbsp; // 数据<br /> &nbsp;&nbsp;&nbsp; if (bitMap.getVariable() &gt; 0) {<br /> &nbsp;&nbsp;&nbsp;&nbsp; // 数据是可变长的:拼变长的值<br /> &nbsp;&nbsp;&nbsp;&nbsp; byte[] varValue = null;<br /> &nbsp;&nbsp;&nbsp;&nbsp; if (bitMap.getBittype() == 2) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; varValue = LoUtils.StrToBCDBytes(String.format(&quot;%0&quot;+ bitMap.getVariable() + &quot;d&quot;,bitMap.getDat().length));<br /> &nbsp;&nbsp;&nbsp;&nbsp; } else {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; varValue = String.format(&quot;%0&quot; + bitMap.getVariable() + &quot;d&quot;,bitMap.getDat().length).getBytes();<br /> &nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp; System.arraycopy(varValue, 0, body, temp, varValue.length);<br /> &nbsp;&nbsp;&nbsp;&nbsp; temp += varValue.length;<br /> &nbsp;&nbsp;&nbsp;&nbsp; // 拼变长部分后所带的数的值。<br /> &nbsp;&nbsp;&nbsp;&nbsp; System.arraycopy(bitMap.getDat(), 0, body, temp, bitMap.getDat().length);<br /> &nbsp;&nbsp;&nbsp;&nbsp; temp += bitMap.getDat().length;<br /> &nbsp;&nbsp;&nbsp; } else {<br /> &nbsp;&nbsp;&nbsp;&nbsp; // 数据是固定长度的。<br /> &nbsp;&nbsp;&nbsp;&nbsp; byte dat[] =new byte[bitMap.getLen()];<br /> &nbsp;&nbsp;&nbsp;&nbsp; if (bitMap.getDat().length!=bitMap.getLen()){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.arraycopy(bitMap.getDat(), 0, dat, 0, bitMap.getLen());<br /> &nbsp;&nbsp;&nbsp;&nbsp; }else{<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dat=bitMap.getDat();<br /> &nbsp;&nbsp;&nbsp;&nbsp; } <br /> &nbsp;&nbsp;&nbsp;&nbsp; System.arraycopy(dat, 0, body, temp, dat.length);<br /> &nbsp;&nbsp;&nbsp;&nbsp; temp += bitMap.getDat().length;<br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp; }<br /> &nbsp;&nbsp; return body;<br /> }</p> 
<p> </p> 
<p>｝</p> 
<p>源代码测试没有问题。<br /> <a href="http://www.cnblogs.com/dengzhaozhe/archive/2009/05/09/1453251.html">http://www.cnblogs.com/dengzhaozhe/archive/2009/05/09/1453251.html</a></p></div></body></html>