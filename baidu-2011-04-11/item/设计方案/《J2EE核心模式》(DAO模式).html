<html><head><title>《J2EE核心模式》(DAO模式)</title></head><body><div id='tit'>《J2EE核心模式》(DAO模式)</div><div id='cate'>设计方案</div><div id='date'>2008年03月11日 星期二 01:57 P.M.</div><div id='page'>159</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/c4190924209e6637c895598c.html'>http://hi.baidu.com/hxzon/blog/item/c4190924209e6637c895598c.html</a><div id='cnt'><table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="560" border="0"> 
 <tbody> 
  <tr> 
   <th class="f24"><font color="#05006c">《J2EE核心模式》(DAO模式)</font></th> 
  </tr> 
  <tr> 
   <td>
    <hr size="1" bgcolor="#d9d9d9" /> </td> 
  </tr> 
  <tr> 
   <td align="center" height="20"> 
    <div align="center">
     佚名&nbsp;&nbsp; 2005-04-02 10:50:43&nbsp;&nbsp; 不详
    </div> </td> 
  </tr> 
  <tr> 
   <td height="15"> </td> 
  </tr> 
  <tr> 
   <td class="l17"><font class="f14"> <p> </p>
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 很多的J2EE应用程序需<br /> 是各不相同的，并且用来访<br /> 序要在不同的持久性存储间</td> 
        <td class="content" nowrap="nowrap">要使用持久性数据(数据库、文<br /> 问这些不同的持久性存储机制的<br /> 迁移，这些访问特定持久存储层</td> 
        <td class="content" nowrap="nowrap">件等)。不同的程序，持久性存储<br /> API也有很大的不同。如果应用程<br /> 的代码将面临重写。</td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 如何解决这个问题?且看&quot;DAO模式&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 数据访问对象(Data Acess Object) 模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="100%" align="center" border="0"> 
      <tbody> 
       <tr> 
        <td class="content"> <strong>一.环境</strong></td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 根据数据源不同，数据<br /> 件等等)和供应商实现不同</td> 
        <td class="content" nowrap="nowrap">访问也不同。根据存储的类型(<br /> ，持久性存储(比如数据库)的访</td> 
        <td class="content" nowrap="nowrap">关系数据库、面向对象数据库、文<br /> 问差别也很大。</td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="100%" align="center" border="0"> 
      <tbody> 
       <tr> 
        <td class="content"> <strong>二.问题</strong></td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 许多真是的J2EE应用程<br /> 存储是使用不同的机制实现<br /> 同。</td> 
        <td class="content" nowrap="nowrap">序需要在一定程度上使用持久性<br /> 的,并且用来访问这些不同的持</td> 
        <td class="content" nowrap="nowrap">数据。对于许多应用程序，持久性<br /> 久性存储机制的API也有很大的不</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 比如，应用程序使用实体bean(这里<br /> RDBMS的耦合)的分布式组件来表示持久性<br /> 管理系统(RDBMS)中的数据，这些组件中<br /> 源实现之间的紧密耦合。组件中这类代码<br /> 据源将变得非常麻烦和困难。当数据源变<br /> 据源。</td> 
        <td class="content" nowrap="nowrap">应该是指BMP的bean，CMP的bean已大大降低了与<br /> 数据，或者使用JDBC API来访问驻留在某关系数据库<br /> 包含连接性性和数据访问代码会引入这些组件与数据<br /> 依赖性使应用程序从某种数据源迁移到其他种类的数<br /> 化时，组件也需要改变，以便于能够处理新类型的数</td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> (举个例子来说，我们UPTEL系统是使<br /> ，这些JDBC API与SQL语句散布在系统中<br /> 迁移到INFORMIX，就面临重写数据库连接</td> 
        <td class="content" nowrap="nowrap">用JDBC API对 ORACLE数据库进行连接和数据访问的<br /> ，当我们需要将UPTEL迁移到其他RDBMS时，比如曾经<br /> 和访问数据的模块。)</td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="100%" align="center" border="0"> 
      <tbody> 
       <tr> 
        <td class="content"> <strong>三.作用力</strong></td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 1.诸如bean管理的实体<br /> 检索数据，以及进行数据存</td> 
        <td class="content" nowrap="nowrap">bean、会话bean、servlet等组<br /> 储等操作。</td> 
        <td class="content" nowrap="nowrap">件往往需要从持久性存储数据源中</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 2.根据产品供应商的不同，持久性存<br /> 类型不同也有差别，这样存在以下缺点，</td> 
        <td class="content" nowrap="nowrap">储API差别也很大，这些API和其能力同样根据存储的<br /> 即访问这些独立系统的API很不统一。</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 3.组件需要透明于实际<br /> 同存储类型和不同数据源类</td> 
        <td class="content" nowrap="nowrap">的持久性存储或者数据源实现，<br /> 型的更容易的移植性。</td> 
        <td class="content" nowrap="nowrap">以便于提供到不同供应商产品、不</td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="100%" align="center" border="0"> 
      <tbody> 
       <tr> 
        <td class="content"> <strong>四.解决方案</strong></td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 使用数据访问对象(DAO<br /> 连接以便检索和存储数据。</td> 
        <td class="content" nowrap="nowrap">)模式来抽象和封装所有对数据</td> 
        <td class="content" nowrap="nowrap">源的访问。DAO管理着与数据源的</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> DAO实现了用来操作数<br /> 业务组件为其客户端使用DA<br /> 于当低层数据源实现变化时<br /> 不同的存储模式，而不会影<br /> 适配器。</td> 
        <td class="content" nowrap="nowrap">据源的访问机制。数据源可以时<br /> O提供更简单的接口。DAO完全向<br /> ，DAO向客户端提供的接口不会<br /> 响其客户端或者业务组件。重要</td> 
        <td class="content" nowrap="nowrap">RDBMS,LDAP,File等。依赖于DAO的<br /> 客户端隐藏了数据源实现细节。由<br /> 变化，所有该模式允许DAO调整到<br /> 的是,DAO充当组件和数据源之间的</td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> (按照这个理论，如果我们UPTEL系统<br /> 个RDBMS了。梦想总是很完美的，且看看D</td> 
        <td class="content" nowrap="nowrap">使用了DAO模式,就可以无缝的从ORACLE迁移到任何一<br /> AO模式如何实现)</td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 1.结构，图1是表示DAO模式中各种关系的类图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 此主题相关图片如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="100%" align="center" border="0"> 
      <tbody> 
       <tr> 
        <td class="content"> 
         <center>
          <img src="image/《J2EE核心模式》(DAO模式).ht.b373a232edc3759979f3c2620bcff9ee.gif" />
          <p class="origImg">http://www.phome.net/d/file/document/java/2005-04-02/b373a232edc3759979f3c2620bcff9ee.gif</p>
         </center></td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 2.参与者和职责&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 1)BusinessObject(业务对象)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 代表数据客户端。正是该对象需要访问数据源以获取和存储数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 2)DataAccessObject(数据访问对象)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 是该模式的主要对象。DataAccessOb<br /> 保证对数据源的透明访问。BusinessObje<br /> DataAccessObject。</td> 
        <td class="content" nowrap="nowrap">ject抽取该BusinessObject的低层数据访问实现，以<br /> ct也可以把数据加载和存储操作委托给</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 3)DataSource(数据源)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 代表数据源实现。数据</td> 
        <td class="content" nowrap="nowrap">源可以是各RDBMSR数据库，OODB</td> 
        <td class="content" nowrap="nowrap">MS,XML文件等等。</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 4)valueObject(值对象)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 代表用做数据携带着的<br /> 。</td> 
        <td class="content" nowrap="nowrap">值对象。DataAccessObject可以</td> 
        <td class="content" nowrap="nowrap">使用值对象来把数据返回给客户端</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> DataAccessObject也许会接受来自于<br /> 于值对象中来传递。</td> 
        <td class="content" nowrap="nowrap">客户端的数据，其中这些用于更新数据源的数据存放</td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 3.策略&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 1).自动DAO代码产生策略&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 因为每个BusinessObje<br /> 层实现(比如RDBMS中的表)<br /> 写与应用程序有馆的代码生<br /> 就完了，最多自己写几个Ad<br /> 应用程序需要的所有DAO代</td> 
        <td class="content" nowrap="nowrap">ct对应于一个特殊的DAO,因此有<br /> 之间的关系(映射)。一点这些关<br /> 成的简单工具了(什么?自己写GP<br /> apter,牛人就是不同，啥都要自<br /> 码。</td> 
        <td class="content" nowrap="nowrap">可能建立BusinessObject,DAO和低<br /> 系(映射)已经建立，我们就可以编<br /> 程序?用ORM的附带工具自动生成不<br /> 己写...)，其中的工具可以产生该</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 如果DAO需求很复杂，<br /> 的关系映射(这里指的是前<br /> ORM工具有很多:Hibernate,</td> 
        <td class="content" nowrap="nowrap">我们可以采用第三方工具，其中<br /> 面提到的ORM工具，全称是Objec<br /> OJB,Torque,TopLink等等)。</td> 
        <td class="content" nowrap="nowrap">这些工具提供对象到RDBMS数据库<br /> t Relation Mapping,目前成熟的</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 这些工具通常包含GUI工具来把业务<br /> 。一旦这些映射完成，这些工具会自动地<br /> 缓冲、查询缓冲、与应用程序集成，以及</td> 
        <td class="content" nowrap="nowrap">对象映射到持久性存储对象，并且因而定义中间DAO<br /> 生成代码，并且也许会提供其他增值功能，比如结果<br /> 与其他第三方产品(比如分布式缓冲)地继承，等等。</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> （增值服务：Torque提<br /> ,OJB提供JDO API、OMDB AP</td> 
        <td class="content" nowrap="nowrap">供了结果缓冲,Hibernate提供了<br /> I）</td> 
        <td class="content" nowrap="nowrap">对Oracle数据库SQL指令的优化</td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 2).数据访问对象的工厂策略&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 通过调整抽象工厂和工厂方法模式，DAO模式可以达到很高的灵活度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 当低层存储不会随着实现变化而变化<br /> 产生应用程序需要的大量DAO。图2是这种</td> 
        <td class="content" nowrap="nowrap">时，该策略可以使用工厂方法模式来实现该策略。以<br /> 情况下的类图。</td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 此主题相关图片如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="100%" align="center" border="0"> 
      <tbody> 
       <tr> 
        <td class="content"> 
         <center>
          <img src="image/《J2EE核心模式》(DAO模式).ht.d05c65fd29a8d5370c6e93809365e717.jpg" />
          <p class="origImg">http://www.phome.net/d/file/document/java/2005-04-02/d05c65fd29a8d5370c6e93809365e717.jpg</p>
         </center></td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 当低层存储随着实现变化而变化时，该策略可以使用抽象工厂方法模式而实现。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 图3是这种情况下的类图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 此主题相关图片如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="100%" align="center" border="0"> 
      <tbody> 
       <tr> 
        <td class="content"> 
         <center>
          <img src="image/《J2EE核心模式》(DAO模式).ht.140304096edd6b880e1f265829af2e33.gif" />
          <p class="origImg">http://www.phome.net/d/file/document/java/2005-04-02/140304096edd6b880e1f265829af2e33.gif</p>
         </center></td> 
       </tr> 
      </tbody> 
     </table> <br /> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 5.结果&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 1).启用透明性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 业务对象可以是使用数<br /> 是实现被隐藏在DAO的内部</td> 
        <td class="content" nowrap="nowrap">据源，而无须了解该数据源实现<br /> 。</td> 
        <td class="content" nowrap="nowrap">的具体细节。访问是透明的，原因</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 2).启用更容易的迁移&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> DAO层使应用程序更加<br /> 现。因而，该迁移只涉及对<br /> 个低层存储实现提供一个具<br /> 程序提供一个新的工厂实现</td> 
        <td class="content" nowrap="nowrap">容易地迁移到一个不同的数据库<br /> DAO层的变化。更进一步说，如<br /> 体工厂实现。在这种情况下，迁<br /> 。</td> 
        <td class="content" nowrap="nowrap">实现。业务对象不了解低层数据实<br /> 果使用工厂策略，则有可能为每一<br /> 移到不同的迁移实现意味着给应用</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 3).减少业务对象中代码复杂度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 由于DAO管理所有的数据访问复杂性<br /> 代码。所有与实现有关的代码(比如sql语<br /> 样做提高了代码的可读性，已经代码生产</td> 
        <td class="content" nowrap="nowrap">，它可以简化业务对象和其他使用DAO的客户端中的<br /> 句)都被包含在DAO中，而不是包含在业务对象中。这<br /> 效率。</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 4).把所有的数据访问集中到一个独立的层。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 因为所有的数据访问操<br /> 实现与应用程序中的其他代</td> 
        <td class="content" nowrap="nowrap">作现在被委托给DAO,所有单独的<br /> 码相隔离的。这种集中化使应用</td> 
        <td class="content" nowrap="nowrap">数据访问层可以被看作把数据访问<br /> 程序更容易地维护和管理。</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 5).不适用于容器管理的持久性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 由于EJB容器用容器管理的持久性(CM<br /> 性存储访问。使用容器管理的实体bean的<br /> 地提供该功能。然而，当需要组合使用CM</td> 
        <td class="content" nowrap="nowrap">P)来管理实体bean,该容器会自动地服务所有的持久<br /> 应用程序不需要DAO层，因为该应用程序服务器透明<br /> P和BMP时,DAO仍旧有用处。</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 6).添加其他层&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> DAO会在数据客户端和数据源之间创<br /> 便于权衡该模式的好处。但是选择本方法</td> 
        <td class="content" nowrap="nowrap">建其他的对象层，其中该数据源需要被设计和实现以<br /> 也会带来额外的开销。</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 7).需要类层次设计&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> 
       </tr> 
      </tbody> 
     </table> 
     <table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="0" width="18%" border="0"> 
      <tbody> 
       <tr> 
        <td class="content" nowrap="nowrap"> 在使用工厂策略时，我<br /> 层次。如果能够确保这种灵<br /> 。然而，在实现该工厂策略<br /> 厂。</td> 
        <td class="content" nowrap="nowrap">们需要设计和实现具体工厂的层<br /> 活性，则有必要考虑这种额外的<br /> 时，你可以首先考虑工厂方法模</td> 
        <td class="content" nowrap="nowrap">次，以及这些工厂产生的具体产品<br /> 工作。这样做会增加设计的复杂性<br /> 式，然后再根据需要过渡到抽象工</td> 
       </tr> 
      </tbody> 
     </table>  </font></td> 
  </tr> 
 </tbody> 
</table></div></body></html>