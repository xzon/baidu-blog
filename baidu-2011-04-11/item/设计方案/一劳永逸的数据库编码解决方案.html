<html><head><title>一劳永逸的数据库编码解决方案</title></head><body><div id='tit'>一劳永逸的数据库编码解决方案</div><div id='cate'>设计方案</div><div id='date'>2007年11月28日 星期三 09:31 P.M.</div><div id='page'>195</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/2e77e1116965bcc5a6ef3f5d.html'>http://hi.baidu.com/hxzon/blog/item/2e77e1116965bcc5a6ef3f5d.html</a><div id='cnt'><table class="buttomBorder FCK__ShowTableBorders" cellspacing="3" cellpadding="3" width="100%" border="0"> 
 <tbody> 
  <tr> 
   <td class="contentTitle" align="center">一劳永逸的数据库编码解决方案 
    <hr width="70%" /> </td> 
  </tr> 
  <tr> 
   <td align="center">2005-07-01 来源:IBM 作者:刘冬</td> 
  </tr> 
  <tr> 
   <td class="content" valign="top" align="left"> <p> <strong>问题提出</strong></p> <p> 现在几乎所有的应用系统都无法避免使用数据库系统。在JAVA世界里访问数据库是一件非常轻松的事情，JDBC为JAVA应用程序访问数据库提供了一个统一的接口，通过使用JDBC接口开发者无需关心系统最终采用哪种数据库，因为JDBC仅仅是定义了访问几个JAVA的接口类，具体的实现是由数据库厂商提供的，这种做法其实与其他数据库连接方式例如ODBC是类似的。但是在实际的应用过程中，开发者发现离JDBC设计的初衷还是有一定距离，就比如说在存储字符串时的编码问题，我想很多开发者都会遇见这个问题，倒不是因为说解决它有什么技术方面的难度，而是它的的确确非常繁琐。我们必须在每次写入或者读出字符串的时候进行编码和反编码处理；或者说我们可以写一个方法可以进行编码处理的，但又必须在每次数据库操作的时候调用，虽然调用很简单，可是我非得这样吗？要是忘了编码那又要DEBUG了。当然你可能觉得这并没有什么，或者你可能很勤快，喜欢写大量重复的代码，可是你难道没有觉得这种繁琐的工作正在浪费你过于宝贵的青春吗？停止你的键盘输入，让我们来解决这个问题吧！</p> <p> <strong>解决思路</strong></p> <p> 在传统的应用程序中数据库操作部分我们可以想象成两层，如图所示：一个是数据库的&quot;连接池&quot;，另外一个业务数据操作层。在这里数据库的连接池是广义的，你可以把JDBC中的DriverManager也当成是连接池，具体的意思就是我们可以通过这层来获取到指定数据库的连接而不去关心它是怎么获取的。如果这个时候数据库系统（有如Informix，SQL Server）要求对字符串进行转码才能存储（例如最常见的GBK-&gt;ISO8859_1转码），那我们就必须在业务数据操作层来进行，这样有多少业务数据操作我们就要做多少编码转码的工作，太麻烦了，代码中充斥中大量重复的内容。本文提出的解决方案就是利用对获取到的数据库连接实例进行二次封装，也就是在数据库连接池与业务数据操作层之间加入了连接封装层，当然了，我们也完全可以直接将连接封装集成到数据库连接池内部。关于连接池的实现请参照我的另外一篇文章《使用JAVA动态代理实现数据库连接池》</p> <p align="center"><img height="173" width="247" border="0" src="image/一劳永逸的数据库编码解决方案.html.20041212111952100.gif" /><p class="origImg">http://www.javafan.net/uploadfiles/20041212111952100.gif</p><br /> 图一</p> <p> 我们知道进行编码和转码工作都是集中在JDBC的两个接口PreparedStatement和ResultSet上进行的，主要涉及PreparedStatement的setString方法以及ResultSet的getString方法。前面我们讲过需要加入一个连接封装层来对数据库连接实例进行二次封装，但是怎么通过这个封装来改变PreparedStatement和ResultSet这两个接口的行为呢？这个问题其实也很简单，因为PreparedStatement接口必须通过Connection接口来获取实例，而ResultSet接口又必须从Statement或者PreparedStatement接口来获取实例，有了这样的级联关系，问题也就迎刃而解了。还是利用我在文章《使用JAVA动态代理实现数据库连接池》中使用的动态接口代理技术。首先我们设计Connection接口的代理类_Connection，这个代理类接管了Connection接口中所有可能获取到Statement或者PreparedStatement接口实例的方法，例如：prepareStatement和createStatement。改变这两个方法使之返回的是经过接管后的Statement或者PreparedStatement实例。通过对于Statement接口也有相应的代理类_Statement，这个代理类接管用于获取ResultSet接口实例的所有方法，包括对setString方法的接管以决定是否对字符串进行编码处理。对于接口ResultSet的接管类_ResultSet就相应的比较简单，它只需要处理getString方法即可。</p> <p> <strong>关键代码</strong></p> <p> 前面我们大概介绍了这个解决方案的思路，下面我们给出关键的实现代码包括Connection的代理类，Statement的代理类，ResultSet的代理类。这些代码是在原来关于数据库连接池实现的基础上进行扩充使之增加对自动编码处理的功能。有需要源码打包的可以通过电子邮件跟我联系。</p> <p>_Connection.java</p> <p style="background: #eeeeee">/* <br /> * Created on 2003-10-23 by Liudong <br /> */<br /> package lius.pool;<br /> import java.sql.*;<br /> import java.lang.reflect.*;<br /> <br /> /*<br /> * <br /> * 数据库连接的代理类 <br /> * @author Liudong <br /> */<br /> class _Connection implements InvocationHandler{<br /> private Connection conn = null;<br /> private boolean coding = false;<br /> //指定是否进行字符串转码操作<br /> _Connection(Connection conn, boolean coding){<br /> &nbsp;&nbsp; this.conn = conn;<br /> &nbsp;&nbsp; this.coding = coding;<br /> &nbsp;&nbsp; initConnectionParam(this.conn);<br /> <br /> }<br /> <br /> /** <br /> * Returns the conn. <br /> * @return Connection <br /> */<br /> <br /> public Connection getConnection() {<br /> &nbsp;&nbsp; Class[] interfaces = conn.getClass().getInterfaces();<br /> &nbsp;&nbsp; if(interfaces==null||interfaces.length==0){<br /> &nbsp;&nbsp;&nbsp; interfaces = new Class[1];<br /> &nbsp;&nbsp;&nbsp; interfaces[0] = Connection.class;<br /> &nbsp;&nbsp;<br /> &nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp; Connection conn2 = (Connection)Proxy.newProxyInstance( conn.getClass().getClassLoader(), interfaces,this);<br /> &nbsp;&nbsp; return conn2;<br /> <br /> }<br /> <br /> /** <br /> * @see java.lang.reflect.InvocationHandler#invoke <br /> */<br /> public Object invoke(Object proxy, Method m, Object[] args) throws Throwable { <br /> &nbsp;&nbsp; String method = m.getName();<br /> &nbsp;&nbsp; //调用相应的操作<br /> &nbsp;&nbsp; Object obj = null;<br /> &nbsp;&nbsp; try{<br /> &nbsp;&nbsp;&nbsp; obj = m.invoke(conn, args);<br /> &nbsp;&nbsp;&nbsp; //接管用于获取语句句柄实例的方法<br /> &nbsp;&nbsp;&nbsp; if((CS.equals(method)||PS.equals(method))&amp;&amp;coding) <br /> &nbsp;&nbsp;&nbsp;&nbsp; return new _Statement((Statement)obj,true).getStatement();<br /> &nbsp;&nbsp;<br /> &nbsp;&nbsp; } catch(InvocationTargetException e) {<br /> &nbsp;&nbsp;&nbsp; throw e.getTargetException();<br /> &nbsp;&nbsp; }<br /> &nbsp;&nbsp; return obj;<br /> }<br /> <br /> private final static String PS = &quot;prepareStatement&quot;;<br /> private final static String CS = &quot;createStatement&quot;;<br /> }</p> <p><br /> _Statement.java</p> <p style="background: #eeeeee">/* <br /> * Created on 2003-10-23 by Liudong <br /> */<br /> <br /> package lius.pool;<br /> import java.sql.*;<br /> import java.lang.reflect.*;<br /> <br /> /** <br /> * 数据库语句对象实例的代理类 <br /> * @author Liudong <br /> */<br /> class _Statement implements InvocationHandler{ <br /> private Statement statement ; //保存所接管对象的实例 <br /> private boolean decode = false; //指定是否进行字符串转码 <br /> <br /> public _Statement(Statement stmt,boolean decode) { <br /> &nbsp;&nbsp; this.statement = stmt;<br /> &nbsp;&nbsp; this.decode = decode;<br /> }<br /> <br /> /** <br /> * 获取一个接管后的对象实例 <br /> * @return <br /> */<br /> public Statement getStatement() {<br /> &nbsp;&nbsp; Class[] interfaces = statement.getClass().getInterfaces();<br /> &nbsp;&nbsp; if(interfaces==null||interfaces.length==0){ <br /> &nbsp;&nbsp;&nbsp; interfaces = new Class[1];<br /> &nbsp;&nbsp;&nbsp; interfaces[0] = Statement.class;<br /> &nbsp;&nbsp; } <br /> &nbsp;&nbsp; Statement stmt = (Statement)Proxy.newProxyInstance(&nbsp;&nbsp;&nbsp;<br /> &nbsp;&nbsp;&nbsp; statement.getClass().getClassLoader(), <br /> &nbsp;&nbsp;&nbsp; interfaces,this);<br /> &nbsp;&nbsp; return stmt;<br /> <br /> }<br /> <br /> /** <br /> * 方法接管 <br /> */<br /> public Object invoke(Object proxy, Method m, Object[] args) throws Throwable {<br /> &nbsp;&nbsp; String method = m.getName(); //接管setString方法 <br /> &nbsp;&nbsp; if(decode &amp;&amp; SETSTRING.equals(method)) {<br /> &nbsp;&nbsp;&nbsp; try{<br /> &nbsp;&nbsp;&nbsp;&nbsp; String param = (String)args[1];<br /> &nbsp;&nbsp;&nbsp;&nbsp; if(param!=null)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; param = new String(param.getBytes(),&quot;8859_1&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp; return m.invoke(statement,new Object[]{args[0],param});<br /> &nbsp;&nbsp;&nbsp; } catch(InvocationTargetException e){<br /> &nbsp;&nbsp;&nbsp;&nbsp; throw e.getTargetException();<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br /> &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br /> &nbsp;&nbsp; }<br /> &nbsp;&nbsp;<br /> &nbsp;&nbsp; //接管executeQuery方法<br /> &nbsp;&nbsp;<br /> &nbsp;&nbsp; if(decode &amp;&amp; EXECUTEQUERY.equals(method)){<br /> &nbsp;&nbsp;&nbsp; try{<br /> &nbsp;&nbsp;&nbsp;&nbsp; ResultSet rs = (ResultSet)m.invoke(statement,args);<br /> &nbsp;&nbsp;&nbsp;&nbsp; return new _ResultSet(rs,decode).getResultSet();<br /> &nbsp;&nbsp;&nbsp;<br /> &nbsp;&nbsp;&nbsp; }catch(InvocationTargetException e){<br /> &nbsp;&nbsp;&nbsp;&nbsp; throw e.getTargetException();<br /> &nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br /> &nbsp;&nbsp; }<br /> &nbsp;&nbsp;<br /> &nbsp;&nbsp; try{<br /> &nbsp;&nbsp;&nbsp; return m.invoke(statement, args);<br /> &nbsp;&nbsp; } catch(InvocationTargetException e) {<br /> &nbsp;&nbsp;&nbsp; throw e.getTargetException();<br /> &nbsp;&nbsp;&nbsp; } <br /> }<br /> //两个要接管的方法名<br /> <br /> private final static String SETSTRING = &quot;setString&quot;;<br /> private final static String EXECUTEQUERY = &quot;executeQuery&quot;;<br /> }</p> <p><br /> _ResultSet.java</p> <p style="background: #eeeeee">/* <br /> * Created on 2003-10-23 by Liudong <br /> */<br /> <br /> package lius.pool;<br /> import java.sql.ResultSet;<br /> import java.lang.reflect.InvocationHandler;<br /> import java.lang.reflect.InvocationTargetException;<br /> import java.lang.reflect.Method;<br /> import java.lang.reflect.Proxy;<br /> <br /> /** <br /> * 数据库结果集的代理类 <br /> * @author Liudong <br /> */<br /> class _ResultSet implements InvocationHandler{ <br /> private ResultSet rs = null;<br /> private boolean decode = false;<br /> <br /> public _ResultSet(ResultSet rs,boolean decode) {<br /> &nbsp;&nbsp; this.rs = rs;<br /> &nbsp;&nbsp; this.decode = decode;<br /> }<br /> <br /> public ResultSet getResultSet(){ <br /> &nbsp;&nbsp; Class[] interfaces = rs.getClass().getInterfaces();<br /> &nbsp;&nbsp; if(interfaces==null||interfaces.length==0){<br /> &nbsp;&nbsp;&nbsp; interfaces = new Class[1];<br /> &nbsp;&nbsp;&nbsp; interfaces[0] = ResultSet.class;&nbsp;&nbsp;<br /> &nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp; ResultSet rs2 = (ResultSet)Proxy.newProxyInstance(rs.getClass().getClassLoader(),interfaces,this);<br /> &nbsp;&nbsp; return rs2;<br /> <br /> }<br /> <br /> /** <br /> * 结果getString方法 <br /> */<br /> public Object invoke(Object proxy, Method m, Object[] args) throws Throwable { <br /> &nbsp;&nbsp; String method = m.getName();<br /> &nbsp;&nbsp; if(decode &amp;&amp; GETSTRING.equals(method)){<br /> &nbsp;&nbsp;&nbsp; try{<br /> &nbsp;&nbsp;&nbsp;&nbsp; String result = (String)m.invoke(rs,args);<br /> &nbsp;&nbsp;&nbsp;&nbsp; if(result!=null)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new String(result.getBytes(&quot;8859_1&quot;));<br /> &nbsp;&nbsp;&nbsp;&nbsp; return null;<br /> &nbsp;&nbsp;&nbsp;<br /> &nbsp;&nbsp;&nbsp; }catch(InvocationTargetException e){<br /> &nbsp;&nbsp;&nbsp;&nbsp; throw e.getTargetException();<br /> &nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;<br /> &nbsp;&nbsp; } <br /> &nbsp;&nbsp;<br /> &nbsp;&nbsp; try{<br /> &nbsp;&nbsp;&nbsp; return m.invoke(rs, args);<br /> &nbsp;&nbsp; }catch(InvocationTargetException e){<br /> &nbsp;&nbsp;&nbsp; throw e.getTargetException();<br /> &nbsp;&nbsp; }<br /> }<br /> <br /> private final static String GETSTRING = &quot;getString&quot;;<br /> <br /> }</p> <p> 现在我们已经把三个接口的代理类做好了，下一步就是怎么来使用这三个类。其实对于使用者来讲并不需要关心三个类，只需要了解_Connection就可以了，因为另外两个是_Connection直接调用的。为了使用_Connection我们必须传入两个参数，第一个是数据库实际的数据库连接实例，另外一个是布尔值代表是否进行转码处理。我们必须先通过实际的情况获取到数据库连接后再传入_Connection的构造函数作为参数，下面例子告诉你如何来使用_Connection这个类：</p> <p style="background: #eeeeee"> Connection conn = getConnection(); //获取数据库连接<br /> boolean coding = false; //从配置或者其他地方读取是否进行转码的配置 <br /> //接管数据库连接实例 <br /> _Connection _conn = new _Connection(conn,coding);<br /> //获得接管后的数据库连接实例，以后直接使用conn2而不是conn <br /> Connection conn2 = _conn.getConnection();</p> <p> 因为对一个应用系统来讲，数据库连接的获取必然有统一的方法，在这个方法中加入对连接的接管就可以一劳永逸的解决数据库的编码问题。</p> <p> <strong>性能比较</strong></p> <p> 功能没有问题了，开发者接下来就会关心性能的问题，因为在进行一些对响应速度要求很高或者大数据量的处理情况下性能就成为一个非常突出的问题。由于JAVA中的动态接口代理采用的是反射（Reflection）机制，同时又加入我们自己的一些代码例如方法名判断，字符串转码等操作因此在性能上肯定比不上直接使用没有经过接管的数据库连接。但是这点性能上的差别是不是我们可以忍受的呢，为此我做了一个试验对二者进行了比较：</p> <p> 测试环境简单描述：</p> <p> 使用ACCESS数据库，建两张结构一样的表，计算从获取连接后到插入数据完毕后的时间差，两个程序（直连数据库和使用连接接管）都进行的字符串的转码操作。</p> <p> 测试结果：</p> 
    <table class="FCK__ShowTableBorders" cellspacing="1" cellpadding="1" width="500" align="center" bgcolor="#999999" border="0"> 
     <tbody> 
      <tr bgcolor="#ffffff"> 
       <td align="center" height="25">插入记录数</td> 
       <td align="center">直连数据库程序耗时 单位：ms</td> 
       <td align="center">使用连接接管程序耗时</td> 
       <td align="center">性能比较</td> 
      </tr> 
      <tr bgcolor="#ffffff"> 
       <td height="25">1000</td> 
       <td>2063</td> 
       <td>2250</td> 
       <td>9.0%</td> 
      </tr> 
      <tr bgcolor="#ffffff"> 
       <td height="25">5000</td> 
       <td>8594</td> 
       <td>8359</td> 
       <td>-2.7%</td> 
      </tr> 
      <tr bgcolor="#ffffff"> 
       <td height="25">10000</td> 
       <td>16750</td> 
       <td>17219</td> 
       <td>2.8%</td> 
      </tr> 
      <tr bgcolor="#ffffff"> 
       <td height="25">15000</td> 
       <td>22187</td> 
       <td>23000</td> 
       <td>3.6%</td> 
      </tr> 
      <tr bgcolor="#ffffff"> 
       <td height="25">20000</td> 
       <td>27031</td> 
       <td>27813</td> 
       <td>2.9%</td> 
      </tr> 
     </tbody> 
    </table> <p> 从上面这张测试结果表中来看，二者的性能的差别非常小，尽管在两万条数据的批量插入的时候时间差别也不会多于一秒钟，这样的结果应该说还是令人满意的，毕竟为了程序良好的结构有时候牺牲一点点性能还是值得的。</p> <p> 本文算是我之前文章《使用JAVA动态代理实现数据库连接池》中提出的数据库连接池实现的进一步完善，同样使用动态接口代理的技术来解决数据库编码的问题。JAVA的这个高级技术可以用来解决许多实际中非常棘手的问题，就像本文提到的编码问题的处理以及数据库连接池的实现，同时在WEB开发框架的实现上也有非常大的作为。欢迎对这方面感兴趣的朋友来信共同来研究。</p> </td> 
  </tr> 
 </tbody> 
</table></div></body></html>