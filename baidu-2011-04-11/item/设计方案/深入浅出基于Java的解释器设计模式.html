<html><head><title>深入浅出基于Java的解释器设计模式</title></head><body><div id='tit'>深入浅出基于Java的解释器设计模式</div><div id='cate'>设计方案</div><div id='date'>2008年04月10日 星期四 08:07 P.M.</div><div id='page'>139</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/9a7087cb341eb0f853664f10.html'>http://hi.baidu.com/hxzon/blog/item/9a7087cb341eb0f853664f10.html</a><div id='cnt'><p>深入浅出基于Java的解释器设计模式<br /> 开发者在线 Builder.com.cn 更新时间:2007-08-26作者：中国IT实验室 来源:中国IT实验室<br /> 本文关键词： JAVA 解释器设计模式</p> 
<p> <strong>一、引子</strong><br /> 其实没有什么好的例子引入解释器模式，因为它描述了如何构成一个简单的语言解释器，主要应用在使用面向对象语言开发编译器中；在实际应用中，我们可能很少碰到去构造一个语言的文法的情况。<br /> <br /> 虽然你几乎用不到这个模式，但是看一看还是能受到一定的启发的。<br /> <br /> <strong>二、定义与结构</strong><br /> 解释器模式的定义如下：定义语言的文法，并且建立一个解释器来解释该语言中的句子。它属于类的行为模式。这里的语言意思是使用规定格式和语法的代码。<br /> <br /> 在GOF的书中指出：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。而且当文法简单、效率不是关键问题的时候效果最好。<br /> <br /> 这也就是解释器模式应用的环境了。<br /> <br /> 让我们来看看神秘的解释器模式是由什么来组成的吧。<br /> <br /> 1) 抽象表达式角色：声明一个抽象的解释操作，这个接口为所有具体表达式角色（抽象语法树中的节点）都要实现的。<br /> <br /> 什么叫做抽象语法树呢？《java与模式》中给的解释为：抽象语法树的每一个节点都代表一个语句，而在每个节点上都可以执行解释方法。这个解释方法的执行就代表这个语句被解释。由于每一个语句都代表这个语句被解释。由于每一个语句都代表一个常见的问题的实例，因此每一个节点上的解释操作都代表对一个问题实例的解答。<br /> <br /> 2) 终结符表达式角色：具体表达式。<br /> <br /> a) 实现与文法中的终结符相关联的解释操作<br /> <br /> b) 而且句子中的每个终结符需要该类的一个实例与之对应<br /> <br /> 3) 非终结符表达式角色：具体表达式。<br /> <br /> a) 文法中的每条规则R::=R1R2…Rn都需要一个非终结符表带式角色<br /> <br /> b) 对于从R1到Rn的每个符号都维护一个抽象表达式角色的实例变量<br /> <br /> c) 实现解释操作，解释一般要递归地调用表示从R1到Rn的那些对象的解释操作<br /> <br /> 4) 上下文（环境）角色：包含解释器之外的一些全局信息。<br /> <br /> 5) 客户角色：<br /> <br /> a) 构建（或者被给定）表示该文法定义的语言中的一个特定的句子的抽象语法树<br /> <br /> b) 调用解释操作<br /> <br /> 放上张解释器结构类图吧，这也是来自于GOF的书中。<br /> <img src="image/深入浅出基于Java的解释器设计模式.h.2005.1.11.12.0.56.1.jpg" /><p class="origImg">http://java.chinaitlab.com/imgfiles/2005.1.11.12.0.56.1.jpg</p><br /> 对每一个角色都给出了详细的职责，而且在类图中给出五个角色之间的关系。这样实现起来也不是很困难了，下面举了一个简单的例子，希望能加深你对解释器模式的理解。<br /> <strong>三、举例</strong><br /> 来举一个加减乘除的例子吧，实现思路来自于《java与模式》中的例子。每个角色的功能按照上面提到的规范来实现。<br /> <br /> //上下文（环境）角色，使用HashMap来存储变量对应的数值<br /> <br /> class Context<br /> {<br /> private Map valueMap = new HashMap();<br /> public void addValue(Variable x , int y)<br /> {<br /> Integer yi = new Integer(y);<br /> valueMap.put(x , yi);<br /> }<br /> <br /> public int LookupValue(Variable x)<br /> {<br /> int i = ((Integer)valueMap.get(x)).intValue();<br /> return i ;<br /> }<br /> }<br /> <br /> //抽象表达式角色，也可以用接口来实现<br /> <br /> abstract class Expression<br /> {<br /> public abstract int interpret(Context con);<br /> }<br /> <br /> //终结符表达式角色<br /> <br /> class Constant extends Expression<br /> {<br /> private int i ;<br /> public Constant(int i)<br /> {<br /> this.i = i;<br /> }<br /> <br /> public int interpret(Context con)<br /> {<br /> return i ;<br /> }<br /> }<br /> <br /> class Variable extends Expression<br /> {<br /> public int interpret(Context con)<br /> {<br /> //this为调用interpret方法的Variable对象<br /> return con.LookupValue(this);<br /> }<br /> }<br /> //非终结符表达式角色<br /> <br /> class Add extends Expression<br /> {<br /> private Expression left ,right ;<br /> public Add(Expression left , Expression right)<br /> {<br /> this.left = left ;<br /> this.right= right ;<br /> }<br /> <br /> public int interpret(Context con)<br /> {<br /> return left.interpret(con) + right.interpret(con);<br /> }<br /> }<br /> <br /> class Subtract extends Expression<br /> {<br /> private Expression left , right ;<br /> public Subtract(Expression left , Expression right)<br /> {<br /> this.left = left ;<br /> this.right= right ;<br /> }<br /> <br /> public int interpret(Context con)<br /> {<br /> return left.interpret(con) - right.interpret(con);<br /> }<br /> <br /> }<br /> <br /> class Multiply extends Expression<br /> {<br /> private Expression left , right ;<br /> public Multiply(Expression left , Expression right)<br /> {<br /> this.left = left ;<br /> this.right= right ;<br /> }<br /> public int interpret(Context con)<br /> {<br /> return left.interpret(con) * right.interpret(con);<br /> }<br /> }<br /> <br /> class Division extends Expression<br /> {<br /> private Expression left , right ;<br /> public Division(Expression left , Expression right)<br /> {<br /> this.left = left ;<br /> this.right= right ;<br /> }<br /> <br /> public int interpret(Context con)<br /> {<br /> try{<br /> return left.interpret(con) / right.interpret(con);<br /> }catch(ArithmeticException ae)<br /> {<br /> System.out.println(&quot;被除数为0！&quot;);<br /> return -11111;<br /> }<br /> }<br /> }<br /> <br /> //测试程序，计算 (a*b)/(a-b+2)<br /> <br /> public class Test<br /> {<br /> private static Expression ex ;<br /> private static Context con ;<br /> public static void main(String[] args)<br /> {<br /> con = new Context();<br /> //设置变量、常量<br /> Variable a = new Variable();<br /> Variable b = new Variable();<br /> Constant c = new Constant(2);<br /> //为变量赋值<br /> con.addValue(a , 5);<br /> con.addValue(b , 7);<br /> //运算，对句子的结构由我们自己来分析，构造<br /> ex = new Division(new Multiply(a , b), new Add(new Subtract(a , b) , c));<br /> System.out.println(&quot;运算结果为：&quot;+ex.interpret(con));<br /> }<br /> }<br /> <br /> 解释器模式并没有说明如何创建一个抽象语法树，因此它的实现可以多种多样，在上面我们是直接在Test中提供的，当然还有更好、更专业的实现方式。<br /> <br /> 对于终结符，GOF建议采用享元模式来共享它们的拷贝，因为它们要多次重复出现。但是考虑到享元模式的使用局限性，我建议还是当你的系统中终结符重复的足够多的时候再考虑享元模式。<br /> <br /> <strong>四、优缺点</strong><br /> 解释器模式提供了一个简单的方式来执行语法，而且容易修改或者扩展语法。一般系统中很多类使用相似的语法，可以使用一个解释器来代替为每一个规则实现一个解释器。而且在解释器中不同的规则是由不同的类来实现的，这样使得添加一个新的语法规则变得简单。<br /> <br /> 但是解释器模式对于复杂文法难以维护。可以想象一下，每一个规则要对应一个处理类，而且这些类还要递归调用抽象表达式角色，多如乱麻的类交织在一起是多么恐怖的一件事啊！<br /> <br /> <strong>五、总结</strong><br /> 这样对解释器模式应该有了些大体的认识了吧，由于这个模式使用的案例匮乏，所以本文大部分观点直接来自于GOF的原著。只是实例代码是亲自实现并调试通过的。</p></div></body></html>