<html><head><title><div class="tit">
  Linux常用命令 -hxzon动手 -grule
</div></title></head><body><div id='tit'>Linux常用命令 -hxzon动手 -grule</div><div id='cate'>Linux</div><div id='date'>2008年10月08日 星期三 10:14 A.M.</div><div id='page'>94</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/7f258a5468c321193a2935bb.html'>http://hi.baidu.com/hxzon/blog/item/7f258a5468c321193a2935bb.html</a><div id='cnt'><p>Linux常用命令 -hxzon动手 -grule</p> 
<p>1. 文件管理命令</p> 
<p>●名称：ls<br /> 功能：列出当前目录下的文件和目录</p> 
<p>&nbsp;&nbsp;&nbsp; ls（list）是一个最常用的命令，用于显示当前目录下的文件和于目录。</p> 
<p>第一、显示当前目录的内容<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#Is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 显示当前目录下的内容）<br /> &nbsp;&nbsp;&nbsp; install.log&nbsp;&nbsp;&nbsp; install.log.syslog<br /> &nbsp;&nbsp;&nbsp; Linux约定以以“.”开头的文件为隐含文件，要显示这样的文件可以使用ls命令的“-a”参数。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#Is－a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 显示所有内容，包括隐含文件）<br /> &nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp; .bash_logout&nbsp;&nbsp;&nbsp; .bashrc&nbsp;&nbsp;&nbsp; .gconfd&nbsp;&nbsp;&nbsp; intall.log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .tcshrc<br /> &nbsp;&nbsp;&nbsp; ..&nbsp;&nbsp; .bash_profile&nbsp;&nbsp; .cshrc&nbsp;&nbsp;&nbsp;&nbsp; .gtkrc&nbsp;&nbsp;&nbsp;&nbsp; install.log.syslog&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Xresources<br /> Linux的每一个目录中都包含“.”和“..”两个特殊目录，分别代表当前目录和上级目录。“ /”表示系统的根；而“～”则为用户的主目录（home）。用户主目录是用户登录后所处的目录，例如用户root的主目录为<br /> /root，而普通用户yanghsia的主目录则为/home/yanghsia。</p> 
<p>第二、显示文件的详细信息<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#ls-l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 以长格式列出当前目录下所有内容）<br /> &nbsp;&nbsp;&nbsp; total 28<br /> &nbsp;&nbsp;&nbsp; -rw-r--r-- 1&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp; 24477&nbsp;&nbsp;&nbsp; 4月&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 20:35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; install.log<br /> &nbsp;&nbsp;&nbsp; -rw-r--r-- 1&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp; 4096&nbsp;&nbsp;&nbsp;&nbsp; 4月&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 20:20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; install.log.syslog<br /> 输出信息中各个部分的含义如表1所示。</p> 
<p>表1 长格式显示的文件属性<br /> 第一项&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第二项&nbsp;&nbsp; 第三项&nbsp;&nbsp; 第四项 第五项&nbsp;&nbsp; 第六项&nbsp;&nbsp; 第六项<br /> 操作权限&nbsp;&nbsp; 链接数目 所有者&nbsp;&nbsp; 用户组&nbsp;&nbsp; 大小&nbsp;&nbsp; 创建时间&nbsp;&nbsp; 名称</p> 
<p>&nbsp;&nbsp;&nbsp; 用ls命令显示的文件操作权限有10个小格，最前面的那个小格是一个特殊标记，用来区分目录和链接，其中d表示目录（如drwx--x--x），l代表链接（如lrwx--x--x），如果是“-”，则表明它只是一个普通文件。其余的格于以三个为一组，其中第一组代表文件所有者的权限，第二组代表组用户的权限，第三组代表其他用户的权限，每个组中的三个小格依次分别代表读权限（r）、写权限（W）和可执行权限（x），如果是“-”，则代表不具备相应的权限。例如，-rwxrw-r--（用数字可以表示为764），表明该文件的所有者拥有对该文件的全部权限，组用户拥有读和写权限，而其他用户则只有读权限。<br /> &nbsp;&nbsp;&nbsp; 由于Linux是一个多用户、多任务操作系统，同一文件可能同时被很多人使用，因此。一定要为文件设置好相应的权限，这样才能保护好重要数据。</p> 
<p>名称：cd<br /> 功能：切换目录</p> 
<p>&nbsp;&nbsp;&nbsp; cd（change directory）命令可以改变用户当前所在的目录。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia yanghsia]#cd /home/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 切换到/home/目录）<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia home]#cd yanghsia/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 切换到当前目录下yanghsia子目录中）<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia yanghsia]#cd..&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 切换到上一级目录）<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia yanghsia]#cd～&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 切换到用户主目录：home）</p> 
<p>名称：pwd<br /> 功能：显示当前工作目录</p> 
<p>&nbsp;&nbsp;&nbsp; 由于Linux的树状目录结构非常庞大，用户经常会忘记当前所处的目录。命令提示符一般又只显示最后一级的目录名称，这时pwd能帮上你的大忙。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#pwd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 显示当前所在的工作目录）<br /> &nbsp;&nbsp;&nbsp; /root</p> 
<p>名称：mkdir<br /> 功能：创建目录</p> 
<p>&nbsp;&nbsp;&nbsp; mkdir（make directory）命令可以用来创建目录。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#mkdir student&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 创建student子目录）<br /> &nbsp;&nbsp; <br /> 名称：rmdir<br /> 功能：删除目录</p> 
<p>&nbsp;&nbsp;&nbsp; rmdir（remove directoy）命令可以用来删除目录，但要求该目录中不包含任何文件或子目录。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#rmdir student&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 删除student子目录）</p> 
<p>●名称：cp<br /> 功能：复制文件</p> 
<p>&nbsp;&nbsp;&nbsp; cp（copy）命令用于将文件从一个地方复制到另一个地方，在进行文件复制时，需要指定要复制的源位置和目标位置。</p> 
<p>第一、复制文件<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#cp source.txt dest.txt&nbsp;&nbsp;&nbsp; （# 将source.txt复制成dest.txt）<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#cp source.txt /tmp/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 将source.txt复制到/tmp/目录中）</p> 
<p>第二、覆盖文件前询问<br /> &nbsp;&nbsp;&nbsp; 如果在要复制的目标位置上已经存在了相同名称的文件，若用强行复制将会覆盖该文件，这时可以用“-i”参数来询问用户是否确实需要覆盖该文件。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#cp -q source.txt dest.txt （# 将source.txt复制成dest.txt）<br /> &nbsp;&nbsp;&nbsp; cp：overwrite dest.txt ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# dest．txt已经存在，询问用户是否覆盖该文件，按Y键覆盖，技N键不覆盖）。</p> 
<p>第三、强制复制<br /> &nbsp;&nbsp;&nbsp; 如果在要复制的目标位置上已经存在了相同名称的文件，用“-f”参数可以强制覆盖该文件。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#cp -f source.txt dest.txt （# 强制复制文件source.txt成dest．txt）</p> 
<p>第四、递归复制<br /> &nbsp;&nbsp;&nbsp; cp命令不仅可以用来复制文件，也可以用来复制目录，由于目录中可能包含子目录，因而需要用到“-R”参数来进行递归复制。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#cp -R /home/yanghsia/ /imp/（# 将目录/home/yanghsia/复制到/imp/目录下）。<br /> &nbsp;&nbsp;&nbsp; <br /> 名称：rm<br /> 功能：删除文件<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; rm（remove）命令可以用来删除文件。</p> 
<p>第一、删除文件<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#rm student.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 删除文件student.txt）<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#rm *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 删除当前目录下的所有文件）</p> 
<p>第二、强制删除文件<br /> &nbsp;&nbsp;&nbsp; 在删除文件时，有时Linux会询问你是否确实需要删除这些文件，其目的是避免误操作。如果确信要删除这些文件，可以用“-f”参数来强制删除这些文件，此时Linux将不会再作提示。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#rm -f *.bak&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 强制删除当前目录下所有后缀为.bak的<br /> 文件）。</p> 
<p>第三、删除文件前询问<br /> &nbsp;&nbsp;&nbsp; 如果不是很确定，删除文件时最好带上“-i”参数，Linux会询问你是否确实执行删除操作，这样做的好处是可以避免误操作。Linux命令行方式下可没有像Windows那样的“回收站”，删除操作是不可恢复的，文件一旦被删除，就可能永远无法找回它了，所以一定要认真对待。删除文件时习惯性的加上“-i”参数，说不定在某个时候就会帮上你的大忙。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#rm *.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 删除所有后缀为.txt的文件）<br /> &nbsp;&nbsp;&nbsp; rm：remove regular empty file 'student.txt'?&nbsp;&nbsp;&nbsp; （# 询问是否删除文件，按Y键删除，按N键<br /> 不删除）。</p> 
<p>第四、递归删除<br /> &nbsp;&nbsp;&nbsp; 除删除文件外，rm命令还可以用来删除目录，它不像rmdir那样要求被删除的目录是空的。由于目录下可能会包含子目录，因此需要用“-r”参数进行递归删除。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#rm-r /tmp/yanghsia/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 删除/tmp/yanghsia/目录）</p> 
<p>名称：mv<br /> 功能：移动文件或目录<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; mv（move）命令可以将文件或目录或移动到另一个位置，或者更改文件或目录的名称。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#mv student.txt /imp/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 将student.txt移到/imp/目录）<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#mv student.txt teacher.txt （# 将student.txt更名为teacher.txt）<br /> &nbsp;&nbsp; <br /> 2. 文件查找命令<br /> &nbsp;&nbsp;&nbsp; <br /> 名称：whereis<br /> 功能：定位文件所在的目录<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; 使用whereis命令可以定位常用命令的位置：<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#whereis ls&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 定位ls命令的位置）<br /> ？ ls：/bin/ls&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# ls位于/usr/bln目录下）<br /> &nbsp;&nbsp; whereis命令不是通过查找磁盘上的所有文件来实现定位的，你可以随便指定一个可执行文件，估计whereis会找不到，这是因为whereis是根据环境变量PATH来查找文件的，而PATH通常设置成存放命令的那些路径，如 /bin、/usr/bin等，因此whereis的用途仅限于定位shell命令所在的位置。<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> ●名称：find<br /> 功能：查找文件<br /> &nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; find命令可以用来从指定的目录开始查找文件，它的速度虽比不上whereis命令，但没有任何限制，而且功能要比whereis命令强。<br /> ？ [root@yanghsia root]#find -name student.txt<br /> ？ /tmp/student.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 查找结果）</p> 
<p>●名称：locate<br /> 功能：查找文件或目录<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; 除find命令外，locate也是在系统中查找文件的常用方法。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#locate student.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 查找student.txt文件）<br /> &nbsp;&nbsp;&nbsp; 用locate命令查找的文件和find一样没有任何限制，但执行速度却比find要快不少，其主要原因在于，locate不是从磁盘中实时查找文件，而是到由updatedb命令产生的信息库中查找相应的文件和目录，这样一来速度当然了。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#updatedb<br /> &nbsp;&nbsp;&nbsp; 如果locate找不到某个文件，而你又确信该文件肯定存在，那一定是updatedb生成的信息库已经过时了。此时你要做的就是以root身份登录，然后执行updatedb命令，重新建立整个系统所有文件和目录的资料库，虽然这个过程可能会浪费一点时间，但以后再查找文件时就方便多了。<br /> &nbsp;&nbsp; <br /> 3. 磁盘管理命令<br /> &nbsp;&nbsp;&nbsp; <br /> 名称：df<br /> 功能：显示文件系统的当前占用情况<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; df（disk filesystem）可以用来获得文件系统当前占用的磁盘空间大小，以及剩余的可用空间的大小。<br /> ？ []$df&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 查询文件系统当前占用的磁盘空间大小）<br /> &nbsp;&nbsp;&nbsp; filesystem&nbsp;&nbsp;&nbsp;&nbsp; 1K-blocks&nbsp;&nbsp;&nbsp;&nbsp; Used&nbsp;&nbsp;&nbsp; available&nbsp;&nbsp;&nbsp; Use%&nbsp;&nbsp;&nbsp; Mounted on<br /> &nbsp;&nbsp;&nbsp; /dev/hda2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13203660&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1869264 10663684&nbsp;&nbsp;&nbsp;&nbsp; 15%&nbsp;&nbsp;&nbsp;&nbsp; /<br /> &nbsp;&nbsp;&nbsp; none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30768&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30768&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /dev/shm<br /> &nbsp;&nbsp;&nbsp; 在df命令的输出结果中，Filesystem列显示各个文件系统对应的硬盘分区名称，1K-blocks列为每个分区占用的磁盘空间大小（单位是1KB），Used列是已经使用的磁盘空间的大小，Available列是目前剩余的可用磁盘空间的大小，Use%列是各个分区磁盘空间的使用率，最后一列Mounted on则代表分区在整个Linux文件系统中的加载位置。<br /> &nbsp;&nbsp;&nbsp; <br /> 名称：du<br /> 功能：显示文件或目录占用的磁盘空间大小<br /> &nbsp;&nbsp;&nbsp; du（disk usage）命令用来统计文件或目录占用的磁盘空间大小。<br /> ？ [root@yanghsia root]#du -sm /bin/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 查询/bin/目录占用的磁盘空间大小）<br /> &nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp; /bin<br /> &nbsp;&nbsp;&nbsp; du命令的输出结果显示/bin/目录共占据7MB磁盘空间，如果不加“-s”参数则可以显示此目录下每个文件的大小。</p> 
<p>●名称：mount<br /> 功能：加载存储设备<br /> &nbsp;&nbsp;&nbsp; 如果你是个资深的Windows用户，肯定已经习惯将光盘或软盘插入驱动器中后，就可以通过相应的磁盘（如 A：）来访问这些存储设备上的数据了。但遗憾的是，在Linux中使用光盘和软盘就没有这么简单了。Linux采用的方式是，必须先将这些设备映射到系统中的某个目录之后，才可以存取上面的数据。<br /> &nbsp;&nbsp;&nbsp; 将软盘和光盘映射到文件系统指定目录的过程称为加载（mount），它是Linux中很重要的一个概念。其实，加载就是将某个存储介质（如软盘或光盘）与文件系统中的某个目录（如/mnt/floppy/或/mnt/cdrom/）建立起联系，此后凡是对该目录的操作，实际上就是读写此存储介质上相应的数据。<br /> &nbsp;&nbsp;&nbsp; 如果想在Linux中使用软盘，首先将软盘插入软盘驱动器中，然后执行mount命令，将软盘加载到文件系统中：<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#mount /dev/fd0/mnt/floppy/ （# 将软盘加载至文件系统的/mnt/floppy/目录）<br /> &nbsp;&nbsp;&nbsp; 同理，光盘的使用方法也是先加载后使用：<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#mount /dev/cdrom/mnt/cdrom/ （# 将光盘加载到文件系统的/mnt/cdrom/目录）<br /> &nbsp;&nbsp;&nbsp; <br /> 名称：umount<br /> 功能：卸载存储设备<br /> &nbsp;&nbsp;&nbsp; 对初学者来说，在Linux命令行方式下使用软盘和光盘的确要比Windows麻烦许多，不仅需要在使用前先加载它们，使用完毕后还必须先卸载它们，然后才能将软盘或光盘从驱动器中取出。特别是对光盘来说，如果不先将其卸载，那无论怎么按光驱上的退出按钮，都无法于打开光驱的门，更别说取出光盘了，此时不要以为是自己的光驱出问题。<br /> &nbsp;&nbsp;&nbsp; 当软盘加载后不再需要使用时，必须先执行umount命令，然后才能取出软盘。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#umount /mnt/floppy/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 将软盘卸载，不再与目录/mnt/floppy/相关联）。<br /> &nbsp;&nbsp;&nbsp; 光盘的卸载与软盘类似。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#umount /mnt/cdrom/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 将光盘卸载，不再与目录/mnt/cdrom/相关联）<br /> &nbsp;&nbsp;&nbsp; 若当前正处于光盘加载的目录（即/mnt/cdroml/），或有其他用户正在使用该光盘，则无法成功地完成卸载。例如，在卸载存储设备时，Linux提示“device is busy”的错误信息，则需用cd命令将工作目录切换到其它目录，并要求其他用户退出此目录，然后才能卸载光盘。<br /> &nbsp;&nbsp;&nbsp; 如果是在Red Hat Linux 9的桌面环境使用光驱，那就不会有这些麻烦了。只要把光盘放进光驱，系统将自动在桌面上出现一个光盘图标，只要双击它打开，就可以像在Windows 98/2000/XP下一样来查看光盘内容了。</p> 
<p>4. 文件处理命令<br /> &nbsp;&nbsp;&nbsp; <br /> 名称：cat<br /> 功能：显示文件内容<br /> <br /> &nbsp;&nbsp;&nbsp; cat（concatenate）命令可以用来显示文件的内容。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#cat ～/.bashrc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 显示用户主目录下隐藏文件bashrc的内容）<br /> &nbsp;&nbsp;&nbsp; Cat命令还可以用来将已有的多个文件合并成一个文件。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#cat 1.txt 2.txt &gt; 0.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 连接多个文本文件）<br /> &nbsp;&nbsp;&nbsp; Linux系统中一个很有趣的概念就是I/O重定向，可以用输出重定向符“&gt;”将输出内容写入到一个指定的文件中。通常命令的执行结果都显示在屏幕上，但如果你想将结果记录到一个文件中，就可以利用该输出重定向的功能了。<br /> &nbsp;&nbsp;&nbsp; <br /> ●名称：more<br /> 功能：分页显示文件内容<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; 当文件内容过长以至于整个屏幕都显示不下时，用cat命令只能看到最后几行，这时more命令可就大有处了，它可以一页一页地查看内容冗长的文件内容。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#more /etc/passwd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 分页显示/etc/passwd文件的内容）<br /> &nbsp;&nbsp;&nbsp; 当文件内容超过一屏以至于显示不下时，more命令将暂停显示文件中的其它内容，同时在屏幕的底部左侧显示“--more--”，提示还有未显示完的内容，此时可以按空格键来显示下一屏内容，也可以按Q键结束显示。</p> 
<p>●名称：less<br /> 功能：分页显示文件内容<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; less命令的作用和more类似，都是用来浏览内容较多的文件，唯一的不同在于less命令除了可以按空格键显示文件内容外，还可以利用上、下键来上下翻动显示内容。而more只能向下显示文件内容，不能再回头去查看已经出现过的内容。<br /> &nbsp;&nbsp;&nbsp; 当文件内容超过一屏时，less将暂停显示文件中的其它内容，同时在屏幕底部显示提示符“：”，此时可以用上、下键来浏览文件内容，也可以用空格键继续显示文件中的其它内容，或者按Q键退出。</p> 
<p>●名称：grep<br /> 功能：查找字符串<br /> &nbsp;&nbsp;&nbsp; grep命令可以在一个或多个文件中查找某个指定的字符串，如果找到则显示文件中包含该字符串的每一行。<br /> ？ [root@yanghsia root]#grep xxxy/etc/passwd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 从文件/etc/passwd中查找字符串xxxy）<br /> &nbsp;&nbsp;&nbsp; xxxy:x:500:500:Xxxy Swau:/home/xxxy:/bin/bash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 查找结果）<br /> &nbsp;&nbsp;&nbsp; grep还可以与其它命令搭配起来使用。例如，用ps命令可以列出系统中当前正在运行的所有进程信息，但如果只对名为mount的进程感兴趣，就可以用grep命令将其“过滤”出来。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#ps -aux | grep mount<br /> &nbsp;&nbsp;&nbsp; “管道”是Linux中另一个很特殊的概念，用符号“|”表示，其功能是将某个程序的输出作为另一个程序的输入。在上面的例子中，ps命令执行完毕后所有的输出都将被作为输入传递给grep命令。<br /> &nbsp;&nbsp;&nbsp; <br /> ●名称：vi<br /> 功能：编辑文本<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; 不管你使用的是哪种操作系统，总要使用文本编辑器编辑文件，在Win下可以使用记事本或UltraEdit，那么在Linux下呢？一般有两种选择：emacs和vi，其中vi是所有与UNIX类似的系统都会提供的一个标准文本编辑器。对于初学者来说，emacs和vi掌握起来都不太容易，因为两者的功能都很强大，而且操作方式与自己以前已经习惯的文本编辑器截然不同。但相对而言，vi还是更容易上手一些。<br /> &nbsp;&nbsp;&nbsp; 在命令提示符后输入vi及要编辑的文件名后，就可以进入vi全屏编辑界面。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#vi student.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 编辑文件student.txt）<br /> &nbsp;&nbsp;&nbsp; 试着输入字符串“why”，没有反应是吧？这是你还没有了解它的“脾气”。<br /> &nbsp;&nbsp;&nbsp; 与你以前使用的普通文本编辑器不同，vi有三种操作状态，分别是命令模式（command mode）、输入模式（input mode）和末行模式（last line mode），理解vi的这三种模式是很重要的。输入模式的主要功能是文本录入，这与常用的文本编辑器是一致的；命令模式的主要功能是移动鼠标和编辑文本；末行模式的主要功能是查找、替换、保存及退出。<br /> &nbsp;&nbsp;&nbsp; vi启动后默认进入命令模式。<br /> &nbsp;&nbsp;&nbsp; 在命令模式下输入i、a、o都可以进入输入模式。由命令模式切换到输入模式的三种方法是有细微区别的：按i键将从当前光标所在位置开始输入，按a键将从当前光标所在位置的下一个字符开始输入，按o键将添加一个新行，同时光标移到该行的第一个字符处开始输入。回到命令模式则按Esc键。<br /> &nbsp;&nbsp;&nbsp; 在命令模式下输入“:”可以进入末行模式。命令错误或按Esc键将回到命令模式。键入pi、q、wq将退出vi回到提示符下。</p> 
<p>●5. 进程管理命令<br /> &nbsp;&nbsp; <br /> 名称：ps<br /> 功能：查看进程<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; Linux一个很突出的优点就是可以同时高效地执行多个任务，为了更好地协调这些任务，Linux提出了进程的概念。什么是进程呢？简单地说就是系统中正在执行的各种工作，例如，在用文本编辑器修改一个文档时，在Linux看来就是有一个进程正在执行。退出编辑器后，相应的进程也就结柬了。<br /> &nbsp;&nbsp;&nbsp; 如果你对系统中正在运行的进程感兴趣，可以使用ps（process status）命令查看。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#ps－aux&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 列出系统中当前所有的进程）<br /> &nbsp;&nbsp;&nbsp; ......<br /> &nbsp;&nbsp;&nbsp; xxxy 1234 1.0 2.2 4560 1392 pts/0 S 14:18 0:00 -bash<br /> &nbsp;&nbsp;&nbsp; root 1265 0.1 1.6 4092 1008 pts/0 S 14:18 0:00 su-<br /> &nbsp;&nbsp;&nbsp; root 1266 1.6 2.2 4568 1412 pts/0 S 14:19 0:00 -bash<br /> &nbsp;&nbsp;&nbsp; root 1308 0.0 1.1 2700&nbsp;&nbsp; 732 pts/0 R 14:20 0:00 ps -aux<br /> &nbsp;&nbsp;&nbsp; 看到系统中当前所有正在运行的进程了吧。实际上ps就类似于Windows下的任务管理器。了解系统中正在执行的进程是管理员的一项必备基本功，如果你对系统的当前状态一点也不清楚，估计在同黑客周旋时要吃大亏的。<br /> &nbsp;&nbsp;&nbsp; <br /> 名称：kill<br /> 功能：结束进程<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; 就像在Windows中可以用任务管理器结束某个任务一样，在Linux中也同样可以在需要时结束当前正在运行的一些进程，方法是使用kill命令。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#kill -9 1308&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 结束进程标识符为1308的进程）<br /> &nbsp;&nbsp;&nbsp; 在使用kill命令时，必须告诉系统究竟想要结束哪个进程。所有的进程在Linux中都有一个编号，称为进程标识符（PID），在用ps命令查看进程时，输出信息中的第二个字段就是PID。<br /> &nbsp;&nbsp;&nbsp; 如果某个进程使用了kill命令仍不能结束它，试试用“-9”参数。</p> 
<p>名称：killall<br /> 功能：结束所有进程</p> 
<p>&nbsp;&nbsp;&nbsp; 如果不知道PID但知道进程名称，可以使用killall命令杀死指定名称的进程。例如，在用mount命令加载软盘时产生了硬件错误，mount命令不断地去读写磁盘，这时如果想结束该进程而又不知道其进程标识符，就可以用下面的方法。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#killall -9 mount&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 结束名称为mount的进程）<br /> &nbsp;&nbsp;&nbsp; 如果系统中名称相同的进程有多个时（比如同时有多个用户在执行mount命令进行加载），该怎样区分它们呢？<br /> &nbsp;&nbsp;&nbsp; 以root身份执行killall，它会结束系统中每个用户正在运行的同名进程，而如果是普通用户，就只会影响属于自己的进程，不会影响系统中的其他用户。<br /> &nbsp;&nbsp;&nbsp; <br /> 名称：top<br /> 功能：监视进程状态<br /> &nbsp;&nbsp;&nbsp; 对一个称职的系统管理员来说，任何时候都能监视系统性能和进程状态是很重要的，在Windows中可以使用任务管理器，而在Linux中则可以使用top命令。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#top&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 监视系统状态）</p> 
<p>●6. 软件包管理命令<br /> <br /> 名称：rpm<br /> 功能：RPM软件包的管理<br /> &nbsp;&nbsp;&nbsp; RPM的全名是Red Hat Package Manager（Red Hat软件包管理工具），由Red Hat公司开发的一个软件包管理系统。虽然RPM这一文件格式已经打上了Red Hat的烙印，但其设计理念却是开放的，并且现在已经成为公认的行业标准了。<br /> &nbsp;&nbsp;&nbsp; 使用RPM可以很轻松地实现软件的安装、查询和卸载，你甚至会发现它比在Windows中安装软件还要简单。<br /> Red Hat公司一直鼓励Linux软件开发商以RPM方式来发布他们的软件，标准的RPM软件包都以 xxx-v-m.p.rpm命名，如tree-1.2-20.i386.rpm，它包含了软件包的名称（tree），主版本号（1.2），次版本号（20）及适用的硬件平台（i386），但并非所有的RPM软件包都按照这样的格式来命名。<br /> &nbsp;&nbsp;&nbsp; 目前RPM除了在Red Hat Linux中得到了广泛应用外，其实还可以在许多其它的Linux和Unix系统上运行。<br /> &nbsp;&nbsp;&nbsp; 第一、软件安装<br /> &nbsp;&nbsp;&nbsp; 在用RPM安装软件包时，软件包内所有的文件都将自动被复制到Linux系统中的正确位置上，无需你亲自动手。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia RPMS]#rpm -ivh tree-1.2-20.i386.rpm&nbsp;&nbsp;&nbsp; （# 安装软件包）<br /> &nbsp;&nbsp;&nbsp; 第二、卸载软件<br /> &nbsp;&nbsp;&nbsp; 要卸载已经安装的RPM软件包也很简单，使用“-e”参数就可以了。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#rpm -e tree-1.2-20.i386.rpm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 卸载软件包）<br /> &nbsp;&nbsp;&nbsp; 在卸载软件包时，只要给出软件包的名称（如“tree”或“tree-1.2”）就可以了，而不必象当初安装软件包时要用完整的文件名。<br /> &nbsp;&nbsp;&nbsp; 第三、升级软件<br /> &nbsp;&nbsp;&nbsp; Linux下软件升级的速度比Windows下的软件快多了，RPM将软件的升级变得空非常简单。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia RPMS]#rpm -Uvh tree-1.2-20.i386.rpm&nbsp;&nbsp;&nbsp; （# 升级软件包）<br /> &nbsp;&nbsp;&nbsp; 在升级软件包时，RPM将首先删除系统中已有的旧版本，然后再安装新版本。其实不管以前是否曾经安装过该软件，都可以用“rpm－Uvh”来进行安装。<br /> &nbsp;&nbsp;&nbsp; 第四、查询软件<br /> &nbsp;&nbsp;&nbsp; 如果对某个软件包的相关信息感兴趣，可以使用RPM的查询功能。例如，在使用gcc编译源程序时，可能关心它当前的版本号，通过执行命令：<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#rpm -q gcc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 查询gcc软件包）<br /> &nbsp;&nbsp;&nbsp; gcc-3.2-7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 查询结果）<br /> &nbsp;&nbsp;&nbsp; 屏幕上将显示查找到的软件包的名称和版本号。<br /> &nbsp;&nbsp;&nbsp; 如果还不满足，想知道tree软件包中究竟包含哪些文件，RPM依然能够很轻松地实现。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#rpm -ql tree&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 查询tree软件包中的文件）<br /> &nbsp;&nbsp;&nbsp; 能够知道系统中安装的所有软件包吗？当然没问题，对RPM来讲简直就是举手之劳。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#rpm -qa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 查询系统中安装的所有软件包）<br /> &nbsp;&nbsp;&nbsp; <br /> ●名称：tar<br /> 功能：打包文件＿<br /> &nbsp;&nbsp;&nbsp; tar命令可以将指定的文件和目录打包成一个文件，这是一个在Unix系统中很早就被广泛使用的一个文件备份工具。在没有光盘和刻录机的年代，系统管理员通常都将数据备份到磁带机上，由于磁带只能顺序读写，备份多个目录和文件是相当麻烦的，这时tar命令可就帮上大忙了。<br /> &nbsp;&nbsp;&nbsp; 第一、打包和解包<br /> &nbsp;&nbsp;&nbsp; tar命令最常用的功能是打包和解包。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#tar cvf backup.tar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 将当前目录下所有文件打包为backup.tar）<br /> &nbsp;&nbsp;&nbsp; 需要时可以用下面的命令将其解包：<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#tar xvf backup.tar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 将backup.tar文件解包）<br /> &nbsp;&nbsp;&nbsp; 第二、压缩和解压<br /> &nbsp;&nbsp;&nbsp; tar命令可以将一个目录下的所有文件打包成一个文件，但并不进行压缩，也就是说，打包后的文件所占用的磁盘空间等于该目录下所有文件所占磁盘空间的总和。如果磁盘空间不足或为了便于传输时，可以在打包文件时为tar命令指定相应的参数，告诉tar使用相应的压缩工具进行压缩。例如，执行命令：<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#tar czvf backup.tar.gz /tmp/（# 将整个/tmp/打包并且压缩为backup.tar.gz）<br /> &nbsp;&nbsp;&nbsp; 要解包经过压缩的文件，可以使用下面的命令：<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#tar xzvf backup.tar.gz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 解包经过压缩的backup.tar.gz文件）<br /> &nbsp;&nbsp;&nbsp; tar本身并不具备压缩和解压缩的功能，通过为其加上参数“-z”，tar会使用gzip命令来对打包后的文件进行压缩和解压缩。习惯上将压缩后的打包文件命名为xxx.tar.gz或xxx.tgz。<br /> &nbsp;&nbsp;&nbsp; <br /> ●7. 压缩及解压缩命令<br /> &nbsp;&nbsp;&nbsp; <br /> 名称：gzip<br /> 功能：压缩文件<br /> &nbsp;&nbsp;&nbsp; gzip是Linux中最常用的压缩工具，使用它可以得到很高的压缩率，这也就是为什么从FTP网站下载的文件大多都是采用gzip压缩的原因。虽然处理时间会比较长，但经gzip压缩后的文件大小将小很多。下面的命令用来对文件进行压缩：<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#gzip data.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 压缩文件data.txt）<br /> &nbsp;&nbsp;&nbsp; gzip只能用来对单个文件进行压缩，通常不能用来处理目录，如果要将整个目录压缩成一个文件，可以将<br /> gzip和tar结合起来使用：先用tar命令将其打包成一个文件，然后再用gzip对打包后的文件进行压缩。<br /> <br /> 名称：gunzip<br /> 功能：解压缩文件<br /> &nbsp;&nbsp;&nbsp; 用gzip压缩后的文件可以用gunzip进行解压缩，但gunzip的功能并不仅限于此，还可以用来解压缩扩展名为gz、tgz、z和Z的文件。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#gunzip data.txt.tgz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 解压缩data.txt.tgz文件）<br /> <br /> 名称：bzip2<br /> 功能：压缩文件<br /> <br /> &nbsp;&nbsp;&nbsp; bzip2也是Linux下的一个常用文件压缩命令，Linux内核源码在发布时就是采用bzip2进行压缩的。用bzip2可以将一个文件压缩成.bz2格式。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#bzip2 data.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 压缩文件data.txt）<br /> &nbsp;&nbsp;&nbsp; <br /> 名称：bunzip2<br /> 功能：解压缩文件<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; 用bzip2压缩后的文件可以用bunzip2进行解压。<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#bunzip2 data.txt.bz2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 解压缩文件data.txt.bz2）<br /> &nbsp;&nbsp;&nbsp; 现在经常会在网上碰到名为*tar.bz2的文件，这些文件都是用tar打包并用bzip2进行压缩后的结果，在解压缩这类文件时可以用下面的命令：<br /> &nbsp;&nbsp;&nbsp; [root@yanghsia root]#bunzip2 -c backup.tar.bz2 | tar xvf</p> 
<p> </p> 
<p>其他命令：<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp; [root@yanghsia root]#df&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （# 查看磁盘使用情况）</p></div></body></html>