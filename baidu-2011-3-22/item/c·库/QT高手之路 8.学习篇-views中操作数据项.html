<html><head><title><div class="tit">
  QT高手之路 8.学习篇-views中操作数据项
</div></title></head><body><div id='tit'>QT高手之路 8.学习篇-views中操作数据项</div><div id='cate'>c&middot;库</div><div id='date'>2009年04月27日 星期一 02:20 A.M.</div><div id='page'>53</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/033fd74336ee5b1b72f05d3c.html'>http://hi.baidu.com/hxzon/blog/item/033fd74336ee5b1b72f05d3c.html</a><div id='cnt'><p>QT高手之路 8.学习篇-views中操作数据项</p> 
<p><strong><font size="5">views中选择数据项</font></strong></p> 
<p><span style="color: #0000ff"><strong>概念</strong></span></p> 
<p>用于新的view类中的选择模型比Qt3中的模型有了很大的改进。它为基于model/view架构的选择提供了更为全面的描述。尽管对提供了的views来说，负责操纵选择的标准类已经足以应付，但是你也可以创建特定的选择模型来满足你特殊的需求。<br /> 关于在view被选择的数据项的信息保持在<span style="color: #0000ff">QItemSelectionModel</span>类的实例中。它也为每个独立的model中的数据项维护model indexes信息，与任何views都关联关系。既然一个model可用于多个views,那么在多个views之间共享选择信息也是可以做到的，这使得多个views可以以一致的方式进行显示。<br /> 选择由多个选择范围组成。通过仅仅记录开始model indexes与结束model indexes，最大化地记录了可以选择的范围。非连续选择数据项由多个选择范围来描述。选择模型记录model indexes的集合来描述一个选择。最近选择的数据项被称为<span style="color: #0000ff">current</span> <span style="color: #0000ff">selection</span>。应用程序可以通过使用某种类型的选择命令来修改选择的效果。<br /> 在进行选择操作时，可以把<span style="color: #0000ff">QItemSelectionModel</span>看成是model中所有数据项选择状态的一个记录。一旦建立一个选择模型，所有项的集合都可以选择，撤消选择，或者选择状态进行切换而不需要知道哪个数据项是否已经被选择过。所有被选择的项的indexes在任何时候都可以得到，通过信号槽机制可以通知别的组件发生的变化。<br /> <br /> <strong style="color: #0000ff">使用选择模型<br /> </strong>标准view类提供了缺省的选择模型，它们可以在大次数程序中使用。一个view中的选择模型可以通过调用view的函数<span style="color: #ff00ff">selectionModel</span>()取得，也可以通过<span style="color: #ff00ff">setSelectionModel</span>()在多个views之间共享选择模型，因此总的来说构建一个新的模型一般情况不太必要。<br /> 通过给<span style="color: #0000ff">QItemSelection</span>指定一个model,一对model indexes，可以创建一个选择。indexes的用法依赖于给定的model,这两个indexes被解释成选择的区块中的左上角项和右下角项。model中的项的选择服从于选择模型。<br /> <br /> <span style="color: #0000ff">选择项</span><br /> 构建一个table model ，它有32个项，用一个table view进行显示：<br /> &nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">TableModel</span> *model = new TableModel(8, 4, &amp;app);</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">QTableView</span> *table = new QTableView(0);<br /> &nbsp;&nbsp;&nbsp;&nbsp; table-&gt;<span style="color: #ff00ff">setModel</span>(model);</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">QItemSelectionModel</span> *selectionModel = table-&gt;<span style="color: #ff00ff">selectionModel</span>();<br /> &nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">QModelIndex</span> topLeft;<br /> &nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">QModelIndex</span> bottomRight;</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; topLeft = model-&gt;index(0, 0, QModelIndex());<br /> &nbsp;&nbsp;&nbsp;&nbsp; bottomRight = model-&gt;index(5, 2, QModelIndex());<br /> &nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">QItemSelection</span> selection(topLeft, bottomRight);<br /> &nbsp;&nbsp;&nbsp;&nbsp; selectionModel-&gt;<span style="color: #ff00ff">select</span>(selection, QItemSelectionModel::<span style="color: #ff00ff">Select</span>);<br /> 结果如下：<br /> <br /> <br /> <span style="color: #0000ff"><img width="374" height="244" src="image/QT高手之路 8.学习篇-views中操.175317649.p.png-d=20081227175325383" /><p class="origImg">http://album.hi.csdn.net/app_uploads/xjp86/20081227/175317649.p.png?d=20081227175325383</p></span></p> 
<p><span style="color: #0000ff">读取选择状态</span> <br /> 存储在选择模型中indexes可以用selectionIndexes()函数来读取。它返回一个未排序的model indexes列表，我们可以遍历它，如果我们知道他们关联于哪个model的话。<br /> &nbsp;&nbsp;&nbsp; <span style="color: #0000ff">QModelIndexList</span> indexes = selectionModel-&gt;<span style="color: #ff00ff">selectedIndexes</span>();<br /> &nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">QModelIndex</span> index;</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #ff00ff">foreach</span>(index, indexes) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QString text = QString(&quot;(%1,%2)&quot;).arg(index.row()).arg(index.column());<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; model-&gt;setData(index, text);<br /> &nbsp;&nbsp;&nbsp;&nbsp; }<br /> 选择模型在选择发生变化时会发出信号。这用于通知别的组件包括整体与当前焦点项所发生的变化。我们可以连接selectionChanged()信号到一个槽，检查当信号产生时哪些项被选择或被取消选择。这个槽被调用时带有两个参数，它们都是<span style="color: #0000ff">QItemSelection</span>对象，一个包含新被选择的项，另一个包含新近被取消选择的项。下面的代码演示了给新选择的项添加数据内容，新近被取消选择的项的内容被清空。<br /> void MainWindow::<span style="color: #ff00ff">updateSelection</span>(const <span style="color: #0000ff">QItemSelection</span> &amp;<span style="color: #ff00ff">selected</span>,<br /> &nbsp;&nbsp;&nbsp;&nbsp; const <span style="color: #0000ff">QItemSelection</span> &amp;<span style="color: #ff00ff">deselected</span>)<br /> {<br /> &nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">QModelIndex</span> index;<br /> &nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">QModelIndexList</span> items = selected.<span style="color: #ff00ff">indexes</span>();</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #ff00ff">foreach</span> (index, items) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QString text = QString(&quot;(%1,%2)&quot;).arg(index.row()).arg(index.column());<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; model-&gt;setData(index, text);<br /> &nbsp;&nbsp;&nbsp;&nbsp; }</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; items = deselected.<span style="color: #ff00ff">indexes</span>();</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #ff00ff">foreach</span> (index, items)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; model-&gt;setData(index, &quot;&quot;);<br /> }<br /> 也可以通过响应currentChanged()信号来跟踪当前焦点项.对应的槽就有两个接收参数，一个表示之前的焦点，另一个表示当前的焦点。<br /> void MainWindow::<span style="color: #ff00ff">changeCurrent</span>(const <span style="color: #0000ff">QModelIndex</span> &amp;current,<br /> &nbsp;&nbsp;&nbsp;&nbsp; const <span style="color: #0000ff">QModelIndex</span> &amp;previous)<br /> {<br /> &nbsp;&nbsp;&nbsp;&nbsp; statusBar()-&gt;showMessage(<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tr(&quot;Moved from (%1,%2) to (%3,%4)&quot;)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .arg(previous.row()).arg(previous.column())<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .arg(current.row()).arg(current.column()));<br /> }</p> 
<p><span style="color: #0000ff">更新选择<br /> </span>选择指令是通过选择标志提供的，它被定义在QItemSelectionModel::SelectionFlag中。常用的有Select标记，Toggle标记，Deselect标记,Current标记，Clear标记，其意义一目了然。沿上面例子的结果执行以下代码：<br /> &nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">QItemSelection</span> toggleSelection;</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; topLeft = model-&gt;index(2, 1, QModelIndex());<br /> &nbsp;&nbsp;&nbsp;&nbsp; bottomRight = model-&gt;index(7, 3, QModelIndex());<br /> &nbsp;&nbsp;&nbsp;&nbsp; toggleSelection.<span style="color: #ff00ff">select</span>(topLeft, bottomRight);</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; selectionModel-&gt;<span style="color: #ff00ff">select</span>(toggleSelection, QItemSelectionModel::<span style="color: #ff00ff">Toggle</span>);<br /> 结果如下:<br /> <br /> <br /> <img width="374" height="244" src="image/QT高手之路 8.学习篇-views中操.175359602.p.png-d=20081227175412211" /><p class="origImg">http://album.hi.csdn.net/app_uploads/xjp86/20081227/175359602.p.png?d=20081227175412211</p></p> 
<p>缺省情况下，选择指令只针对单个项(由model indexes指定)。然而，选择指令可以通过与另外标记的结合来改变整行和整列。举例来说，假如你只使用一个index来调用select(),但是用Select标记与Rows标记的组合，那么包括那个项的整行都将被选择。看以下示例：<br /> &nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">QItemSelection</span> columnSelection;</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; topLeft = model-&gt;index(0, 1, QModelIndex());<br /> &nbsp;&nbsp;&nbsp;&nbsp; bottomRight = model-&gt;index(0, 2, QModelIndex());</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; columnSelection.<span style="color: #ff00ff">select</span>(topLeft, bottomRight);</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; selectionModel-&gt;select(columnSelection,<br /> &nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">QItemSelectionModel</span>::Select | <span style="color: #0000ff">QItemSelectionModel</span>::<span style="color: #ff00ff">Columns</span>);</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">QItemSelection</span> rowSelection;</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; topLeft = model-&gt;index(0, 0, QModelIndex());<br /> &nbsp;&nbsp;&nbsp;&nbsp; bottomRight = model-&gt;index(1, 0, QModelIndex());</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; rowSelection.<span style="color: #ff00ff">select</span>(topLeft, bottomRight);</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; selectionModel-&gt;select(rowSelection,<br /> &nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">QItemSelectionModel</span>::Select | <span style="color: #0000ff">QItemSelectionModel</span>::<span style="color: #ff00ff">Rows</span>);<br /> 结果如下<br /> <br /> <br /> <span style="color: #0000ff"><img width="374" height="244" src="image/QT高手之路 8.学习篇-views中操.175440555.p.png-d=20081227175456680" /><p class="origImg">http://album.hi.csdn.net/app_uploads/xjp86/20081227/175440555.p.png?d=20081227175456680</p></span></p> 
<p><span style="color: #0000ff">选择模型中所有项<br /> </span>为了选择model中的所有项，必须先得创建一个选择，它包括当前层次上的所有项:<br /> &nbsp;&nbsp;&nbsp; <span style="color: #0000ff">QModelIndex</span> topLeft = model-&gt;index(0, 0, parent);<br /> &nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">QModelIndex</span> bottomRight = model-&gt;<span style="color: #ff00ff">index</span>(model-&gt;<span style="color: #ff00ff">rowCount</span>(parent)-1,<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; model-&gt;<span style="color: #ff00ff">columnCount</span>(parent)-1, parent);<br /> <br /> &nbsp;&nbsp;&nbsp; <span style="color: #0000ff">QItemSelection</span> selection(topLeft, bottomRight);<br /> &nbsp;&nbsp;&nbsp;&nbsp; selectionModel-&gt;<span style="color: #ff00ff">select</span>(selection, QItemSelectionModel::Select);<br /> 顶级index可以这样：<br /> QModelIndex parent = <span style="color: #ff00ff">QModelIndex</span>();<br /> 对具有层次结构的model来说，可以使用<span style="color: #ff00ff">hasChildren</span>()函数来决定给定项是否是其它项的父项。<br /> <a href="http://blog.csdn.net/xjp86/archive/2008/12/27/3622577.aspx">http://blog.csdn.net/xjp86/archive/2008/12/27/3622577.aspx</a></p></div></body></html>