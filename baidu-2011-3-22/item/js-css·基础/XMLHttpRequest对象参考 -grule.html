<html><head><title><div class="tit">
  XMLHttpRequest对象参考 -grule
</div></title></head><body><div id='tit'>XMLHttpRequest对象参考 -grule</div><div id='cate'>js-css&middot;基础</div><div id='date'>2008年09月24日 星期三 03:26 P.M.</div><div id='page'>98</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/809caaafd38010ca7dd92a6b.html'>http://hi.baidu.com/hxzon/blog/item/809caaafd38010ca7dd92a6b.html</a><div id='cnt'><div> 
 <h1 style="color: #ff0000">XMLHttpRequest对象参考 -grule</h1> 
 <p>提供客户端同http服务器通讯的协议</p> 
 <blockquote> 
  <pre>Dim HttpReq As New MSXML2.XMLHTTP30 
HttpReq.open &quot;GET&quot;, &quot;http://localhost/books.xml&quot;, False 
HttpReq.send 
MsgBox HttpReq.responseText</pre> 
 </blockquote> 
 <h2>备注</h2> 
 <p>客户端可以通过XmlHttp对象(MSXML2.XMLHTTP.3.0)向http服务器发送请求并使用微软XML文档对象模型Microsoft&reg; XML Document Object Model (DOM)处理回应。</p> 
 <h1 style="color: #ff0000">XMLHttpRequest成员</h1> 
 <h2>属性</h2> 
 <p> </p> 
 <table class="t1" border="1" cellpadding="3"> 
  <tbody> 
   <tr> 
    <td><a href="http://www.feisha.cn/Articles/Art.63.htm#onreadystatechange"><font color="#003366">onreadystatechange</font></a></td> 
    <td>指定当readyState属性改变时的事件处理句柄。只写</td> 
   </tr> 
   <tr> 
    <td><a href="http://www.feisha.cn/Articles/Art.63.htm#readystate"><font color="#003366">readyState</font></a></td> 
    <td>返回当前请求的状态，只读.</td> 
   </tr> 
   <tr> 
    <td><a href="http://www.feisha.cn/Articles/Art.63.htm#responsebody"><font color="#003366">responseBody</font></a></td> 
    <td>将回应信息正文以unsigned byte数组形式返回.只读</td> 
   </tr> 
   <tr> 
    <td><a href="http://www.feisha.cn/Articles/Art.63.htm#responsestream"><font color="#003366">responseStream</font></a></td> 
    <td>以Ado Stream对象的形式返回响应信息。只读</td> 
   </tr> 
   <tr> 
    <td><a href="http://www.feisha.cn/Articles/Art.63.htm#responseText"><font color="#003366">responseText</font></a></td> 
    <td>将响应信息作为字符串返回.只读</td> 
   </tr> 
   <tr> 
    <td><a href="http://www.feisha.cn/Articles/Art.63.htm#responsexml"><font color="#003366">responseXML</font></a></td> 
    <td>将响应信息格式化为Xml Document对象并返回，只读</td> 
   </tr> 
   <tr> 
    <td><a href="http://www.feisha.cn/Articles/Art.63.htm#status"><font color="#003366">status</font></a></td> 
    <td>返回当前请求的http状态码.只读</td> 
   </tr> 
   <tr> 
    <td><a href="http://www.feisha.cn/Articles/Art.63.htm#statustext"><font color="#003366">statusText</font></a></td> 
    <td>返回当前请求的响应行状态，只读</td> 
   </tr> 
  </tbody> 
 </table> 
 <p> </p> 
 <p>* 表示此属性是W3C文档对象模型的扩展.</p> 
 <h2>方法</h2> 
 <p> </p> 
 <table class="t1" border="1" cellpadding="3"> 
  <tbody> 
   <tr> 
    <td><a href="http://www.feisha.cn/Articles/Art.63.htm#abort"><font color="#003366">abort</font></a></td> 
    <td>取消当前请求</td> 
   </tr> 
   <tr> 
    <td><a href="http://www.feisha.cn/Articles/Art.63.htm#getallresponseheaders"><font color="#003366">getAllResponseHeaders</font></a></td> 
    <td>获取响应的所有http头</td> 
   </tr> 
   <tr> 
    <td><a href="http://www.feisha.cn/Articles/Art.63.htm#getresponseheader"><font color="#003366">getResponseHeader</font></a></td> 
    <td>从响应信息中获取指定的http头</td> 
   </tr> 
   <tr> 
    <td><a href="http://www.feisha.cn/Articles/Art.63.htm#open"><font color="#003366">open</font></a></td> 
    <td>创建一个新的http请求，并指定此请求的方法、URL以及验证信息(用户名/密码)</td> 
   </tr> 
   <tr> 
    <td><a href="http://www.feisha.cn/Articles/Art.63.htm#send"><font color="#003366">send</font></a></td> 
    <td>发送请求到http服务器并接收回应</td> 
   </tr> 
   <tr> 
    <td><a href="http://www.feisha.cn/Articles/Art.63.htm#setrequestheader"><font color="#003366">setRequestHeader</font></a></td> 
    <td>单独指定请求的某个http头</td> 
   </tr> 
  </tbody> 
 </table> 
 <p> </p> 
 <h1 style="color: #ff0000">onreadystatechange</h1> 
 <p>指定当readyState属性改变时的事件处理句柄</p> 
 <h2>语法</h2> 
 <blockquote> 
  <pre>oXMLHttpRequest.onreadystatechange = funcMyHandler;</pre> 
 </blockquote> 
 <p>如下的例子演示当XMLHTTPRequest对象的readyState属性改变时调用HandleStateChange函数，当数据接收完毕后（readystate == 4）此页面上的一个按钮将被激活</p> 
 <blockquote> 
  <pre>var xmlhttp=null; 
function PostOrder(xmldoc) 
{ 
  var xmlhttp = new ActiveXObject(&quot;Msxml2.XMLHTTP.5.0&quot;); 
  xmlhttp.Open(&quot;POST&quot;, &quot;http://myserver/orders/processorder.asp&quot;, false);  
  xmlhttp.onreadystatechange= HandleStateChange; 
  xmlhttp.Send(xmldoc); 
  myButton.disabled = true; 
} 
function HandleStateChange() 
{ 
  if (xmlhttp.readyState == 4) 
  { 
    myButton.disabled = false; 
    alert(&quot;Result = &quot; + xmlhttp.responseXML.xml); 
  } 
}</pre> 
 </blockquote> 
 <h2>备注</h2> 
 <p>此属性只写，为W3C文档对象模型的扩展.</p> 
 <h1 style="color: #ff0000">readyState</h1> 
 <p>返回XMLHTTP请求的当前状态</p> 
 <h2>语法</h2> 
 <blockquote> 
  <pre>lValue = oXMLHttpRequest.readyState;</pre> 
  <pre>var XmlHttp; 
XmlHttp = new ActiveXObject(&quot;Msxml2.XMLHTTP.3.0&quot;); 

function send() { 
   XmlHttp.onreadystatechange = doHttpReadyStateChange; 
   XmlHttp.open(&quot;GET&quot;, &quot;http://localhost/sample.xml&quot;, true); 
   XmlHttp.send(); 
} 

function doHttpReadyStateChange() { 
   if (XmlHttp.readyState == 4) { 
      alert(&quot;Done&quot;); 
   } 
}</pre> 
 </blockquote> 
 <h2>备注</h2> 
 <p>变量，此属性只读，状态用长度为4的整型表示.定义如下：</p> 
 <p> </p> 
 <table class="t1" border="1" cellpadding="3"> 
  <tbody> 
   <tr> 
    <td>0 (未初始化)</td> 
    <td>对象已建立，但是尚未初始化（尚未调用open方法）</td> 
   </tr> 
   <tr> 
    <td>1 (初始化)</td> 
    <td>对象已建立，尚未调用send方法</td> 
   </tr> 
   <tr> 
    <td>2 (发送数据)</td> 
    <td>send方法已调用，但是当前的状态及http头未知</td> 
   </tr> 
   <tr> 
    <td>3 (数据传送中)</td> 
    <td>已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，</td> 
   </tr> 
   <tr> 
    <td>4 (完成)</td> 
    <td>数据接收完毕,此时可以通过通过responseBody和responseText获取完整的回应数据</td> 
   </tr> 
  </tbody> 
 </table> 
 <p> </p> 
 <h1 style="color: #ff0000">responseBody</h1> 
 <p>返回某一格式的服务器响应数据</p> 
 <h2>语法</h2> 
 <blockquote> 
  <pre>strValue = oXMLHttpRequest.responseBody;</pre> 
  <pre>var xmlhttp = new ActiveXObject(&quot;Msxml2.XMLHTTP.3.0&quot;); 
xmlhttp.open(&quot;GET&quot;, &quot;http://localhost/books.xml&quot;, false); 
xmlhttp.send(); 
alert(xmlhttp.responseBody);</pre> 
 </blockquote> 
 <h2>备注</h2> 
 <p>变量，此属性只读，以unsigned array格式表示直接从服务器返回的未经解码的二进制数据。</p> 
 <h1 style="color: #ff0000">responseStream</h1> 
 <p>以Ado Stream对象的形式返回响应信息</p> 
 <h2>语法</h2> 
 <blockquote> 
  <pre>strValue = oXMLHttpRequest.responseStream;</pre> 
 </blockquote> 
 <h2>备注</h2> 
 <p>变量，此属性只读，以Ado Stream对象的形式返回响应信息。</p> 
 <h1 style="color: #ff0000">responseText</h1> 
 <p>将响应信息作为字符串返回</p> 
 <h2>语法</h2> 
 <blockquote> 
  <pre>strValue = oXMLHttpRequest.responseText;</pre> 
  <pre>var xmlhttp = new ActiveXObject(&quot;Msxml2.XMLHTTP.3.0&quot;); 
xmlhttp.open(&quot;GET&quot;, &quot;http://localhost/books.xml&quot;, false); 
xmlhttp.send(); 
alert(xmlhttp.responseText);</pre> 
 </blockquote> 
 <h2>备注</h2> 
 <p>变量，此属性只读，将响应信息作为字符串返回。<br /> XMLHTTP尝试将响应信息解码为Unicode字符串，XMLHTTP默认将响应数据的编码定为UTF-8，如果服务器返回的数据带BOM(byte-order mark)，XMLHTTP可以解码任何UCS-2 (big or little endian)或者UCS-4 数据。注意，如果服务器返回的是xml文档，此属性并不处理xml文档中的编码声明。你需要使用<a href="http://www.feisha.cn/Articles/Art.63.htm#responsexml"><font color="#003366">responseXML</font></a>来处理。</p> 
 <h1 style="color: #ff0000">responseXML</h1> 
 <p>将响应信息格式化为Xml Document对象并返回</p> 
 <h2>语法</h2> 
 <blockquote> 
  <pre>var objDispatch = oXMLHttpRequest.responseXML;</pre> 
  <pre>var xmlhttp = new ActiveXObject(&quot;Msxml2.XMLHTTP.3.0&quot;); 
xmlhttp.open(&quot;GET&quot;, &quot;http://localhost/books.xml&quot;, false); 
xmlhttp.send(); 
alert(xmlhttp.responseXML.xml);</pre> 
 </blockquote> 
 <h2>备注</h2> 
 <p>变量，此属性只读，将响应信息格式化为Xml Document对象并返回。如果响应数据不是有效的XML文档，此属性本身不返回XMLDOMParseError，可以通过处理过的DOMDocument对象获取错误信息。</p> 
 <h1 style="color: #ff0000">status</h1> 
 <p>返回当前请求的http状态码</p> 
 <h2>语法</h2> 
 <blockquote> 
  <pre>lValue = oXMLHttpRequest.status;</pre> 
  <pre>var xmlhttp = new ActiveXObject(&quot;Msxml2.XMLHTTP.3.0&quot;); 
xmlhttp.open(&quot;GET&quot;, &quot;http://localhost/books.xml&quot;, false); 
xmlhttp.send(); 
alert(xmlhttp.status);</pre> 
 </blockquote> 
 <h2>返回值</h2> 
 <p>长整形标准http状态码，定义如下：</p> 
 <table class="t1" border="1" cellpadding="3"> 
  <tbody> 
   <tr> 
    <th>Number</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td> <p>100</p> </td> 
    <td> <p>Continue</p> </td> 
   </tr> 
   <tr> 
    <td> <p>101</p> </td> 
    <td> <p>Switching protocols</p> </td> 
   </tr> 
   <tr> 
    <td> <p>200</p> </td> 
    <td> <p>OK</p> </td> 
   </tr> 
   <tr> 
    <td> <p>201</p> </td> 
    <td> <p>Created</p> </td> 
   </tr> 
   <tr> 
    <td> <p>202</p> </td> 
    <td> <p>Accepted</p> </td> 
   </tr> 
   <tr> 
    <td> <p>203</p> </td> 
    <td> <p>Non-Authoritative Information</p> </td> 
   </tr> 
   <tr> 
    <td> <p>204</p> </td> 
    <td> <p>No Content</p> </td> 
   </tr> 
   <tr> 
    <td> <p>205</p> </td> 
    <td> <p>Reset Content</p> </td> 
   </tr> 
   <tr> 
    <td> <p>206</p> </td> 
    <td> <p>Partial Content</p> </td> 
   </tr> 
   <tr> 
    <td> <p>300</p> </td> 
    <td> <p>Multiple Choices</p> </td> 
   </tr> 
   <tr> 
    <td> <p>301</p> </td> 
    <td> <p>Moved Permanently</p> </td> 
   </tr> 
   <tr> 
    <td> <p>302</p> </td> 
    <td> <p>Found</p> </td> 
   </tr> 
   <tr> 
    <td> <p>303</p> </td> 
    <td> <p>See Other</p> </td> 
   </tr> 
   <tr> 
    <td> <p>304</p> </td> 
    <td> <p>Not Modified</p> </td> 
   </tr> 
   <tr> 
    <td> <p>305</p> </td> 
    <td> <p>Use Proxy</p> </td> 
   </tr> 
   <tr> 
    <td> <p>307</p> </td> 
    <td> <p>Temporary Redirect</p> </td> 
   </tr> 
   <tr> 
    <td> <p>400</p> </td> 
    <td> <p>Bad Request</p> </td> 
   </tr> 
   <tr> 
    <td> <p>401</p> </td> 
    <td> <p>Unauthorized</p> </td> 
   </tr> 
   <tr> 
    <td> <p>402</p> </td> 
    <td> <p>Payment Required</p> </td> 
   </tr> 
   <tr> 
    <td> <p>403</p> </td> 
    <td> <p>Forbidden</p> </td> 
   </tr> 
   <tr> 
    <td> <p>404</p> </td> 
    <td> <p>Not Found</p> </td> 
   </tr> 
   <tr> 
    <td> <p>405</p> </td> 
    <td> <p>Method Not Allowed</p> </td> 
   </tr> 
   <tr> 
    <td> <p>406</p> </td> 
    <td> <p>Not Acceptable</p> </td> 
   </tr> 
   <tr> 
    <td> <p>407</p> </td> 
    <td> <p>Proxy Authentication Required</p> </td> 
   </tr> 
   <tr> 
    <td> <p>408</p> </td> 
    <td> <p>Request Timeout</p> </td> 
   </tr> 
   <tr> 
    <td> <p>409</p> </td> 
    <td> <p>Conflict</p> </td> 
   </tr> 
   <tr> 
    <td> <p>410</p> </td> 
    <td> <p>Gone</p> </td> 
   </tr> 
   <tr> 
    <td> <p>411</p> </td> 
    <td> <p>Length Required</p> </td> 
   </tr> 
   <tr> 
    <td> <p>412</p> </td> 
    <td> <p>Precondition Failed</p> </td> 
   </tr> 
   <tr> 
    <td> <p>413</p> </td> 
    <td> <p>Request Entity Too Large</p> </td> 
   </tr> 
   <tr> 
    <td> <p>414</p> </td> 
    <td> <p>Request-URI Too Long</p> </td> 
   </tr> 
   <tr> 
    <td> <p>415</p> </td> 
    <td> <p>Unsupported Media Type</p> </td> 
   </tr> 
   <tr> 
    <td> <p>416</p> </td> 
    <td> <p>Requested Range Not Suitable</p> </td> 
   </tr> 
   <tr> 
    <td> <p>417</p> </td> 
    <td> <p>Expectation Failed</p> </td> 
   </tr> 
   <tr> 
    <td> <p>500</p> </td> 
    <td> <p>Internal Server Error</p> </td> 
   </tr> 
   <tr> 
    <td> <p>501</p> </td> 
    <td> <p>Not Implemented</p> </td> 
   </tr> 
   <tr> 
    <td> <p>502</p> </td> 
    <td> <p>Bad Gateway</p> </td> 
   </tr> 
   <tr> 
    <td> <p>503</p> </td> 
    <td> <p>Service Unavailable</p> </td> 
   </tr> 
   <tr> 
    <td> <p>504</p> </td> 
    <td> <p>Gateway Timeout</p> </td> 
   </tr> 
   <tr> 
    <td> <p>505</p> </td> 
    <td> <p>HTTP Version Not Supported</p> </td> 
   </tr> 
  </tbody> 
 </table> 
 <p> </p> 
 <h2>备注</h2> 
 <p>长整形，此属性只读，返回当前请求的http状态码,此属性仅当数据发送并接收完毕后才可获取。</p> 
 <h1 style="color: #ff0000">statusText</h1> 
 <p>返回当前请求的响应行状态</p> 
 <h2>语法</h2> 
 <blockquote> 
  <pre>strValue = oXMLHttpRequest.statusText;</pre> 
  <pre>var xmlhttp = new ActiveXObject(&quot;Msxml2.XMLHTTP.3.0&quot;); 
xmlhttp.open(&quot;GET&quot;, &quot;http://localhost/books.xml&quot;, false); 
xmlhttp.send(); 
alert(xmlhttp.statusText);</pre> 
 </blockquote> 
 <h2>备注</h2> 
 <p>字符串，此属性只读，以BSTR返回当前请求的响应行状态,此属性仅当数据发送并接收完毕后才可获取。</p> 
 <h1 style="color: #ff0000">abort</h1> 
 <p>取消当前请求</p> 
 <h2>语法</h2> 
 <blockquote> 
  <pre>oXMLHttpRequest.abort();</pre> 
 </blockquote> 
 <h2>备注</h2> 
 <p>调用此方法后，当前请求返回UNINITIALIZED 状态。</p> 
 <h1 style="color: #ff0000">getAllResponseHeaders</h1> 
 <p>获取响应的所有http头</p> 
 <h2>语法</h2> 
 <blockquote> 
  <pre>strValue = oXMLHttpRequest.getAllResponseHeaders();</pre> 
  <pre>var xmlhttp = new ActiveXObject(&quot;Msxml2.XMLHTTP.3.0&quot;); 
xmlhttp.open(&quot;GET&quot;, &quot;http://localhost/sample.xml&quot;, false); 
xmlhttp.send(); 
alert(xmlhttp.getAllResponseHeaders());</pre> 
 </blockquote> 
 <p>输出由web服务器返回的http头信息:</p> 
 <blockquote> 
  <pre>Server:Microsoft-IIS/5.1 
X-Powered-By:ASP.NET 
Date:Sat, 07 Jun 2003 23:23:06 GMT 
Content-Type:text/xml 
Accept-Ranges:bytes 
Last Modified:Sat, 06 Jun 2003 17:19:04 GMT 
ETag:&quot;a0e2eeba4f2cc31:97f&quot; 
Content-Length:9</pre> 
 </blockquote> 
 <h2>备注</h2> 
 <p>每个http头名称和值用冒号分割，并以\r\n结束。当send方法完成后才可调用该方法。</p> 
 <h1 style="color: #ff0000">getResponseHeader</h1> 
 <p>从响应信息中获取指定的http头</p> 
 <h2>语法</h2> 
 <blockquote> 
  <pre>strValue = oXMLHttpRequest.getResponseHeader(bstrHeader);</pre> 
  <pre>var xmlhttp = new ActiveXObject(&quot;MSXML2.XMLHTTP.3.0&quot;); 
xmlhttp.open(&quot;GET&quot;, &quot;http://localhost/sample.xml&quot;, false); 
xmlhttp.send(); 
alert(xmlhttp.getResponseHeader(&quot;Server&quot;));</pre> 
 </blockquote> 
 <p>输出http头中的server列：当前web服务器的版本及名称。</p> 
 <h2>备注</h2> 
 <p>当send方法成功后才可调用该方法。如果服务器返回的文档类型为&quot;text/xml&quot;, 则这句话xmlhttp.getResponseHeader(&quot;Content-Type&quot;);将返回字符串&quot;text/xml&quot;。可以使用getAllResponseHeaders方法获取完整的http头信息。</p> 
 <h1 style="color: #ff0000">open</h1> 
 <p>创建一个新的http请求，并指定此请求的方法、URL以及验证信息</p> 
 <h2>语法</h2> 
 <blockquote> 
  <pre>oXMLHttpRequest.open(bstrMethod, bstrUrl, varAsync, bstrUser, bstrPassword);</pre> 
 </blockquote> 
 <h2>参数</h2> 
 <p><em>bstrMethod</em><br /> http方法，例如：POST、GET、PUT及PROPFIND。大小写不敏感。</p> 
 <p><em>bstrUrl</em><br /> 请求的URL地址，可以为绝对地址也可以为相对地址。</p> 
 <p><em>varAsync[可选]</em><br /> 布尔型，指定此请求是否为异步方式，默认为true。如果为真，当状态改变时会调用onreadystatechange属性指定的回调函数。</p> 
 <p><em>bstrUser[可选]</em><br /> 如果服务器需要验证，此处指定用户名，如果未指定，当服务器需要验证时，会弹出验证窗口。</p> 
 <p><em>bstrPassword[可选]</em><br /> 验证信息中的密码部分，如果用户名为空，则此值将被忽略。</p> 
 <p>下面的例子演示从服务器请求book.xml,并显示其中的book字段。</p> 
 <blockquote> 
  <pre>var xmlhttp = new ActiveXObject(&quot;Msxml2.XMLHTTP.3.0&quot;); 
xmlhttp.open(&quot;GET&quot;,&quot;http://localhost/books.xml&quot;, false); 
xmlhttp.send(); 
var book = xmlhttp.responseXML.selectSingleNode(&quot;//book[@id='bk101']&quot;); 
alert(book.xml);</pre> 
 </blockquote> 
 <h2>备注</h2> 
 <p>调用此方法后，可以调用send方法向服务器发送数据。</p> 
 <h1 style="color: #ff0000">send</h1> 
 <p>发送请求到http服务器并接收回应</p> 
 <h2>语法</h2> 
 <blockquote> 
  <pre>oXMLHttpRequest.send(varBody);</pre> 
 </blockquote> 
 <h2>参数</h2> 
 <p><em>varBody </em><br /> 欲通过此请求发送的数据。</p> 
 <blockquote> 
  <pre>xmlhttp = new ActiveXObject(&quot;Msxml2.XMLHTTP.3.0&quot;); 
xmlhttp.open(&quot;GET&quot;, &quot;http://localhost/sample.xml&quot;, false); 
xmlhttp.send(); 
alert(xmlhttp.responseXML.xml);</pre> 
 </blockquote> 
 <h2>备注</h2> 
 <p>此方法的同步或异步方式取决于open方法中的bAsync参数，如果bAsync == False，此方法将会等待请求完成或者超时时才会返回，如果bAsync == True，此方法将立即返回。</p> 
 <p>This method takes one optional parameter, which is the requestBody to use. The acceptable VARIANT input types are BSTR, SAFEARRAY of UI1 (unsigned bytes), IDispatch to an XML Document Object Model (DOM) object, and IStream *. You can use only chunked encoding (for sending) when sending IStream * input types. The component automatically sets the Content-Length header for all but IStream * input types.</p> 
 <p>如果发送的数据为BSTR，则回应被编码为utf-8, 必须在适当位置设置一个包含charset的文档类型头。</p> 
 <p>If the input type is a SAFEARRAY of UI1, the response is sent as is without additional encoding. The caller must set a Content-Type header with the appropriate content type.</p> 
 <p>如果发送的数据为XML DOM object，则回应将被编码为在xml文档中声明的编码，如果在xml文档中没有声明编码，则使用默认的UTF-8。</p> 
 <p>If the input type is an IStream *, the response is sent as is without additional encoding. The caller must set a Content-Type header with the appropriate content type.</p> 
 <h1 style="color: #ff0000">setRequestHeader</h1> 
 <p>单独指定请求的某个http头</p> 
 <h2>语法</h2> 
 <blockquote> 
  <pre>oXMLHttpRequest.setRequestHeader(bstrHeader, bstrValue);</pre> 
 </blockquote> 
 <h2>参数</h2> 
 <p><em>bstrHeader</em><br /> 字符串，头名称。</p> 
 <p><em>bstrValue</em><br /> 字符串，值。</p> 
 <p> </p> 
 <h2>备注</h2> 
 <p>如果已经存在已此名称命名的http头，则覆盖之。此方法必须在open方法后调用。</p> 
 <p>另外参见 <a href="http://www.w3.org/TR/ /">http://www.w3.org/TR/XMLHttpRequest/</a></p> 
</div></div></body></html>