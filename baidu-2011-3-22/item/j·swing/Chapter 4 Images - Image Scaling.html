<html><head><title><div class="tit">
  Chapter 4 Images - Image Scaling
</div></title></head><body><div id='tit'>Chapter 4 Images - Image Scaling</div><div id='cate'>j&middot;swing</div><div id='date'>2010年06月09日 星期三 05:23 P.M.</div><div id='page'>13</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/8051fdedb2c0174279f0553f.html'>http://hi.baidu.com/hxzon/blog/item/8051fdedb2c0174279f0553f.html</a><div id='cnt'><p>Chapter 4 Images - Image Scaling</p> 
<p> </p> 
<p>《Filthy Rich Clients: Developing Animated and Graphical Effects for Desktop Java? Applications》pdf</p> 
<p>java swing image scale 图像压缩 gcode hxzon</p> 
<h3>Image Scaling3</h3> 
<p>Let’s talk about one particular image operation that has bugged me for years:<br /> scaling. Scaling tends to be a problem area for 2D programmers because of the<br /> many options available for scaling images and the accompanying variety of dif-<br /> ferences in terms of quality and performance.<br /> Tip: One of the most important items to mention here is that you should avoid per-<br /> forming a scaling operation repeatedly for any particular image that you need to dis-<br /> play at the same scaled size. If you ﬁnd that you are constantly re-rendering the<br /> same image with the same scaling factor, it may make sense to cache another pres-<br /> caled version of the image and simply copy from that prescaled image instead of<br /> scaling from the original image. This idea is discussed further in Chapter 5 under<br /> “Intermediate Images.” The idea of caching intermediate results goes beyond scal-<br /> ing images, but scaling is a great example of why this technique is useful.<br /> There are so many ways to scale an image. For any scaling operation that you<br /> need to perform, which method should you use? Here are some of the most obvi-<br /> ous ways that you might consider, although this is only a partial list:<br /> Method 1:<br /> g.drawImage(img, x, y, width, height, null);<br /> Method 2:<br /> g.drawImage(img, dx1, dy1, dx2, dy2, <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sx1, sy1, sx2, sy2, null);<br /> Method 3:<br /> g.translate(x, y);<br /> ((Graphics2D)g).scale(sx, sy);<br /> g.drawImage(img, 0, 0, null);</p> 
<p>3. I have been planning to write an article on this topic for years. I even started the article a couple of<br /> years back but deadlocked when I realized that I needed some nice code and screenshots to go along<br /> with it. So it sat on the back burner until I found myself in the middle of writing this book and want-<br /> ed to discuss the topic in the chapter on images. I wrote up a draft of this section, complete with a<br /> demo application and screenshots, sent it to Chris Campbell to review . . . and he replied that he’d<br /> just written his own article on the subject. Clearly, the topic scales quite well. For more details on<br /> this topic, check out Chris’s excellent article, “The Perils of Image.getScaledInstance()” at http://<br /> today.java.net/pub/a/today/2007/04/03/perils-of-image-getscaledinstance.html.</p> 
<p>Method 4:<br /> AffineTransform at = new AffineTransform();<br /> at.translate(x, y);<br /> at.scale(sx, sy);<br /> ((Graphics2D)g).drawImage(img, at, null);<br /> Method 5:<br /> Image scaledImg = img.getScaledInstance(w, h, hints);<br /> g.drawImage(scaledImg, x, y, null);<br /> You can see these different approaches in action in the ScalingMethods applica-<br /> tion on the book’s Web site (see Figure 4-1).<br /> The ﬁrst four of these methods are all actually quite similar, at least under the<br /> hood. Java 2D sets up scaling calculations internally that match the requirements<br /> in all four methods. The only real functional difference in the ﬁrst four<br /> approaches is that the second alternative, with all of the d* and s* parameters,<br /> allows the ﬂexibility of specifying source and destination subrectangles, instead<br /> of scaling the entire source image into place. All of these options are affected by<br /> the RenderingHints.KEY_INTERPOLATION hint, as discussed later in this chap-<br /> ter and in the “Graphics State” section of Chapter 3.<br /> The getScaledInstance() method is really a different kind of beast, which we<br /> discuss later in this chapter. Just know that there are good reasons for you to con-<br /> sider the other alternatives that we cover.<br /> Let’s discuss these approaches in more detail.<br /> g.drawImage(img, x, y, width, height, null);<br /> This approach is by far the simplest. The source image (img) is resized into an<br /> area of size (width &times; height) and drawn at the location (x, y). It is a great choice</p> 
<p>Figure 4-1&nbsp;&nbsp; The ScalingMethods application scales the same image using the ﬁve <br /> scaling methods described here.</p> 
<p>for scaling operations that ﬁt this simple model in which the source image is<br /> resized in its entirety into the destination area. <br /> Tip: If you have no overriding reason to use one of the other options, drawImage(img,<br /> x, y, w, h, null) is the scaling method you should use.<br /> g.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, null);<br /> This version is more ﬂexible than the previous version and allows a subregion of<br /> the source image, deﬁned by (sx1, sy1, sx2, sy2), to be scaled to ﬁt into the area<br /> in the destination deﬁned by the rectangle (dx1, dy1, dx2, dy2). Note that this<br /> variant uses the actual boundary points of the regions instead of the width and<br /> height parameters of some of the other approaches. This difference can make the<br /> method slightly more complicated to use than the other methods, but also more<br /> ﬂexible. Otherwise, it has similar performance characteristics to the ﬁrst option.<br /> In fact, the simpler drawImage() option can be seen as a degenerate example of<br /> this more ﬂexible method. But if you do not need the extra ﬂexibility, why<br /> bother with all of the dx/dy/sx/sy parameters?<br /> g.translate(x, y);<br /> ((Graphics2D)g).scale(sx, sy);<br /> g.drawImage(img, 0, 0, null);<br /> and<br /> AffineTransform at = new AffineTransform();<br /> at.translate(x, y);<br /> at.scale(sx, sy);<br /> Graphics2D)g).drawImage(img, at, null);<br /> These two options are listed together because they are functionally equivalent,<br /> differing only in the extra step of creating and composing the AffineTransform<br /> object in the latter approach. These options change the state of the transform<br /> used by the Graphics object and translate and scale the source image according<br /> to that transform.<br /> 4 It is a more tedious way to scale an image than the previous<br /> options and may, in the at.scale(sx, sy) case, cause you to create an unneces-<br /> sary temporary AffineTransform object. But if you happen to be doing other<br /> transforms or just have a hankering for working with matrices, feel free to use<br /> these alternatives.</p> 
<p>4. Note the necessary translation to or from some origin to perform the scaling operation around<br /> that origin. This technique is explained in the section on transforms in Chapter 3.</p> 
<p>Image scaledImg = img.getScaledInstance(w, h, hints);<br /> g.drawImage(scaledImg, x, y, null); <br /> This method is quite different from the other four options. getScaledInstance()<br /> does not render the image directly but instead creates a new image of the speci-<br /> ﬁed size, which you can then use as your source image in a drawImage() opera-<br /> tion. The hints parameter controls the trade-off between quality and performance<br /> for the scaling operation and can take on one of the following ﬁve values:<br /> Image.SCALE_AREA_AVERAGING <br /> Image.SCALE_DEFAULT <br /> Image.SCALE_FAST <br /> Image.SCALE_REPLICATE <br /> Image.SCALE_SMOOTH <br /> In Sun’s current implementation, REPLICATE is basically equivalent to the<br /> NEAREST_NEIGHBOR algorithm discussed in Chapter 3 under “RenderingHints.”<br /> FAST and DEFAULT are both set to use REPLICATE.<br /> AREA_AVERAGING averages all of the pixel values that contribute to a destination<br /> pixel value. This approach tends to give the highest quality during downscale<br /> operations, especially when scaling by large factors, at the cost of much slower<br /> performance. SMOOTH is, in Sun’s current implementation,<br /> 5 set to be equivalent to<br /> AREA_AVERAGING and thus has the same quality and performance</p> 
<h3>Quality versus Performance</h3> 
<p>The whole reason for launching into the topic of image scaling is to discuss the<br /> performance of the different scaling algorithms available to you. Like many situ-<br /> ations in graphics rendering, there is a trade-off between quality and perfor-<br /> mance. If you want better quality from your image-scaling operation, you may<br /> have to take a hit in performance. However, there are some hidden “gotchas” in<br /> the various techniques of scaling images that may trip you up unnecessarily. You<br /> can, in fact, get excellent image-scaling quality without taking a huge perfor-<br /> mance hit. You just have to know how to avoid the pitfalls.</p> 
<p>5. Rumor has it that Sun may try to change how SCALE_SMOOTH is implemented in a future version<br /> of Java SE to make it perform much better than the current implementation. It is apparently dif-<br /> ﬁcult to change AREA_AVERAGING while remaining compatible with the API speciﬁcation, but<br /> the same is not true for SMOOTH. Read on for the discussion of progressive bilinear scaling, which<br /> is what Sun is currently investigating to gain much better performance from SMOOTH.</p> 
<p>Let’s start the discussion with a subtle tip:<br /> Tip: Do not use getScaledInstance().<br /> Let me repeat that sentiment in a nicer way: <br /> Please don’t use getScaledInstance(). Or else . . .<br /> It’s just, well, slow. And there are much better alternatives available.<br /> You may be wondering why this method is an issue. In a word: quality. The qual-<br /> ity of an image-scaling operation is controlled by two mechanisms:<br /> 1. The method invoked to scale the image.<br /> 2. The scaling hint used to control the quality.</p> 
<h3>Method</h3> 
<p>Methods 1 through 4, discussed earlier, all use the internal implementation of<br /> Graphics, whereas Method 5 uses getScaledInstance(). To simplify the dis-<br /> cussion, let’s assume that if you’re not using getScaledInstance(), you’re<br /> using the drawImage(img, x, y, w, h, null) method of java.awt.Graphics<br /> shown earlier.</p> 
<h3>Scaling Hints</h3> 
<p>Each of the two approaches, drawImage() and getScaledInstance(), uses a<br /> different set of hints. The hints for scaling with drawImage() are set by a call to<br /> setRenderingHint(), which we introduced in the “Graphics State” section of<br /> Chapter 3, with the key RenderingHints.KEY_INTERPOLATION. Recall that that<br /> key takes one of the following three values:<br /> RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR <br /> RenderingHints.VALUE_INTERPOLATION_BILINEAR <br /> RenderingHints.VALUE_INTERPOLATION_BICUBIC <br /> The default hint for scaling with drawImage() is NEAREST_NEIGHBOR. This algo-<br /> rithm is the simplest to compute and, as you would expect, the fastest. BILINEAR<br /> is slower, but provides better quality. BICUBIC is better still, but comes at an even<br /> higher performance cost.<br /> The hints for getScaledInstance(), on the other hand, are provided during the<br /> call to that function and come from the java.awt.Image class:<br /> Image.SCALE_DEFAULT <br /> Image.SCALE_REPLICATE <br /> Image.SCALE_FAST </p> 
<p>Image.SCALE_SMOOTH <br /> Image.SCALE_AREA_AVERAGING <br /> These hints break down into two categories: DEFAULT, REPLICATE, and FAST are<br /> all equivalent on Sun’s Java implementation and use the same approach as the<br /> NEAREST_NEIGHBOR hint for drawImage(). The AREA_AVERAGING and SMOOTH<br /> approaches are equivalent on Sun’s Java implementation, producing a higher<br /> quality result in general than either the other hints for getScaledInstance() or<br /> the BILINEAR and BICUBIC results for drawImage(), especially when scaling<br /> down an image by a large factor.</p> 
<h3>Downscaling Quality Results</h3> 
<p>With the bilinear technique, the scaling algorithm samples the four pixels closest<br /> to the source pixel that each pixel in the scaled image maps back to, averaging<br /> those colors to get the ﬁnal result. This approach provides a reasonable result<br /> when these surrounding pixels represent most of the color information that<br /> should go into that ﬁnal pixel. However, if the image is downscaled by a large<br /> factor from the original, each pixel in the resulting image must represent a far<br /> greater number of pixels from the original image, so sampling only the four<br /> nearest pixels is not enough. Important information from the original image is<br /> lost in the process.<br /> Bicubic is similar to bilinear except that it uses a 4 &times; 4 grid of pixels surrounding<br /> the source pixel. This increased amount of data means that downscales retain<br /> more information from the original image than is the case for bilinear down-<br /> scales. But downscaling by a large factor will still lose a lot of pixel data, result-<br /> ing in a loss of quality.<br /> Area averaging, on the other hand, samples all of the pixels that contribute to the<br /> scaled pixel value, no matter what the scaling factor. This approach provides a<br /> far more accurate value for each of the pixels in the ﬁnal image. Consequently,<br /> using getScaledInstance() with the Image.SCALE_AREA_AVERAGING hint pro-<br /> vides much higher quality for large downscales than drawImage() using either<br /> BILINEAR or BICUBIC.<br /> Let’s look at the quality of the various algorithms from lowest to highest:<br /> • NEAREST_NEIGHBOR: This algorithm is used when you call drawImage()<br /> with no hint, as well as when you call getScaledInstance() with either<br /> SCALE_REPLICATE, SCALE_FAST, or SCALE_DEFAULT. This algorithm is the<br /> fastest but results in the worst quality, with artifacts that are more notice-<br /> able as the scale magnitude increases.</p> 
<p>• BILINEAR: drawImage() with the hint RenderingHints.VALUE_<br /> INTERPOLATION_BILINEAR provides reasonable quality for small down-<br /> scales in which the scaled image is greater than half the size of the original.<br /> However, as with NEAREST_NEIGHBOR, artifacts are more noticeable as the<br /> scale magnitude increases. This approach does, however, tend to provide<br /> the best results for upscales.<br /> • BICUBIC: drawImage() with the hint RenderingHints.VALUE_<br /> INTERPOLATION_BICUBIC provides good quality for small downscales.<br /> However, artifacts are more noticeable as the scale magnitude increases.<br /> • AREA_AVERAGING: getScaledInstance() in conjunction with Image.SCALE_<br /> AREA_AVERAGING provides the best ﬁltering quality of these options for<br /> large downscales. For downscales in which the result is more than half<br /> the size of the original image, this approach is roughly equivalent to<br /> BILINEAR, but as the downscale factor increases, this approach looks better<br /> than BILINEAR and BICUBIC. Upscaling, in which the result is larger than the<br /> original image, tends to have worse quality than the BILINEAR approach.<br /> If the quality comparison is that clear, why are we even discussing it? If you<br /> need a quality downscale, shouldn’t you use getScaledInstance() with<br /> Image.SCALE_AREA_AVERAGING, regardless of the performance implications?<br /> No. With the performance differences involved, which can easily be orders of<br /> magnitude between getScaledInstance() and any of the other approaches, it is<br /> worth seeing if there is a better alternative that provides both the quality and per-<br /> formance that you need. We don’t want to sacriﬁce too much performance for<br /> the sake of quality, but we would like our images to look good. Let’s consider an<br /> alternate approach instead: progressive bilinear scaling.</p> 
<h3>Progressive Bilinear Scaling</h3> 
<p>We know that a signiﬁcant problem with the quality of the bilinear approach<br /> occurs when the downscale is by more than 50 percent. So what if we compen-<br /> sated for that problem by scaling iteratively toward the ﬁnal size, scaling down<br /> by exactly 50 percent each time until the ﬁnal iteration, when we scale by 50<br /> percent or less? Then we would account for all of the pixels along the way that<br /> should ﬁgure into the ﬁnal image. And, believe it or not, we can do this in a frac-<br /> tion of the time required by the area-averaging technique.<br /> We show the code for this approach, but ﬁrst let’s see some pictures to motivate<br /> the quality and performance angles of this discussion.</p> 
<p>Example: ScaleTest<br /> The ScaleTest demo on the book’s Web site shows how an image looks when it<br /> is scaled down by progressively larger factors. The original image is a collage of<br /> four different images, shown in Figure 4-2, representing four different types of<br /> graphics situations:<br /> • RGB stripes: The upper-left quadrant is simply repeating stripes of red,<br /> green, and blue. This is probably not something you would see in a typical<br /> application, but it’s great for demonstrating some of the artifacts in these<br /> scaling operations.<br /> • Photograph: The upper-right quadrant is a thumbnail of a photograph,<br /> which represents pictures that a typical application might show in its UI.<br /> • Vector drawing: The beautiful smiley face in the lower-left quadrant is a<br /> simple line drawing, black on white.<br /> • Grid: The lower-right quadrant is a simple black-and-white line grid,<br /> which shows some of the rendering artifacts of scaling nicely.<br /> The ScaleTest demo scales the image down several times from the original<br /> image, increasing the amount of the scale each time. It does this for ﬁve different</p> 
<p>Figure 4-2&nbsp;&nbsp; ScaleTest: Source image with RGB stripes, a photograph, vector art, and a <br /> black and white grid.</p> 
<p>approaches to scaling, timing the results for each approach and displaying the<br /> rendering times in the window.<br /> You can see the results of a sample run of ScaleTest in Figure 4-3. The columns<br /> in the ﬁgure show the different scaled sizes, with the original image on the left.<br /> The rows represent the different ways of scaling the images, from NEAREST_<br /> NEIGHBOR to BILINEAR to BICUBIC to getScaledInstance() with the AREA_</p> 
<p>Figure 4-3&nbsp;&nbsp; ScaleTest results for various alternative approaches to scaling. Times <br /> are in milliseconds for the total time taken to render each row of scaled images.</p> 
<p>AVERAGING hint and ﬁnally to our new progressive bilinear approach. The time<br /> that each row took to produce the series of scaled images is displayed on the left<br /> of each row.<br /> What you should notice about the ﬁgure is that the artifacts of scaling increase as<br /> the scaled images get smaller and that the artifacts are more noticeable in the<br /> ﬁrst three rows (NEAREST, BILINEAR, and BICUBIC). You should also notice the<br /> performance times for each of the rows. Rendering all of the NEAREST images<br /> took the least time (“0” here means that the real time was within the resolution of<br /> the timer being used, or about 1 to 2 milliseconds). BILINEAR took a bit more at<br /> 3 milliseconds. BICUBIC took 8 milliseconds. getScaledInstance() took the<br /> most at a whopping 132 milliseconds. And ﬁnally, the progressive bilinear approach<br /> took 6 milliseconds.<br /> Tip: Some people have reported fast performance from getScaledInstance(), but<br /> beware: getScaledInstance() is asynchronous and may not actually have com-<br /> pleted the scaling operation when it returns to the caller. It will complete the scaling<br /> when the image data is requested (which it is in the ensuing drawImage() call in this<br /> demo). So if you just time getScaledInstance() without a following operation<br /> that requires the data, you may get misleadingly fast results. Don’t buy it;<br /> getScaledInstance() is a slow way to scale images.<br /> It might help to see a larger version of the smallest image on the right from the<br /> ScaleTest application, where the artifacts are most pronounced because more<br /> information from the original image is lost in deriving the ﬁnal image. We can<br /> see these close-up results for the ﬁve rows in Figures 4-4 through 4-8.</p> 
<p>As you can see in the close-up pictures, the errors for NEAREST, BILINEAR, and<br /> BICUBIC are fairly large, especially for the parts of the original image with dis-<br /> crete pixel values: the RGB stripes, the vector drawing, and the black and white<br /> grid. For example, you cannot even tell in these ﬁrst two snapshots that the vec-<br /> tor drawing is supposed to be a smiley face. The additional computation involved<br /> in BILINEAR and BICUBIC compared to NEAREST_NEIGHBOR seems wasted for<br /> downscales of this magnitude. The last two images, on the other hand, appear to<br /> provide reasonable, if slightly different, approximations of the original image.<br /> Even the smiley face is clearly discernible at this extreme size reduction with the<br /> getScaledInstance() and progressive bilinear approaches.</p> 
<p>Finally, you should notice that even though the quality of the progressive bilinear<br /> approach nearly matches that of getScaledInstance(), it does so in a small<br /> fraction of the time that getScaledInstance() took. This improved perfor-<br /> mance for similar quality is the big takeaway from this section.<br /> Tip: You can get high-quality scaling without resorting to the performance hit of<br /> getScaledInstance() by using the progressive bilinear approach.<br /> It is worth making some ﬁnal points about getScaledInstance(), just in case<br /> you are still, for unknown reasons, thinking that it’s a pretty great way to scale<br /> images on the ﬂy. First, as we noted earlier, the call to getScaledInstance() is<br /> asynchronous. The getScaledInstance() method will return immediately and<br /> will not actually perform the scaling operation until the image data is requested<br /> at some later time. This means that there could be hidden side effects from<br /> changing the original image after you have supposedly received your scaled<br /> image; those changes to the original image may show up in the scaled version,<br /> depending on when the scaling operation actually occurs. The other point is that<br /> getScaledInstance() accesses the pixel array for the image directly, which, as<br /> we see in Chapter 5, means that managed image acceleration is not possible for<br /> the image. So, all things considered, you should just avoid this method.</p> 
<h3>Example: PictureScaler</h3> 
<p>We can see what happens to a higher resolution picture as we put it through the<br /> various scaling approaches just discussed. Figure 4-9 shows a snapshot from the<br /> PictureScaler demo on the book’s Web site. This application scales an original<br /> high-resolution picture on the ﬂy through the same mechanisms used in the</p> 
<p>Figure 4-9&nbsp;&nbsp; PictureScaler: High-resolution photo scaled on the ﬂy using the same ﬁve <br /> approaches as before.</p> 
<p>ScaleTest application. We can see the quality results in the thumbnails and the<br /> performance results listed below each picture.<br /> The three images on the left, using drawImage() with the NEAREST_NEIGHBOR,<br /> BILINEAR, and BICUBIC approaches, show clear scaling artifacts. For example,<br /> look at the straight and diagonal lines in the pictures and notice that the jaggies<br /> are very prominent. Figure 4-10 shows a close-up view of these three images,<br /> where you can see some of these artifacts quite clearly.<br /> The two images on the right, using the getScaledInstance() and progressive<br /> bilinear approaches, show much smoother lines and transitions between areas of<br /> high contrast, as shown in the close-up view of Figure 4-11.</p> 
<p>Figure 4-10&nbsp;&nbsp; Close-up of the NEAREST, BILINEAR, and BICUBIC scaling results. All have <br /> similar artifacts for this large downscale.</p> 
<p>Figure 4-11&nbsp;&nbsp; Close-up of the getScaledInstance() and progressive bilinear scaling <br /> results. Note the smoother lines with these approaches compared to those in Figure 4-10.</p> 
<p>Note, once again, that the performance of getScaledInstance() is completely<br /> out of sync with the performance of the other approaches. The quality of that<br /> approach comes at a substantial cost. But note more importantly that the perfor-<br /> mance of the progressive bilinear approach is substantially better, providing a<br /> good-quality alternative at a fraction of the time that getScaledInstance()<br /> takes.</p> 
<h3>getFasterScaledInstance(): Utility for Faster, <br /> Better Scaled Images</h3> 
<p>I have taken the liberty of borrowing and modifying a utility from Chris Camp-<br /> bell and Jim Graham, which also exists in some form in the SwingLabs project<br /> on http://swinglabs.dev.java.net. You can use this method to create a scaled ver-<br /> sion of an image with various approaches. This is an easy way to use the pro-<br /> gressive bilinear approach for your own images, since you simply pass it a ﬂag<br /> to tell it to choose this approach. This method is used in the PictureScaler<br /> demo, and is therefore also available online in that demo code.<br /> public BufferedImage getFasterScaledInstance(BufferedImage img,<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int targetWidth, int targetHeight, Object hint,<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean progressiveBilinear)<br /> {<br /> int type = (img.getTransparency() == Transparency.OPAQUE) ?<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedImage.TYPE_INT_RGB : BufferedImage.TYPE_INT_ARGB;<br /> BufferedImage ret = (BufferedImage)img;<br /> BufferedImage scratchImage = null;<br /> Graphics2D g2 = null;<br /> int w, h;<br /> int prevW = ret.getWidth();<br /> int prevH = ret.getHeight();<br /> if (progressiveBilinear) {<br /> &nbsp;&nbsp;&nbsp; // Use multistep technique: start with original size, <br /> &nbsp;&nbsp;&nbsp; // then scale down in multiple passes with drawImage()<br /> &nbsp;&nbsp;&nbsp; // until the target size is reached<br /> &nbsp;&nbsp;&nbsp; w = img.getWidth();<br /> &nbsp;&nbsp;&nbsp; h = img.getHeight();<br /> } else {<br /> &nbsp;&nbsp;&nbsp; // Use one-step technique: scale directly from original<br /> &nbsp;&nbsp;&nbsp; // size to target size with a single drawImage() call<br /> &nbsp;&nbsp;&nbsp; w = targetWidth;<br /> &nbsp;&nbsp;&nbsp; h = targetHeight;<br /> }</p> 
<p> do {<br /> &nbsp;&nbsp;&nbsp; if (progressiveBilinear &amp;&amp; w &gt; targetWidth) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w /= 2;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (w &lt; targetWidth) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w = targetWidth;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; if (progressiveBilinear &amp;&amp; h &gt; targetHeight) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h /= 2;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (h &lt; targetHeight) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h = targetHeight;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; if (scratchImage == null) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use a single scratch buffer for all iterations<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and then copy to the final, correctly sized image<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // before returning<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scratchImage = new BufferedImage(w, h, type);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g2 = scratchImage.createGraphics();<br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION, <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hint);<br /> &nbsp;&nbsp;&nbsp; g2.drawImage(ret, 0, 0, w, h, 0, 0, prevW, prevH, null);<br /> &nbsp;&nbsp;&nbsp; prevW = w;<br /> &nbsp;&nbsp;&nbsp; prevH = h;<br /> &nbsp;&nbsp;&nbsp; ret = scratchImage;<br /> } while (w != targetWidth || h != targetHeight);<br /> if (g2 != null) {<br /> &nbsp;&nbsp;&nbsp; g2.dispose();<br /> }<br /> // If we used a scratch buffer that is larger than our <br /> // target size, create an image of the right size and copy <br /> // the results into it<br /> if (targetWidth != ret.getWidth() || <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetHeight != ret.getHeight()) {<br /> &nbsp;&nbsp;&nbsp; scratchImage = new BufferedImage(targetWidth, <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; targetHeight, type);<br /> &nbsp;&nbsp;&nbsp; g2 = scratchImage.createGraphics();<br /> &nbsp;&nbsp;&nbsp; g2.drawImage(ret, 0, 0, null);<br /> &nbsp;&nbsp;&nbsp; g2.dispose();<br /> &nbsp;&nbsp;&nbsp; ret = scratchImage;<br /> }<br /> <br /> return ret;<br /> }</p> 
<p>The method is not too complex, so we leave most of the details to curious readers.<br /> The basic idea is that a caller requests a scaled image, specifying whether progres-<br /> sive bilinear ﬁltering is desired with the cleverly named progressiveBilinear<br /> ﬂag. If this ﬂag is true, and if targetWidth or targetHeight is less than half of<br /> the original image width or height, then the image will be progressively scaled<br /> by halves using the BILINEAR rendering hint until the target size is reached. <br /> Note the use of the scratchImage variable; we create a single image the ﬁrst<br /> time through that is used for future iterations through the loop, ﬁnally creating<br /> an image of the correct size and copying to it before returning. This approach<br /> avoids having to create a new BufferedImage for every new intermediate scal-<br /> ing size.<br /> Let’s leave this chapter with one ﬁnal performance tip about image scaling.</p> 
<p>Tip: No matter which approach you decide to use for your quality-versus-<br /> performance needs, consider the approach of using intermediate images.<br /> The fastest operation is the one that you don’t have to perform. If you need<br /> to constantly scale the same image to the same size, consider creating a<br /> cached version of the scaled image and simply copying that version around<br /> instead. Java 2D can copy the prescaled version of the image much faster<br /> than it can scale the original image.</p> 
<p> </p> 
<p> </p> 
<p> </p></div></body></html>