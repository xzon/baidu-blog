<html><head><title><div class="tit">
  GraphicsUtilities -javacode
</div></title></head><body><div id='tit'>GraphicsUtilities -javacode</div><div id='cate'>j&middot;swing</div><div id='date'>2010年06月21日 星期一 12:00 P.M.</div><div id='page'>12</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/8468d3620696d8d0e6113a3f.html'>http://hi.baidu.com/hxzon/blog/item/8468d3620696d8d0e6113a3f.html</a><div id='cnt'><div> 
 <p>GraphicsUtilities.java -java2D -gcode</p> 
 <p>《Filthy Rich Clients: Developing Animated and Graphical Effects for Desktop Java? Applications》pdf<br />--------------------------------------</p>
 <pre>package filthyRichClients.chapter17.DynamicEffects.Bloom;

/*
 * $Id: GraphicsUtilities.java,v 1.1 2007/02/14 00:56:19 gfx Exp $
 *
 * Dual-licensed under LGPL (Sun and Romain Guy) and BSD (Romain Guy).
 *
 * Copyright 2005 Sun Microsystems, Inc., 4150 Network Circle,
 * Santa Clara, California 95054, U.S.A. All rights reserved.
 *
 * Copyright (c) 2006 Romain Guy &lt;romain.guy@mac.com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsEnvironment;
import java.awt.RenderingHints;
import java.awt.Transparency;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.io.IOException;
import java.net.URL;
import javax.imageio.ImageIO;

/**
 * &lt;p&gt;&lt;code&gt;GraphicsUtilities&lt;/code&gt; contains a set of tools to perform
 * common graphics operations easily. These operations are divided into
 * several themes, listed below.&lt;/p&gt;
 * &lt;h2&gt;Compatible Images&lt;/h2&gt;
 * &lt;p&gt;Compatible images can, and should, be used to increase drawing
 * performance. This class provides a number of methods to load compatible
 * images directly from files or to convert existing images to compatibles
 * images.&lt;/p&gt;
 * &lt;h2&gt;Creating Thumbnails&lt;/h2&gt;
 * &lt;p&gt;This class provides a number of methods to easily scale down images.
 * Some of these methods offer a trade-off between speed and result quality and
 * shouuld be used all the time. They also offer the advantage of producing
 * compatible images, thus automatically resulting into better runtime
 * performance.&lt;/p&gt;
 * &lt;p&gt;All these methodes are both faster than
 * {@link java.awt.Image#getScaledInstance(int, int, int)} and produce
 * better-looking results than the various &lt;code&gt;drawImage()&lt;/code&gt; methods
 * in {@link java.awt.Graphics}, which can be used for image scaling.&lt;/p&gt;
 * &lt;h2&gt;Image Manipulation&lt;/h2&gt;
 * &lt;p&gt;This class provides two methods to get and set pixels in a buffered image.
 * These methods try to avoid unmanaging the image in order to keep good
 * performance.&lt;/p&gt;
 *
 * @author Romain Guy &lt;romain.guy@mac.com&gt;
 */
public class GraphicsUtilities {
    private GraphicsUtilities() {
    }

    // Returns the graphics configuration for the primary screen
    private static GraphicsConfiguration getGraphicsConfiguration() {
        return GraphicsEnvironment.getLocalGraphicsEnvironment().
                    getDefaultScreenDevice().getDefaultConfiguration();
    }

    /**
     * &lt;p&gt;Returns a new &lt;code&gt;BufferedImage&lt;/code&gt; using the same color model
     * as the image passed as a parameter. The returned image is only compatible<br />     * with the image passed as a parameter. This does not mean the returned<br />     * image is compatible with the hardware.&lt;/p&gt;<br />     *<br />     * @param image the reference image from which the color model of the new<br />     *   image is obtained<br />     * @return a new &lt;code&gt;BufferedImage&lt;/code&gt;, compatible with the color model<br />     *   of &lt;code&gt;image&lt;/code&gt;<br />     */<br />    public static BufferedImage createColorModelCompatibleImage(BufferedImage image) {<br />        ColorModel cm = image.getColorModel();<br />        return new BufferedImage(cm,<br />            cm.createCompatibleWritableRaster(image.getWidth(),<br />                                              image.getHeight()),<br />            cm.isAlphaPremultiplied(), null);<br />    }<br /><br />    /**<br />     * &lt;p&gt;Returns a new compatible image with the same width, height and<br />     * transparency as the image specified as a parameter.&lt;/p&gt;<br />     *<br />     * @see java.awt.Transparency<br />     * @see #createCompatibleImage(int, int)<br />     * @see #createCompatibleImage(java.awt.image.BufferedImage, int, int)<br />     * @see #createCompatibleTranslucentImage(int, int)<br />     * @see #loadCompatibleImage(java.net.URL)<br />     * @see #toCompatibleImage(java.awt.image.BufferedImage)<br />     * @param image the reference image from which the dimension and the<br />     *   transparency of the new image are obtained<br />     * @return a new compatible &lt;code&gt;BufferedImage&lt;/code&gt; with the same<br />     *   dimension and transparency as &lt;code&gt;image&lt;/code&gt;<br />     */<br />    public static BufferedImage createCompatibleImage(BufferedImage image) {<br />        return createCompatibleImage(image, image.getWidth(), image.getHeight());<br />    }<br /><br />    /**<br />     * &lt;p&gt;Returns a new compatible image of the specified width and height, and<br />     * the same transparency setting as the image specified as a parameter.&lt;/p&gt;<br />     *<br />     * @see java.awt.Transparency<br />     * @see #createCompatibleImage(java.awt.image.BufferedImage)<br />     * @see #createCompatibleImage(int, int)<br />     * @see #createCompatibleTranslucentImage(int, int)<br />     * @see #loadCompatibleImage(java.net.URL)<br />     * @see #toCompatibleImage(java.awt.image.BufferedImage)<br />     * @param width the width of the new image<br />     * @param height the height of the new image<br />     * @param image the reference image from which the transparency of the new<br />     *   image is obtained<br />     * @return a new compatible &lt;code&gt;BufferedImage&lt;/code&gt; with the same<br />     *   transparency as &lt;code&gt;image&lt;/code&gt; and the specified dimension<br />     */<br />    public static BufferedImage createCompatibleImage(BufferedImage image,<br />                                                      int width, int height) {<br />        return getGraphicsConfiguration().createCompatibleImage(width, height,<br />                                                   image.getTransparency());<br />    }<br /><br />    /**<br />     * &lt;p&gt;Returns a new opaque compatible image of the specified width and<br />     * height.&lt;/p&gt;<br />     *<br />     * @see #createCompatibleImage(java.awt.image.BufferedImage)<br />     * @see #createCompatibleImage(java.awt.image.BufferedImage, int, int)<br />     * @see #createCompatibleTranslucentImage(int, int)<br />     * @see #loadCompatibleImage(java.net.URL)<br />     * @see #toCompatibleImage(java.awt.image.BufferedImage)<br />     * @param width the width of the new image<br />     * @param height the height of the new image<br />     * @return a new opaque compatible &lt;code&gt;BufferedImage&lt;/code&gt; of the<br />     *   specified width and height<br />     */<br />    public static BufferedImage createCompatibleImage(int width, int height) {<br />        return getGraphicsConfiguration().createCompatibleImage(width, height);<br />    }<br /><br />    /**<br />     * &lt;p&gt;Returns a new translucent compatible image of the specified width<br />     * and height.&lt;/p&gt;<br />     *<br />     * @see #createCompatibleImage(java.awt.image.BufferedImage)<br />     * @see #createCompatibleImage(java.awt.image.BufferedImage, int, int)<br />     * @see #createCompatibleImage(int, int)<br />     * @see #loadCompatibleImage(java.net.URL)<br />     * @see #toCompatibleImage(java.awt.image.BufferedImage)<br />     * @param width the width of the new image<br />     * @param height the height of the new image<br />     * @return a new translucent compatible &lt;code&gt;BufferedImage&lt;/code&gt; of the<br />     *   specified width and height<br />     */<br />    public static BufferedImage createCompatibleTranslucentImage(int width,<br />                                                                 int height) {<br />        return getGraphicsConfiguration().createCompatibleImage(width, height,<br />                                                   Transparency.TRANSLUCENT);<br />    }<br /><br />    /**<br />     * &lt;p&gt;Returns a new compatible image from a URL. The image is loaded from the<br />     * specified location and then turned, if necessary into a compatible<br />     * image.&lt;/p&gt;<br />     *<br />     * @see #createCompatibleImage(java.awt.image.BufferedImage)<br />     * @see #createCompatibleImage(java.awt.image.BufferedImage, int, int)<br />     * @see #createCompatibleImage(int, int)<br />     * @see #createCompatibleTranslucentImage(int, int)<br />     * @see #toCompatibleImage(java.awt.image.BufferedImage)<br />     * @param resource the URL of the picture to load as a compatible image<br />     * @return a new translucent compatible &lt;code&gt;BufferedImage&lt;/code&gt; of the<br />     *   specified width and height<br />     * @throws java.io.IOException if the image cannot be read or loaded<br />     */<br />    public static BufferedImage loadCompatibleImage(URL resource)<br />            throws IOException {<br />        BufferedImage image = ImageIO.read(resource);<br />        return toCompatibleImage(image);<br />    }<br /><br />    /**<br />     * &lt;p&gt;Return a new compatible image that contains a copy of the specified<br />     * image. This method ensures an image is compatible with the hardware,<br />     * and therefore optimized for fast blitting operations.&lt;/p&gt;<br />     *<br />     * @see #createCompatibleImage(java.awt.image.BufferedImage)<br />     * @see #createCompatibleImage(java.awt.image.BufferedImage, int, int)<br />     * @see #createCompatibleImage(int, int)<br />     * @see #createCompatibleTranslucentImage(int, int)<br />     * @see #loadCompatibleImage(java.net.URL)<br />     * @param image the image to copy into a new compatible image<br />     * @return a new compatible copy, with the<br />     *   same width and height and transparency and content, of &lt;code&gt;image&lt;/code&gt;<br />     */<br />    public static BufferedImage toCompatibleImage(BufferedImage image) {<br />        if (image.getColorModel().equals(<br />                getGraphicsConfiguration().getColorModel())) {<br />            return image;<br />        }<br /><br />        BufferedImage compatibleImage =<br />                getGraphicsConfiguration().createCompatibleImage(<br />                    image.getWidth(), image.getHeight(),<br />                    image.getTransparency());<br />        Graphics g = compatibleImage.getGraphics();<br />        g.drawImage(image, 0, 0, null);<br />        g.dispose();<br /><br />        return compatibleImage;<br />    }<br /><br />    /**<br />     * &lt;p&gt;Returns a thumbnail of a source image. &lt;code&gt;newSize&lt;/code&gt; defines<br />     * the length of the longest dimension of the thumbnail. The other<br />     * dimension is then computed according to the dimensions ratio of the<br />     * original picture.&lt;/p&gt;<br />     * &lt;p&gt;This method favors speed over quality. When the new size is less than<br />     * half the longest dimension of the source image,<br />     * {@link #createThumbnail(BufferedImage, int)} or<br />     * {@link #createThumbnail(BufferedImage, int, int)} should be used instead<br />     * to ensure the quality of the result without sacrificing too much<br />     * performance.&lt;/p&gt;<br />     *<br />     * @see #createThumbnailFast(java.awt.image.BufferedImage, int, int)<br />     * @see #createThumbnail(java.awt.image.BufferedImage, int)<br />     * @see #createThumbnail(java.awt.image.BufferedImage, int, int)<br />     * @param image the source image<br />     * @param newSize the length of the largest dimension of the thumbnail<br />     * @return a new compatible &lt;code&gt;BufferedImage&lt;/code&gt; containing a<br />     *   thumbnail of &lt;code&gt;image&lt;/code&gt;<br />     * @throws IllegalArgumentException if &lt;code&gt;newSize&lt;/code&gt; is larger than<br />     *   the largest dimension of &lt;code&gt;image&lt;/code&gt; or &amp;lt;= 0<br />     */<br />    public static BufferedImage createThumbnailFast(BufferedImage image,<br />                                                    int newSize) {<br />        float ratio;<br />        int width = image.getWidth();<br />        int height = image.getHeight();<br /><br />        if (width &gt; height) {<br />            if (newSize &gt;= width) {<br />                throw new IllegalArgumentException(&quot;newSize must be lower than&quot; +<br />                                                   &quot; the image width&quot;);<br />            } else if (newSize &lt;= 0) {<br />                 throw new IllegalArgumentException(&quot;newSize must&quot; +<br />                                                    &quot; be greater than 0&quot;);<br />            }<br /><br />            ratio = (float) width / (float) height;<br />            width = newSize;<br />            height = (int) (newSize / ratio);<br />        } else {<br />            if (newSize &gt;= height) {<br />                throw new IllegalArgumentException(&quot;newSize must be lower than&quot; +<br />                                                   &quot; the image height&quot;);<br />            } else if (newSize &lt;= 0) {<br />                 throw new IllegalArgumentException(&quot;newSize must&quot; +<br />                                                    &quot; be greater than 0&quot;);<br />            }<br /><br />            ratio = (float) height / (float) width;<br />            height = newSize;<br />            width = (int) (newSize / ratio);<br />        }<br /><br />        BufferedImage temp = createCompatibleImage(image, width, height);<br />        Graphics2D g2 = temp.createGraphics();<br />        g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION,<br />                            RenderingHints.VALUE_INTERPOLATION_BILINEAR);<br />        g2.drawImage(image, 0, 0, temp.getWidth(), temp.getHeight(), null);<br />        g2.dispose();<br /><br />        return temp;<br />    }<br /><br />    /**<br />     * &lt;p&gt;Returns a thumbnail of a source image.&lt;/p&gt;<br />     * &lt;p&gt;This method favors speed over quality. When the new size is less than<br />     * half the longest dimension of the source image,<br />     * {@link #createThumbnail(BufferedImage, int)} or<br />     * {@link #createThumbnail(BufferedImage, int, int)} should be used instead<br />     * to ensure the quality of the result without sacrificing too much<br />     * performance.&lt;/p&gt;<br />     *<br />     * @see #createThumbnailFast(java.awt.image.BufferedImage, int)<br />     * @see #createThumbnail(java.awt.image.BufferedImage, int)<br />     * @see #createThumbnail(java.awt.image.BufferedImage, int, int)<br />     * @param image the source image<br />     * @param newWidth the width of the thumbnail<br />     * @param newHeight the height of the thumbnail<br />     * @return a new compatible &lt;code&gt;BufferedImage&lt;/code&gt; containing a<br />     *   thumbnail of &lt;code&gt;image&lt;/code&gt;<br />     * @throws IllegalArgumentException if &lt;code&gt;newWidth&lt;/code&gt; is larger than<br />     *   the width of &lt;code&gt;image&lt;/code&gt; or if code&gt;newHeight&lt;/code&gt; is larger<br />     *   than the height of &lt;code&gt;image&lt;/code&gt; or if one of the dimensions<br />     *   is &amp;lt;= 0<br />     */<br />    public static BufferedImage createThumbnailFast(BufferedImage image,<br />                                                    int newWidth, int newHeight) {<br />        if (newWidth &gt;= image.getWidth() ||<br />            newHeight &gt;= image.getHeight()) {<br />            throw new IllegalArgumentException(&quot;newWidth and newHeight cannot&quot; +<br />                                               &quot; be greater than the image&quot; +<br />                                               &quot; dimensions&quot;);<br />        } else if (newWidth &lt;= 0 || newHeight &lt;= 0) {<br />            throw new IllegalArgumentException(&quot;newWidth and newHeight must&quot; +<br />                                               &quot; be greater than 0&quot;);<br />        }<br /><br />        BufferedImage temp = createCompatibleImage(image, newWidth, newHeight);<br />        Graphics2D g2 = temp.createGraphics();<br />        g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION,<br />                            RenderingHints.VALUE_INTERPOLATION_BILINEAR);<br />        g2.drawImage(image, 0, 0, temp.getWidth(), temp.getHeight(), null);<br />        g2.dispose();<br /><br />        return temp;<br />    }<br /><br />    /**<br />     * &lt;p&gt;Returns a thumbnail of a source image. &lt;code&gt;newSize&lt;/code&gt; defines<br />     * the length of the longest dimension of the thumbnail. The other<br />     * dimension is then computed according to the dimensions ratio of the<br />     * original picture.&lt;/p&gt;<br />     * &lt;p&gt;This method offers a good trade-off between speed and quality.<br />     * The result looks better than<br />     * {@link #createThumbnailFast(java.awt.image.BufferedImage, int)} when<br />     * the new size is less than half the longest dimension of the source<br />     * image, yet the rendering speed is almost similar.&lt;/p&gt;<br />     *<br />     * @see #createThumbnailFast(java.awt.image.BufferedImage, int, int)<br />     * @see #createThumbnailFast(java.awt.image.BufferedImage, int)<br />     * @see #createThumbnail(java.awt.image.BufferedImage, int, int)<br />     * @param image the source image<br />     * @param newSize the length of the largest dimension of the thumbnail<br />     * @return a new compatible &lt;code&gt;BufferedImage&lt;/code&gt; containing a<br />     *   thumbnail of &lt;code&gt;image&lt;/code&gt;<br />     * @throws IllegalArgumentException if &lt;code&gt;newSize&lt;/code&gt; is larger than<br />     *   the largest dimension of &lt;code&gt;image&lt;/code&gt; or &amp;lt;= 0<br />     */<br />    public static BufferedImage createThumbnail(BufferedImage image,<br />                                                int newSize) {<br />        int width = image.getWidth();<br />        int height = image.getHeight();<br /><br />        boolean isWidthGreater = width &gt; height;<br /><br />        if (isWidthGreater) {<br />            if (newSize &gt;= width) {<br />                throw new IllegalArgumentException(&quot;newSize must be lower than&quot; +<br />                                                   &quot; the image width&quot;);<br />            }<br />        } else if (newSize &gt;= height) {<br />            throw new IllegalArgumentException(&quot;newSize must be lower than&quot; +<br />                                               &quot; the image height&quot;);<br />        }<br /><br />        if (newSize &lt;= 0) {<br />            throw new IllegalArgumentException(&quot;newSize must&quot; +<br />                                               &quot; be greater than 0&quot;);<br />        }<br /><br />        float ratioWH = (float) width / (float) height;<br />        float ratioHW = (float) height / (float) width;<br /><br />        BufferedImage thumb = image;<br />        BufferedImage temp = null;<br /><br />        Graphics2D g2 = null;<br /><br />        int previousWidth = width;<br />        int previousHeight = height;<br /><br />        do {<br />            if (isWidthGreater) {<br />                width /= 2;<br />                if (width &lt; newSize) {<br />                    width = newSize;<br />                }<br />                height = (int) (width / ratioWH);<br />            } else {<br />                height /= 2;<br />                if (height &lt; newSize) {<br />                    height = newSize;<br />                }<br />                width = (int) (height / ratioHW);<br />            }<br /><br />            if (temp == null) {<br />                temp = createCompatibleImage(image, width, height);<br />                g2 = temp.createGraphics();<br />                g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION,<br />                                RenderingHints.VALUE_INTERPOLATION_BILINEAR);<br />            }<br />            g2.drawImage(thumb, 0, 0, width, height,<br />                         0, 0, previousWidth, previousHeight, null);<br /><br />            previousWidth = width;<br />            previousHeight = height;<br /><br />            thumb = temp;<br />        } while (newSize != (isWidthGreater ? width : height));<br /><br />        g2.dispose();<br /><br />        if (width != thumb.getWidth() || height != thumb.getHeight()) {<br />            temp = createCompatibleImage(image, width, height);<br />            g2 = temp.createGraphics();<br />            g2.drawImage(thumb, 0, 0, null);<br />            g2.dispose();<br />            thumb = temp;<br />        }<br /><br />        return thumb;<br />    }<br /><br />    /**<br />     * &lt;p&gt;Returns a thumbnail of a source image.&lt;/p&gt;<br />     * &lt;p&gt;This method offers a good trade-off between speed and quality.<br />     * The result looks better than<br />     * {@link #createThumbnailFast(java.awt.image.BufferedImage, int)} when<br />     * the new size is less than half the longest dimension of the source<br />     * image, yet the rendering speed is almost similar.&lt;/p&gt;<br />     *<br />     * @see #createThumbnailFast(java.awt.image.BufferedImage, int)<br />     * @see #createThumbnailFast(java.awt.image.BufferedImage, int, int)<br />     * @see #createThumbnail(java.awt.image.BufferedImage, int)<br />     * @param image the source image<br />     * @param newWidth the width of the thumbnail<br />     * @param newHeight the height of the thumbnail<br />     * @return a new compatible &lt;code&gt;BufferedImage&lt;/code&gt; containing a<br />     *   thumbnail of &lt;code&gt;image&lt;/code&gt;<br />     * @throws IllegalArgumentException if &lt;code&gt;newWidth&lt;/code&gt; is larger than<br />     *   the width of &lt;code&gt;image&lt;/code&gt; or if code&gt;newHeight&lt;/code&gt; is larger<br />     *   than the height of &lt;code&gt;image or if one the dimensions is not &amp;gt; 0&lt;/code&gt;<br />     */<br />    public static BufferedImage createThumbnail(BufferedImage image,<br />                                                int newWidth, int newHeight) {<br />        int width = image.getWidth();<br />        int height = image.getHeight();<br /><br />        if (newWidth &gt;= width || newHeight &gt;= height) {<br />            throw new IllegalArgumentException(&quot;newWidth and newHeight cannot&quot; +<br />                                               &quot; be greater than the image&quot; +<br />                                               &quot; dimensions&quot;);<br />        } else if (newWidth &lt;= 0 || newHeight &lt;= 0) {<br />            throw new IllegalArgumentException(&quot;newWidth and newHeight must&quot; +<br />                                               &quot; be greater than 0&quot;);<br />        }<br /><br />        BufferedImage thumb = image;<br />        BufferedImage temp = null;<br /><br />        Graphics2D g2 = null;<br /><br />        int previousWidth = width;<br />        int previousHeight = height;<br /><br />        do {<br />            if (width &gt; newWidth) {<br />                width /= 2;<br />                if (width &lt; newWidth) {<br />                    width = newWidth;<br />                }<br />            }<br /><br />            if (height &gt; newHeight) {<br />                height /= 2;<br />                if (height &lt; newHeight) {<br />                    height = newHeight;<br />                }<br />            }<br /><br />            if (temp == null) {<br />                temp = createCompatibleImage(image, width, height);<br />                g2 = temp.createGraphics();<br />                g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION,<br />                                RenderingHints.VALUE_INTERPOLATION_BILINEAR);<br />            }<br />            g2.drawImage(thumb, 0, 0, width, height,<br />                         0, 0, previousWidth, previousHeight, null);<br /><br />            previousWidth = width;<br />            previousHeight = height;<br /><br />            thumb = temp;<br />        } while (width != newWidth || height != newHeight);<br /><br />        g2.dispose();<br /><br />        if (width != thumb.getWidth() || height != thumb.getHeight()) {<br />            temp = createCompatibleImage(image, width, height);<br />            g2 = temp.createGraphics();<br />            g2.drawImage(thumb, 0, 0, null);<br />            g2.dispose();<br />            thumb = temp;<br />        }<br /><br />        return thumb;<br />    }<br /><br />    /**<br />     * &lt;p&gt;Returns an array of pixels, stored as integers, from a<br />     * &lt;code&gt;BufferedImage&lt;/code&gt;. The pixels are grabbed from a rectangular<br />     * area defined by a location and two dimensions. Calling this method on<br />     * an image of type different from &lt;code&gt;BufferedImage.TYPE_INT_ARGB&lt;/code&gt;<br />     * and &lt;code&gt;BufferedImage.TYPE_INT_RGB&lt;/code&gt; will unmanage the image.&lt;/p&gt;<br />     *<br />     * @param img the source image<br />     * @param x the x location at which to start grabbing pixels<br />     * @param y the y location at which to start grabbing pixels<br />     * @param w the width of the rectangle of pixels to grab<br />     * @param h the height of the rectangle of pixels to grab<br />     * @param pixels a pre-allocated array of pixels of size w*h; can be null<br />     * @return &lt;code&gt;pixels&lt;/code&gt; if non-null, a new array of integers<br />     *   otherwise<br />     * @throws IllegalArgumentException is &lt;code&gt;pixels&lt;/code&gt; is non-null and<br />     *   of length &amp;lt; w*h<br />     */<br />    public static int[] getPixels(BufferedImage img,<br />                                  int x, int y, int w, int h, int[] pixels) {<br />        if (w == 0 || h == 0) {<br />            return new int[0];<br />        }<br /><br />        if (pixels == null) {<br />            pixels = new int[w * h];<br />        } else if (pixels.length &lt; w * h) {<br />            throw new IllegalArgumentException(&quot;pixels array must have a length&quot; +<br />                                               &quot; &gt;= w*h&quot;);<br />        }<br /><br />        int imageType = img.getType();<br />        if (imageType == BufferedImage.TYPE_INT_ARGB ||<br />            imageType == BufferedImage.TYPE_INT_RGB) {<br />            Raster raster = img.getRaster();<br />            return (int[]) raster.getDataElements(x, y, w, h, pixels);<br />        }<br /><br />        // Unmanages the image<br />        return img.getRGB(x, y, w, h, pixels, 0, w);<br />    }<br /><br />    /**<br />     * &lt;p&gt;Writes a rectangular area of pixels in the destination<br />     * &lt;code&gt;BufferedImage&lt;/code&gt;. Calling this method on<br />     * an image of type different from &lt;code&gt;BufferedImage.TYPE_INT_ARGB&lt;/code&gt;<br />     * and &lt;code&gt;BufferedImage.TYPE_INT_RGB&lt;/code&gt; will unmanage the image.&lt;/p&gt;<br />     *<br />     * @param img the destination image<br />     * @param x the x location at which to start storing pixels<br />     * @param y the y location at which to start storing pixels<br />     * @param w the width of the rectangle of pixels to store<br />     * @param h the height of the rectangle of pixels to store<br />     * @param pixels an array of pixels, stored as integers<br />     * @throws IllegalArgumentException is &lt;code&gt;pixels&lt;/code&gt; is non-null and<br />     *   of length &amp;lt; w*h<br />     */<br />    public static void setPixels(BufferedImage img,<br />                                 int x, int y, int w, int h, int[] pixels) {<br />        if (pixels == null || w == 0 || h == 0) {<br />            return;<br />        } else if (pixels.length &lt; w * h) {<br />            throw new IllegalArgumentException(&quot;pixels array must have a length&quot; +<br />                                               &quot; &gt;= w*h&quot;);<br />        }<br /><br />        int imageType = img.getType();<br />        if (imageType == BufferedImage.TYPE_INT_ARGB ||<br />            imageType == BufferedImage.TYPE_INT_RGB) {<br />            WritableRaster raster = img.getRaster();<br />            raster.setDataElements(x, y, w, h, pixels);<br />        } else {<br />            // Unmanages the image<br />            img.setRGB(x, y, w, h, pixels, 0, w);<br />        }<br />    }<br />}</pre> 
 <p></p>
</div></div></body></html>