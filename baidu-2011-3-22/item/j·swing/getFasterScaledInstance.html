<html><head><title><div class="tit">
  getFasterScaledInstance
</div></title></head><body><div id='tit'>getFasterScaledInstance</div><div id='cate'>j&middot;swing</div><div id='date'>2010年06月09日 星期三 05:33 P.M.</div><div id='page'>13</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/ff0258df4e1ddf1e48540300.html'>http://hi.baidu.com/hxzon/blog/item/ff0258df4e1ddf1e48540300.html</a><div id='cnt'><pre>package filthyRichClients.chapter4.Images.PictureScaler;<br /><br />import java.awt.BorderLayout;<br />import java.awt.Dimension;<br />import java.awt.Graphics;<br />import java.awt.Graphics2D;<br />import java.awt.Image;<br />import java.awt.RenderingHints;<br />import java.awt.Transparency;<br />import java.awt.image.BufferedImage;<br />import java.net.URL;<br />import javax.imageio.ImageIO;<br />import javax.swing.JComponent;<br />import javax.swing.JFrame;<br />import javax.swing.SwingUtilities;<br />/*<br /> * PictureScaler.java<br /> *<br /> * Created on May 1, 2007, 5:03 PM<br /> *<br /> * Copyright (c) 2007, Sun Microsystems, Inc<br /> * All rights reserved.<br /> *<br /> * Redistribution and use in source and binary forms, with or without<br /> * modification, are permitted provided that the following conditions<br /> * are met:<br /> *<br /> *   * Redistributions of source code must retain the above copyright<br /> *     notice, this list of conditions and the following disclaimer.<br /> *   * Redistributions in binary form must reproduce the above<br /> *     copyright notice, this list of conditions and the following<br /> *     disclaimer in the documentation and/or other materials provided<br /> *     with the distribution.<br /> *   * Neither the name of the TimingFramework project nor the names of its<br /> *     contributors may be used to endorse or promote products derived<br /> *     from this software without specific prior written permission.<br /> *<br /> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS<br /> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT<br /> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR<br /> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT<br /> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,<br /> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT<br /> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,<br /> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY<br /> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT<br /> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE<br /> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<br /> */<br /><br />/**<br /> *<br /> * @author Chet<br /> */<br />public class PictureScaler extends JComponent {<br /><br />    private static BufferedImage picture = null;<br />    private static final int PADDING = 10;<br />    private static final double SCALE_FACTOR = .05;<br />    private int scaleW, scaleH;<br />    <br />    /** Creates a new instance of PictureScaler */<br />    public PictureScaler() {<br />        try {<br />            URL url = getClass().getResource(&quot;BB.jpg&quot;);<br />            picture = ImageIO.read(url);<br />            scaleW = (int)(SCALE_FACTOR * picture.getWidth());<br />            scaleH = (int)(SCALE_FACTOR * picture.getHeight());<br />            System.out.println(&quot;w, h = &quot; + picture.getWidth() + &quot;, &quot; + picture.getHeight());<br />            setPreferredSize(new Dimension(PADDING + (5 * (scaleW + PADDING)), <br />                    scaleH + (4 * PADDING)));<br />        } catch (Exception e) {<br />            System.out.println(&quot;Problem reading image file: &quot; + e);<br />            System.exit(0);<br />        }<br />    }<br /><br />    /**<br />     * Convenience method that returns a scaled instance of the<br />     * provided BufferedImage.<br />     * <br />     * <br />     * @param img the original image to be scaled<br />     * @param targetWidth the desired width of the scaled instance,<br />     *    in pixels<br />     * @param targetHeight the desired height of the scaled instance,<br />     *    in pixels<br />     * @param hint one of the rendering hints that corresponds to<br />     *    RenderingHints.KEY_INTERPOLATION (e.g.<br />     *    RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR,<br />     *    RenderingHints.VALUE_INTERPOLATION_BILINEAR,<br />     *    RenderingHints.VALUE_INTERPOLATION_BICUBIC)<br />     * @param progressiveBilinear if true, this method will use a multi-step<br />     *    scaling technique that provides higher quality than the usual<br />     *    one-step technique (only useful in down-scaling cases, where<br />     *    targetWidth or targetHeight is<br />     *    smaller than the original dimensions)<br />     * @return a scaled version of the original BufferedImage<br />     */<br />    public BufferedImage getFasterScaledInstance(BufferedImage img,<br />            int targetWidth, int targetHeight, Object hint,<br />            boolean progressiveBilinear)<br />    {<br />        int type = (img.getTransparency() == Transparency.OPAQUE) ?<br />            BufferedImage.TYPE_INT_RGB : BufferedImage.TYPE_INT_ARGB;<br />        BufferedImage ret = img;<br />        BufferedImage scratchImage = null;<br />        Graphics2D g2 = null;<br />        int w, h;<br />        int prevW = ret.getWidth();<br />        int prevH = ret.getHeight();<br />        boolean isTranslucent = img.getTransparency() !=  Transparency.OPAQUE; <br /><br />        if (progressiveBilinear) {<br />            // Use multi-step technique: start with original size, then<br />            // scale down in multiple passes with drawImage()<br />            // until the target size is reached<br />            w = img.getWidth();<br />            h = img.getHeight();<br />        } else {<br />            // Use one-step technique: scale directly from original<br />            // size to target size with a single drawImage() call<br />            w = targetWidth;<br />            h = targetHeight;<br />        }<br />        <br />        do {<br />            if (progressiveBilinear &amp;&amp; w &gt; targetWidth) {<br />                w /= 2;<br />                if (w &lt; targetWidth) {<br />                    w = targetWidth;<br />                }<br />            }<br /><br />            if (progressiveBilinear &amp;&amp; h &gt; targetHeight) {<br />                h /= 2;<br />                if (h &lt; targetHeight) {<br />                    h = targetHeight;<br />                }<br />            }<br /><br />            if (scratchImage == null || isTranslucent) {<br />                // Use a single scratch buffer for all iterations<br />                // and then copy to the final, correctly-sized image<br />                // before returning<br />                scratchImage = new BufferedImage(w, h, type);<br />                g2 = scratchImage.createGraphics();<br />            }<br />            g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION, hint);<br />            g2.drawImage(ret, 0, 0, w, h, 0, 0, prevW, prevH, null);<br />            prevW = w;<br />            prevH = h;<br /><br />            ret = scratchImage;<br />        } while (w != targetWidth || h != targetHeight);<br />        <br />        if (g2 != null) {<br />            g2.dispose();<br />        }<br /><br />        // If we used a scratch buffer that is larger than our target size,<br />        // create an image of the right size and copy the results into it<br />        if (targetWidth != ret.getWidth() || targetHeight != ret.getHeight()) {<br />            scratchImage = new BufferedImage(targetWidth, targetHeight, type);<br />            g2 = scratchImage.createGraphics();<br />            g2.drawImage(ret, 0, 0, null);<br />            g2.dispose();<br />            ret = scratchImage;<br />        }<br />        <br />        return ret;<br />    }<br />    <br />    /**<br />     * Render all scaled versions 10 times, timing each version and <br />     * reporting the results below the appropriate scaled image.<br />     */<br />    protected void paintComponent(Graphics g) {<br />        // Scale with NEAREST_NEIGHBOR<br />        int xLoc = PADDING, yLoc = PADDING;<br />        long startTime, endTime;<br />        float totalTime;<br />        int iterations = 10;<br />        ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_INTERPOLATION, <br />                RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);<br />        startTime = System.nanoTime();<br />        for (int i = 0; i &lt; iterations; ++i) {<br />            g.drawImage(picture, xLoc, yLoc, scaleW, scaleH, null);<br />        }<br />        endTime = System.nanoTime();<br />        totalTime = (float)((endTime - startTime) / 1000000) / iterations;<br />        g.drawString(&quot;NEAREST &quot;, xLoc, yLoc + scaleH + PADDING);<br />        g.drawString(Float.toString(totalTime) + &quot; ms&quot;, <br />                xLoc, yLoc + scaleH + PADDING + 10);<br />        System.out.println(&quot;NEAREST: &quot; + ((endTime - startTime) / 1000000));<br />        <br />        // Scale with BILINEAR<br />        xLoc += scaleW + PADDING;<br />        ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_INTERPOLATION, <br />                RenderingHints.VALUE_INTERPOLATION_BILINEAR);<br />        startTime = System.nanoTime();<br />        for (int i = 0; i &lt; iterations; ++i) {<br />            g.drawImage(picture, xLoc, yLoc, scaleW, scaleH, null);<br />        }<br />        endTime = System.nanoTime();<br />        totalTime = (float)((endTime - startTime) / 1000000) / iterations;<br />        g.drawString(&quot;BILINEAR&quot;, xLoc, yLoc + scaleH + PADDING);<br />        g.drawString(Float.toString(totalTime) + &quot; ms&quot;, <br />                xLoc, yLoc + scaleH + PADDING + 10);<br />        System.out.println(&quot;BILINEAR: &quot; + ((endTime - startTime) / 1000000));<br /><br />        // Scale with BICUBIC<br />        xLoc += scaleW + PADDING;<br />        ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_INTERPOLATION, <br />                RenderingHints.VALUE_INTERPOLATION_BICUBIC);<br />        startTime = System.nanoTime();<br />        for (int i = 0; i &lt; iterations; ++i) {<br />            g.drawImage(picture, xLoc, yLoc, scaleW, scaleH, null);<br />        }<br />        endTime = System.nanoTime();<br />        totalTime = (float)((endTime - startTime) / 1000000) / iterations;<br />        g.drawString(&quot;BICUBIC&quot;, xLoc, yLoc + scaleH + PADDING);<br />        g.drawString(Float.toString(totalTime) + &quot; ms&quot;, <br />                xLoc, yLoc + scaleH + PADDING + 10);<br />        System.out.println(&quot;BICUBIC: &quot; + ((endTime - startTime) / 1000000));<br /><br />        // Scale with getScaledInstance<br />        xLoc += scaleW + PADDING;<br />        startTime = System.nanoTime();<br />        for (int i = 0; i &lt; iterations; ++i) {<br />            Image scaledPicture = picture.getScaledInstance(scaleW, scaleH, <br />                    Image.SCALE_AREA_AVERAGING);<br />            g.drawImage(scaledPicture, xLoc, yLoc, null);<br />        }<br />        endTime = System.nanoTime();<br />        totalTime = (float)((endTime - startTime) / 1000000) / iterations;<br />        g.drawString(&quot;getScaled&quot;, xLoc, yLoc + scaleH + PADDING);<br />        g.drawString(Float.toString(totalTime) + &quot; ms&quot;, <br />                xLoc, yLoc + scaleH + PADDING + 10);<br />        System.out.println(&quot;getScaled: &quot; + ((endTime - startTime) / 1000000));<br />        <br />        // Scale with Progressive Bilinear<br />        xLoc += scaleW + PADDING;<br />        startTime = System.nanoTime();<br />        for (int i = 0; i &lt; iterations; ++i) {<br />            Image scaledPicture = getFasterScaledInstance(picture, scaleW, scaleH, <br />                    RenderingHints.VALUE_INTERPOLATION_BILINEAR, true);<br />            g.drawImage(scaledPicture, xLoc, yLoc, null);<br />        }<br />        endTime = System.nanoTime();<br />        totalTime = (float)((endTime - startTime) / 1000000) / iterations;<br />        g.drawString(&quot;Progressive&quot;, xLoc, yLoc + scaleH + PADDING);<br />        g.drawString(Float.toString(totalTime) + &quot; ms&quot;, <br />                xLoc, yLoc + scaleH + PADDING + 10);<br />        System.out.println(&quot;Progressive: &quot; + ((endTime - startTime) / 1000000));<br />    }<br />    <br />    private static void createAndShowGUI() {<br />        JFrame f = new JFrame();<br />        f.setLayout(new BorderLayout());<br />        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br />        PictureScaler test = new PictureScaler();<br />        //f.setSize(scaleW + (4 * PADDING), scaleH + (4 * PADDING));<br />        f.add(test);        <br />        f.validate();<br />        f.pack();<br />        f.setVisible(true);<br />    }<br />    <br />    public static void main(String args[]) {<br />        Runnable doCreateAndShowGUI = new Runnable() {<br />            public void run() {<br />                createAndShowGUI();<br />            }<br />        };<br />        SwingUtilities.invokeLater(doCreateAndShowGUI);<br />    }<br />}</pre> 
<p>图像压缩 gcode</p></div></body></html>