<html><head><title><div class="tit">
  Dom4j的使用
</div></title></head><body><div id='tit'>Dom4j的使用</div><div id='cate'>j&middot;入门</div><div id='date'>2008年04月03日 星期四 04:40 P.M.</div><div id='page'>148</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/7333af012fa19a021c95833d.html'>http://hi.baidu.com/hxzon/blog/item/7333af012fa19a021c95833d.html</a><div id='cnt'><div> 
 <p><font size="3">Dom4j的使用</font></p> 
 <p><br /> <font size="3">select *</font></p> 
</div> 
<div> 
</div> 
<div>
 <font size="3">from opendatasource</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">(</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">&nbsp;&nbsp;&nbsp; 'SQLOLEDB',</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">&nbsp;&nbsp;&nbsp; 'Data Source=192.168.1.101;User Id=sa;Password=zhtz'</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">).sims.dbo.sims_Apply</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">where 1=1</font>
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 <font size="3">1．'SQLOLEDB'：注册为用于访问数据源的 OLE DB 访问接口的 PROGID 的名称。provider_name 的数据类型为 char，无默认值。</font>
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 <font size="3">2．'Data Source=192.168.1.101;User Id=sa;Password=pwd'：连接字符串，该字符串将要传递给目标提供程序的 IDataInitialize 接口。提供程序字符串语法是以关键字值对为基础的，这些关键字值对由分号隔开，例如：“keyword1=value; keyword2=value”。</font>
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 <font size="3">3．Sims:数据库</font>
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 <font size="3">4．Sims_Apply：表名<br /> Dom4j 使用简介<br /> 作者：冰云 icecloud(AT)sina.com<br /> 时间：2003.12.15</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">版权声明：<br /> 本文由冰云完成，首发于CSDN，未经许可，不得使用于任何商业用途。<br /> 文中代码部分引用自DOM4J文档。<br /> 欢迎转载，但请保持文章及版权声明完整。<br /> 如需联络请发邮件：icecloud(AT)sina.com</font>
</div> 
<div> 
</div> 
<div>
 <br /> 
 <font size="3">DOM4J是dom4j.org出品的一个开源XML解析包，它的网站中这样定义：<br /> Dom4j is an easy to use, open source library for working with XML, XPath and XSLT on the Java platform using the Java Collections Framework and with full support for DOM, SAX and JAXP.<br /> Dom4j是一个易用的、开源的库，用于XML，XPath和XSLT。它应用于Java平台，采用了Java集合框架并完全支持DOM，SAX和JAXP。<br /> DOM4J使用起来非常简单。只要你了解基本的XML-DOM模型，就能使用。然而他自己带的指南只有短短一页（html），不过说的到挺全。国内的中文资料很少。因而俺写这个短小的教程方便大家使用，这篇文章仅谈及基本的用法，如需深入的使用，请……自己摸索或查找别的资料。<br /> 之前看过IBM developer社区的文章（参见附录），提到一些XML解析包的性能比较，其中DOM4J的性能非常出色，在多项测试中名列前茅。（事实上DOM4J的官方文档中也引用了这个比较）所以这次的项目中我采用了DOM4J作为XML解析工具。<br /> 在国内比较流行的是使用JDOM作为解析器，两者各擅其长，但DOM4J最大的特色是使用大量的接口，这也是它被认为比JDOM灵活的主要原因。大师不是说过么，“面向接口编程”。目前使用DOM4J的已经越来越多。如果你善于使用JDOM，不妨继续用下去，只看看本篇文章作为了解与比较，如果你正要采用一种解析器，不如就用DOM4J吧。 <br /> 它的主要接口都在org.dom4j这个包里定义：<br /> Attribute Attribute定义了XML的属性 <br /> Branch Branch为能够包含子节点的节点如XML元素(Element)和文档(Docuemnts)定义了一个公共的行为， <br /> CDATA CDATA 定义了XML CDATA 区域 <br /> CharacterData CharacterData是一个标识借口，标识基于字符的节点。如CDATA，Comment, Text. <br /> Comment Comment 定义了XML注释的行为 <br /> Document 定义了XML文档 <br /> DocumentType DocumentType 定义XML DOCTYPE声明 <br /> Element Element定义XML 元素 <br /> ElementHandler ElementHandler定义了 Element 对象的处理器 <br /> ElementPath 被 ElementHandler 使用，用于取得当前正在处理的路径层次信息 <br /> Entity Entity定义 XML entity <br /> Node Node为所有的dom4j中XML节点定义了多态行为 <br /> NodeFilter NodeFilter 定义了在dom4j节点中产生的一个滤镜或谓词的行为（predicate） <br /> ProcessingInstruction ProcessingInstruction 定义 XML 处理指令. <br /> Text Text 定义XML 文本节点. <br /> Visitor Visitor 用于实现Visitor模式. <br /> XPath XPath 在分析一个字符串后会提供一个XPath 表达式</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">看名字大致就知道它们的涵义如何了。<br /> 要想弄懂这套接口，关键的是要明白接口的继承关系：<br /> interface java.lang.Cloneable <br /> interface org.dom4j.Node <br /> interface org.dom4j.Attribute <br /> interface org.dom4j.Branch <br /> interface org.dom4j.Document <br /> interface org.dom4j.Element <br /> interface org.dom4j.CharacterData <br /> interface org.dom4j.CDATA <br /> interface org.dom4j.Comment <br /> interface org.dom4j.Text <br /> interface org.dom4j.DocumentType <br /> interface org.dom4j.Entity <br /> interface org.dom4j.ProcessingInstruction <br /> 一目了然，很多事情都清楚了。大部分都是由Node继承来的。知道这些关系，将来写程序就不会出现ClassCastException了。<br /> 下面给出一些例子（部分摘自DOM4J自带的文档），简单说一下如何使用。<br /> １．&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 读取并解析XML文档：<br /> 读写XML文档主要依赖于org.dom4j.io包，其中提供DOMReader和SAXReader两类不同方式，而调用方式是一样的。这就是依靠接口的好处。</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">// 从文件读取XML，输入文件名，返回XML文档<br /> public Document read(String fileName) throws MalformedURLException, DocumentException {<br /> &nbsp;&nbsp;&nbsp; SAXReader reader = new SAXReader();<br /> &nbsp;&nbsp;&nbsp; Document document = reader.read(new File(fileName));<br /> &nbsp;&nbsp;&nbsp; return document;<br /> }</font>
</div> 
<div> 
</div> 
<div>
 <br /> 
 <font size="3">其中，reader的read方法是重载的，可以从InputStream, File, Url等多种不同的源来读取。得到的Document对象就带表了整个XML。<br /> 根据本人自己的经验，读取的字符编码是按照XML文件头定义的编码来转换。如果遇到乱码问题，注意要把各处的编码名称保持一致即可。<br /> ２．&nbsp;&nbsp; 取得Root节点<br /> 读取后的第二步，就是得到Root节点。熟悉XML的人都知道，一切XML分析都是从Root元素开始的。</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> public Element getRootElement(Document doc){<br /> &nbsp;&nbsp;&nbsp; return doc.getRootElement();<br /> }</font>
</div> 
<div> 
</div> 
<div>
 <br /> 
 <font size="3">３．&nbsp;&nbsp; 遍历XML树<br /> DOM4J提供至少3种遍历节点的方法：<br /> 1) 枚举(Iterator)</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">// 枚举所有子节点<br /> for ( Iterator i = root.elementIterator(); i.hasNext(); ) {<br /> &nbsp;&nbsp;&nbsp; Element element = (Element) i.next();<br /> &nbsp;&nbsp;&nbsp; // do something<br /> }<br /> // 枚举名称为foo的节点<br /> for ( Iterator i = root.elementIterator(foo); i.hasNext();) {<br /> &nbsp;&nbsp;&nbsp; Element foo = (Element) i.next();<br /> &nbsp;&nbsp;&nbsp; // do something<br /> }<br /> // 枚举属性<br /> for ( Iterator i = root.attributeIterator(); i.hasNext(); ) {<br /> &nbsp;&nbsp;&nbsp; Attribute attribute = (Attribute) i.next();<br /> &nbsp;&nbsp;&nbsp; // do something<br /> }</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">2)递归 <br /> 递归也可以采用Iterator作为枚举手段，但文档中提供了另外的做法</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">public void treeWalk() {<br /> &nbsp;&nbsp;&nbsp; treeWalk(getRootElement());<br /> }<br /> public void treeWalk(Element element) {<br /> &nbsp;&nbsp;&nbsp; for (int i = 0, size = element.nodeCount(); i &lt; size; i++)&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node node = element.node(i);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (node instanceof Element) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; treeWalk((Element) node);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else { // do something....<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; }<br /> }</font>
</div> 
<div> 
</div> 
<div>
 <br /> 
 <font size="3">3) Visitor模式<br /> 最令人兴奋的是DOM4J对Visitor的支持，这样可以大大缩减代码量，并且清楚易懂。了解设计模式的人都知道，Visitor是GOF设计模式之一。其主要原理就是两种类互相保有对方的引用，并且一种作为Visitor去访问许多Visitable。我们来看DOM4J中的Visitor模式(快速文档中没有提供)<br /> 只需要自定一个类实现Visitor接口即可。</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> &nbsp;&nbsp;&nbsp;&nbsp; public class MyVisitor extends VisitorSupport {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void visit(Element element){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(element.getName());<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void visit(Attribute attr){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(attr.getName());<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; }</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">&nbsp;&nbsp;&nbsp; 调用： root.accept(new MyVisitor())</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">Visitor接口提供多种Visit()的重载，根据XML不同的对象，将采用不同的方式来访问。上面是给出的Element和Attribute的简单实现，一般比较常用的就是这两个。VisitorSupport是DOM4J提供的默认适配器，Visitor接口的Default Adapter模式，这个模式给出了各种visit(*)的空实现，以便简化代码。<br /> 注意，这个Visitor是自动遍历所有子节点的。如果是root.accept(MyVisitor)，将遍历子节点。我第一次用的时候，认为是需要自己遍历，便在递归中调用Visitor，结果可想而知。<br /> 4. XPath支持<br /> DOM4J对XPath有良好的支持，如访问一个节点，可直接用XPath选择。</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">public void bar(Document document) {<br /> &nbsp;&nbsp;&nbsp; List list = document.selectNodes( //foo/bar );<br /> &nbsp;&nbsp;&nbsp; Node node = document.selectSingleNode(//foo/bar/author);<br /> &nbsp;&nbsp;&nbsp; String name = node.valueOf( @name );<br /> }</font>
</div> 
<div> 
</div> 
<div>
 <br /> 
 <font size="3">例如，如果你想查找XHTML文档中所有的超链接，下面的代码可以实现：</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">public void findLinks(Document document) throws DocumentException {<br /> &nbsp;&nbsp;&nbsp; List list = document.selectNodes( </font>
 <a><font size="3">//a/@href</font></a>
 <font size="3"> );<br /> &nbsp;&nbsp;&nbsp; for (Iterator iter = list.iterator(); iter.hasNext(); ) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Attribute attribute = (Attribute) iter.next();<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String url = attribute.getValue();<br /> &nbsp;&nbsp;&nbsp; }<br /> }</font>
</div> 
<div> 
</div> 
<div>
 <br /> 
 <font size="3">5. 字符串与XML的转换<br /> 有时候经常要用到字符串转换为XML或反之，</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">// XML转字符串 <br /> Document document = ...;<br /> String text = document.asXML();<br /> // 字符串转XML<br /> String text = &lt;person&gt; &lt;name&gt;James&lt;/name&gt; &lt;/person&gt;;<br /> Document document = DocumentHelper.parseText(text);</font>
</div> 
<div> 
</div> 
<div>
 <br /> 
 <font size="3">6 用XSLT转换XML</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">public Document styleDocument(<br /> &nbsp;&nbsp;&nbsp; Document document, <br /> &nbsp;&nbsp;&nbsp; String stylesheet<br /> ) throws Exception {<br /> // load the transformer using JAXP<br /> TransformerFactory factory = TransformerFactory.newInstance();<br /> Transformer transformer = factory.newTransformer( <br /> &nbsp;&nbsp;&nbsp; new StreamSource( stylesheet ) <br /> );<br /> // now lets style the given document<br /> DocumentSource source = new DocumentSource( document );<br /> DocumentResult result = new DocumentResult();<br /> transformer.transform( source, result );<br /> // return the transformed document<br /> Document transformedDoc = result.getDocument();<br /> return transformedDoc;<br /> }</font>
</div> 
<div> 
</div> 
<div>
 <br /> 
 <font size="3">7. 创建XML<br /> 一般创建XML是写文件前的工作，这就像StringBuffer一样容易。</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">public Document createDocument() {<br /> &nbsp;&nbsp;&nbsp; Document document = DocumentHelper.createDocument();<br /> &nbsp;&nbsp;&nbsp; Element root = document.addElement(root);<br /> &nbsp;&nbsp;&nbsp; Element author1 =<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addElement(author)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addAttribute(name, James)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addAttribute(location, UK)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addText(James Strachan);<br /> &nbsp;&nbsp;&nbsp; Element author2 =<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addElement(author)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addAttribute(name, Bob)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addAttribute(location, US)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addText(Bob McWhirter);<br /> &nbsp;&nbsp;&nbsp; return document;<br /> }</font>
</div> 
<div> 
</div> 
<div>
 <br /> 
 <font size="3">8. 文件输出<br /> 一个简单的输出方法是将一个Document或任何的Node通过write方法输出</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">FileWriter out = new FileWriter( foo.xml );<br /> document.write(out);</font>
</div> 
<div> 
</div> 
<div>
 <br /> 
 <font size="3">如果你想改变输出的格式，比如美化输出或缩减格式，可以用XMLWriter类</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">public void write(Document document) throws IOException {<br /> &nbsp;&nbsp;&nbsp; // 指定文件<br /> &nbsp;&nbsp;&nbsp; XMLWriter writer = new XMLWriter(<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new FileWriter( output.xml )<br /> &nbsp;&nbsp;&nbsp; );<br /> &nbsp;&nbsp;&nbsp; writer.write( document );<br /> &nbsp;&nbsp;&nbsp; writer.close();<br /> &nbsp;&nbsp;&nbsp; // 美化格式<br /> &nbsp;&nbsp;&nbsp; OutputFormat format = OutputFormat.createPrettyPrint();<br /> &nbsp;&nbsp;&nbsp; writer = new XMLWriter( System.out, format );<br /> &nbsp;&nbsp;&nbsp; writer.write( document );<br /> &nbsp;&nbsp;&nbsp; // 缩减格式<br /> &nbsp;&nbsp;&nbsp; format = OutputFormat.createCompactFormat();<br /> &nbsp;&nbsp;&nbsp; writer = new XMLWriter( System.out, format );<br /> &nbsp;&nbsp;&nbsp; writer.write( document );<br /> }</font>
</div> 
<div> 
</div> 
<div> 
 <p><br /> <font size="3">如何，DOM4J够简单吧，当然，还有一些复杂的应用没有提到，如ElementHandler等。如果你动心了，那就一起来用DOM4J.<br /> DOM4J官方网站：(我老连不上)<br /> </font><a href="http://www.dom4j.org/"><font size="3">http://www.dom4j.org/</font></a><br /> <font size="3">DOM4J下载(SourceForge)，最新版本为1.4<br /> </font><a href="http://sourceforge.net/projects/dom4j"><font size="3">http://sourceforge.net/projects/dom4j</font></a></p> 
 <p><font size="3">参考资料：</font></p> 
 <p><font size="3">DOM4J文档</font></p> 
 <p><font size="3">Java 中的 XML：文档模型，第一部分：性能</font></p> 
 <p><a target="_blank" href="http://www-900.ibm.com/developerWorks/cn/xml/x-injava/index.shtml"><font size="3">http://www-900.ibm.com/developerWorks/cn/xml/x-injava/index.shtml</font></a></p> 
 <p><font size="3">Java 中的 XML：Java 文档模型的用法</font></p> 
 <p><a target="_blank" href="http://www-900.ibm.com/developerWorks/cn/xml/x-injava2/index.shtml"><font size="3">http://www-900.ibm.com/developerWorks/cn/xml/x-injava2/index.shtml</font></a></p> 
 <p><font size="3">Java XML API 漫谈 by robbin</font></p> 
 <p><a target="_blank" href="http://www.hibernate.org.cn:8000/137.html"><font size="3">http://www.hibernate.org.cn:8000/137.html</font></a></p> 
</div></div></body></html>