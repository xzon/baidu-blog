<html><head><title><div class="tit">
  Hibernate查询语言：HQL
</div></title></head><body><div id='tit'>Hibernate查询语言：HQL</div><div id='cate'>j&middot;入门</div><div id='date'>2008年04月01日 星期二 10:10 A.M.</div><div id='page'>150</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/60ce054f38cb1832afc3ab8f.html'>http://hi.baidu.com/hxzon/blog/item/60ce054f38cb1832afc3ab8f.html</a><div id='cnt'><p>Hibernate查询语言：HQL</p> 
<p>&nbsp;&nbsp;&nbsp; HQL：Hibernate Qusery Language，如果你已经熟悉它，就会发现它跟SQL非常相像。不过 你不要被表面的假象迷惑，HQL是面向对象的（OO，用生命的眼光看待每一个对象，他们是如此鲜活）。如果你对JAVA和SQL语句有一定了解的话，那么HQL对你简直易如反掌，你完全可以利用在公车上的时间掌握它。<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以下从几个方面进行慢慢深入：<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>1。大小些敏感<br /> </strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 大家知道Query是对大小写不敏感的，但是在HQL（前面提到它是OO的）中那么对象类的名称和属性确实大小写敏感的（符合java编程语法）。<br /> &nbsp;&nbsp;&nbsp;&nbsp; 如：sElect cat.name from Cat as cat和select cat.name from Cat as cat是一样的<br /> &nbsp;&nbsp;&nbsp;&nbsp; 但是：<br /> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sElect cat.name from CAT as cat和select cat.name from Cat as cat确实不一样的。<br /> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp; <strong>2。from语句<br /> </strong>&nbsp;&nbsp;&nbsp;&nbsp; 最简单的：<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from eg.Cat <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 它只是简单的返回所有eg.Cat的实例<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通常我们此时会为eg.Cat其个别名，因为在query的其余部分可能会用到(参看上边关于大小写<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 敏感时的例子情形)，如：<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from eg.Cat as cat 这里as可以省略。<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上边只是单表查询，多表的情况如下写法：<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from eg.Cat,eg.Dog<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from eg.Cat as cat,eg.Dog as dog<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>3。join相关<br /> </strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (inner) join<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left (outer) join<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; right (outer) join<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; full join<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HQL同样对SQL中的这些特性支持<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下面插播一个小话题，关于上边的那些特性，我一直都没怎么用，今天既然说到这里，就想<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把上边的几个特性的用法说一下，也算对自己的一个补充：<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假设有两个表：部门、员工，下面列举一些数据：<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 员工(Employee)：<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name&nbsp;&nbsp;&nbsp; DepNo<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001&nbsp;&nbsp;&nbsp;&nbsp; Jplateau 01<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 002&nbsp;&nbsp;&nbsp;&nbsp; Jony&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 003&nbsp;&nbsp;&nbsp;&nbsp; Camel&nbsp;&nbsp;&nbsp; 02<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 部门(Department)：<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 01&nbsp;&nbsp;&nbsp;&nbsp; 研发部<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 02&nbsp;&nbsp;&nbsp; 营销部<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在Hibernate中我们操纵的都是对象，所以我们操纵的是部门类和员工类<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1).(inner) join<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select employee.ID as id1,employee.Name as name1,department.ID as id2,department.Name<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as name2 from Employee as employee join Department as department on employee.DepNo=<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; department.ID (注意到条件语句我用on 没有用where)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那么执行结果是什么呢？<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id1 name1 id2 name2<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++++++++++++++++++++++++++++++++++++++<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001 Jplateau 01 研发部<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 002 Jony&nbsp;&nbsp;&nbsp;&nbsp; 01 研发部<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2).left (outer) join<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select employee.ID as id1,employee.Name as name1,department.ID as id2,department.Name<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as name2 from Employee as employee left join Department as department on employee.DepNo=<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; department.ID <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那么执行结果又该是什么呢？<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id1 name1 id2 name2<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++++++++++++++++++++++++++++++++++++++<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001 Jplateau 01 研发部<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 002 Jony&nbsp;&nbsp;&nbsp;&nbsp; 01 研发部 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 003 Camel&nbsp;&nbsp;&nbsp; null null&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {就是说此时我要已第一个表的记录多少为准，第二个表中没有相应纪录的时候填充null} <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3). right (outer) join<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select employee.ID as id1,employee.Name as name1,department.ID as id2,department.Name<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as name2 from Employee as employee right join Department as department on employee.DepNo=<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; department.ID <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那么执行结果又该是什么呢？<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id1 name1 id2 name2<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++++++++++++++++++++++++++++++++++++++<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 001 Jplateau 01 研发部<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 002 Jony&nbsp;&nbsp;&nbsp;&nbsp; 01 研发部 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; null null&nbsp;&nbsp;&nbsp;&nbsp; 02 营销部&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {就是说此时我要已第二个表的记录多少为准，第一个表中没有相应纪录的时候填充null} <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>4。select语句<br /> </strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 就是要确定你要从查询中返回哪些对象或者哪些对象的属性。写几个例子吧：<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; select employee form Employee as employee <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; select employee form Employee as employee where employee.Name like ''J%''<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; select employee.Name form Employee as employee where employee.Name like ''J%''<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; select employee.ID as id1,employee.Name as name1,department.ID as id2,department.Name<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as name2 from Employee as employee right join Department as department on employee.DepNo=<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; department.ID <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; select elements(employee.Name) from Employee as employee <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; （不明白elements到底是做什么用的？望给于说明）</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 等等<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>5。数学函数<br /> </strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; JDO目前好像还不支持此类特性。<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; avg(...), sum(...), min(...), max(...)</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count(*)</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp; count(...), count(distinct ...), count(all...) <br /> &nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp; 其用法和SQL基本相同<br /> &nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp; select distinct employee.name from Employee as employee <br /> &nbsp;&nbsp;&nbsp;&nbsp; select count(distinct employee.name),count(employee) from Employee as employee <br /> &nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp; <strong>6。polymorphism (暂时不知道如何解释？)<br /> </strong>&nbsp;&nbsp;&nbsp;&nbsp; from com.test.Animal as animal<br /> &nbsp;&nbsp;&nbsp;&nbsp; 不光得到所有Animal得实例，而且可以得到所有Animal的子类（如果我们定义了一个子类Cat）<br /> &nbsp;&nbsp;&nbsp;&nbsp; 一个比较极端的例子<br /> &nbsp;&nbsp;&nbsp;&nbsp; from java.lang.Object as o<br /> &nbsp;&nbsp;&nbsp;&nbsp; 可以得到所有持久类的实例<br /> &nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;<strong> 7。where语句</strong><br /> &nbsp;&nbsp;&nbsp;&nbsp; 定义查询语句的条件，举几个例子吧：<br /> &nbsp;&nbsp;&nbsp;&nbsp; from Employee as employee where employee.Name=''Jplateau''<br /> &nbsp;&nbsp;&nbsp;&nbsp; from Employee as employee where employee.Name like ''J%''<br /> &nbsp;&nbsp;&nbsp;&nbsp; from Employee as employee where employee.Name like ''%u''<br /> &nbsp;&nbsp;&nbsp;&nbsp; 在where语句中“=”不光可以比较对象的属性，也可以比较对象，如：<br /> &nbsp;&nbsp;&nbsp;&nbsp; select animal from com.test.Animal as animal where animal.name=dog<br /> &nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;<strong> 8。表达式<br /> </strong>&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; 在SQL语句中大部分的表达式在HQL中都可以使用：<br /> &nbsp;&nbsp;&nbsp; mathematical operators +, -, *, /</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; binary comparison operators =, &gt;=, &lt;=, &lt;&gt;, !=, like</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logical operations and, or, not</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string concatenation ||</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL scalar functions like upper() and lower() <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Parentheses ( ) indicate grouping</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in, between, is null</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JDBC IN parameters ?</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; named parameters :name, :start_date, :x1 （这种应该是另一种&quot;?&quot;的变通解决方法）</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL literals ''foo'', 69, ''1970-01-01 10:00:01.0''</p> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Java public static final constants eg.Color.TABBY <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其他不必解释了，在这里我只想对查询中的参数问题说明一下：<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 大家知道在SQL中进行传递参数进行查询的时候，我们通常用PreparedStatement，在语句中写一大堆的“？”，<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在hql中也可以用这种方法，如：<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List mates = sess.find(<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;select employee.name from Employee as employee &quot; +<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;where employee.Name=? &quot;,<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name,<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hibernate.STRING<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (说明：上面利用Session里的find方法，在hibernate的api Session中重载了很多find方法，它可以满足你多种形式的查询)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上边是一个参数的情形，这种情况下紧接着引入参数和定义参数的类型，当为多个参数，调用另一个find方法，它的后两个<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 参数都是数组的形式。<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 还有另外一种方法来解决上边的问题，JDO也有这样的方法，不过和hibernate的表现形式上有差别，但他们两个骨子里却是<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一样的，如：<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Query q = sess.createQuery(&quot;select employee.name from Employee as employee where employee.Name=:name&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q.setString(&quot;name&quot;, &quot;Jplateau&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //当有多个参数的时候在此逐一定义<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator employees = q.iterate();&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>9。order 语句<br /> </strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 和sql语句没什么差别，如：<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select employee.name from Employee as employee where employee.Name like ''J%'' order by employee.ID desc (或者asc)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>10。group by 语句<br /> </strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 同样和sql语句没什么差别，如：<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select employee.name,employee.DepNo from Employee as employee group by employee.DepNo<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>select foo.id, avg( elements(foo.names) ), max( indices(foo.names) ) from eg.Foo foo group by foo.id<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {Note: You may use the elements and indices constructs inside a select clause, even on databases with no subselects.}<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 谁帮我解释一下上边两句，谢过！</strong><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>11。子查询<br /> </strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hibernate同样支持子查询，写几个例子：<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from eg.Cat as fatcat where fatcat.weight &gt; ( select avg(cat.weight) from eg.DomesticCat cat )<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp; <strong>小节：<br /> </strong>&nbsp;&nbsp; 其实HQL和SQL是非常相似的，在写的时候你只要时刻想到对象的概念，那么你完全可以用SQL的思想来写HQL.<br /> &nbsp;&nbsp; <br /> &nbsp;&nbsp; 参考资源：Hibernate参考手册第七章以及第九章，建议由时间的并且要用hibernate开发项目的朋友仔细研读该手册。</p></div></body></html>