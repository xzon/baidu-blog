<html><head><title><div class="tit">
  JAVA中浅复制与深复制概念详细解析
</div></title></head><body><div id='tit'>JAVA中浅复制与深复制概念详细解析</div><div id='cate'>j&middot;入门</div><div id='date'>2008年03月30日 星期日 09:25 P.M.</div><div id='page'>152</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/d272ba3e4a7ddffe828b139c.html'>http://hi.baidu.com/hxzon/blog/item/d272ba3e4a7ddffe828b139c.html</a><div id='cnt'><div> 
 <table style="border-top: #ffffff 17px solid" class="titel FCK__ShowTableBorders" border="0" cellspacing="0" cellpadding="0" width="560"> 
  <tbody> 
   <tr> 
    <td align="center"> <h1 class="titel">JAVA中浅复制与深复制概念详细解析</h1> </td> 
   </tr> 
  </tbody> 
 </table> 
 <table style="margin: 2px 0px 20px" class="FCK__ShowTableBorders" border="0" cellspacing="0" cellpadding="0" width="560"> 
  <tbody> 
   <tr> 
    <td bgcolor="#b1bcc0" height="1"> </td> 
   </tr> 
  </tbody> 
 </table> 
 <table style="margin-bottom: 20px" class="FCK__ShowTableBorders" border="0" cellspacing="0" cellpadding="0" width="560"> 
  <tbody> 
   <tr> 
    <td align="center"><span class="b">发布时间：2007.03.23 13:23</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="b"> 来源：赛迪网技术社区</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="b">作者：korn</span></td> 
   </tr> 
  </tbody> 
 </table> 
 <table class="p11 FCK__ShowTableBorders" border="0" cellspacing="0" cellpadding="0" width="560"> 
  <tbody> 
   <tr> 
    <td style="word-wrap: break-word" align="left"> <p style="text-indent: 2em" class="a14c"> </p> <p style="text-indent: 2em">1．浅复制与深复制概念</p> <p style="text-indent: 2em">⑴浅复制（浅克隆）</p> <p style="text-indent: 2em">被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。</p> <p style="text-indent: 2em"> </p> <p style="text-indent: 2em">⑵深复制（深克隆）</p> <p style="text-indent: 2em">被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p> <p style="text-indent: 2em"> </p> <p style="text-indent: 2em">2．Java的clone（）方法</p> <p style="text-indent: 2em">⑴clone方法将对象复制了一份并返回给调用者。一般而言，clone（）方法满足：</p> <p style="text-indent: 2em">①对任何的对象x，都有x.clone() !=x//克隆对象与原对象不是同一个对象</p> <p style="text-indent: 2em">②对任何的对象x，都有x.clone().getClass()= =x.getClass()//克隆对象与原对象的类型一样</p> <p style="text-indent: 2em">③如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</p> <p style="text-indent: 2em"> </p> <p style="text-indent: 2em">⑵Java中对象的克隆</p> <p style="text-indent: 2em">①为了获取对象的一份拷贝，我们可以利用Object类的clone()方法。</p> <p style="text-indent: 2em">②在派生类中覆盖基类的clone()方法，并声明为public。</p> <p style="text-indent: 2em">③在派生类的clone()方法中，调用super.clone()。</p> <p style="text-indent: 2em">④在派生类中实现Cloneable接口。</p> <p style="text-indent: 2em"> </p> <p style="text-indent: 2em">请看如下代码：</p> <p style="text-indent: 2em"> </p> <p style="text-indent: 2em">class Student implements Cloneable</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">String name;</p> <p style="text-indent: 2em">int age;</p> <p style="text-indent: 2em">Student(String name,int age)</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">this.name=name;</p> <p style="text-indent: 2em">this.age=age;</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">public Object clone()</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">Object o=null;</p> <p style="text-indent: 2em">try</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">o=(Student)super.clone();//Object中的clone()识别出你要复制的是哪一</p> <p style="text-indent: 2em">// 个对象。</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">catch(CloneNotSupportedException e)</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">System.out.println(e.toString());</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">return o;</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em"> </p> <p style="text-indent: 2em">public static void main(String[] args)</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">Student s1=new Student(&quot;zhangsan&quot;,18);</p> <p style="text-indent: 2em">Student s2=(Student)s1.clone();</p> <p style="text-indent: 2em">s2.name=&quot;lisi&quot;;</p> <p style="text-indent: 2em">s2.age=20;</p> <p style="text-indent: 2em">System.out.println(&quot;name=&quot;+s1.name+&quot;,&quot;+&quot;age=&quot;+s1.age);//修改学生2后，不影响</p> <p style="text-indent: 2em">//学生1的值。</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em"> </p> <p style="text-indent: 2em">说明：</p> <p style="text-indent: 2em">①为什么我们在派生类中覆盖Object的clone()方法时，一定要调用super.clone()呢？在运行时刻，Object中的clone()识别出你要复制的是哪一个对象，然后为此对象分配空间，并进行对象的复制，将原始对象的内容一一复制到新对象的存储空间中。</p> <p style="text-indent: 2em">②继承自java.lang.Object类的clone()方法是浅复制。以下代码可以证明之。</p> <p style="text-indent: 2em"> </p> <p style="text-indent: 2em">class Professor</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">String name;</p> <p style="text-indent: 2em">int age;</p> <p style="text-indent: 2em">Professor(String name,int age)</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">this.name=name;</p> <p style="text-indent: 2em">this.age=age;</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">class Student implements Cloneable</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">String name;//常量对象。</p> <p style="text-indent: 2em">int age;</p> <p style="text-indent: 2em">Professor p;//学生1和学生2的引用值都是一样的。</p> <p style="text-indent: 2em">Student(String name,int age,Professor p)</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">this.name=name;</p> <p style="text-indent: 2em">this.age=age;</p> <p style="text-indent: 2em">this.p=p;</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">public Object clone()</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">Student o=null;</p> <p style="text-indent: 2em">try</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">o=(Student)super.clone();</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">catch(CloneNotSupportedException e)</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">System.out.println(e.toString());</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">o.p=(Professor)p.clone();</p> <p style="text-indent: 2em">return o;</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">public static void main(String[] args)</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">Professor p=new Professor(&quot;wangwu&quot;,50);</p> <p style="text-indent: 2em">Student s1=new Student(&quot;zhangsan&quot;,18,p);</p> <p style="text-indent: 2em">Student s2=(Student)s1.clone();</p> <p style="text-indent: 2em">s2.p.name=&quot;lisi&quot;;</p> <p style="text-indent: 2em">s2.p.age=30;</p> <p style="text-indent: 2em">System.out.println(&quot;name=&quot;+s1.p.name+&quot;,&quot;+&quot;age=&quot;+s1.p.age);//学生1的教授</p> <p style="text-indent: 2em">//成为lisi,age为30。</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em"> </p> <p style="text-indent: 2em">那应该如何实现深层次的克隆，即修改s2的教授不会影响s1的教授？代码改进如下。</p> <p style="text-indent: 2em"> </p> <p style="text-indent: 2em">改进使学生1的Professor不改变（深层次的克隆）</p> <p style="text-indent: 2em">class Professor implements Cloneable</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">String name;</p> <p style="text-indent: 2em">int age;</p> <p style="text-indent: 2em">Professor(String name,int age)</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">this.name=name;</p> <p style="text-indent: 2em">this.age=age;</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">public Object clone()</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">Object o=null;</p> <p style="text-indent: 2em">try</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">o=super.clone();</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">catch(CloneNotSupportedException e)</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">System.out.println(e.toString());</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">return o;</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">class Student implements Cloneable</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">String name;</p> <p style="text-indent: 2em">int age;</p> <p style="text-indent: 2em">Professor p;</p> <p style="text-indent: 2em">Student(String name,int age,Professor p)</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">this.name=name;</p> <p style="text-indent: 2em">this.age=age;</p> <p style="text-indent: 2em">this.p=p;</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">public Object clone()</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">Student o=null;</p> <p style="text-indent: 2em">try</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">o=(Student)super.clone();</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">catch(CloneNotSupportedException e)</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">System.out.println(e.toString());</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">o.p=(Professor)p.clone();</p> <p style="text-indent: 2em">return o;</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">public static void main(String[] args)</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">Professor p=new Professor(&quot;wangwu&quot;,50);</p> <p style="text-indent: 2em">Student s1=new Student(&quot;zhangsan&quot;,18,p);</p> <p style="text-indent: 2em">Student s2=(Student)s1.clone();</p> <p style="text-indent: 2em">s2.p.name=&quot;lisi&quot;;</p> <p style="text-indent: 2em">s2.p.age=30;</p> <p style="text-indent: 2em">System.out.println(&quot;name=&quot;+s1.p.name+&quot;,&quot;+&quot;age=&quot;+s1.p.age);//学生1的教授不改变。</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em"> </p> <p style="text-indent: 2em">3．利用串行化来做深复制</p> <p style="text-indent: 2em">把对象写到流里的过程是串行化（Serilization）过程，但是在Java程序师圈子里又非常形象地称为“冷冻”或者“腌咸菜（picking）”过程；而把对象从流中读出来的并行化（Deserialization）过程则叫做“解冻”或者“回鲜(depicking)”过程。应当指出的是，写在流里的是对象的一个拷贝，而原对象仍然存在于JVM里面，因此“腌成咸菜”的只是对象的一个拷贝，Java咸菜还可以回鲜。</p> <p style="text-indent: 2em">在Java语言里深复制一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里（腌成咸菜），再从流里读出来（把咸菜回鲜），便可以重建对象。</p> <p style="text-indent: 2em">如下为深复制源代码。</p> <p style="text-indent: 2em">public Object deepClone()</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">//将对象写到流里</p> <p style="text-indent: 2em">ByteArrayOutoutStream bo=new ByteArrayOutputStream();</p> <p style="text-indent: 2em">ObjectOutputStream oo=new ObjectOutputStream(bo);</p> <p style="text-indent: 2em">oo.writeObject(this);</p> <p style="text-indent: 2em">//从流里读出来</p> <p style="text-indent: 2em">ByteArrayInputStream bi=new ByteArrayInputStream(bo.toByteArray());</p> <p style="text-indent: 2em">ObjectInputStream oi=new ObjectInputStream(bi);</p> <p style="text-indent: 2em">return(oi.readObject());</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em"> </p> <p style="text-indent: 2em">这样做的前提是对象以及对象内部所有引用到的对象都是可串行化的，否则，就需要仔细考察那些不可串行化的对象可否设成transient，从而将之排除在复制过程之外。上例代码改进如下。</p> <p style="text-indent: 2em"> </p> <p style="text-indent: 2em">class Professor implements Serializable</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">String name;</p> <p style="text-indent: 2em">int age;</p> <p style="text-indent: 2em">Professor(String name,int age)</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">this.name=name;</p> <p style="text-indent: 2em">this.age=age;</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">class Student implements Serializable</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">String name;//常量对象。</p> <p style="text-indent: 2em">int age;</p> <p style="text-indent: 2em">Professor p;//学生1和学生2的引用值都是一样的。</p> <p style="text-indent: 2em">Student(String name,int age,Professor p)</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">this.name=name;</p> <p style="text-indent: 2em">this.age=age;</p> <p style="text-indent: 2em">this.p=p;</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">public Object deepClone() throws IOException,</p> <p style="text-indent: 2em">OptionalDataException,ClassNotFoundException</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">//将对象写到流里</p> <p style="text-indent: 2em">ByteArrayOutoutStream bo=new ByteArrayOutputStream();</p> <p style="text-indent: 2em">ObjectOutputStream oo=new ObjectOutputStream(bo);</p> <p style="text-indent: 2em">oo.writeObject(this);</p> <p style="text-indent: 2em">//从流里读出来</p> <p style="text-indent: 2em">ByteArrayInputStream bi=new ByteArrayInputStream(bo.toByteArray());</p> <p style="text-indent: 2em">ObjectInputStream oi=new ObjectInputStream(bi);</p> <p style="text-indent: 2em">return(oi.readObject());</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em"> </p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em">public static void main(String[] args)</p> <p style="text-indent: 2em">{</p> <p style="text-indent: 2em">Professor p=new Professor(&quot;wangwu&quot;,50);</p> <p style="text-indent: 2em">Student s1=new Student(&quot;zhangsan&quot;,18,p);</p> <p style="text-indent: 2em">Student s2=(Student)s1.deepClone();</p> <p style="text-indent: 2em">s2.p.name=&quot;lisi&quot;;</p> <p style="text-indent: 2em">s2.p.age=30;</p> <p style="text-indent: 2em">System.out.println(&quot;name=&quot;+s1.p.name+&quot;,&quot;+&quot;age=&quot;+s1.p.age); //学生1的教授不改变。</p> <p style="text-indent: 2em">}</p> <p style="text-indent: 2em"> </p> <p style="text-indent: 2em">4．参考资料</p> <p style="text-indent: 2em">⑴阎宏，Java与模式，电子工业出版社，2006</p> <p style="text-indent: 2em">⑵孙鑫Java讲座视频资料。(T002)</p> </td> 
   </tr> 
  </tbody> 
 </table> 
</div></div></body></html>