<html><head><title><div class="tit">
  Java基础课（续）8-1
</div></title></head><body><div id='tit'>Java基础课（续）8-1</div><div id='cate'>j&middot;入门</div><div id='date'>2008年01月07日 星期一 01:43 A.M.</div><div id='page'>181</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/1a62a1860e38523a67096eba.html'>http://hi.baidu.com/hxzon/blog/item/1a62a1860e38523a67096eba.html</a><div id='cnt'><div> 
 <p>Java基础课（续）8-1</p> 
 <p>Java课第八章 类的高级特性~2 final<br /> 关键字: final<br /> final与static一样属于修饰符,可放在变量,方法,和类的前面,与访问修饰符不同</p> 
</div> 
<div> 
</div> 
<div>
 1.想声明一个常量,不希望它的值有所改变,只可赋值一次
 <br /> 例:final i;&nbsp;&nbsp;&nbsp;&nbsp; i=30;&nbsp;&nbsp; 此时,变量i不可再被赋值,第一次赋值可在任何地方;
 <br /> 2.声明一个方法,可以不被任何其他方法所覆盖,通常用在父类方法中
 <br /> 例:final void print(){} 此时print方法被定义为最终方法,不可被其他方法覆盖
 <br /> 3.声明一个最终类,不可被任何类继承(String 类也属于final类,因此他的对象不可被改变)
 <br /> 例:final class Demo(){}
 <br /> 
 <br /> 变量-作用
 <br /> 1.一个变量可以声明为final,这样做的目的是阻止它的内容被修改.
 <br /> 2.声明final变量后,只能被初始化一次,然后就不能对其值进行修改
 <br /> 3.一个final变量实质上是一个常量.
 <br /> 
 <br /> 方法-作用
 <br /> 1.在方法声明中使用final关键字向编译器表明子类不能覆盖此方法.
 <br /> 
 <br /> 类-作用
 <br /> 1.在声明中,一个final方法只能被实现一次,声明final的类不能被继承
 <br /> 2.如果一个类为final类,那么它的所有方法都为隐式的final方法
</div> 
<div> 
</div> 
<div>
 <br /> Java课第八章 类的高级特性 
 <br /> 静态修饰符：
 <br /> static ：
 <br /> 用static 可以用来修饰变量和方法，被修饰的变量和方法可以当作全局变量，既没有创建对象，也可以直接使用该方法或变量。
 <br /> 被静态修饰符修饰的变量，可以当作是类自己的属性，是实际的，而不是抽象的，并且不属于某个具体的实例对象。它们也叫做类变量和类方法 ，顾名思义 ~！！
 <br /> 使用它的意义，例 ：
 <br /> 用Student对象保存学生信息，希望每个对象有一个单独的编号。第一个创建的对象编号为1，第二个对象编号为2，以此类推.
 <br /> class Student
 <br /> {
 <br /> static int id=0;
 <br /> String name;
 <br /> Student(String name)
 <br /> {
 <br /> &nbsp;&nbsp; this.name=name;
 <br /> &nbsp;&nbsp; id++;
 <br /> }
 <br /> 
 <br /> public static void main(String args[])
 <br /> {
 <br /> Student s1=new Student(&quot;超人&quot;);
 <br /> System.out.println(s1.id,s1.name)
 <br /> Student s2=new Student(&quot;神仙&quot;);
 <br /> System.out.println(s2.id,s2.name)
 <br /> Student s3=new Student(&quot;汽车人&quot;);
 <br /> System.out.println(s3.id,s3.name)
 <br /> Student .........
 <br /> }
 <br /> }
 <br /> 这样他们的 ID号就一按顺序这么排列下去。要注意的是，如果对象创建到 N的时候 ，静态的那个成员也自动加到n......
 <br /> 
 <br /> 静态成员可以在包中任何地方被访问，被访问的格式 
 <br /> className.staticVar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; className.staticMethod
 <br /> 
 <br /> 小结：
 <br /> 1.构造函数是不能够静态化的 
 <br /> 2.类方法只能访问本身的参数和类变量。访问非类变量的尝试会引起编译错误。
 <br /> 3.静态方法重载和覆盖的4个情况
 <br /> --可以使用非静态的方法重载静态方法 (应为静态方法被编译器最先执行，所以非静态方法可以覆盖静态方法 ，反之，静态方法不能够重载非静态方法)
 <br /> 
 <br /> --可以静态方法重载静态方法
 <br /> 
 <br /> --静态方法可以被静态方法覆盖
 <br /> 
 <br /> 成员初始化顺序:
 <br /> 1.首先按从上到下的顺序初始化父类和相关子类中的 静态属性或方法
 <br /> 2.再则是初始化父类定义初始化,然后在父类构造函数
 <br /> 3.子类定义初始化，然后子类构造函数
 <br /> 4.最后才是另外的一些成员方法 或 别的操作
</div> 
<div> 
</div> 
<div>
 Java课第七章 *面向对象*~5 (END)
 <br /> 关键字：instanceof,import,package&nbsp;&nbsp; 特殊方法:toString(),equals()
</div> 
<div> 
</div> 
<div>
 instanceof:
 <br /> 1.instanceof运算符可以用来检查对象与类之间的关系
 <br /> 2.格式：if(obj instanceof classname).....,当obj为classname类或其子类的对象时，运算符返回true.
 <br /> 例：Father为一个父类，Son为一个子类
 <br /> Son s1=new Son();
 <br /> if(s1 instanceof Father) //返回的值为true,因为子类的对象也可以属于是父类
</div> 
<div> 
</div> 
<div>
 Father s2=new Father();
 <br /> if (s2 instanceof Son)&nbsp;&nbsp; /返回的值为false,因为父类的对象不属于子类
</div> 
<div> 
</div> 
<div>
 <br /> 类型转换：
 <br /> 1.执行自动类型转换需要2个条件：
 <br /> -接受转换的类型种类是兼容的
 <br /> -目的类型数的范围比源类型大
</div> 
<div> 
</div> 
<div>
 2.强制类型转换的格式：
 <br /> (目标类型)value
</div> 
<div> 
</div> 
<div>
 Object类
 <br /> 1.所有创建的类都有一个默认的公共超级父类Object,它其中有一些已经定义好的方法
 <br /> 2.Object类包括在java.lang的包中，无论是哪个文件,系统默认调用java.lang这个包
 <br /> 3.此类定义了所有对象都具有的基本属性和方法 既默认的构造函数
 <br /> 4.可以用类型为Object的变量来引用任意类型的对象 //不解
</div> 
<div> 
</div> 
<div>
 equals()
 <br /> 格式:
 <br /> (obj_name.equals(obj_name2));
 <br /> 对象1与对象2比较,
</div> 
<div> 
</div> 
<div>
 1.equals()这个方法在Object中，在其他类中可以任意调用
 <br /> 2.用于比较两个对象在堆中指向的地点是否相同，如果相同就返回true
 <br /> 3.子类可以通过覆盖Object的equals方法来实现由意义的测试，可以实现:若同一类型的两个不同对象包含相同的信息既返回true。也可以理解为同类中两个对象的值是否相等.
 <br /> 子类覆盖equals方法:
 <br /> public boolean equals(Object Obj)
 <br /> &nbsp;&nbsp;&nbsp;&nbsp; {
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(this==Obj) return true;//比较的是两个对象的引用(references)是否相等
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(Obj==null) return false;//检查 Obj是否为空
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(getClass() != Obj.getClass()) return false;//检查是否属于同一个class
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;
 <br /> &nbsp;&nbsp;&nbsp;&nbsp; }
 <br /> 第一句：//比较的是两个对象的引用(references)是否相等
 <br /> 第二句：//检查 Obj是否为空
 <br /> 第三句：//检查是否属于同一个class
</div> 
<div> 
</div> 
<div>
 toString()
 <br /> 1.toString也是Object类中的一个方法，也可以在任何类中被调用
 <br /> 2.toString 用于返回对象的字符串表示
 <br /> 3.建议所有子类都覆盖此方法
 <br /> 4.使用&quot;+&quot;运算符将对象同一个字符串连接，java编译器会自动调用toString方法，获取对象的字符串表现形式
 <br /> (以上好像在实际中都运用了)
</div> 
<div> 
</div> 
<div>
 源文件(编译单元)
 <br /> 1.每个编译单元必须是以.java结尾的文件名称,在一个编译单元里(既一个文件内),可以有一个public的类,这个类的名字必须与保存的文件同名.在一个单元内,除了public类,其它的类如果没被声明访问权限,就默认为protected的.
</div> 
<div> 
</div> 
<div>
 2.可以,尽管很少见,一个编译单元没有一个public类,所有的类都是protected的,那么文件名可以任意起,
</div> 
<div> 
</div> 
<div>
 3.编译一个.java文件时,对应于文件中的每一个类,会得到一个.class文件,文件名与类的名字相同.一个程序是一堆.class文件.
</div> 
<div> 
</div> 
<div>
 <br /> 包:库单元 (最重要的部分之一)
 <br /> 1.用import来引入包或者包里的成员.
 <br /> 例:import java.util.*; //这里引入了java.util中的所有类
 <br /> &nbsp;&nbsp;&nbsp;&nbsp; import java.util.Vector //这里引入了java.util中的Vector类(可以具体化)
</div> 
<div> 
</div> 
<div>
 2.java中，包德主要用途
 <br /> -包允许将类组合成较小的单元.
 <br /> -包允许在在更广的范围内保护类、数据和方法.
 <br /> -在一个包中可以调用其它包中任何类,起到&quot;类&quot;_&quot;覆用&quot;的作用.
</div> 
<div> 
</div> 
<div>
 3.包可以是类、接口和子包的集合
</div> 
<div> 
</div> 
<div>
 4.两个不同包中含有同名类，如java.util包和java.sql包中都有一个Date类，下面程序会出现编译&nbsp;&nbsp;&nbsp; 出错，因为编译器不知道使用哪个Date类，这个时候要给......不知道同时调用他们的Date类
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 使用包: 
 <br /> 创建包:
 <br /> 格式: package package_name;
</div> 
<div> 
</div> 
<div>
 访问java成员包 
 <br /> 格式: package_name.class_name
</div> 
<div> 
</div> 
<div>
 导入包:
 <br /> 格式: import package_namme.*;
</div> 
<div> 
</div> 
<div>
 导入子包: 
 <br /> 格式: import package_name.package2_name.*;
</div> 
<div> 
</div> 
<div>
 注意: 
 <br /> --只能用*来引入一个包中的所有类,并不能嵌套引入下层包
 <br /> 例: package_name下层还有一个包为package_name2,这里就不能用package_name.*来调用package_name2中间的类
</div> 
<div> 
</div> 
<div>
 --若两个Date类都要使用,则只能在每个类前面加上完整的包名
 <br /> 例:根据前面的例来导入2个包中的所有类
 <br /> import package_name.*;
 <br /> import package_name.package_name2.*;
</div> 
<div> 
</div> 
<div>
 --只能引入类,不能引入对象.如: 不能用import System.out.
</div> 
<div> 
</div> 
<div>
 --Java缺省自动引入java.lang包中所有的类,相当于import java.lang.*
</div> 
<div> 
</div> 
<div>
 CLASSPATH 类的路径
 <br /> 1.CLASSPATH是一个环境变量,包含一个或多个目录
 <br /> 2.它的意思是说JVM需要找一个.class文件的时候到哪里去找
 <br /> 3.CLASSPATH,它们作为一种特殊的根使用,从这里展开对.class文件的搜索
 <br /> 4.如果在没有设置CLASSPATH的环境变量时,系统默认给了一个&quot;.&quot;(当前目录),编译器会在当前目录里去寻找.class文件
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 Java课第七章 *面向对象*~4
 <br /> 关键字:super 
 <br /> Super关键字:
 <br /> 1.super关键字用来解决如何直接访问从父类继继承过来的属性或方法
 <br /> 例：
 <br /> class Father
 <br /> {
 <br /> int value;
 <br /> String name;
 <br /> public Father(int value,String name)
 <br /> {
 <br /> &nbsp;&nbsp; this.value=value;
 <br /> &nbsp;&nbsp; this.name=name;
 <br /> }
 <br /> class Son extends Father
 <br /> {
 <br /> String character;
 <br /> String like;
 <br /> Son(int value,String name,String character,String like)
 <br /> {
 <br /> super(value,name)//这里将调用父类中的构造函数，这里的参数要与父类的构造函数配对
 <br /> this.character=character;
 <br /> this.like=like;
 <br /> }
 <br /> 
 <br /> 2.调用父类的构造函数，用来访问被子类覆盖了的父类成员
 <br /> 例
 <br /> class Weapon
 <br /> {
 <br /> int price;
 <br /> int value;
 <br /> }
 <br /> class Sword extends Weapon
 <br /> {
 <br /> int price;
 <br /> int value;
 <br /> Sword(int p,int v)
 <br /> {
 <br /> super.price=10;&nbsp;&nbsp;&nbsp; //虽然子类的成员变量与父类的相同，在这里加了super.来识别变量为父类的
 <br /> super.value=50; //如果想子类中给父类的成员变量赋值，必须在子类的构造函数中
 <br /> price=p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 <br /> value=v;
 <br /> }
 <br /> 
 <br /> void print()
 <br /> {
 <br /> System.out.println(super.price); //在这里，一样可以打印父类的，怕子类的成员变量覆盖父类的
 <br /> System.out.println(super.value);
 <br /> }
 <br /> public static void main(String args[])
 <br /> {
 <br /> Sword s1=new Sword(100,50);
 <br /> s1.print();
 <br /> }
 <br /> } 
 <br /> 
 <br /> 
 <br /> 3.它用在对象的 构造函数中，将构造细节通过继承链往上传
 <br /> 
 <br /> 4.与this一样，必须在构造函数的第一行
 <br /> 
 <br /> Super的使用格式:
 <br /> super.variable 用来访问被子类成员变量覆盖的父类的成员变量
 <br /> super.Method([paramlist]) 调用父类中被重写的方法
 <br /> super([paramlist]) 调用父类的构造函数
 <br /> 
 <br /> this 与 super:
 <br /> 1.如果子类声明了一个与父类的成员变量同名的成员变量，则称父类的该成员变量被隐藏
 <br /> 
 <br /> 2.如果子类声明了一个与父类的成员方法同名的成员方法，则称父类的该成员方法被覆盖 
 <br /> 
 <br /> 3.关键字this 和super分别用来指明子类和父类中同名的成员变量或成员方法 
 <br /> this 区分本类中相同名称的成员变量与局部变量和参数
 <br /> super 区分子类与父类之间相同名称的成员变量与方法
 <br /> 
 <br /> 4.当父类的成员变量、子类的成员变量和类中方法使用的局部变量三者同名，或其中的两者同名时，可以使用关键字this和super来指定所要使用的变量.
 <br /> 
 <br /> 5. 如果一个构造函数既没有调用super(…)也没有调用this(…)，编译器自动插入一个对父类构造函数的调用super() (不带参数)
 <br /> 
 <br /> 成员初始化顺序：
 <br /> 在java中，成员初始化(块)顺序是在构造函数之前被执行，构造函数之前我们就做了定义初始化。在一个类中，初始化顺序是由变量在类内的定义顺序决定的，即使初始化(块)大量遍布与类中最下面或中间位置，那些变量仍然会在调用任何方法之前得到初始化。
 <br /> 
 <br /> 面向对象的多态性：方法覆盖
 <br /> 1.方法覆盖是java实现多态性机制的另一种方式。第一种是方法重载
 <br /> 2. 在类层次结构中，如果子类中的一个方法与父类中的方法有相同的方法名并具有相同数量和类型的参数列表，这种情况称为方法覆盖.
 <br /> 例：父类中有 
 <br /> void print()
 <br /> {
 <br /> System.out.println(&quot;父类&quot;);
 <br /> }
 <br /> 子类中也有
 <br /> void print()
 <br /> { 
 <br /> System.out.println(&quot;子类&quot;);
 <br /> }
 <br /> 这种情况下，子类的方法将覆盖父类方法。他们拥有相同的名称以及相同数量的参数和数据类型，所以这了构成方法覆盖.
 <br /> 
 <br /> 3.当一个覆盖方法通过父类引用被调用，Java根据当前被引用对象的类型来决定执行哪个版本的方法。 
 <br /> 比如用父类来创建一个对象，但new 的是子类，java根据子类与父类中的构造函数中的参数来决定执行哪一个版本的方法.
 <br /> 例:
 <br /> class SuperClass {
 <br /> int a;
 <br /> SuperClass()
 <br /> { 
 <br /> a = 10; 
 <br /> }
 <br /> public void printA()
 <br /> {
 <br /> System.out.println(&quot;父类中a =&quot;+a);
 <br /> }
 <br /> 
 <br /> public void printB()
 <br /> {
 <br /> System.out.println(&quot;你好，儿子。我是你爸爸&quot;);
 <br /> }
 <br /> }
 <br /> class SubClass extends SuperClass {
 <br /> int a;
 <br /> SubClass(int a)
 <br /> { 
 <br /> this.a = a; 
 <br /> }
 <br /> public void printA()
 <br /> { 
 <br /> System.out.println(&quot;子类中a = &quot;+a); 
 <br /> }
 <br /> } 
 <br /> public class OverrideDemo {
 <br /> &nbsp;&nbsp; public static void main(String args[]) {
 <br /> &nbsp;&nbsp;&nbsp;&nbsp; SuperClass s1 = new SubClass(10);&nbsp;&nbsp; //关键就是这里，new 的构造函数是子类的
 <br /> &nbsp;&nbsp;&nbsp;&nbsp; s1.printA();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //后面参数10等于给子类构造函数中的a赋值,
 <br /> &nbsp;&nbsp;&nbsp;&nbsp; s1.printB();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //最后输出子类中的print这个方法覆盖的版本
 <br /> &nbsp;&nbsp; }
 <br /> }
 <br /> 
 <br /> 4.可以通过super关键字调用直属父类中被覆盖的方法版本
 <br /> 
 <br /> 覆盖的3条规则：
 <br /> 1.必须有一个与它所覆盖的方法相同的返回类型
 <br /> 2.不能比它所覆盖的方法访问性差。
 <br /> 3.不能比它所覆盖的方法抛出更多的异常
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 Java课第七章 *面向对象*~3
 <br /> 关键字:extends,this
 <br /> 第9天
 <br /> this 引用:
 <br /> 1.this 调用了那个方法的那个对象(这个还是不大明白)
 <br /> 2.在一个构造函数调用另外一个构造函数时，用this
 <br /> 例：
 <br /> class Vehicle
 <br /> {
 <br /> String brand;
 <br /> String color;
 <br /> int price;
 <br /> int number;
 <br /> Vehicle(String b,String c)
 <br /> {
 <br /> &nbsp;&nbsp; brand=b; color=c;
 <br /> }
 <br /> 
 <br /> Vehicle(String b,String c,int p,int n)
 <br /> {
 <br /> &nbsp;&nbsp; this(b,c);/*这里的(b,c)对应上面的那个构造函数，
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this将自动调用式配与参数相同的构造函数*/
 <br /> &nbsp;&nbsp; price=p;
 <br /> &nbsp;&nbsp; number=n;
 <br /> &nbsp;&nbsp; System.out.print(&quot;车牌=&quot;+brand );
 <br /> &nbsp;&nbsp; System.out.print(&quot;- 颜色=&quot;+color);
 <br /> &nbsp;&nbsp; System.out.print(&quot;- 价格=&quot;+price );
 <br /> &nbsp;&nbsp; System.out.print(&quot;- 座位数=&quot;+number);
 <br /> }
 <br /> public static void main(String args[])
 <br /> {
 <br /> &nbsp;&nbsp;&nbsp;&nbsp; Vehicle c1=new Vehicle(&quot;法拉利&quot;,&quot;红色&quot;,300,4);
 <br /> }
 <br /> }
 <br /> 
 <br /> 3.如果方法的参数与成员变量名称相同，方法的局部变量与成员变量名称相同。这里可以用this来引用类的成员变量。比如上面的例子,稍微改一下
 <br /> Vehicle(String brand,String color,int price,int number)
 <br /> {
 <br /> this.brand=brand;&nbsp;&nbsp;&nbsp;&nbsp; this.color=color;
 <br /> this.price=price;&nbsp;&nbsp;&nbsp;&nbsp; this.number=number;
 <br /> }
 <br /> //这里就用this的引用来将要被赋值的brand当作为成员变量，而不是局部变量和参数
 <br /> 
 <br /> 
 <br /> 继承:extends
 <br /> 继承允许创建“分等级层次”类。可创建一个通用类定义一系列一般特性。
 <br /> 例：
 <br /> “雇员”这个父类下面分为“工人类”和“管理员类”，在雇员类可以中可以定义他们都有的共同性质，比如，年纪，姓名，等等.....到了“工人类”中就可以定义更加具体的一些属性，比如工人的“工作内容”等等属性.......
 <br /> 
 <br /> 1.被继承的类为“父类”
 <br /> 2.继承“父类”的类“为子类”
 <br /> 3.“子类”自动继承“父类”拥有的属性，并且拥有自身的特有的属性。
 <br /> 
 <br /> 格式：
 <br /> class subclass-name extends superclass-name{//主体}
 <br /> 例：
 <br /> class Empolyee
 <br /> { 
 <br /> String name;
 <br /> int age;
 <br /> ....
 <br /> }
 <br /> class Worker extends Empolyee 
 <br /> {
 <br /> //这里将不需要再定义name和age两个属性，将自动继承“父类”中有的所有属性和行为
 <br /> 
 <br /> }
</div> 
<div> 
</div> 
<div>
 Java课第七章 *面向对象*~2
 <br /> 关键字：new
 <br /> 第8天 
 <br /> 构造函数：
 <br /> 定义规则：
 <br /> 1.构造函数与类名称相同
 <br /> 2.构造函数没有任何返回值 所以构造函数前没有任何void和所返回的类型
 <br /> 3.他的任务是在创建对象时初始化其内部状态
 <br /> 例：
 <br /> class Car
 <br /> {
 <br /> &nbsp;&nbsp; int speed;
 <br /> &nbsp;&nbsp; int weight;
 <br /> &nbsp;&nbsp;&nbsp; Car(int s,int w)
 <br /> &nbsp;&nbsp;&nbsp; {
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; speed=s;
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weight=w;
 <br /> &nbsp;&nbsp;&nbsp; }
 <br /> }
 <br /> 这样，就可以在创建Car这个对象的时候给对象赋不同的属性了.
 <br /> 
 <br /> 类的多态性：
 <br /> 1.多态性是指对类的成员函数的调用导致完全不同的行为
 <br /> 2.java中类的多态性主要表现为方法的重载(overlord),和方法的覆盖(override).
 <br /> 
 <br /> 
 <br /> 方法重载:
 <br /> 1.方法重载是java实现面向对象多态性机制的一种方式。
 <br /> 2.在一个类中多个方法名称相同，但参数列表不同(个数和类型不同),这个情况构成方法重载
 <br /> 3.返回类型不同，不足以构成方法的重载
 <br /> 4.当重载方法被调用时，编译器根据参数类型和数量来确定实际调用哪个重载方法的版本
 <br /> 5.java中不允许在一个类中声明2个识别标记相同的方法
 <br /> 例: test(int x,int y)
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test(int i,int k) 
 <br /> 这两种方法的识别标记是相同的，虽然形参的变量名不同，但还是不足以构成方法重载
 <br /> 
 <br /> 构成方法重载的例子：
 <br /> &nbsp;&nbsp;&nbsp; test (int x)
 <br /> &nbsp;&nbsp;&nbsp; test (int x,int y)
 <br /> &nbsp;&nbsp;&nbsp; test (float i)
 <br /> &nbsp;&nbsp;&nbsp; test (double i)
 <br /> &nbsp;&nbsp;&nbsp; test (float i ,double k)
 <br /> 
 <br /> 重载构造函数：
 <br /> 1.java会为每一个类自动缺省一个构造函数，缺省构造函数将成员变量的值初始化为缺省值。
 <br /> 如，boolean x; x的缺省值为false.&nbsp;&nbsp; int x;&nbsp;&nbsp; x的缺省值为0
 <br /> 2.一旦创建了自己的构造函数，缺省的构造函数将失效
 <br /> 3.重载构造函数提供了一组创建对象的方式，根据需要，是否带初始参数。
 <br /> 例：
 <br /> class Bread
 <br /> { 
 <br /> int water,flour,sugar; 
 <br /> Bread(int w,int f,int s)
 <br /> {
 <br /> water=w;
 <br /> flour=f;
 <br /> sugar=s;
 <br /> System.out.println(&quot;带3个参数的构造函数&quot;);
 <br /> }
 <br /> Bread(int w,int f)
 <br /> {
 <br /> water=w;
 <br /> flour=f;
 <br /> System.out.println(&quot;带2个参数的构造函数&quot;);
 <br /> }
 <br /> 
 <br /> 如果在这了在创建对象的时候，给的参数不一样，就构成了构造函数的重载
 <br /> Bread b1=new Bread(10,5,10);
 <br /> Bread b2=new Bread(10,50);
 <br /> b1调用了第一个构造函数，因为他对应第一个构造函数的参数
 <br /> b2就对应第2个，相同的对应了第2个构造函数的参数
 <br /> 
 <br /> 
 <br /> Java中内存分配的方法：
 <br /> 栈区(stack):这里一般储存&quot;引用变量&quot;，函数的参数值，和局部变量的值等...
 <br /> 堆区(heap):所有new出来的对象都是在堆中分配的，内存不够时使用垃圾回收机制处理。
 <br /> 
 <br /> 创建对象：
 <br /> 格式：
 <br /> class name=new 构造函数(); //类名_对象名=new 构造函数();
 <br /> 必须使用new来创建对象,关键字new通常称为创建运算符，用于分配对象内存，并且该内存初始化为缺省值。
 <br /> 一旦new完成分配和初始化内存，它就将调用构造函数来执行对象初始化。
 <br /> 
 <br /> 缺省初始值：
 <br /> 变量在被初始化之前是不能使用的，在一个方法的局部变量必须先初始化才能使用
 <br /> 比如 void Demo
 <br /> {
 <br /> int x;
 <br /> }
 <br /> 这里面的x是不能使用的，因为没有被初始化!
 <br /> 
 <br /> 关键字 public,protected,private
 <br /> 第七天 初步了解了“类”与“对象”这两个概念。
 <br /> 对象：一个对象首先应该有一个名字，并且有自身的状态（属性-&gt;变量），还有自身的功能，即行为（方法-&gt;函数),例：
 <br /> person(一个人) 
 <br /> 属性 ：人名：jack&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 公开(public)
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 体重：100kg&nbsp;&nbsp;&nbsp;&nbsp; 受保护(protected)
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 身高:180cm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 受保护(protected)
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 银行密码:***** 私有的(private)
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 等等.......&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可以给属性4种封装，public protected,private,....
 <br /> 
 <br /> 行为：行走 {用方法（函数） 来实现}
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 思考 
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 搏斗
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 等等..........
 <br /> 
 <br /> 对象是某类事物的一个个体，也称为实例，具有自身的结构，即属性与行为。行为在程序中可以当作是具体的某种操作。比如说移动。。。
 <br /> 
 <br /> 类：物以“类”聚，人以群分，类是对某一类事物的抽象，概念上的定义。我们可以基于类来创建对象。例：生物这个类是对动物+植物的抽象，动物又分为许多类……等等....
 <br /> 
 <br /> 抽象的理解：抽象是从特定的实例中抽取共同的性质而形成概念上的过程，比如男人和女人被“人类”抽象，将男人与女人共有的性质抽象而形成“人类”。类也称为模板，因为它们提供了对象的基本框架
 <br /> 
 <br /> 面向对象3大优点：1.按照人类的超自然思维的方式，面对客观世界建立软件模型
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.所构造的类可以重复使用
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.易扩展性与易修改性
 <br /> 
 <br /> *面向对象3大特性*：
 <br /> 1.封装：将类与对象中的变量与方法可以封装起来，可以阻止外部定义的代码随意访问内部代码和数据。封装把对象的所有组成部份结合在一起，封装定义程序如何引用对象的数据。
 <br /> 封装允许有选择性的隐藏类与对象中的属性和方法。控制使用者对类的修改和访问数据的程度。
 <br /> 
 <br /> 2.继承性：继承在中文意思中有“接过来”和“照搬使用”的意思，继承性就是自动地共享父类中的方法和数据的机制。例：比如前面说了，“人类”算父类，“男人”算子类，男人直接继承父类中的“行走”这个行为。例：
 <br /> 人类--&gt;男人--&gt;中年男人
 <br /> 从共性--&gt;个性
 <br /> 从大--&gt;小
 <br /> 从抽象--&gt;具体
 <br /> 
 <br /> 3.多态性：程序中，参数不一样的相同的方法调用时，可导致不同的行为。在子类中重新定义父类中已有的方法，隐藏了父类的方法，使子类拥有自己具体的实现，更进一步表明了与父类相比，子类所具有的特殊。例如，在“动物”这个类中，“鸟”继承了动物“行走”这个行为，但是在“鸟”这个类中的时候，行走时用的可能是翅膀了，与“父类”中“移动”这个行为不同。（这个还得具体到程序中去做菜能明白）
 <br /> 
 <br /> 创建类：
 <br /> class name 
 <br /> {
 <br /> type variable1;//成员变量，对象的属性或状态
 <br /> type variableN;
 <br /> ....
 <br /> type methodName1(parameter-list)//成员方法，既对象的行为或操作
 <br /> {
 <br /> //方法体
 <br /> } 
 <br /> type methodNameN(parameter-list)
 <br /> {
 <br /> //方法体
 <br /> }
 <br /> }
 <br /> 
 <br /> 定义方法（函数):
 <br /> [access]type methodName1([parameter-list])
 <br /> {
 <br /> //方法体
 <br /> } 
 <br /> 
 <br /> 例：
 <br /> public int setdate(int day,int month,int year)
 <br /> {
 <br /> day=7; month=5; year=2005;
 <br /> }
 <br /> 
 <br /> 
 <br /> 简单访问控制：
 <br /> public 声明的数据成员和函数成员可以从类外部的任何地方访问
 <br /> private 声明的将被隐藏，这就是实现数据封装的概念
 <br /> 要从外部操作private成员，只能通过类内部的public 或者protected成员来实现
 <br /> 
 <br /> 
 <br /> JAVA课第6章 函数
 <br /> 关键字 无；
 <br /> 第6天 函数还是比较好理解，就是用另外一个方法来处理一件事情，最后的结果再再返回给调用它的人
 <br /> 
 <br /> 定义函数，例：
 <br /> static int circle(int x) // static 不用管-_-,int 定义这个函数返回的值为int型，括号内的(int x)为形式参数，可以在主函数中使用，成为实际参数。
 <br /> 
 <br /> 使用函数的例子，这里用函数来算出圆的周长与面积；已知周长公式是2*PI*R,面积是2*R*R
 <br /> public class Circle
 <br /> {
 <br /> &nbsp;&nbsp;&nbsp;&nbsp; public static void main(String args[])
 <br /> &nbsp;&nbsp;&nbsp; {
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radius=Integer.parseInt(args[0]);//下面两句中的(radius)是实际参数，对应函数中的形参
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;length=&quot;+length(radius); //这里将调用length函数来计算圆的长度
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;length=&quot;+area(radius);//这里调用area的函数来计算面积
 <br /> &nbsp;&nbsp;&nbsp; }
 <br /> static double length(int x) 
 <br /> {
 <br /> &nbsp;&nbsp;&nbsp; return 2*3.14*x;
 <br /> }
 <br /> 
 <br /> static double area(int y)
 <br /> {
 <br /> return 2*y*y;
 <br /> }
 <br /> 
 <br /> }
 <br /> 
 <br /> 基本上是这样了，还讲了些JAVA在内存中存放的概念，即“堆”和“栈”这2个概念，其中堆存放变量的值，等等数据比较大的东西，它的弹性很大，可以无限扩大，但他运行速度低。“栈“的概念是将一些在程序中数据较少的东西，并且弹性低，不过运行效率很高。
 <br /> 
 <br /> 局部变量：
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 局部变量值的是在{}内声明的变量值能在{}这个作用域内使用,例：
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static void main(String args[])
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i=1;
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(i==1)
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c=2;
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i=i+c;
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(i);
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在if {}内定义的c的作用域只在if{}内，在main{}内就不能使用这个变量；
</div> 
<div> 
</div> 
<div>
 JAVA第5章 数组(极重要)
 <br /> 关键字,new
 <br /> 
 <br /> 第5天 数组，今天的课终于理解了，可以理解成如果定义一个数组中有10个元素，10个元素分别又代表10个变量，10个变量可以赋值后就可以拿来当普通变量用，可以通过“下标“来使用它。“下标“ 就是 &quot;[]&quot; 中数字。数组中各个元素的数据类型一定得是同样的。
 <br /> 
 <br /> 首先看看定义数组的格式把，
 <br /> 
 <br /> int GroupNumber[]; //格式
 <br /> GroupNumber[]=new int [10];//给数组分配10个元素，元素是从0开始，所以这里元素是0~9，10个
 <br /> 上面2项也可以写成（更加简化）&nbsp;&nbsp; int GroupNumber[]=new int [10] //
 <br /> 
 <br /> 还有就是直接给数组中的元素附值
 <br /> int GroupNumber[];{1,2,3,4,5}. //给GroupNumber定义了5个元素，其中每个元素中的值分别是1,2,3,4,5,。这里又可以换种方式写，即
 <br /> int GroupNumber[]=new int [5];
 <br /> GroupNumber[0]=1;
 <br /> GroupNumber[1]=2;
 <br /> GroupNumber[2]=3;
 <br /> GroupNumber[3]=4;
 <br /> GroupNumber[4]=5;
 <br /> //这样写看起来很繁琐阿，不过更加容易理解数组元素是从0开始的，所以这里数组中的元素就是[0],[1],[2],[3],[4]就到了。。呵呵呵呵~~~
 <br /> 
 <br /> 2维数组，可以理解为表格的概念，就是行和列的概念
 <br /> 定义：int GroupNumber[][];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 定义数组元素GroupNumber[][]=new int[10][5];
 <br /> 上面的定义意思是说GroupNumber等于有10行，5列，再细化一点
 <br /> GroupNumber[0]这个数组元素中再另外有5个数组，
 <br /> GroupNumber[0][0]=10; //GroupNumber数组元素0中包含的数组0赋值为10；
 <br /> 就这样，以此推类，就可以完全2维数组的概念了，不过还是很抽象，具体等以后要实际用上多维数组的时候了~~~
 <br /> 另外，直接给2维数组赋值的格式
 <br /> int GroupNumber[][]={{1,3,5},{5,3,8},{11,-15,8}};
 <br /> 
 <br /> 命令行参数: (Done)
 <br /> @Java 应用程序可以从命令行中接收任意数量的参数
 <br /> @每个参数被视为字符串分别存储在main函数的参数数组中
 <br /> @可以使用双引号将多个字符串作为一个整体显示
 <br /> 例：public class Demo
 <br /> { 
 <br /> public static void main(String args[]) 
 <br /> {
 <br /> &nbsp;&nbsp;&nbsp; for(int k=0;k&lt;args.length;k++);
 <br /> &nbsp;&nbsp;&nbsp; System.out.println(args[k]);
 <br /> }
 <br /> }
 <br /> 
 <br /> 下面可以在命令行中输入：
 <br /> java Demo &quot;Welcome to hell wa hahaha&quot; bull shit
 <br /> 输出的结果为:
 <br /> Welcome to hell
 <br /> bull
 <br /> shit
 <br /> 
 <br /> DONE...................
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 Jva课3-4章 结构控制
 <br /> 关键字：if-else,swith-case-default,while,do while,for,continue,break!
 <br /> 第3天和第4天 学的控制结构，选择语句:if-else,swtich-。循环语句:while,do-while,for,其中功能最强的的就是for了，不过有时也用用while,比如下面这个例子
 <br /> 题目：找出第一个2，3，5的倍数，找到后输出并退出
 <br /> 逻辑:while(!((number%2==0)&amp;&amp;(number%3==0)&amp;&amp;(number%5==0))) 使用while就可与不需要控制范围....
 <br /> 还有跳转语句：break和continue。 break跳出整个循环体。符合continue时就结束此循环继续执行下一次循环。
 <br /> switch 的格式
 <br /> switch (表达式)
 <br /> case '常量或者字符': 语句1
 <br /> case '常量或者字符': 语句2
 <br /> case ..........
 <br /> default:语句n......
 <br /> 
 <br /> //for 和 continue的运用
 <br /> for(num = 1; num &lt;=100; num++) 
 <br /> { 
 <br /> if(num % 9 == 0) 
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue; 
 <br /> System.out.println(&quot;不能被9整除的数有：&quot;+num); 
 <br /> 
 <br /> 结构控制的语法和格式没问题，还得多练习这些!!
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 Java课1-2章 Java简史
 <br /> 第1天 Java 的一些发展史与HelloWorld这个程序~ 第1天
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1990 sun公司以James Gosling 为主的一批人开发了oak语言, 1995年Sun 公司的 HotJava 浏览器问世, 将Oak语言更名为Java.
 <br /> 
 <br /> 第2天:java中的标识符,关键字，运算符，变量，基本数据类型.
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 比较麻烦的就是各种运算符了，其中包括了，算数运算符(没问题)
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 关系运算符：==，！=，&gt;，&lt;，等.......返回的值为一个boolean值（目前感觉一般用于for和while的表达式里）
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 逻辑运算符：&amp;,&amp;&amp;,|,||,^,!.....这里要注意的就是!这个“反“和^“异或“
 <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 位运算符：~(非),&amp;(与),|(或),^(异或),..这些之运用在int,char,byte,long,short数据类型上,数据为1时就为真(true)，数据为0时就为假(false).
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
 Trackback: 
 <a href="http://tb.blog.csdn.net/TrackBack.aspx?PostId=1289783">http://tb.blog.csdn.net/TrackBack.aspx?PostId=1289783</a>
</div> 
<div> 
</div> 
<div>
 <a href="http://blog.csdn.net/aflylove/archive/2006/09/26/1289783.aspx">http://blog.csdn.net/aflylove/archive/2006/09/26/1289783.aspx</a>
</div></div></body></html>