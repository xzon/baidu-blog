<html><head><title><div class="tit">
  Servlet 2.5的新特征
</div></title></head><body><div id='tit'>Servlet 2.5的新特征</div><div id='cate'>j&middot;入门</div><div id='date'>2009年05月12日 星期二 03:41 P.M.</div><div id='page'>51</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/6fa54dfb86a6046c034f569a.html'>http://hi.baidu.com/hxzon/blog/item/6fa54dfb86a6046c034f569a.html</a><div id='cnt'><p class="MsoNormal"><strong><span style="color: black; font-size: 9pt">Servlet 2.5</span></strong><strong><span style="color: black; font-size: 9pt">的新特征</span></strong></p> 
<p class="MsoNormal">
 <st1:chsdate isrocdate="False" islunardate="False" day="26" month="9" year="2005">
  <span style="color: black; font-size: 9pt">2005</span>
  <span style="color: black; font-size: 9pt">年</span>
  <span style="color: black; font-size: 9pt">9</span>
  <span style="color: black; font-size: 9pt">月</span>
  <span style="color: black; font-size: 9pt">26</span>
  <span style="color: black; font-size: 9pt">日</span>
 </st1:chsdate><span style="color: black; font-size: 9pt">，</span><span style="color: black; font-size: 9pt">Sun</span><span style="color: black; font-size: 9pt">公司和</span><span style="color: black; font-size: 9pt">JSR154</span><span style="color: black; font-size: 9pt">的专家组发布</span><span style="color: black; font-size: 9pt">Servlet API</span><span style="color: black; font-size: 9pt">的一个新的版本。在一般情况下，一个</span><span style="color: black; font-size: 9pt">JSR</span><span style="color: black; font-size: 9pt">的新版本仅仅包括对以前少数有名无实的规范进行去除更新。但这次，新版本中增加新的特征和变化，他们对</span><span style="color: black; font-size: 9pt">Servlets</span><span style="color: black; font-size: 9pt">的产生重要影响，使得</span><span style="color: black; font-size: 9pt">Servlet</span><span style="color: black; font-size: 9pt">的版本升到了</span><span style="color: black; font-size: 9pt">2.5</span><span style="color: black; font-size: 9pt">。</span><span style="color: black; font-size: 9pt"><br /> <br /> </span><span style="color: black; font-size: 9pt">在这篇文章里，我主要谈谈</span><span style="color: black; font-size: 9pt">Servlet2.5</span><span style="color: black; font-size: 9pt">版本中的新特征。描述每一个变化，阐述那些必要变化产生的背景，并展示如何在基于</span><span style="color: black; font-size: 9pt">Servlet</span><span style="color: black; font-size: 9pt">的项目中利用这些变化。</span><span style="color: black; font-size: 9pt"><br /> <br /> </span><span style="color: black; font-size: 9pt">事实上，这是我为</span><span style="color: black; font-size: 9pt">JavaWorld</span><span style="color: black; font-size: 9pt">提供的第六篇关于</span><span style="color: black; font-size: 9pt">Servlet API</span><span style="color: black; font-size: 9pt">更新资料的文章。这篇文章意在两个目的：从眼前来看，向你介绍</span><span style="color: black; font-size: 9pt">Servlet</span><span style="color: black; font-size: 9pt">的新特征。从长远来看，是展现</span><span style="color: black; font-size: 9pt">Servlet</span><span style="color: black; font-size: 9pt">变化的历史概要，这样当你基于老的</span><span style="color: black; font-size: 9pt">Servlet API</span><span style="color: black; font-size: 9pt">版本进行编码的时候，你可以正确地决定哪些特征和功能你可以使用，而哪些特征和功能你不应该使用。你可以参考我先前写的关于</span><span style="color: black; font-size: 9pt">Servlet</span><span style="color: black; font-size: 9pt">的文章。</span><span style="color: black; font-size: 9pt"><br /> <br /> </span><span style="color: black; font-size: 9pt">注意：当你想实践这些</span><span style="color: black; font-size: 9pt">Servlet</span><span style="color: black; font-size: 9pt">的新特征和功能时，你要知道的是：并不是所有的</span><span style="color: black; font-size: 9pt">Servlet</span><span style="color: black; font-size: 9pt">容器和</span><span style="color: black; font-size: 9pt">Java</span><span style="color: black; font-size: 9pt">企业级应用服务器都能立即适用于最新版的</span><span style="color: black; font-size: 9pt">Servlet API</span><span style="color: black; font-size: 9pt">，写这篇文章时（</span>
 <st1:chsdate isrocdate="False" islunardate="False" day="2" month="1" year="2006">
  <span style="color: black; font-size: 9pt">2006</span>
  <span style="color: black; font-size: 9pt">年</span>
  <span style="color: black; font-size: 9pt">1</span>
  <span style="color: black; font-size: 9pt">月</span>
  <span style="color: black; font-size: 9pt">2</span>
  <span style="color: black; font-size: 9pt">日</span>
 </st1:chsdate><span style="color: black; font-size: 9pt">），</span><span style="color: black; font-size: 9pt">Jetty 6 server</span><span style="color: black; font-size: 9pt">和</span><span style="color: black; font-size: 9pt">Sun</span><span style="color: black; font-size: 9pt">公司的</span><span style="color: black; font-size: 9pt">GlassFish server</span><span style="color: black; font-size: 9pt">是公认最好的支持</span><span style="color: black; font-size: 9pt">Servlet2.5</span><span style="color: black; font-size: 9pt">的容器，而</span><span style="color: black; font-size: 9pt">Apache Tomcat5.5</span><span style="color: black; font-size: 9pt">和</span><span style="color: black; font-size: 9pt">Jboss 4.0</span><span style="color: black; font-size: 9pt">目前只支持</span><span style="color: black; font-size: 9pt">Servlet2.4</span><span style="color: black; font-size: 9pt">。</span></p> 
<p style="text-align: left; margin-bottom: 12pt" class="MsoNormal" align="left"><strong><span style="color: black; font-size: 9pt">Servlet2.5</span></strong><strong><span style="color: black; font-size: 9pt">一些变化的介绍：</span></strong><span style="color: black; font-size: 9pt"><br /> 1</span><span style="color: black; font-size: 9pt">）<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>基于最新的<span>J2SE 5.0</span>开发的。<span><br /> 2</span>）<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>支持<span>annotations </span>。<span><br /> 3</span>）<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; web.xml</span>中的几处配置更加方便。<span><br /> 4</span>）<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>去除了少数的限制。<span><br /> 5</span>）<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>优化了一些实例<span><br /> <br /> </span></span><strong><span style="color: black; font-size: 12pt">J2SE 5.0</span></strong><strong><span style="color: black; font-size: 12pt">的产物</span></strong><span style="color: black; font-size: 9pt"><br /> <br /> </span><span style="color: black; font-size: 9pt">从一开始，<span>Servlet 2.5 </span>规范就列出<span>J2SE 5.0 (JDK 1.5) </span>作为它最小的平台要求。它使得<span>Servlet2.5</span>只能适用基于<span>J2SE 5.0</span>开发的平台，这个变动意味着所有<span>J2SE5.0</span>的新特性可以保证对<span>Servlet2.5</span>程序员有用。<span><br /> </span>传统意义上，<span>Servlet</span>和<span>JEE</span>版本一直与<span>JDK</span>的版本保持同步发展，但是这次，<span>Servlet</span>的版本跳过<span>1.4</span>版本。专家组认为版本的加速增长是正当的，因为<span>J2SE5.0</span>提出一个引人注目的，<span>Servlet</span>和<span>JEE</span>规范都要利用的特征<span>—Annotations</span>。<span><br /> <br /> </span></span><strong><span style="color: black; font-size: 12pt">Annotations</span></strong><span style="color: black; font-size: 9pt"><br /> Annotations</span><span style="color: black; font-size: 9pt">是作为<span>JSR175</span>的一部分提出的（一种为<span>Java</span>语言设计提供便利的<span>Metadata</span>）一种新的语言特色。它是利用<span>Metadata</span>为<span>Java</span>编码结构（类，方法，域等等）装饰的一种机制。它不能像代码那样执行，但是可以用于标记代码，这个过程是基于<span>Metadata</span>信息的代码处理机，通过更新他们的事件行为来实现的。<span><br /> <br /> </span>我们可以凭借不同的技巧来注释类和方法，例如连续地标记接口或者是<span>@deprecated Javadoc</span>评论。这种新式的<span>Metadata</span>可以便利地提供了一种标准的机制来实现注释功能，以及通过库来创建用户自己的注释类型的变量。<span><br /> <br /> </span>下面是一个简单的<span>Web service </span>注释例子：</span></p> 
<p style="text-align: left" class="MsoNormal" align="left"><span style="color: black; font-size: 12pt">import javax.jws.WebService;<br /> import javax.jws.WebMethod;<br /> @WebService<br /> public class HelloWorldService {<br /> &nbsp;&nbsp; @WebMethod<br /> &nbsp;&nbsp; public String helloWorld() {<br /> &nbsp;&nbsp;&nbsp;&nbsp; return &quot;Hello World!&quot;;<br /> &nbsp;&nbsp; }<br /> }</span></p> 
<p style="text-align: left; margin-bottom: 12pt" class="MsoNormal" align="left"><span style="color: black; font-size: 9pt"><br /> <br /> @WebService</span><span style="color: black; font-size: 9pt">和<span>@WebMethod</span>这两个注释类型，在<span>JSR181</span>（为<span>Java</span>平台提供的<span>Web ServicesMetadata</span>）有详细说明，可以像类一样的引用，标记这个类作为一个<span>Web service</span>并且标记它的<span>helloWorld</span>（）方法做为一个<span>Web service</span>方法。对于他们本身来说，注释只是写在那里并没有什么作用，好像在岗位上做记录一样，但是，一个容器一旦加载这个类并对那些注释进行二进制编码，就可以把这个类连到<span>Web service</span>上。<span><br /> </span>注释可以接受属性<span>/</span>值这些参数。它保存着参数的信息并且可以利用这些参数来更改被请求的事件行为。例如下面更高级的注释例子：</span></p> 
<p style="text-align: left" class="MsoNormal" align="left"><span style="color: black; font-size: 12pt">@WebService(<br /> name = &quot;PingService&quot;,<br /> &nbsp;&nbsp; targetNamespace=http://acme.com/ping<br /> )<br /> @SOAPBinding(<br /> &nbsp;&nbsp; style=SOAPBinding.Style.RPC,<br /> &nbsp;&nbsp; use=SOAPBinding.Use.LITERAL<br /> )<br /> public class Ping {<br /> &nbsp;&nbsp; @WebMethod(operationName = &quot;Foo&quot;)<br /> &nbsp;&nbsp; public void foo() { }<br /> }</span></p> 
<p style="text-align: left" class="MsoNormal" align="left"><span style="color: black; font-size: 9pt"><br /> <br /> <br /> </span><span style="color: black; font-size: 9pt">一旦加载了这个类，一个正确配置的容器就会识别出注释及其参数，并将这个做为一个<span>PingService</span>通过利用<span>remote-procedure-call/literal</span>的编码方式与一个<span>Foo operation</span>相连。实际上，注释便指明了类和类的容器之间的联系。<span><br /> <br /> Java</span>本身的规范（<span>JSR175</span>）仅仅有少量的注释类型变量。而这些有趣的注释类型变量主要来自于其他的<span>JSRs</span>：<span><br /> &middot;JSR 250: Java</span>平台的公共注释<span><br /> &middot;JSR 220: </span>企业级<span>JavaBeans 3.0 <br /> &middot;JSR 224: </span>基于<span>XML</span>的<span>Java API Web Services (JAX-WS) 2.0 <br /> &middot;JSR 181: Java</span>平台的<span>Web Services Metadata <br /> <br /> <strong>Servlet2.5</strong></span><strong>中的注释：</strong><span><br /> </span>回到<span>Servlet2.5</span>上来，一种新的规范描述了几种注释在<span>Servlet</span>环境中是如何工作的。功能弱的<span>Servlet</span>容器忽略了这些规范，然而<span>JEE</span>容器中的<span>Servlet</span>却严格遵守这些规范。<span><br /> </span>有的注释提供了在<span>XML</span>注册的可选择性，否则就要注册在配置文件<span>web.xml</span>中。有的作为容器的请求来执行其任务，否则就由<span>Servlet</span>亲自来执行。还有的注释两者都具备。<span><br /> <br /> <br /> </span>注释准确的定义不是完全固定的，因为<span>Servlet</span>本身并没有定义注释。它仅仅解释了它们如何影响<span>Servlet</span>环境，下面是注释的一个简要的概述，你可以看到在<span>JEE5</span>中它们的用途：<span><br /> <br /> &middot;@Resource and @Resources</span>：<span>@Resource</span>位于类或变量中以对<span>Servlet</span>容器进行<span>“</span>资源注入<span>”</span>。当容器识别出这个注释时，它会在获得服务地位之前，用适当的值实现带注释的变量的重新注入。通过使用这种注释，你不必利用<span>JNDI</span>来查找命令和在配置文件<span>web.xml</span>中手动声明资源。服务器通过<span>Servlet</span>的自我调整来执行它的任务。变量的名称和类型由映像机制自动确定，尽管你可以利用注释的参数来超越这一限制。一个注入的资源可以是数据源，<span>Java</span>信息服务目的文件或者是环境设置的标量。下面是一个例子：</span></p> 
<p style="text-align: left" class="MsoNormal" align="left"><span style="color: black; font-size: 12pt">@Resource javax.sql.DataSource catalog;<br /> public getData() {<br /> &nbsp;&nbsp; Connection con = catalog.getConnection();<br /> }</span></p> 
<p style="text-align: left" class="MsoNormal" align="left"><span style="color: black; font-size: 9pt"><br /> </span><span style="color: black; font-size: 9pt">现在，在这段<span>Servlet</span>代码变成服务之前，容器会定位<span>JNDI</span>变量，并对于目录变量进行手动分配。<span><br /> </span>为了效率，仅仅某些类支持资源注入，这些类有：<span>Servlets</span>，<span>Servlet</span>过滤器，<span>Servlet</span>事件监听器，<span>JSP</span>标签操作器，<span>JSP</span>库事件监听器，用于处理<span>beans</span>的<span>JSF</span>，以及一些与<span>Serlvets</span>无关的类。<span><br /> <br /> &middot;@Resources</span>注释与<span>@Resource</span>相似，但是它用于一组<span>@Resource</span>注释。它们都来自<span>JSR250</span>，是<span>Java</span>平台的公共注释。<span><br /> <br /> &middot;@PostConstruct and @PreDestroy</span>：可以使方法成为带有生命周期的方法。<span>@PostConstruct</span>方法用于资源注入初始化之后。<span>@PreDestroy</span>方法用于<span>Servlet</span>脱离服务并释放注入的资源的时候。回收的方法必须是事实的方法，返回<span>void</span>并且不可以抛出任何异常。这些注释本质上使得任何方法都成为<span>init()</span>和<span>destroy()</span>的子方法，这些特征也来自与<span>JSR250</span>。<span><br /> <br /> &middot;@EJB</span>：类似于<span>@Resource</span>，设计用于注入企业级的<span>JavaBeans</span>。比起<span>@Resource</span>，它略有不同，在于<span>@EJB</span>的参数特定设计用来定位<span>EJB</span>的参数。这个注释来自<span>EJB3.0</span>的规范。<span><br /> <br /> &middot;@WebServiceRef</span>：与<span>@Resource </span>和<span> @EJB</span>相似，设计用于注入<span>Web service</span>参数。来自于<span>JAX-WS2.0</span>规范。<span><br /> <br /> &middot;@PersistenceContext, @PersistenceContexts, @PersistenceUnit, and @PersistenceUnits</span>：这些注释来自<span>EJB3.0</span>规范来支持<span>Java</span>对象的持久化。<span><br /> <br /> &middot;@DeclareRoles: </span>定义应用程序中安全角色的使用。当定义一个<span>Servlet</span>类时，在配置文件<span>web.xml</span>中<span>&lt;security-role&gt;</span>标签中对它进行设置，来自<span>JSR250</span>。<span><br /> <br /> &middot; @RunAs</span>：用于声明哪个类应该执行。当定义一个<span>Servlet</span>类时，在配置文件<span>web.xml</span>中<span>&lt;run-as&gt;</span>标签中对它进行设置。来自于<span>JSR250</span>。<span><br /> <br /> <strong>Annotation</strong></span><strong>的效率</strong><span><br /> </span>不论你使用注释与否<span>——</span>尤其在你不使用时<span>——</span>它对于理解服务器上程序的执行有着重要意义。为了让服务器识别类中的注释，它必须加载这些类，这就意味着服务器必须是启动着的，服务器通过<span>WEB-INF/classes</span>目录下和<span>WEB</span>－<span>INF/lib</span>目录下的所有类文件来查找注释。（每个规范下，服务器不必查找这两个目录以外的目录。）你可以通过下面的方法指明<span>&lt;web-app&gt;</span>根的属性而不必使用如何进行注释：</span></p> 
<p style="text-align: left" class="MsoNormal" align="left"><span style="color: black; font-size: 12pt">&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; version=&quot;2.5&quot; full=&quot;true&quot;&gt;<br /> &lt;/web-app&gt;</span></p> 
<p style="text-align: left; margin-bottom: 12pt" class="MsoNormal" align="left"><span style="color: black; font-size: 9pt"><br /> <br /> </span><strong><span style="color: black; font-size: 12pt">web.xml</span></strong><strong><span style="color: black; font-size: 12pt">的便利</span></strong><span style="color: black; font-size: 9pt"><br /> <br /> Servlet2.5</span><span style="color: black; font-size: 9pt">对于<span>web.xml</span>引入几个小的变动，使得它更加方便。<span><br /> <br /> <strong>Servlet</strong></span><strong>名称的通配符化</strong><span><br /> </span>首先，当你写<span>&lt;filter-mapping&gt;,</span>你现在可以在<span>&lt;Servlet-name&gt;</span>标签中使用<span>*</span>号来代表所有的<span>Servlets</span>。而以前，你必须一次把一个<span>Servlet</span>绑定到过滤器上，像这样：</span></p> 
<p style="text-align: left" class="MsoNormal" align="left"><span style="color: black; font-size: 12pt">&lt;filter-mapping&gt;<br /> &nbsp;&nbsp; &lt;filter-name&gt;Image Filter&lt;/filter-name&gt;<br /> &nbsp;&nbsp; &lt;Servlet-name&gt;ImageServlet&lt;/Servlet-name&gt;<br /> &lt;/filter-mapping&gt; </span></p> 
<p style="text-align: left; margin-bottom: 12pt" class="MsoNormal" align="left"><span style="color: black; font-size: 9pt"><br /> <br /> </span><span style="color: black; font-size: 9pt">现在，你可以一次绑定所有的<span>Servlets</span>：</span></p> 
<p style="text-align: left" class="MsoNormal" align="left"><span style="color: black; font-size: 12pt">&lt;filter-mapping&gt;<br /> &nbsp;&nbsp; &lt;filter-name&gt;Image Filter&lt;/filter-name&gt;<br /> &nbsp;&nbsp; &lt;Servlet-name&gt;*&lt;/Servlet-name&gt;&nbsp;&nbsp; &lt;!—</span><span style="color: black; font-size: 12pt">新特征<span> --&gt;<br /> &lt;/filter-mapping&gt;</span></span></p> 
<p style="text-align: left; margin-bottom: 12pt" class="MsoNormal" align="left"><span style="color: black; font-size: 9pt"><br /> <br /> </span><span style="color: black; font-size: 9pt">这有着很大用途，例如：</span></p> 
<p style="text-align: left" class="MsoNormal" align="left"><span style="color: black; font-size: 12pt">&lt;filter-mapping&gt;<br /> &nbsp;&nbsp; &lt;filter-name&gt;Dispatch Filter&lt;/filter-name&gt;<br /> &nbsp;&nbsp; &lt;Servlet-name&gt;*&lt;/Servlet-name&gt;<br /> &nbsp;&nbsp; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;<br /> &lt;/filter-mapping&gt;</span></p> 
<p style="text-align: left; margin-bottom: 12pt" class="MsoNormal" align="left"><span style="color: black; font-size: 9pt"><br /> <br /> </span><strong><span style="color: black; font-size: 9pt">映射的复合模式</span></strong><span style="color: black; font-size: 9pt"><br /> </span><span style="color: black; font-size: 9pt">其次，当我们写<span>&lt;Servlet-mapping&gt; </span>或者<span> &lt;filter-mapping&gt;</span>时，你现在可以在同一的标签中采用复合匹配的标准。以前一个<span>&lt;Servlet-mapping&gt;</span>只支持一个<span>&lt;url-pattern&gt;</span>元素，现在它不只支持一个，例如：</span></p> 
<p style="text-align: left" class="MsoNormal" align="left"><span style="color: black; font-size: 12pt">&lt;Servlet-mapping&gt;<br /> &nbsp;&nbsp; &lt;Servlet-name&gt;color&lt;/Servlet-name&gt;<br /> &nbsp;&nbsp; &lt;url-pattern&gt;/color/*&lt;/url-pattern&gt;<br /> &nbsp;&nbsp; &lt;url-pattern&gt;/colour/*&lt;/url-pattern&gt;<br /> &lt;/Servlet-mapping&gt;</span></p> 
<p style="text-align: left; margin-bottom: 12pt" class="MsoNormal" align="left"><span style="color: black; font-size: 9pt"><br /> <br /> </span><span style="color: black; font-size: 9pt">同样地，以前<span>&lt;filter-mapping&gt;</span>也是只支持一个<span>&lt;url-pattern&gt; </span>或者一个<span> &lt;Servlet-name&gt;</span>。现在它对于每个元素都可以支持任意多个：</span></p> 
<p style="text-align: left" class="MsoNormal" align="left"><span style="color: black; font-size: 12pt">&lt;filter-mapping&gt;<br /> &nbsp;&nbsp; &lt;filter-name&gt;Multipe Mappings Filter&lt;/filter-name&gt;<br /> &nbsp;&nbsp; &lt;url-pattern&gt;/foo/*&lt;/url-pattern&gt;<br /> &nbsp;&nbsp; &lt;Servlet-name&gt;Servlet1&lt;/Servlet-name&gt;<br /> &nbsp;&nbsp; &lt;Servlet-name&gt;Servlet2&lt;/Servlet-name&gt;<br /> &nbsp;&nbsp; &lt;url-pattern&gt;/bar/*&lt;/url-pattern&gt;<br /> &lt;/filter-mapping&gt;</span></p> 
<p style="text-align: left; margin-bottom: 12pt" class="MsoNormal" align="left"><span style="color: black; font-size: 9pt"><br /> <br /> <strong>HTTP</strong></span><strong><span style="color: black; font-size: 9pt">方法名</span></strong><span style="color: black; font-size: 9pt"><br /> </span><span style="color: black; font-size: 9pt">最近，你可以将合法的<span>HTTP/1.1</span>方法名放进<span>&lt;http-method&gt;</span>元素中。当你使用这些方法时，<span>&lt;http-method&gt;</span>将指明<span>&lt;security-constraint&gt;</span>标记里的方法应该被应用。从以前来看，它仅限于<span>HTTP/1.1</span>的<span>7</span>个标准方法：<span>GET</span>，<span>POST</span>，<span>PUT</span>，<span>DELETE</span>，<span>HEAD</span>，<span>OPTIONS</span>和<span>TRACE</span>。但是，<span>HTTP/1.1</span>允许对方法进行扩展，<span>WebDAV</span>是用于这种扩展的普遍技术。在<span>Servlet2.5</span>中，你可以安全地约束任何可能的<span>HTTP</span>方法名，标准及扩展，包括<span>WebDAV</span>方法，例如：<span>LOCK</span>，<span>UNLOCK</span>，<span>COPY</span>及<span>MOVE</span>。<span><br /> </span>如果你写一个<span>WebDAV</span>的<span>Servlet</span>，你不必使用<span>doLock()</span>和<span>doCopy()</span>方法。你必须写自己的<span>service()</span>方法及分派<span>request.getMethod()</span>方法。正由于这种变化，你不必管理系统的安全性。<span><br /> <br /> </span></span><strong><span style="color: black; font-size: 12pt">去除限制</span></strong><span style="color: black; font-size: 9pt"><br /> <br /> Servlet2.5</span><span style="color: black; font-size: 9pt">去除了关于错误处理和回话跟踪的一些限制。对于错误处理，<span>Servlet2.5</span>之前，配置在<span>&lt;error-page&gt;</span>中的错误处理页面不能通过调用<span>setStatus()</span>方法来修改触发他们的错误代码，而<span>Servlet2.5</span>减弱了这一规范。这样的规范的产生于这样的观点，就是错误页面的工作是指出每个错误而不是修改错误。但是，实际使用中，错误页面不只是用于指出错误，而是还能做更多的事情，或许可以代替在线帮助来帮助用户解决问题。这个规范将不再限制错误页面所产生的反馈信息。<span><br /> <br /> </span>对于会话跟踪，<span>Servlet2.5</span>之前，调用<span>RequestDispatcher.include()</span>的<span>Servlet</span>不能设置响应的标题头，而<span>Servlet2.5</span>减弱了这一规范。原规范的目的是使内部的<span>Servlets</span>限制在自己的页面空间中，不可以影响外部的页面。现在这个规范已经减弱，允许在内部的<span>Servlet</span>中使用<span>request.getSession()</span>命令，这个命令可以悄悄地创建一个会话跟踪<span>cookie</span>的标题头。逻辑上要求限制内部的资源，但逻辑上也要求这些限制不应该取消其启动<span>session</span>的这一功能。这个变动对于<span>Portlet</span>规范来说显得尤其重要。作用是：如果响应已经有效，则<span>getSession()</span>命令就会抛出一个<span>IllegalStateException(</span>异常<span>)</span>，而在此之前，就没有这个功能。<span><br /> <br /> </span></span><strong><span style="color: black; font-size: 12pt">Clarifications</span></strong><span style="color: black; font-size: 9pt"><br /> </span><span style="color: black; font-size: 9pt">最近，新的规范对一些边缘方法进行了说明，使得<span>Servlets</span>更加方便而且保证了更好地按要求工作。<span><br /> <br /> </span><strong>终止响应</strong><span><br /> </span>第一处说明细小又深奥，但做为规范中的一个例子还有蛮有趣的。<span>Servlet2.4</span>规范规定响应在这几种情况下应该是有效的，包括：在响应的<span>setContentLength</span>方法中内容已经明确说明，以及内容已经写进了响应中。这种情况只有你的代码像下面这样才可以使响应重新定向：</span></p> 
<p style="text-align: left" class="MsoNormal" align="left"><span style="color: black; font-size: 12pt">response.setHeader(&quot;Host&quot;, &quot;localhost&quot;)</span><span style="color: black; font-size: 12pt">；<span><br /> response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;)</span>；<span><br /> response.setHeader(&quot;Content-Length&quot;, &quot;0&quot;)</span>；<span><br /> response.setHeader(&quot;Location&quot;, &quot;http://www.apache.org&quot;)</span>；</span></p> 
<p class="MsoNormal"><span style="color: black; font-size: 9pt"><br /> <br /> Servlet</span><span style="color: black; font-size: 9pt">技术忽略特定区域的标题头，因为内容满足<span>0</span>字节长度，响应就会立即生效。而在它开始之前，响应就已失效了！<span>Servlet</span>容器通常拒绝执行这种行为，而<span>Servlet2.5</span>版本增加了<span>“</span>长度必须大于
  <st1:chmetcnv tcsc="0" numbertype="1" negative="False" hasspace="False" sourcevalue="0" unitname="”">
   <span>0”</span>
  </st1:chmetcnv>这个原则。<span><br /> <br /> </span><strong>实例编码</strong><span><br /> Servlet2.4</span>规范规定必须在调用<span>request.getReader()</span>方法之前调用<span>request.setCharacterEncoding()</span>方法。但是，如果你忽略这个原则而在其之后去调用<span>request.setCharacterEncoding()</span>方法，那么会产生什么后果，这个问题规范里并没有说。为了简便，现在消除这种情况！<span><br /> <br /> <strong>Cross-context sessions(</strong></span><strong>不同上下文目录间的会话<span>)</span></strong><span><br /> </span>最近，关于<span>Cross-context</span>会话处理的规则已经明确说明。当<span>Servlets</span>指派从一个上下文到其他上下文的请求时，这个规则就发挥了作用<span>——</span>在目标调用过程中，包括哪些会话。这个版本的出现使得一个上下文目录的主页里的<span>portlets</span>可以通过几种内部的命令来对别的上下文目录里的<span>portlets</span>起作用。<span>Servlet2.5</span>明确指出一个上下文目录里的资源可以访问其他上下文目录的<span>session(</span>会话<span>)</span>，而不用考虑这个请求从哪里开始的。这意味着<span>portlets</span>可以脱离主页的范围而在自己的范围里运行，而且这个规范还会应用在不兼容的<span>Serlvet</span>容器中。<span><br /> <br /> </span></span><strong><span style="color: black; font-size: 12pt">期待</span></strong><span style="color: black; font-size: 9pt"><br /> </span><span style="color: black; font-size: 9pt">由于<span>Servlet2.5</span>版本要保持一些旧的性质，几个大的概念不得不延后到下一个阶段。它们包括：<span><br /> &middot;</span>新的输入<span>/</span>输出<span>(NIO)</span>支持：使<span>NIO</span>通道更有利于<span>Servlets</span>进行客户端通信成为可能。<span><br /> &middot;</span>过滤器<span>wrap-under</span>或<span>wrap-over</span>语义：有时用过滤器包装请求，和<span>/</span>或者响应对象去修改方法行为或者启用新的方法。当把这种包装和服务器对请求和响应的包装结合起来时，又应该怎么包装在一起？<span><br /> &middot;</span>用于欢迎的<span>Servlets</span>文件：做为索引应该充当欢迎作用的文件吗？在此之前，这个回答是肯定的。但是规范没有明确说明如何使用这个功能，尤其在没有索引的情况下。<span><br /> &middot;</span>用于欢迎的文件的分派规则：如何分派欢迎文件，这个细节并没有完全说明，而是遗留了一些开放的缺口来应对不兼容问题。<span><br /> &middot;</span>登陆后选择默认页面：如果用户通过他们的书签访问<span>Servlet</span>的登陆页面，那么在成功登陆后页面应该转向哪里呢？这个问题至今尚未明确说明。<span><br /> &middot;</span>用户的主题日志：在通过网站正确地注册之后，不通过传统地登陆方式没有办法使<span>Servlet</span>信任用户。<span><br /> <br /> </span></span><strong><span style="color: black; font-size: 12pt">结束语</span></strong><span style="color: black; font-size: 9pt"><br /> </span><span style="color: black; font-size: 9pt">如果抛开注释来看<span>Servlet2.5</span>的变化，可见在配置文件<span>web.xml</span>中去除了一些限制，是有利的，同时又优化了实例行为使其更适合更便于开发<span>Web</span>系统<span>(</span>网页<span>)</span>。<span><br /> Servlet2.5</span>中注释的作用更加戏剧化。<span>Servlets</span>本身不能声明注释类型的变量，甚至性能弱的<span>Servlet</span>容器都不支持注释。然而在<span>JEE5</span>环境下的<span>Servlets</span>编写者可以看到，通过公共的注释及<span>EJB3.0</span>和<span>JAX-WS2.0</span>规范而引入的注释类型会对代码产生很大变化，并且这也将对<span>Servlet</span>如何管理外部资源，对象的持久化及<span>EJB</span>的构成产生重大影响。<span><br /> <br /> </span><strong>关于作者</strong><span><br /> Jason Hunter</span>：《<span>Java Servlet Programming, 2nd Edition</span>》的作者，于他人合著了《<span>Java Enterprise Best Practices</span>》。他是<span>Apache</span>组织的成员，是<span>Java </span>公共过程执行委员会的<span>Apache</span>代表，并为<span>Java</span>的开源制定了具有里程碑意义的协议。他是<span>Servlets.com</span>的发行人，也是最早为<span>Apache Tomcat</span>投稿的人之一，还开发了开源的<span>JDOM library</span>来优化<span>java</span>和<span>XML</span>的整合。他还设计开发了<span>CountryHawk</span>，这个产品可以根据用户的<span>IP</span>地址快速地确定用户的所在国。</span></p></div></body></html>