<html><head><title><div class="tit">
  字符串匹配
</div></title></head><body><div id='tit'>字符串匹配</div><div id='cate'>j&middot;入门</div><div id='date'>2008年04月23日 星期三 00:25 A.M.</div><div id='page'>139</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/84e026a409262cf29052eed1.html'>http://hi.baidu.com/hxzon/blog/item/84e026a409262cf29052eed1.html</a><div id='cnt'><div> 
 <p><span style="COLOR: rgb(100,100,100)">字符串匹配</span></p> 
 <p><a href="http://www.blogjava.net/renyangok/archive/2007/03/05/101927.html">http://www.blogjava.net/renyangok/archive/2007/03/05/101927.html</a></p>1 术语定义 
 <p>在字符串匹配问题中，我们期待察看串T中是否含有串P。<br />其中串T被称为目标串，串S被称为模式串。</p>2 朴素匹配算法 
 <p>进行字符串匹配，最简单的一个想法是：</p>public class SimpleMatch { public int StringMatch(String target,String patten) { int tl = target.length(); int pl = patten.length(); int i = 0 ; int j = 0 ; while (i &lt; tl - pl &amp;&amp; j &lt; pl) { if (patten.charAt(j) == target.charAt(i + j)) j ++ ; else { j = 0 ; i ++ ; } } if (j == pl) return i; return - 1 ; } public static void main(String[] args) {
 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String t = &quot; 123456789 &quot; ;
 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String p = &quot; 456 &quot; ;
 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SimpleMatch sm = new SimpleMatch();
 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(sm.StringMatch(t, p));
 <br />&nbsp;&nbsp; }
 <br />} 
 <p>可以看见，这个算法（假定m&gt;&gt;n）的复杂度是O(mn)，其中m是T的长度，n是P的长度。这种算法的缺陷是匹配过程中带有回溯——准确地说是T串存在回溯，也就是当匹配不成功的时候，之前进行的匹配完全变为无用功，所有的比较需要重新开始。</p>3 KMP算法 
 <p>KMP算法是D.E.Knuth、J.H.Morris和V.R.Pratt提出的无回溯的字符串匹配算法，算法的核心思想就是设法在匹配失败的时候，尽量利用之前的匹配结果，消除T串的回溯问题。那么如何消除回溯呢？请看下面的例子：</p> 
 <p>假设P=abacd，如果T=abax...，当从头开始匹配到字符c时，若c=x，显然，匹配过程继续；当c≠x时，按照朴素的匹配算法，T串会发生回溯，之后T串会从第2个字符b开始重新匹配，而不是从匹配失败的字符x开始继续。但是显然，对于上述的匹配过程，T串不需要从b开始重新匹配，它只需要从x开始和P的b字符继续匹配即可。如下：<br />匹配过程：<br />P=abacd<br />T=abax....<br />&nbsp;&nbsp;&nbsp;&nbsp; ^----比较到此处时发生匹配失败<br />朴素匹配算法：<br />P= abacd<br />T=abax...<br />&nbsp;&nbsp; ^----回溯到b，重新开始和P的匹配<br />KMP算法：<br />P= abacd<br />T=abax...<br />&nbsp;&nbsp;&nbsp;&nbsp; ^----T串不回溯，从x处继续匹配</p> 
 <p>现在的问题是，按照KMP算法，匹配失败的时候，P串需要重新调整位置，但是调整的依据是什么？Knuth等人发现，P调整位置的依据和P的构造有关，和T无关。具体来说，定义失效函数：f(j)=k，其中0&lt;=k&lt;=j，且k是使得p0p1...pk-1 = pj-k+1pj-k+2...pj成立的最大整数。建立失效函数的算法如下：<br />public void Build() {<br />if(pattern == null)<br />&nbsp;&nbsp; throw new Exception(&quot;KMP Exception : null pattern&quot;);<br />array = new int[pattern.Length];<br />int i = 0, s = pattern.Length;<br />if(s &gt; 1)<br />&nbsp;&nbsp; array[0] = 0;<br />for(i = 1; i &lt; s; i++) {<br />&nbsp;&nbsp; if(pattern[i] == pattern[array[i - 1]])<br />&nbsp;&nbsp;&nbsp; array[i] = array[i - 1] + 1;<br />&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp; array[i] = 0;<br />}<br />}</p> 
 <p>匹配过程如下：<br />public int Match(String target, int start) {<br />if(array == null || pattern == null || target == null)<br />&nbsp;&nbsp; return -1;<br />int target_index = start;<br />int pattern_index = 0;<br />int token_length = target.Length;<br />int pattern_length = pattern.Length;<br />while(target_index &lt; token_length &amp;&amp; pattern_index &lt; pattern_length) {<br />&nbsp;&nbsp; if(target[target_index] == pattern[pattern_index]) {<br />&nbsp;&nbsp;&nbsp; target_index++;<br />&nbsp;&nbsp;&nbsp; pattern_index++;<br />&nbsp;&nbsp; } else {<br />&nbsp;&nbsp;&nbsp; if(pattern_index == begin)<br />&nbsp;&nbsp;&nbsp;&nbsp; target_index++;<br />&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp; pattern_index = array[pattern_index - 1];<br />&nbsp;&nbsp; }<br />}<br />if(pattern_index == pattern_length)<br />&nbsp;&nbsp; return target_index - pattern_length;<br />return -1;<br />}</p>4 支持通配符?和*的KMP算法 
 <p>KMP算法虽然能够进行字符串匹配，但是，在实践中字符串匹配往往还要支持通配符，MS系统中最常见的通配符是?和*。其中，?可以代表一个字符（不能没有），*可以代表任意多个字符（可以为空）。经典的KMP算法针对通配符是无能为力的，但是经过简单的改造，KMP算法也可以识别通配符。</p> 
 <p>首先是?，根据?的功能，?表示任意字符，也就是说在匹配过程中，?永远匹配成功。因此对匹配函数的修改十分简单：<br />...<br />while(target_index &lt; token_length &amp;&amp; pattern_index &lt; pattern_length) {<br />&nbsp;&nbsp; if(target[target_index] == pattern[pattern_index]|| pattern[pattern_index] == '?') {<br />&nbsp;&nbsp;&nbsp; target_index++;<br />&nbsp;&nbsp;&nbsp; pattern_index++;<br />&nbsp;&nbsp; } else {<br />...<br />建立失效函数的过程和匹配过程类似，修改如下：<br />...<br />for(i = 1; i &lt; s; i++) {<br />&nbsp;&nbsp; if(pattern[i] == pattern[array[i - 1]]|| pattern[i] == '?' || pattern[array[i - 1]] == '?')<br />&nbsp;&nbsp;&nbsp; array[i] = array[i - 1] + 1;<br />...</p> 
 <p>本质上，?并没有修改算法，而仅仅修改了匹配规则——遇到?则一定匹配。然而*与此不同，*的作用是匹配任意多个字符，显然我们不能简单的修改匹配过程而满足要求。如果我们重新思考*的作用，我们会发现*的另一个作用就是分割P串，即如果P=P1*P2，那么与其说*代表匹配任意多个字符，不如说P的匹配条件是在匹配P1子串后再匹配P2子串。</p> 
 <p>现在回顾失效函数的作用，如果当匹配到P的j+1位时匹配失败，那么重新开始匹配的时候，P串的位置调整到f(j)位，直到P串的位置调整到0，则匹配重新开始。但当P=P1*P2，假如P1已经匹配成功，而在P2中发生匹配失败，那么P串要需要调整位置，但P串无论如何调整，此时也不应该调整到0，最多调整到P2的开始处，因为P1已经匹配，只需匹配P2即可。假如P=abcab*abcab，失效函数应该是（注意之前提到*的作用）：<br />a b c a b * a b c a b<br />0 0 0 1 2 - 6 6 6 7 8</p> 
 <p>因此，要想让KMP支持*，那么关键是要重新设计失效函数的建立算法，如下：<br />public void Build() {<br />if(pattern == null)<br />&nbsp;&nbsp; throw new Exception(&quot;KMP Exception : null pattern&quot;);<br />array = new int[pattern.Length];<br />int i = 0, s = pattern.Length;<br />if(s &gt; 1)<br />&nbsp;&nbsp; array[0] = 0;<br />int begin = 0;<br />for(i = 1; i &lt; s; i++) {<br />&nbsp;&nbsp; if(pattern[i] == '*') {<br />&nbsp;&nbsp;&nbsp; array[i] = i;<br />&nbsp;&nbsp;&nbsp; begin = i + 1;<br />&nbsp;&nbsp; } else if(pattern[i] == pattern[array[i - 1]] || pattern[i] == '?' || pattern[array[i - 1]] == '?')<br />&nbsp;&nbsp;&nbsp; array[i] = array[i - 1] + 1;<br />&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp; array[i] = begin;<br />}<br />}</p> 
 <p>算法中begin表示每段字符串的开始位置。此外，匹配过程也应该进行相应的修改，因为字符*对于匹配没有任何帮助，它属于占位符，因此需要跳过，匹配算法如下：<br />public int Match(String target, int start) {<br />if(array == null || pattern == null || target == null)<br />&nbsp;&nbsp; return -1;<br />int target_index = start;<br />int pattern_index = 0;<br />int token_length = target.Length;<br />int pattern_length = pattern.Length;<br />int begin = 0;<br />while(target_index &lt; token_length &amp;&amp; pattern_index &lt; pattern_length) {<br />&nbsp;&nbsp; if(pattern[pattern_index] == '*') {<br />&nbsp;&nbsp;&nbsp; begin = pattern_index + 1;<br />&nbsp;&nbsp;&nbsp; pattern_index++;<br />&nbsp;&nbsp; } else if(target[target_index] == pattern[pattern_index] || pattern[pattern_index] == '?') {<br />&nbsp;&nbsp;&nbsp; target_index++;<br />&nbsp;&nbsp;&nbsp; pattern_index++;<br />&nbsp;&nbsp; } else {<br />&nbsp;&nbsp;&nbsp; if(pattern_index == begin)<br />&nbsp;&nbsp;&nbsp;&nbsp; target_index++;<br />&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp; pattern_index = array[pattern_index - 1];<br />&nbsp;&nbsp; }<br />}<br />if(pattern_index == pattern_length)<br />&nbsp;&nbsp; return target_index - pattern_length + begin;<br />return -1;<br />}</p>5 正则语言和确定状态自动机 
 <p>一个数字逻辑的问题：设计一个识别11011的电路，解这个问题的关键就是设计出这个电路的DFA，如下：<br /><img style="CURSOR: pointer" src="image/字符串匹配.html.823915044.png" /><p class="origImg">http://www.blog.edu.cn/UploadFiles/2006-8/823915044.png</p></p> 
 <p>仔细看看这个状态机，是不是和KMP的算法有几分类似呢？这并不是巧合，因为KMP算法中的失效函数总可以等价的转化为一个DFA。当然KMP的 DFA远比识别11011的DFA要复杂，原因在于KMP接受的输入是全体字符集合，识别11011的DFA只接受0和1这两个输入。我们知道，一个正则语言和一个DFA是等价的，而KMP计算失效函数的算法，实际上等价于求DFA的过程，f(j)的值实际上表明状态j+1接受到不正确的字符时应该回溯到的状态（注意此时输入流并没有前进）。普通的字符串都能看成是一个正则语言，含有通配符?和*的字符串也可以等价的转换为一个正则表达式。但是，正则语言的集合远比KMP算法所能支持的模式集合的更大，期间原因还是刚才提过的输入问题。试想P=p1p2...pn，当匹配到pj的时候，如果下一个输入字符正是pj，那么状态机进入下一个状态，如果不是pj，那么状态机按照实效函数的指示转移到状态f(j-1)，也就是说KMP状态机的每个状态只能根据输入是否为pj来进行转移。而正则表达式所对应的状态机则有所不同，如果正则语言L=l1l2...ln，假设这些都是字母，当匹配到lj位的时候，如果下一个输入字符正是lj，那么状态机进入下一个状态，否则它还可以根据输入的值进行转移，例如lj=c1时转换到状态x，lj=c2时状态转换到y等等。</p>6 结语 
 <p>字符串匹配问题是老问题了，并没有太多新意可言，只不过虽然KMP算法十分简单，但它的内在含义还是十分深刻的。横向比较KMP、DFA和正则语言、正则表达式我们会发现，它们之间存在很多的关联，而这种比较也有利于我们更好的理解这些算法，或者改进这些算法。最后说一句，试图利用目前的框架使得 KMP算法支持全部种类的通配符（对应于正则表达式就是x?、x*、x+、{m,n}等等）是不可能，而我们也不需要这么做，因为我们还有正则表达式嘛。</p> 
 <div> 
  <p>posted on 2007-03-05 15:29 <a href="http://www.blogjava.net/renyangok/"><span style="COLOR: rgb(111,188,76)">保尔任</span></a>&nbsp;&nbsp;</p> 
  <p><a href="http://www.blogjava.net/renyangok/archive/2007/03/05/101927.html">http://www.blogjava.net/renyangok/archive/2007/03/05/101927.html</a></p>
 </div> 
 <p><br /></p> 
 <p><br /></p>
</div></div></body></html>