<html><head><title><div class="tit">
  应聘Java笔试时可能出现问题(续)
</div></title></head><body><div id='tit'>应聘Java笔试时可能出现问题(续)</div><div id='cate'>j&middot;入门</div><div id='date'>2008年08月27日 星期三 01:04 P.M.</div><div id='page'>107</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/6aeeab346ae8c6b1d1a2d37f.html'>http://hi.baidu.com/hxzon/blog/item/6aeeab346ae8c6b1d1a2d37f.html</a><div id='cnt'><p><font size="3">应聘Java笔试时可能出现问题(续)</font></p> 
<p><font size="3">说出在JSP页面里是怎么分页的? <br /> 页面需要保存以下参数： <br /> 总行数：根据sql语句得到总行数 <br /> 每页显示行数：设定值 <br /> 当前页数：请求参数 <br /> 页面根据当前页数和每页行数计算出当前页第一行行数，定位结果集到此行，对结果集取出每页显示行数的行即可。 <br /> <br /> 4、在ORACLE大数据量下的分页解决方法。一般用截取ID方法，还有是三层嵌套方法。 <br /> 答:一种分页方法 <br /> &lt;% <br /> int i=1; <br /> int numPages=14; <br /> <br /> //获取当前页面 <br /> String pages = request.getParameter(&quot;page&quot;) ; <br /> int currentPage = 1; <br /> currentPage=(pages==null)?(1):{Integer.parseInt(pages)}; <br /> <br /> //获得记录总数 <br /> sql = &quot;select count(*) from tables&quot;; <br /> ResultSet rs = DBLink.executeQuery(sql) ; <br /> while(rs.next()) i = rs.getInt(1) ; <br /> <br /> //获取总页数 <br /> int intPageCount=1; <br /> intPageCount=(i%numPages==0)?(i/numPages):(i/numPages+1); <br /> <br /> //设置上下页 <br /> int nextPage ; <br /> int upPage; <br /> nextPage = currentPage+1; <br /> if (nextPage&gt;=intPageCount) nextPage=intPageCount; <br /> upPage = currentPage-1; <br /> if (upPage&lt;=1) upPage=1; <br /> <br /> //获取数据内容并显示 <br /> rs.close(); <br /> sql=&quot;select * from tables&quot;; <br /> rs=DBLink.executeQuery(sql); <br /> i=0; <br /> while((i&lt;numPages*(currentPage-1))&amp;&amp;rs.next()){i++;} <br /> %&gt; <br /> //输出内容 <br /> //输出翻页连接 <br /> 合计:&lt;%=currentPage%&gt;/&lt;%=intPageCount%&gt; <br /> &lt;a href=&quot;/List.jsp?page=1&quot;&gt;第一页&lt;/a&gt; <br /> &lt;a href=&quot;List.jsp?page=&lt;%=upPage%&gt;&quot;&gt;上一页&lt;/a&gt; <br /> <br /> &lt;% <br /> for(int j=1;j&lt;=intPageCount;j++){ <br /> if(currentPage!=j){ <br /> %&gt; <br /> //显示所有页面的连接 <br /> &lt;a href=&quot;list.jsp?page=&lt;%=j%&gt;&quot;&gt;[&lt;%=j%&gt;]&lt;/a&gt; <br /> <br /> &lt;% <br /> }else{ <br /> out.println(j); <br /> } //end of if <br /> } //end of for <br /> %&gt; <br /> <br /> &lt;a href=&quot;List.jsp?page=&lt;%=nextPage%&gt;&quot;&gt;下一页&lt;/a&gt; <br /> &lt;a href=&quot;List.jsp?page=&lt;%=intPageCount%&gt;&quot;&gt;最后页 &lt;/a&gt; <br /> <br /> <br /> Xml方面 <br /> 2、你在项目中用到了xml技术的哪些方面?如何实现的? <br /> 答:用到了数据存贮，信息配置两方面。在做数据交换平台时，将不能数据源的数据组装成XML文件，然后将XML文件压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再同XML文件中还原相关信息进行处理。在做软件配置时，利用XML可以很方便的进行，软件的各种配置参数都存贮在XML文件中。 <br /> <br /> 3、用jdom解析xml文件时如何解决中文问题?如何解析? <br /> 答:看如下代码,用编码方式加以解决 <br /> package test; <br /> import java.io.*; <br /> public class DOMTest { <br /> private String inFile = &quot;c:\\people.xml&quot;; <br /> private String outFile = &quot;c:\\people.xml&quot;; <br /> public static void main(String args[]){ <br /> new DOMTest(); <br /> } <br /> public DOMTest() { <br /> try { <br /> javax.xml.parsers.DocumentBuilder builder = <br /> javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder(); <br /> org.w3c.dom.Document doc = builder.newDocument(); <br /> org.w3c.dom.Element root = doc.createElement(&quot;老师&quot;); <br /> org.w3c.dom.Element wang = doc.createElement(&quot;王&quot;); <br /> org.w3c.dom.Element liu = doc.createElement(&quot;刘&quot;); <br /> wang.appendChild(doc.createTextNode(&quot;我是王老师&quot;)); <br /> root.appendChild(wang); <br /> doc.appendChild(root); <br /> javax.xml.transform.Transformer transformer = <br /> javax.xml.transform.TransformerFactory.newInstance().newTransformer(); <br /> <br /> transformer.setOutputProperty(javax.xml.transform.OutputKeys.ENCODING, &quot;gb2312&quot;); <br /> transformer.setOutputProperty(javax.xml.transform.OutputKeys.INDENT, &quot;yes&quot;); <br /> transformer.transform(new javax.xml.transform.dom.DOMSource(doc), <br /> new javax.xml.transform.stream.StreamResult(outFile)); <br /> } catch (Exception e) { <br /> System.out.println (e.getMessage()); <br /> } <br /> } <br /> } <br /> <br /> 4、编程用JAVA解析XML的方式. <br /> 答:用SAX方式解析XML，XML文件如下： <br /> &lt;?xml version=&quot;1.0&quot; encoding=&quot;gb2312&quot;?&gt; <br /> &lt;person&gt; <br /> &lt;name&gt;王小明&lt;/name&gt; <br /> &lt;college&gt;信息学院&lt;/college&gt; <br /> &lt;telephone&gt;6258113&lt;/telephone&gt; <br /> &lt;notes&gt;男,1955年生,博士，95年调入海南大学&lt;/notes&gt; <br /> &lt;/person&gt; <br /> 事件回调类SAXHandler.java <br /> import java.io.*; <br /> import java.util.Hashtable; <br /> import org.xml.sax.*; <br /> public class SAXHandler extends HandlerBase { <br /> private Hashtable table = new Hashtable(); <br /> private String currentElement = null; <br /> private String currentvalue = null; <br /> public void setTable(Hashtable table) { <br /> this.table = table; <br /> } <br /> public Hashtable getTable(){ <br /> return table; <br /> } <br /> public void startElement(String tag, AttributeList attrs) throws SAXException { <br /> currentElement = tag; <br /> } <br /> public void characters(char[] ch, int start, int length) throws SAXException { <br /> currentvalue = new String(ch, start, length); <br /> } <br /> public void endElement(String name) throws SAXException { <br /> if (currentElement.equals(name)) table.put(currentElement, currentvalue); <br /> } <br /> } <br /> <br /> JSP内容显示源码,SaxXml.jsp: <br /> &lt;HTML&gt; <br /> &lt;HEAD&gt; <br /> &lt;title&gt;剖析XML文件people.xml&lt;/title&gt; <br /> &lt;/HEAD&gt; <br /> &lt;BODY&gt; <br /> &lt;%@ page errorPage=&quot;ErrPage.jsp&quot; contentType=&quot;text/html;charset=GB2312&quot; %&gt; <br /> &lt;%@ page import=&quot;java.io.*&quot; %&gt; <br /> &lt;%@ page import=&quot;java.util.Hashtable&quot; %&gt; <br /> &lt;%@ page import=&quot;org.w3c.dom.*&quot; %&gt; <br /> &lt;%@ page import=&quot;org.xml.sax.*&quot; %&gt; <br /> &lt;%@ page import=&quot;javax.xml.parsers.SAXParserFactory&quot; %&gt; <br /> &lt;%@ page import=&quot;javax.xml.parsers.SAXParser&quot; %&gt; <br /> &lt;%@ page import=&quot;SAXHandler&quot; %&gt; <br /> &lt;% <br /> File file = new File(&quot;c:\\people.xml&quot;); <br /> FileReader reader = new FileReader(file); <br /> Parser parser; <br /> SAXParserFactory spf = SAXParserFactory.newInstance(); <br /> SAXParser sp = spf.newSAXParser(); <br /> SAXHandler handler = new SAXHandler(); <br /> sp.parse(new InputSource(reader), handler); <br /> Hashtable hashTable = handler.getTable(); <br /> out.println(&quot;&lt;TABLE BORDER=2&gt;&lt;CAPTION&gt;教师信息表&lt;/CAPTION&gt;&quot;); <br /> out.println(&quot;&lt;TR&gt;&lt;TD&gt;姓名&lt;/TD&gt;&quot; + &quot;&lt;TD&gt;&quot; + <br /> (String)hashTable.get(new String(&quot;name&quot;)) + &quot;&lt;/TD&gt;&lt;/TR&gt;&quot;); <br /> out.println(&quot;&lt;TR&gt;&lt;TD&gt;学院&lt;/TD&gt;&quot; + &quot;&lt;TD&gt;&quot; + <br /> (String)hashTable.get(new String(&quot;college&quot;))+&quot;&lt;/TD&gt;&lt;/TR&gt;&quot;); <br /> out.println(&quot;&lt;TR&gt;&lt;TD&gt;电话&lt;/TD&gt;&quot; + &quot;&lt;TD&gt;&quot; + <br /> (String)hashTable.get(new String(&quot;telephone&quot;)) + &quot;&lt;/TD&gt;&lt;/TR&gt;&quot;); <br /> out.println(&quot;&lt;TR&gt;&lt;TD&gt;备注&lt;/TD&gt;&quot; + &quot;&lt;TD&gt;&quot; + <br /> (String)hashTable.get(new String(&quot;notes&quot;)) + &quot;&lt;/TD&gt;&lt;/TR&gt;&quot;); <br /> out.println(&quot;&lt;/TABLE&gt;&quot;); <br /> %&gt; <br /> &lt;/BODY&gt; <br /> &lt;/HTML&gt;</font></p> 
<p><font size="3">EJB方面 <br /> 1、EJB2.0有哪些内容?分别用在什么场合? EJB2.0和EJB1.1的区别? <br /> 答：规范内容包括Bean提供者，应用程序装配者，EJB容器，EJB配置工具，EJB服务提供者，系统管理员。这里面，EJB容器是EJB之所以能够运行的核心。EJB容器管理着EJB的创建，撤消，激活，去活，与数据库的连接等等重要的核心工作。JSP,Servlet,EJB,JNDI,JDBC,JMS..... <br /> <br /> 2、EJB与JAVA BEAN的区别？ <br /> JavaBean是可复用的平***立的软件组件，开发者可以在软件构造器工具中对其直接进行可视化操作。 <br /> <br /> Enterprise Java Bean 相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。EJB容器是EJB组件的代理，EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。 <br /> <br /> 3、EJB的基本架构 <br /> 答:一个EJB包括三个部分: <br /> Remote Interface 接口的代码 <br /> package Beans; <br /> import javax.ejb.EJBObject; <br /> import java.rmi.RemoteException; <br /> public interface Add extends EJBObject { <br /> //some method declare <br /> } <br /> <br /> Home Interface 接口的代码 <br /> package Beans; <br /> import java.rmi.RemoteException; <br /> import jaax.ejb.CreateException; <br /> import javax.ejb.EJBHome; <br /> public interface AddHome extends EJBHome { <br /> //some method declare <br /> } <br /> <br /> EJB类的代码 <br /> package Beans; <br /> import java.rmi.RemoteException; <br /> import javax.ejb.SessionBean; <br /> import javx.ejb.SessionContext; <br /> public class AddBean Implements SessionBean { <br /> //some method declare <br /> }</font></p> 
<p> </p>
<table class="FCK__ShowTableBorders" border="0" width="72%" bgcolor="#ffffff"> 
 <tbody> 
  <tr> 
   <td width="97%" align="left"> 
    <table class="wr FCK__ShowTableBorders" border="0" cellspacing="0" cellpadding="0"> 
     <tbody> 
      <tr> 
       <td class="gray14"><font size="3">J2EE,MVC方面 <br /> 1、MVC的各个部分都有那些技术来实现?如何实现? <br /> 答:MVC是Model－View－Controller的简写。设计的基本原理是将复杂性分解为三个组件，即模型、视图、控制器。 <br /> 模型表示数据和处理数据的业务逻辑或应用程序对象。 <br /> 试图是用户要查看或存取的数据的表示。 <br /> 控制器定义了用户与模型和试图交互的方式。 <br /> <br /> <br /> 2、应用服务器与WEB SERVER的区别？ <br /> Web Service 是一种新的分布式技术。一个Web服务本质上是一个应用组件，可以通过Web协议和数据编码机制，例如HTTP和XML，对这个组件进行访问。 <br /> <br /> Soap简单对象访问协议： <br /> 是一种基于XML的通信协议。它包括3个部分。 <br /> Soap封装结构：定义消息的XML格式，包括其整体框架、消息内容、由谁处理这些内容等。 <br /> Soap编程规则：定义如何将程序数据表示为XML。 <br /> Soap RPC表示：定义如何使用scap进行远程过程调用。 <br /> <br /> WSDL Web服务描述语言： <br /> WSDL文件是一个XML文档，用于说明一组soap消息以及如何交换这些消息。还定义了服务的位置以及使用服务的通信协议等。 <br /> <br /> Uddi统一描述、发现和集成标准 <br /> 是wed服务的黄页。它提供了用于服务注册的目录技术，并用它来建立Web服务的目录信息。UDDI的核心组件是UDDI商业注册，它使用一个XML文档来描述企业及所提供的Web服务。它包括3个部分： <br /> 白页：介绍提供服务的公司，包括名称、地址和联系方式等； <br /> 黄页：包括按照标准分类法进行分类的行业类别； <br /> 绿页：详细介绍，访问服务接口等技术信息。 <br /> <br /> Web服务是构建在soap（简单对象访问协议）、wsdl（web服务描述语言）、uddi（统一描述、发现和集成标准）3个开放的核心标准之上的。Soap用来进行Web服务通信的协议，WSDL用来进行说明和描述Web服务 <br /> 由于Web服务完全基于XML的，使Web服务成为一个跨语言、跨平台、跨网络的可互操作的分布式应用软件的新平台。 <br /> 3、J2EE是什么？ <br /> J2EE是sun公司推出的一个高层次的全方位、多功能的企业应用开发环境。它包括了当今软件工业界许多最新、最重要的软件技术。J2EE平台包含一整套的服务、应用程序接口和协议，是java技术企业级应用的整体解决方案。J2EE平台通过基于组件的应用程序模型大大简化了开发过程，同时还支持任何分布式体系和多层次的应用开发。随着越来越多的第三方对J2EE的支持和标准认证，J2EE已被广泛用来开发企业级应用软件、中间件和组件软件。 <br /> J2EE Java2平台企业版： <br /> 1、提供了基于组件的方式来设计、开发、组装和部署企业应用。 <br /> 2、提供了一个多层次分布式的应用模型，包括了可复用的组件、基于XML数据交换、统一的安全模式以及灵活的事务控制。基于这些技术，可开发出满足市场要求的，基于平台无关的J2EE组件的解决方案。 <br /> 3、J2EE平台使用的多层分布式应用模型中应用程序主要分为：客户层（Applet）、Web层（Servlet和JSP）、业务层（EJB）、企业信息系统层。 <br /> <br /> <br /> 使用类库开发与使用框架包进行开发的区别？ <br /> 框架包简单的可以认为是一组类和接口，它们相互协作以解决特定类型的软件问题。 <br /> 类库包含的是应用程序可以调用的函数或例程。而框架包提供通用的、相互协作的组件，应用程序通过扩展这些组件提供特定函数组。应用程序将在这些扩展点进行扩展，运行时这些扩展将被框架系统反调用。这正与使用类库开发的应用程序，运行时的函数调用时颠倒的。 <br /> <br /> 5、BS与CS的联系与区别。 <br /> 传统的分布式应用程序都是基于Client/Server结构的，而近年来人们发现基于Client/Server结构的应用程序有很多缺点，比如：如果客户端的代码需要改变，那么所有机器上的客户端程序都要重新安装；如果某台机器有了不可修复的损坏，那么得去别的机器上重新安装客户端软件才能够使用。而基于Browser/Server结构的应用程序就没有以上的缺点了，我们可以使用任何一台有浏览器的机器来工作，而因为所有的程序逻辑都在服务器端，所以服务器端的代码变动不需要作为客户端的浏览器再做任何工作。 <br /> <br /> 6、STRUTS的应用(如STRUTS架构) <br /> 答：Struts是采用Java Servlet/JavaServer Pages技术，开发Web应用程序的开放源码的framework。 采用Struts能开发出基于MVC(Model-View-Controller)设计模式的应用构架。 Struts有如下的主要功能： <br /> 一.包含一个controller servlet，能将用户的请求发送到相应的Action对象。 <br /> 二.JSP自由tag库，并且在controller servlet中提供关联支持，帮助开发员创建交互式表单应用。 <br /> 三.提供了一系列实用对象：XML处理、通过Java reflection APIs自动处理JavaBeans属性、国际化的提示和消息。</font></td> 
      </tr> 
     </tbody> 
    </table> </td> 
  </tr> 
  <tr> 
   <td height="17"> <p><font size="3">设计模式方面 <br /> 1、开发中都用到了那些设计模式?用在什么场合? <br /> 答：人们在自己的环境中不断发现问题和寻找问题的解决方案的时候，发现有一些问题及其解决方案不断变换面孔重复出现，但在这些不同的面孔后面有着共同的本质，这些共同的本质就是模式。设计模式就是用来描述解决这些问题的解决方案的核心的。 <br /> <br /> 工厂模式 <br /> 专门负责将大量有共同接口的类实例化。工厂模式可以动态确定将那一个类实例化，不必事先知道每次要实例化那一个类。 <br /> <br /> 简单工厂模式 <br /> 或称静态工厂方法模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式就是由一个工厂类根据传入的参数决定创建那一种产品类的实例。 <br /> 简单工厂模式涉及到工厂角色、抽象产品角色以及具体产品角色：l工厂类角色：含有与应用紧密相关的商业逻辑。工厂类在客户端的直接调用下创建产品对象。l抽象产品角色：担任这个角色的类是由工厂方法模式所创建的对象的父类，或它们共同拥有的接口。l具体产品角色：工厂方法模式所创建的任何对象都是这个角色的实例。 <br /> 优点是：允许客户端相对独立于产品创建的过程，并且在系统引入新产品的时候无需修改客户端。缺点是：如果有新的产品加入到系统中去，就需要修改工厂类，将必要的逻辑加入到工厂类中。 <br /> 工厂方法模式 <br /> 或称多态性工厂模式。工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。它仅负责给出具体工厂子类必须实现的接口。这样可以用来允许系统在不修改具体工厂角色的情况下引进新的产品。 <br /> 工厂方法模式涉及到的角色：l抽象工厂角色：它不包含应用逻辑。任何在模式中创建对象的工厂类必须实现这个接口。l具体工厂角色：含有与应用密切相关的逻辑，并且受到应用程序的调用以创建产品对象。l抽象产品角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。l具体产品角色：这个角色实现了抽象产品角色所声明的接口。 <br /> 单例模式 <br /> 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 <br /> 特点：单例类只能有一个实例；单例类必须自己创建自己的惟一的实例；单例类必须给所有其他对象提供这一实例。 <br /> 多例模式 <br /> 多例类可以有多个实例，并且多例类必须自己创建、管理自己的实例，并向外界提供自己的实例。 <br /> 在系统中可以用于数据库连接池、键值缓存等。 <br /> 代理模式 <br /> 给某个对象提供一个代理对象，并由代理对象控制对原对象的引用。 <br /> 代理模式所涉及的角色：抽象主题角色：声明了真实主题和代理主题的共同接口，这样一来在任何可以使用真实主题的地方都可以使用代理主题角色。 <br /> <br /> 名称 <br /> <br /> <br /> <br /> 2、UML方面 <br /> UML包括的图有：案例图、类图、序列图、合作图、状态图、活动图、构件图、部署图。 <br /> <br /> 类图中的关系有： <br /> 一般关系（类于类的继承关系、接口与接口的继承关系、类对接口的实现关系）； <br /> 关联关系：它使一个类知道另一个类的属性和方法。在java中，使用实例变量实现。 <br /> 聚合关系：是整体与个体之间的关系。也是使用实例变量实现。 <br /> 合成关系：是比聚合关系强的关系。它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。 <br /> 依赖关系：总是单向的。表示一个类依赖于另一个类的定义。 <br /> <br /> 3、软件的可维护性与可复用性 <br /> 一个好的系统设计应该有如下性质： <br /> 可扩展性：新的性能可以很容易地加入到系统中。 <br /> 灵活性：可以允许代码修改平稳地发生、而不会波及到很多其他的模块。 <br /> 可插入性：可以很容易地将一个类抽出去，同时将另一个有同样接口的类加入进来。 <br /> <br /> 在java中可以给出一个或多个抽象java类或java接口，规定出所有的具体类必须提供的方法特征作为系统设计的抽象层。这个抽象层预见了所有的可能扩展，因此，在任何扩展情况下都不会改变。</font></p> <p><font size="3">接口是实现构件的可插入性的关键。一个java接口是一些方法特征的集合，这些方法一般都是在系统经常出现的方法。一个接口只有方法的特征，没有方法的实现，因此在不同地方的该方法实现，可以具有不同的行为。 <br /> 接口是对可插入性的保证： <br /> 因为在类的关联中，如果一个关联不是针对一个具体类的，而是针对一个接口的，那么任何实现这个接口的类就都可以满足要求。当前对象并不在意所关联的是哪个具体类，而仅仅关心这个类是否实现了某个接口。这样一来，就可以动态地将这个关联从一个具体类转换到另一个具体类，而这样做的唯一条件是它们都实现某个接口。 <br /> <br /> 抽象类仅提供一个类型的部分实现。抽象类通常代表一个抽象概念，它提供一个继承的出发点。 <br /> javascript方面 <br /> 1、如何校验数字型? <br /> var re=/^\d{1,8}$|\.\d{1,2}$/; <br /> var str=document.form1.all(i).value; <br /> var r=str.match(re); <br /> if (r==null) { <br /> sign=-4; <br /> break; <br /> } else{ <br /> document.form1.all(i).value=parseFloat(str); <br /> } <br /> <br /> CORBA方面 <br /> 什么是RMI？ <br /> Java RMI（Remote Method Invocation）--Java的远程方法调用是Java所特有的分布式计算技术，它允许运行在一个Java虚拟机上的对象调用运行在另一个Java虚拟机上的对象的方法，从而使Java编程人员可以方便地在网络环境中作分布式计算。面向对象设计要求每个任务由最适合该任务的对象执行，RMI将这个概念更深入了一步，使任务可以在最适合该任务的机器上完成。 <br /> RMI定义了一组远程接口，可以用于生成远程对象。客户机可以象调用本地对象的方法一样用相同的语法调用远程对象。RMI API提供的类和方法可以处理所有访问远程方法的基础通信和参数引用要求的串行化。 <br /> 使用RMI开发步骤： <br /> 1、定义一个远程接口（远程接口必须继承接口，每个方法必须抛出远程异常，方法参数和方法返回值都必须是可序列化的） <br /> 2、实现远程接口 <br /> 3、定义使用远程对象的客户程序 <br /> 4、产生远程访问对象的桩和框 <br /> 5、注册远程对象 <br /> 6、运行服务器和客户程序 <br /> <br /> RMI和CORBA的区别？ <br /> 远程方法调用（RMI）和CORBA都是分布式计算技术，在进行分布式时各有其优缺点，CORBA和RMI的区别。 <br /> CORBA（Common Object Request Broker Architecture）是OMG的Object Management Architecture（对象管理结构），它是面向对象的分布式系统建立所依据的标准。CORBA被设计成一个能供所有编程语言使用的一个开放性说明，就是说一个机器上的Java客户可以要求另一个用SmallTalk或C++的机器服务。正是由于这种语言的独立性使得CORBA这么灵活和吸引人。为了适应语言独立性，CORBA采用了非常通用的标准作为其接口。在不同的语言中，远程调用、签名和对象的引入有各自不同的定义，所以CORBA必须尽可能的中立和开放。正是这种通用性是CORBA的一个弱点。当开发人员都采用CORBA时，他们要用一种新的标准定义语言接口，它要求开发者学习新的编程接口，从而减小了远程模型的透明性。 <br /> RMI是为仅在Java对Java的分布式计算中而开发的。远程调用的标准是为了Java和应用Java的自然Java签名和调用而开发的，这使得RMI对Java的开发者相当透明而且易于实现。RMI用Java语言紧密集成从而同CORBA相比能够提供非常好的容错能力及对异常的处理。尽管Java的RMI标准不像CORBA那样语言独立，但Java本身是一个独立的平台，这就使RMI在跨平台的分布软件开发中是一个很好的选择。 <br /> RMI是Java语言在分布式计算上的基本模型，很多Java的分布式系统，包括我们本章要涉及的EJB，都是建立在RMI的思想上的。 <br /> <br /> 基于IIOP协议的远程方法调用（RMI-IIOP） <br /> RMI是一个分布对象系统，允许java对象与运行在其他虚拟机上的java对象进行交互。使得可以象访问本地对象一样访问远程对象；只要获得一个远程对象的引用，就可以把这个对象看作如同运行在同一虚拟机上那样来调用它的方法。但RMI是一个仅限于Java的分布式对象系统，这个系统使用了一个java特有的传输协议，即java远程方法协议（JRMP），在客户端和服务器之间进行信息传输。然而，这也意味着使用这种协议只能访问其他java对象，而无法访问非java对象。 <br /> 远程方法调用的实际处理过程与CORBA的过程相似，即RMI使用客户端桩和服务器端框。要调用远程方法，客户端首先在桩上生成一个请求，然后将此请求传递给服务器，在服务器的框将请求转换成对远程对象的实际方法调用。客户端桩将远程方法的所有参数序列化后传递给服务器框，框将对参数反序列化。 <br /> 但是由于这种协议不支持EJB需要的企业级交互，因为在这种类型的交互中必须通过远程方法调用来传递事务和安全环境。为此sun公司创建了RMI-IIOP即基于因特网内部对象请求代理协议之上的远程方法调用。IIOP是一个用在CORBA对象请求代理间进行通信的协议，在IIOP之上的RMI同时具有RMI和CORBA技术的特点。 <br /> <br /> LINUX方面 <br /> 1、LINUX下线程，GDI类的解释。 <br /> 答：LINUX实现的就是基于核心轻量级进程的&quot;一对一&quot;线程模型，一个线程实体对应一个核心轻量级进程，而线程之间的管理在核外函数库中实现。 <br /> GDI类为图像设备编程接口类库。</font></p> </td> 
  </tr> 
 </tbody> 
</table></div></body></html>