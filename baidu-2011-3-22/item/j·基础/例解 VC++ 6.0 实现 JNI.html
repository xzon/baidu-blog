<html><head><title><div class="tit">
  例解 VC++ 6.0 实现 JNI
</div></title></head><body><div id='tit'>例解 VC++ 6.0 实现 JNI</div><div id='cate'>j&middot;基础</div><div id='date'>2009年08月25日 星期二 12:55 P.M.</div><div id='page'>35</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/d63f0c7b8a44a8fd0bd18765.html'>http://hi.baidu.com/hxzon/blog/item/d63f0c7b8a44a8fd0bd18765.html</a><div id='cnt'><h4>例解 VC++ 6.0 实现 JNI</h4> 
<hr color="#dfe0e3" /> 
<p>作者：<a href="http://gceclub.sun.com.cn/yuanchuang/week-15/jni.html#about">陈健明</a></p> 
<a name="about"></a> 
<h4>作者简介</h4> 
<br /> 
<p>陈健明，华中师范大学网络与通讯研究所，您可以通过<a href="mailto:chenjm2000@hotmail.com">chenjm2000@hotmail.com</a>和作者取得联系。</p> 
<h4>内容摘要</h4> 
<br /> 
<p>JNI是JDK的一部分，用于为Java提供一个本地代码的接口。通过使用JNI编写的程序能够确保你的代码能够完全的移植到所有的平台。JNI使得运行在JVM虚拟机上的Java代码能够操作使用其它语言编写的应用程序和库，比如C/C++以及汇编语言等。此外JNI提供的某些API还允许你把 JVM嵌入到本地应用程序中。下图表达了JNI所扮演的角色。</p> 
<p><img border="0" width="269" height="178" src="image/例解 VC++ 6.0 实现 JNI.h.jni-01.jpg" /><p class="origImg">http://gceclub.sun.com.cn/yuanchuang/week-15/jni-01.jpg</p></p> 
<p>本文将通过一个实例来阐述使用VC++6.0来实现JNI的完整过程。使用JNI来整合本地代码和Java代码的步骤是确定的，没有再创作的余地，所以读者可以通过本文的步骤来逐步认识到，其实Java也是&quot;没有什么不可以&quot;的。</p> 
<h4>一、JNI的实现</h4> 
<br /> 
<p>任务描述：在Java中调用windows下的消息框函数，并且从Java中传递一个字符串作为MessageBox函数的显示文本参数，显示在消息框的中间。下面让我们一起进入这一奇妙的旅程。</p> 
<p><strong>Step 1</strong>：写一个Java类，在这个类中包含了需要调用的本地方法的描述。</p> 
<table class="grey4 FCK__ShowTableBorders" border="0" cellspacing="0" cellpadding="10"> 
 <tbody> 
  <tr> 
   <td> <pre>//WinMsgBox.java package edu.netcom.jni; public class WinMsgBox   {  static{   System.loadLibrary(&quot;WinMsgDll&quot;);    // (1)  }  public native void showMsgBox(String str);  // (2) }</pre> </td> 
  </tr> 
 </tbody> 
</table> 
<br /> 
<p>(1)中WinMsgDll是动态链接文件的文件名，不用加扩展名，因为在不同的平台下动态链接文件扩展名是不同的，由JVM自动识别，比如在 Solaris下，会被转换为WinMsgDll.so；而Win32环境下会转换为WinMsgDll.dll。这个文件名必须和Step 4中生成的文件名一致。这个文件的存放位置也很重要，它只能被放在JVM属性值java.library.path中指定的文件夹中。这个属性值可以使用 System.getProperty(&quot;java.library.path&quot;);来查看。一般情况下，至少放在这几个位置是确定可靠的，windows安装目录下的system32下面，JDK安装目录下的bin下面，以及调用主类文件的当前目录。</p> 
<p>(2)中指明了你必须用本地代码实现的方法。</p> 
<p><strong>Step 2</strong>：提示符下使用命令javac -d . WinMsgBox.java编译Step 1编写的java文件。</p> 
<p>此时会在当前目录下建立一个edu\netcom\jni目录结构，并且一个WinMsgBox.class文件存在其中。</p> 
<p><strong>Step 3</strong>：提示符下使用命令javah -jni edu.netcom.jni.WinMsgBox，此时会在当前目录下产生一个edu_netcom_jni_WinMsgBox.h文件，注意这个文件名是由（包名+类名）组成，中间用（_）隔开。此文件内容如下：</p> 
<table class="grey4 FCK__ShowTableBorders" border="0" cellspacing="0" cellpadding="10"> 
 <tbody> 
  <tr> 
   <td> <pre>/* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt;                       // (1) /* Header for class edu_netcom_jni_WinMsgBox */  #ifndef _Included_edu_netcom_jni_WinMsgBox #define _Included_edu_netcom_jni_WinMsgBox #ifdef __cplusplus extern &quot;C&quot; { #endif /*  * Class:     edu_netcom_jni_WinMsgBox  * Method:    showMsgBox  * Signature: (Ljava/lang/String;)V       // (2)  */ JNIEXPORT void JNICALL Java_edu_netcom_jni_WinMsgBox_showMsgBox   (JNIEnv *, jobject, jstring);           // (3)  #ifdef __cplusplus } #endif #endif</pre> </td> 
  </tr> 
 </tbody> 
</table> 
<br /> 
<p>(1)包含的jni.h存在于JDK安装目录下的include下面。</p> 
<p>(2)(Ljava/lang/String;)V这是函数的标记符，当从本地方法端访问Java端的方法时，会用到这个标记符。JNI中为每种数据类型也定义了标记符，标记符的规则请查看JNI标准文档。</p> 
<p>(3)在WinMsgBox.java中本地方法void showMsgBox(String str);的定义，被映射为JNIEXPORT void JNICALL Java_edu_netcom_jni_WinMsgBox_showMsgBox(JNIEnv *, jobject, jstring); 其中函数名的映射规则是（Java_包名_类名_方法名），如果存在重载的方法，则在后面还会增加每个参数的标记符。每一个方法映射到本地C函数后都会增加两个参数：JNIEnv *和jobject，关于这两个参数的用法将在后面阐述。另外，所有Java中的数据类型都会按一定规则进行映射为本地数据类型，这些数据类型都是在 jni.h中定义的。下面分别按照基本数据类型，和对象类型列出。</p> 
<p>表1 Java基本类型到本地类型的映射</p> 
<p><img border="0" width="590" height="236" src="image/例解 VC++ 6.0 实现 JNI.h.jni-02.jpg" /><p class="origImg">http://gceclub.sun.com.cn/yuanchuang/week-15/jni-02.jpg</p></p> 
<p>表2 Java中的类到本地类型的映射</p> 
<p><img border="0" width="623" height="323" src="image/例解 VC++ 6.0 实现 JNI.h.jni-03.jpg" /><p class="origImg">http://gceclub.sun.com.cn/yuanchuang/week-15/jni-03.jpg</p></p> 
<p><strong>Step 4</strong>：使用VC来编写本地方法的实现函数，最后编译成.dll文件。过程如下：</p> 
<p>1) 选择new-&gt;projects(选择Win32 Dynamic-Link Library，以Step 1中指定的库名WinMsgDll作为工程名)-&gt;OK-&gt;An ampty DLL project-&gt;Finish。</p> 
<p>2) 选择Tools-&gt;Options-&gt;Directories(添加目录D:\J2SDK1.4.2_03\INCLUDE和D:\J2SDK1.4.2_03\INCLUDE\WIN32)。在这些目录中包含JNI所需的头文件。</p> 
<p>3) 将Step 3生成的edu_netcom_jni_WinMsgBox.h拷贝到WinMsgDll工程文件夹中。然后FileView中添加这个头文件。</p> 
<p>4) 添加源文件WinMsgDll.cpp，内容如下：</p> 
<table class="grey4 FCK__ShowTableBorders" border="0" cellspacing="0" cellpadding="10"> 
 <tbody> 
  <tr> 
   <td> <pre>#include &quot;windows.h&quot; #include &quot;edu_netcom_jni_WinMsgBox.h&quot; /*  * Class:     edu_netcom_jni_WinMsgBox  * Method:    showMsgBox  * Signature: (Ljava/lang/String;)V  */ JNIEXPORT void JNICALL Java_edu_netcom_jni_WinMsgBox_showMsgBox (JNIEnv * env, jobject obj, jstring str){  const char *msg;  msg = env-&gt;GetStringUTFChars(str,0);  MessageBox(NULL,msg,&quot;Java invoke&quot;,MB_OK);  env-&gt;ReleaseStringUTFChars(str,msg); }</pre> </td> 
  </tr> 
 </tbody> 
</table> 
<br /> 
<p>5) 编译生成WinMsgBox.dll文件。并将这个.dll文件拷贝到Step 1中说明的目录中。</p> 
<p><strong>注意：</strong></p> 
<p>1) 我们知道dll文件有两种指明导出函数的方法，一种是在.def文件中定义，另一种是在定义函数时使用关键字 __declspec(dllexport)。而在JNI中函数定义中的关键字JNIEXPORT实际在jni_md.h中如下定义，#define JNIEXPORT __declspec(dllexport)，可见JNI默认的导出函数使用第二种。使用第二种方式产生的导出函数名会根据编译器发生变化，在有的情况下会发生找不到导出函数的问题（我们在JSP中使用JNI时就发生了这种问题，百思不得其解，后来强行加入一个.def文件就解决了）。因此最好是使用第一种方法自己定义一个.def文件来指明导出函数，这种情况下会强制使用第一种方式产生导出函数。本例中可以加入一个WinMsgDll.def文件，内容如下：</p> 
<table class="grey4 FCK__ShowTableBorders" border="0" cellspacing="0" cellpadding="10"> 
 <tbody> 
  <tr> 
   <td> <pre>LIBRARY      &quot;WinMsgDll&quot; DESCRIPTION  'message Windows Dynamic Link Library' EXPORTS     ; Explicit exports can go here  Java_edu_netcom_jni_WinMsgBox_showMsgBox</pre> </td> 
  </tr> 
 </tbody> 
</table> 
<br /> 
<p>2) 从本例中，我们可以看到WinMsgBox.java决定了edu_netcom_jni_WinMsgBox.h，而后者又决定了 WinMsgDll.dll，也就是说，这是一个&quot;牵一发而动全身&quot;的过程，如果你改动了WinMsgBox.java，就一定要把整个步骤都走一遍（这一点一定要切记，因为这也是我们跌得鼻青脸肿后才得出的警世良言）。</p> 
<p>3) 生成的.dll文件一定要正确拷贝到Step 1说明的目录中，本例中是将生成的WinMsgDll.dll和Step 5中的测试文件放在同一个目录下的（这也是我们困惑了很久才解决的问题）。</p> 
<p><strong>Step 5</strong>：编写一个测试文件来测试对WinMsgDll.dll的调用。测试文件TestJNI.java内容如下：</p> 
<table class="grey4 FCK__ShowTableBorders" border="0" cellspacing="0" cellpadding="10"> 
 <tbody> 
  <tr> 
   <td> <pre>//TestJNI.java import edu.netcom.jni.WinMsgBox; public class TestJNI  {  public static void main(String[] args)   {        WinMsgBox box = new WinMsgBox();   box.showMsgBox(&quot;Wonderful!!&quot;);  } }</pre> </td> 
  </tr> 
 </tbody> 
</table> 
<br /> 
<p>编译，运行，windows下的对话框跃然屏幕中间。到此为此，整个JNI的实现过程就已经完成了。</p> 
<h4>二、补充说明</h4> 
<br /> 
<p>JNI为程序员提供了一种方法，使得他们能够充分利用JVM以外的，完全由平台决定的功能。但是你不应该滥用JNI。大多数情况可能是因为这样而必须使用JNI，如你已经有做好了的本地.dll文件，其中已经包含了大量呕心沥血的函数，而你不愿意，也不可能完全用Java重写它们，那么此时你应该用 JNI。但是你必须按前面的步骤来进行，只是在Step 4中编写的.dll要调用已有的本地.dll，也就是说用Step 4中的.dll&quot;封装&quot;已有的.dll。</p> 
<p>在Java中定义的本地方法映射到本地C函数后都会增加两个参数：JNIEnv *和jobject。第一个参数JNIEnv是一个指针，指向在jni.h中定义的一个数据结构，结构中包含了一系列的函数的指针，我们把它们称之为 JNI函数。使用这些JNI函数可以使程序员从本地函数这一侧完成对Java的操作，如访问Java字符串、数组、调用Java的方法、成员变量、甚至处理Java端的异常等。第二个参数会根据Java类中本地方法的定义不同而不同，如果是定义为static方法，类型会是jclass，表示对特定 Class对象的引用，如果是非static方法，类型是jobject，表示当前对象的引用（本例中就是对WinMsgBox对象的引用），相当于 this。</p> 
<p>C函数通过JNI接受来自Java的传参也是按基本类型直接传值，对象传引用。对于基本类型可以按照表1来使用，其它类型都必须使用JNI函数进行转换后才能在C函数中使用。如本例中从Java中传递了一个字符串，映射为JNI类型jstring。使用JNI函数GetStringUTFChars 将jstring转换为UTF-8字符串，然后便可以使用C语言中的任何字符串操作函数进行操作。由于JVM在调用本地方法时，是在虚拟机中开辟了一块本地方法栈供本地方法使用，当本地方法使用完UTF-8串后，必须使用ReleaseStringUTFChars，通过它来通知虚拟机去回收UTF-8串占用的内存，否则将会造成内存泄漏，最终导致系统崩溃。同样的，如果需要将C函数返回的返回值能够正确通过JNI传给Java，也要使用JNI函数转换为前面两个表中的类型。</p> 
<p>关于 JNI 函数的权威文档请参阅 <a href="http://java.sun.com/j2se/1.5.0/docs/guide/jni/spec/jniTOC.html">Java Native Interface 1.5 Specification</a><br /> <a href="http://gceclub.sun.com.cn/yuanchuang/week-15/jni.html">http://gceclub.sun.com.cn/yuanchuang/week-15/jni.html</a></p></div></body></html>