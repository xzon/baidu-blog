<html><head><title><div class="tit">
  跳马 (knights.pas) -算法设计-pascalcode
</div></title></head><body><div id='tit'>跳马 (knights.pas) -算法设计-pascalcode</div><div id='cate'>代码备份</div><div id='date'>2008年03月16日 星期日 09:12 P.M.</div><div id='page'>160</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/58b9b67e1f66ae3c0dd7daf2.html'>http://hi.baidu.com/hxzon/blog/item/58b9b67e1f66ae3c0dd7daf2.html</a><div id='cnt'><p>跳马 (knights.pas) -算法设计-pascalcode</p> 
<p><br /> 马周游棋盘，每个格子去且仅去一次。给定棋盘大小。 <br /> 输入：knights.in <br /> 一行p,q(p*q&lt;=26) p表示行数，q表示列数（行用数1..p表示，列用字母 A..Z表示） <br /> 输出：knights.out <br /> 一行，字典顺序最小的周游方案；若没有可行方案，输出impossible <br /> 样例 <br /> 输入： <br /> 1 1 <br /> 输出： <br /> A1 <br /> 输入 <br /> 2 3 <br /> 输出 <br /> impossible <br /> 输入 <br /> 4 3 <br /> 输出： <br /> A1B3C1A2B4C2A3B1C3A4B2C4<br /> <br /> 这里用最土的回朔法 <br /> 输入输出省略,只写算法 <br /> #define Max 26 <br /> int main(){ <br /> bool t; <br /> int p,q,i=1,j,move[Max*Max],tempx,tempym,cnt=0,result[Max*Max][2];; <br /> int mstep[8][2]={{1,2},{2,1},{-1,2},{2,-1},{1,-2},{-2,1},{-1,-2},{-2,- <br /> 1}}; <br /> p、q从文件读入略; <br /> move[1]=0;result[0][0]=1;result[0][1]=1; <br /> while(i&gt;0){ <br /> move[i]++; <br /> if (move[i]&gt;7) i-- else{ <br /> tempx = result[i-1][0]+mstep[move[i]][0]; <br /> tempy = result[i-1][1]+mstep[move[i]][1]; <br /> t = (tempx&gt;0&amp;&amp;tempx&lt;=q&amp;&amp;tempy&gt;0&amp;&amp;tempy&lt;=p); <br /> if (t) for (j=0;j&lt;i-1;j++){ <br /> if (tempx==result[j][0]&amp;&amp;tempy==result[j][1]) t=false; <br /> break; <br /> } <br /> if (t) { <br /> result[i][0] = tempx; <br /> result[i][1] = tempy; <br /> i++; <br /> if (i==p*q){ <br /> cnt++; <br /> 输出result数组到文件(注意数字字母转化); <br /> break;//如果除去这个则显示所有跳法 <br /> i--; <br /> } <br /> else move[i]=-1; <br /> } <br /> } <br /> } <br /> if (cnt==0) 输出impossible到文件; <br /> return 0; <br /> } <br /> 抱歉没看到是pascal，下面是pascal程序 <br /> delphi7.0测试通过 <br /> program knight; <br /> const <br /> Max=10; <br /> mstep:array[0..7,0..1] of integer <br /> =((1,2),(2,1),(-1,2),(2,-1),(1,-2),(-2,1),(-1,-2),(-2,-1)); <br /> var <br /> t:boolean; <br /> p,q,i,j,cnt,tempx,tempy:integer; <br /> move:array[1..Max*Max] of integer; <br /> res:array[0..Max*Max,0..1] of integer; <br /> begin <br /> //输入pq <br /> cnt := 0; i := 1; <br /> move[1]:=-1;res[0,0]:=1;res[0,1]:=1; <br /> while i&gt;0 do <br /> begin <br /> move[i] := move[i]+1; <br /> if move[i]&gt;7 then i:=i-1 else <br /> begin <br /> tempx := res[i-1,0]+mstep[move[i],0]; <br /> tempy := res[i-1,1]+mstep[move[i],1]; <br /> t := (tempx&gt;0) and (tempx&lt;=q) and (tempy&gt;0) and (tempy&lt;=p); <br /> if t then for j:=0 to i-2 do <br /> if (tempx=res[j,0]) and (tempy=res[j,1]) then <br /> begin <br /> t:=false; <br /> break; <br /> end; <br /> if t then <br /> begin <br /> res[i,0] := tempx; <br /> res[i,1] := tempy; <br /> i := i + 1; <br /> if i&gt;=p*q then <br /> begin <br /> cnt := cnt + 1; <br /> //输出正确结果 <br /> break;//如果除去这个则显示所有跳法 <br /> i := i-1; <br /> end <br /> else move[i]:=-1; <br /> end; <br /> end; <br /> end; <br /> if cnt=0 then //输出Impossable; <br /> end.</p></div></body></html>