<html><head><title><div class="tit">
  WARNING: firstResult/maxResults specified with collection fetch; applying in memory!
</div></title></head><body><div id='tit'>WARNING: firstResult/maxResults specified with collection fetch; applying in memory!</div><div id='cate'>出错&middot;经验</div><div id='date'>2010年08月31日 星期二 05:47 P.M.</div><div id='page'>8</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/ee87d22a426b1695023bf67c.html'>http://hi.baidu.com/hxzon/blog/item/ee87d22a426b1695023bf67c.html</a><div id='cnt'><p>WARNING: firstResult/maxResults specified with collection fetch; applying in memory!</p> 
<p>----------------------------------------</p> 
<p>hxzon:使用了join fetch p.items导致这个警告。</p> 
<p>----------------------------------------</p> 
<p>学习Hibernate时，经常会遇到Hibernate性能问题，这里将介绍Hibernate性能问题的解决方法。</p> 
<p>在使用Hibernate进行分页的过程中，如果你收到如下警告，那么这里就是一个潜在的Hibernate性能问题点：</p> 
<p>WARNING: firstResult/maxResults specified with collection fetch; applying in memory!</p> 出现这个警告的直接后果是：无论你想要看第几页的数据，从Hibernate打印出的SQL来看它总是查询了所有满足条件的结果。这是为什么呢？来看看这 句警告所在的代码，它位于org.hibernate.hql.ast.QueryTranslatorImpl.list中。 
<pre>public List list(SessionImplementor session, QueryParameters queryParameters)<br />   throws HibernateException {<br />  // Delegate to the QueryLoader...<br />  errorIfDML();<br />  QueryNode query = ( QueryNode ) sqlAst;<br />  boolean hasLimit = queryParameters.getRowSelection() != null &amp;&amp; queryParameters.getRowSelection().definesLimits();<br />  boolean needsDistincting = ( query.getSelectClause().isDistinct() || hasLimit ) &amp;&amp; containsCollectionFetches();<br /><br />  QueryParameters queryParametersToUse;<br />  if ( hasLimit &amp;&amp; containsCollectionFetches() ) {<br />   log.warn( &quot;firstResult/maxResults specified with collection fetch; applying in memory!&quot; );<br />   RowSelection selection = new RowSelection();<br />   selection.setFetchSize( queryParameters.getRowSelection().getFetchSize() );<br />   selection.setTimeout( queryParameters.getRowSelection().getTimeout() );<br />   queryParametersToUse = queryParameters.createCopyUsing( selection );<br />  }<br />  else {<br />   queryParametersToUse = queryParameters;<br />  }<br /><br />  List results = queryLoader.list( session, queryParametersToUse );<br /><br />  if ( needsDistincting ) {<br />   int includedCount = -1;<br />   // NOTE : firstRow is zero-based<br />   int first = !hasLimit || queryParameters.getRowSelection().getFirstRow() == null<br />      ? 0<br />      : queryParameters.getRowSelection().getFirstRow().intValue();<br />   int max = !hasLimit || queryParameters.getRowSelection().getMaxRows() == null<br />      ? -1<br />      : queryParameters.getRowSelection().getMaxRows().intValue();<br />   int size = results.size();<br />   List tmp = new ArrayList();<br />   IdentitySet distinction = new IdentitySet();<br />   for ( int i = 0; i &lt; size; i++ ) {<br />    final Object result = results.get( i );<br />    if ( !distinction.add( result ) ) {<br />     continue;<br />    }<br />    includedCount++;<br />    if ( includedCount &lt; first ) {<br />     continue;<br />    }<br />    tmp.add( result );<br />    // NOTE : ( max - 1 ) because first is zero-based while max is not...<br />    if ( max &gt;= 0 &amp;&amp; ( includedCount - first ) &gt;= ( max - 1 ) ) {<br />     break;<br />    }<br />   }<br />   results = tmp;<br />  }<br /><br />  return results;<br /> }</pre> 
<p>关键在于if ( hasLimit &amp;&amp; containsCollectionFetches() 这句判断，如果满足了这个条件，RowSelection将会被重新生成，原本分页需要的firstRow和maxRows属性将会丢失，后面的数据库分 页自然也无法进行。Hibernate这么做的原因从代码上也很容易理解，如果查询需要限制条数(limit/offset)并且需要fetch结合对 象，则重新生成RowSelection，进一步解释，就是当一个实体(A)和另一个实体(B)是One-To-Many关系的时候，一个需要fetch 的典型查询语句是“select distinct a from A a left join fetch a.b”，由于1个A可能对应多个B，这个时候数据库查询的结果条数和需要生成的A对象的条数可能不一致，所以无法利用数据库层的分页来实现，因为你真正 想分页的是A而不是A left join B。出现这个警告就是提醒你这个查询实际上是查询了所有满足条件的数据，Hibernate是在内存中对其进行了假分页的处理。</p> 
<p>这样，对于查询结果比较多的情况无疑是一个Hibernate性能上的潜在威胁。碰到这样的情况，将Many的查询进行分开也是一种解决办法。</p></div></body></html>