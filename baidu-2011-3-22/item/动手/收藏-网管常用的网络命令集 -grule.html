<html><head><title><div class="tit">
  收藏:网管常用的网络命令集 -grule
</div></title></head><body><div id='tit'>收藏:网管常用的网络命令集 -grule</div><div id='cate'>动手</div><div id='date'>2007年11月27日 星期二 04:32 P.M.</div><div id='page'>202</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/2e77e1116c7cb1c5a6ef3f26.html'>http://hi.baidu.com/hxzon/blog/item/2e77e1116c7cb1c5a6ef3f26.html</a><div id='cnt'><div>
 收藏:网管常用的网络命令集 -grule
</div> 
<div> 
</div> 
<div>
 <br /> 如果你玩过路由器的话，就知道路由器里面那些很好玩的命令缩写。
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div>
  例如，&quot;sh int&quot; 的意思是 &quot;show interface&quot;。
</div> 
<div> 
</div> 
<div>
  现在 Windows 2000 也有了类似界面的工具，叫做 netsh。
</div> 
<div> 
</div> 
<div>
  我们在 Windows 2000 的 cmd shell 下，输入 netsh 
 <br /> 就出来：netsh&gt; 提示符， 
 <br /> 输入 int ip 就显示： 
 <br /> interface ip&gt;
</div> 
<div> 
</div> 
<div>
  然后输入 dump ，我们就可以看到当前系统的网络配置：
</div> 
<div> 
</div> 
<div>
  # ----------------------------------
</div> 
<div> 
</div> 
<div>
  # Interface IP Configuration
</div> 
<div> 
</div> 
<div>
  # ----------------------------------
</div> 
<div> 
</div> 
<div>
  pushd interface ip
</div> 
<div> 
</div> 
<div>
 <br /> # Interface IP Configuration for &quot;Local Area Connection&quot;
</div> 
<div> 
</div> 
<div>
  set address name = &quot;Local Area Connection&quot; source = static addr = 192.168.1.168 
 <br /> mask = 255.255.255.0 
 <br /> add address name = &quot;Local Area Connection&quot; addr = 192.1.1.111 mask = 255.255.255.0 
 <br /> set address name = &quot;Local Area Connection&quot; gateway = 192.168.1.100 gwmetric = 1 
 <br /> set dns name = &quot;Local Area Connection&quot; source = static addr = 202.96.209.5 
 <br /> set wins name = &quot;Local Area Connection&quot; source = static addr = none
</div> 
<div> 
</div> 
<div>
 <br /> popd 
 <br /> # End of interface IP configuration
</div> 
<div> 
</div> 
<div>
  上面介绍的是通过交互方式操作的一种办法。 
 <br /> 我们可以直接输入命令： 
 <br /> &quot;netsh interface ip add address &quot;Local Area Connection&quot; 10.0.0.2 255.0.0.0&quot; 
 <br /> 来添加 IP 地址。
</div> 
<div> 
</div> 
<div>
  如果不知道语法，不要紧的哦！ 
 <br /> 在提示符下，输入 ? 就可以找到答案了。方便不方便啊？ 
 <br /> 原来微软的东西里面，也有那么一些让人喜欢的玩意儿。可惜，之至者甚少啊！
</div> 
<div> 
</div> 
<div>
 <br /> Windows网络命令行程序 
 <br /> 这部分包括：
</div> 
<div> 
</div> 
<div>
  使用 ipconfig /all 查看配置 
 <br /> 使用 ipconfig /renew 刷新配置 
 <br /> 使用 ipconfig 管理 DNS 和 DHCP 类别 ID 
 <br /> 使用 Ping 测试连接 
 <br /> 使用 Arp 解决硬件地址问题 
 <br /> 使用 nbtstat 解决 NetBIOS 名称问题 
 <br /> 使用 netstat 显示连接统计 
 <br /> 使用 tracert 跟踪网络连接 
 <br /> 使用 pathping 测试路由器 
 <br /> 使用 ipconfig /all 查看配置 
 <br /> 发现和解决 TCP/IP 网络问题时，先检查出现问题的计算机上的 TCP/IP 配置。可以使用 ipconfig 命令获得主机配置信息，包括 IP 地址、子网掩码和默认网关。
</div> 
<div> 
</div> 
<div>
  注意
</div> 
<div> 
</div> 
<div>
  对于 Windows 95 和 Windows 98 的客户机，请使用 winipcfg 命令而不是 ipconfig 命令。 
 <br /> 使用带 /all 选项的 ipconfig 命令时，将给出所有接口的详细配置报告，包括任何已配置的串行端口。 使用 ipconfig /all，可以将命令输出重定向到某个文件，并将输出粘贴到其他文档中。也可以用该输出确认网络上每台计算机的 TCP/IP 配置，或者进一步调查 TCP/IP 网络问题。
</div> 
<div> 
</div> 
<div>
  例如，如果计算机配置的 IP 地址与现有的 IP 地址重复，则子网掩码显示为 0.0.0.0。
</div> 
<div> 
</div> 
<div>
  下面的范例是 ipconfig /all 命令输出，该计算机配置成使用 DHCP 服务器动态配置TCP/IP，并使用WINS 和 DNS 服务器解析名称。
</div> 
<div> 
</div> 
<div>
  Windows 2000 IP Configuration
</div> 
<div> 
</div> 
<div>
  Node Type.. . . . . . . . : Hybrid 
 <br /> IP Routing Enabled.. . . . : No 
 <br /> WINS Proxy Enabled.. . . . : No
</div> 
<div> 
</div> 
<div>
  Ethernet adapter Local Area Connection:
</div> 
<div> 
</div> 
<div>
  Host Name.. . . . . . . . : corp1.microsoft.com 
 <br /> DNS Servers . . . . . . . : 10.1.0.200 
 <br /> Description. . . . . . . : 3Com 3C90x Ethernet Adapter 
 <br /> Physical Address. . . . . : 00-60-08-3E-46-07 
 <br /> DHCP Enabled.. . . . . . . : Yes 
 <br /> Autoconfiguration Enabled.: Yes 
 <br /> IP Address. . . . . . . . . : 192.168.0.112 
 <br /> Subnet Mask. . . . . . . . : 255.255.0.0 
 <br /> Default Gateway. . . . . . : 192.168.0.1 
 <br /> DHCP Server. . . . . . . . : 10.1.0.50 
 <br /> Primary WINS Server. . . . : 10.1.0.101 
 <br /> Secondary WINS Server. . . : 10.1.0.102 
 <br /> Lease Obtained.. . . . . . : Wednesday, September 02, 1998 10:32:13 AM 
 <br /> Lease Expires.. . . . . . : Friday, September 18, 1998 10:32:13 AM
</div> 
<div> 
</div> 
<div>
  如果 TCP/IP 配置没有问题，下一步测试能够连接到 TCP/IP 网络上的其他主机。
</div> 
<div> 
</div> 
<div>
  使用 ipconfig /renew 刷新配置 
 <br /> 解决 TCP/IP 网络问题时，先检查遇到问题的计算机上的 TCP/IP 配置。如果计算机启用 DHCP 并使用 DHCP 服务器获得配置，请使用 ipconfig /renew 命令开始刷新租约。
</div> 
<div> 
</div> 
<div>
  使用 ipconfig /renew 时，使用 DHCP 的计算机上的所有网卡（除了那些手动配置的适配器）都尽量连接到DHCP 服务器，更新现有配置或者获得新配置。
</div> 
<div> 
</div> 
<div>
  也可以使用带 /release 选项的 ipconfig 命令立即释放主机的当前 DHCP 配置。有关 DHCP 和租用过程的详细信息，请参阅客户机如何获得配置。
</div> 
<div> 
</div> 
<div>
  注意
</div> 
<div> 
</div> 
<div>
  对于启用 DHCP 的 Windows 95 和 Windows 98 客户，请使用 winipcfg 命令的 release 和 renew 选项，而不是 ipconfig /release 和 ipconfig /renew 命令，手动释放或更新客户的 IP 配置租约。 
 <br /> 使用 ipconfig 管理 DNS 和 DHCP 类别 ID 
 <br /> 也可以使用 ipconfig 命令：
</div> 
<div> 
</div> 
<div>
  显示或重置 DNS 缓存。 
 <br /> 详细信息，请参阅使用 ipconfig 查看或重置客户解析程序缓存。
</div> 
<div> 
</div> 
<div>
  刷新已注册的 DNS 名称。 
 <br /> 详细信息，请参阅使用 ipconfig 更新 DNS 客户注册。
</div> 
<div> 
</div> 
<div>
  显示适配器的 DHCP 类别 ID。 
 <br /> 详细信息，请参阅显示客户机上的 DHCP 类别 ID 信息。
</div> 
<div> 
</div> 
<div>
  设置适配器的 DHCP 类别 ID。 
 <br /> 详细信息，请参阅设置客户机上的 DHCP 类别 ID 信息。
</div> 
<div> 
</div> 
<div>
  使用 Ping 测试连接 
 <br /> Ping 命令有助于验证 IP 级的连通性。发现和解决问题时，可以使用 Ping 向目标主机名或 IP 地址发送 ICMP 回应请求。需要验证主机能否连接到 TCP/IP 网络和网络资源时，请使用 Ping。也可以使用 Ping 隔离网络硬件问题和不兼容配置。
</div> 
<div> 
</div> 
<div>
  通常最好先用 Ping 命令验证本地计算机和网络主机之间的路由是否存在，以及要连接的网络主机的 IP 地址。Ping 目标主机的IP 地址看它是否响应，如下：
</div> 
<div> 
</div> 
<div>
  ping IP_address
</div> 
<div> 
</div> 
<div>
  使用 Ping 时应该执行以下步骤：
</div> 
<div> 
</div> 
<div>
  Ping 环回地址验证是否在本地计算机上安装 TCP/IP 以及配置是否正确。 
 <br /> ping 127.0.0.1
</div> 
<div> 
</div> 
<div>
  Ping 本地计算机的 IP 地址验证是否正确地添加到网络。 
 <br /> ping IP_address_of_local_host
</div> 
<div> 
</div> 
<div>
  Ping 默认网关的 IP 地址验证默认网关是否运行以及能否与本地网络上的本地主机通讯。 
 <br /> ping IP_address_of_default_gateway
</div> 
<div> 
</div> 
<div>
  Ping 远程主机的 IP 地址验证能否通过路由器通讯。 
 <br /> ping IP_address_of_remote_host
</div> 
<div> 
</div> 
<div>
  Ping 命令用 Windows 套接字样式的名称解析将计算机名解析成 IP 地址，所以如果用地址成功，但是用名称 Ping 失败，则问题出在地址或名称解析上，而不是网络连通性的问题。详细信息，请参阅使用 Arp 解决硬件地址问题。
</div> 
<div> 
</div> 
<div>
  如果在任何点上都无法成功地使用 Ping，请确认：
</div> 
<div> 
</div> 
<div>
  安装和配置 TCP/IP 之后重新启动计算机。 
 <br /> “Internet 协议 (TCP/IP) 属性”对话框“常规”选项卡上的本地计算机的 IP 地址有效而且正确。 
 <br /> 启用 IP 路由，并且路由器之间的链路是可用的。 
 <br /> 您可以使用 Ping 命令的不同选项来指定要使用的数据包大小、要发送多少数据包、是否记录用过的路由、要使用的生存时间 (TTL) 值以及是否设置“不分段”标志。可以键入 ping -? 查看这些选项。
</div> 
<div> 
</div> 
<div>
  下例说明如何向 IP 地址 172.16.48.10 发送两个 Ping，每个都是 1,450 字节：
</div> 
<div> 
</div> 
<div>
  C:\&gt;ping -n 2 -l 1450 172.16.48.10 
 <br /> Pinging 172.16.48.10 with 1450 bytes of data:
</div> 
<div> 
</div> 
<div>
  Reply from 172.16.48.10:bytes=1450 time&lt;10ms TTL=32 
 <br /> Reply from 172.16.48.10:bytes=1450 time&lt;10ms TTL=32
</div> 
<div> 
</div> 
<div>
  Ping statistics for 157.59.8.1: 
 <br /> Packets:Sent = 2, Received = 2, Lost = 0 (0% loss), 
 <br /> Approximate roundtrip times in milli-seconds: 
 <br /> Minimum = 0ms, Maximum = 10ms, Average = 2ms 
 <br /> 默认情况下，在显示“请求超时”之前，Ping 等待 1,000 毫秒（1 秒）的时间让每个响应返回。如果通过 Ping 探测的远程系统经过长时间延迟的链路，如卫星链路，则响应可能会花更长的时间才能返回。可以使用 -w （等待）选项指定更长时间的超时。
</div> 
<div> 
</div> 
<div>
  使用 Arp 解决硬件地址问题 
 <br /> “地址解析协议 (ARP)”允许主机查找同一物理网络上的主机的媒体访问控制地址，如果给出后者的 IP 地址。为使 ARP 更加有效，每个计算机缓存 IP 到媒体访问控制地址映射消除重复的 ARP 广播请求。
</div> 
<div> 
</div> 
<div>
  可以使用 arp 命令查看和修改本地计算机上的 ARP 表项。arp 命令对于查看 ARP 缓存和解决地址解析问题非常有用。
</div> 
<div> 
</div> 
<div>
  详细信息，请参阅查看“地址解析协议 (ARP)”缓存和添加静态 ARP 缓存项目。
</div> 
<div> 
</div> 
<div>
  使用 nbtstat 解决 NetBIOS 名称问题 
 <br /> TCP/IP 上的 NetBIOS (NetBT) 将 NetBIOS 名称解析成 IP 地址。TCP/IP 为 NetBIOS 名称解析提供了很多选项，包括本地缓存搜索、WINS 服务器查询、广播、DNS 服务器查询以及 Lmhosts 和主机文件搜索。
</div> 
<div> 
</div> 
<div>
  Nbtstat 是解决 NetBIOS 名称解析问题的有用工具。可以使用nbtstat 命令删除或更正预加载的项目：
</div> 
<div> 
</div> 
<div>
  nbtstat -n 显示由服务器或重定向器之类的程序在系统上本地注册的名称。 
 <br /> nbtstat -c 显示 NetBIOS 名称缓存，包含其他计算机的名称对地址映射。 
 <br /> nbtstat -R 清除名称缓存，然后从 Lmhosts 文件重新加载。 
 <br /> nbtstat -RR 释放在 WINS 服务器上注册的 NetBIOS 名称，然后刷新它们的注册。 
 <br /> nbtstat -a name 对 name 指定的计算机执行 NetBIOS 适配器状态命令。适配器状态命令将返回计算机的本地 NetBIOS 名称表，以及适配器的媒体访问控制地址。 
 <br /> nbtstat -S 列出当前的 NetBIOS 会话及其状态（包括统计），如下例所示： 
 <br /> NetBIOS connection table
</div> 
<div> 
</div> 
<div>
  Local name State In/out Remote Host Input Output 
 <br /> ------------------------------------------------------------------ 
 <br /> CORP1 &lt;00&gt; Connected Out CORPSUP1&lt;20&gt; 6MB 5MB 
 <br /> CORP1 &lt;00&gt; Connected Out CORPPRINT&lt;20&gt; 108KB 116KB 
 <br /> CORP1 &lt;00&gt; Connected Out CORPSRC1&lt;20&gt; 299KB 19KB 
 <br /> CORP1 &lt;00&gt; Connected Out CORPEMAIL1&lt;20&gt; 324KB 19KB 
 <br /> CORP1 &lt;03&gt; Listening 
 <br /> 使用 netstat 显示连接统计 
 <br /> 可以使用 netstat 命令显示协议统计信息和当前的 TCP/IP 连接。netstat -a 命令将显示所有连接，而 netstat -r 显示路由表和活动连接。netstat -e 命令将显示Ethernet 统计信息，而 netstat -s 显示每个协议的统计信息。如果使用 netstat -n，则不能将地址和端口号转换成名称。下面是 netstat 的输出示例：
</div> 
<div> 
</div> 
<div>
  C:\&gt;netstat -e 
 <br /> Interface Statistics
</div> 
<div> 
</div> 
<div>
  Received Sent 
 <br /> Bytes 3995837940 47224622 
 <br /> Unicast packets 120099 131015 
 <br /> Non-unicast packets 7579544 3823 
 <br /> Discards 0 0 
 <br /> Errors 0 0 
 <br /> Unknown protocols 363054211
</div> 
<div> 
</div> 
<div>
  C:\&gt;netstat -a
</div> 
<div> 
</div> 
<div>
  Active Connections
</div> 
<div> 
</div> 
<div>
  Proto Local Address Foreign Address State 
 <br /> TCP CORP1:1572 172.16.48.10:nbsession ESTABLISHED 
 <br /> TCP CORP1:1589 172.16.48.10:nbsession ESTABLISHED 
 <br /> TCP CORP1:1606 172.16.105.245:nbsession ESTABLISHED 
 <br /> TCP CORP1:1632 172.16.48.213:nbsession ESTABLISHED 
 <br /> TCP CORP1:1659 172.16.48.169:nbsession ESTABLISHED 
 <br /> TCP CORP1:1714 172.16.48.203:nbsession ESTABLISHED 
 <br /> TCP CORP1:1719 172.16.48.36:nbsession ESTABLISHED 
 <br /> TCP CORP1:1241 172.16.48.101:nbsession ESTABLISHED 
 <br /> UDP CORP1:1025 *:* 
 <br /> UDP CORP1:snmp *:* 
 <br /> UDP CORP1:nbname *:* 
 <br /> UDP CORP1:nbdatagram *:* 
 <br /> UDP CORP1:nbname *:* 
 <br /> UDP CORP1:nbdatagram *:*
</div> 
<div> 
</div> 
<div>
  C:\&gt;netstat -s 
 <br /> IP Statistics
</div> 
<div> 
</div> 
<div>
  Packets Received = 5378528 
 <br /> Received Header Errors = 738854 
 <br /> Received Address Errors = 23150 
 <br /> Datagrams Forwarded = 0 
 <br /> Unknown Protocols Received = 0 
 <br /> Received Packets Discarded = 0 
 <br /> Received Packets Delivered = 4616524 
 <br /> Output Requests = 132702 
 <br /> Routing Discards = 157 
 <br /> Discarded Output Packets = 0 
 <br /> Output Packet No Route = 0 
 <br /> Reassembly Required = 0 
 <br /> Reassembly Successful = 0 
 <br /> Reassembly Failures = 
 <br /> Datagrams Successfully Fragmented = 0 
 <br /> Datagrams Failing Fragmentation = 0 
 <br /> Fragments Created = 0
</div> 
<div> 
</div> 
<div>
  ICMP Statistics 
 <br /> Received Sent 
 <br /> Messages 693 4 
 <br /> Errors 0 0 
 <br /> Destination Unreachable 685 0 
 <br /> Time Exceeded 0 0 
 <br /> Parameter Problems 0 0 
 <br /> Source Quenches 0 0 
 <br /> Redirects 0 0 
 <br /> Echoes 4 0 
 <br /> Echo Replies 0 4 
 <br /> Timestamps 0 0 
 <br /> Timestamp Replies 0 0 
 <br /> Address Masks 0 0 
 <br /> Address Mask Replies 0 0
</div> 
<div> 
</div> 
<div>
  TCP Statistics
</div> 
<div> 
</div> 
<div>
  Active Opens = 597 
 <br /> Passive Opens = 135 
 <br /> Failed Connection Attempts = 107 
 <br /> Reset Connections = 91 
 <br /> Current Connections = 8 
 <br /> Segments Received = 106770 
 <br /> Segments Sent = 118431 
 <br /> Segments Retransmitted = 461
</div> 
<div> 
</div> 
<div>
  UDP Statistics
</div> 
<div> 
</div> 
<div>
  Datagrams Received = 4157136 
 <br /> No Ports = 351928 
 <br /> Receive Errors = 2 
 <br /> Datagrams Sent = 13809
</div> 
<div> 
</div> 
<div>
  使用 tracert 跟踪网络连接 
 <br /> Tracert（跟踪路由）是路由跟踪实用程序，用于确定 IP 数据报访问目标所采取的路径。Tracert 命令用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由。
</div> 
<div> 
</div> 
<div>
  Tracert 工作原理 
 <br /> 通过向目标发送不同 IP 生存时间 (TTL) 值的“Internet 控制消息协议 (ICMP)”回应数据包， Tracert 诊断程序确定到目标所采取的路由。要求路径上的每个路由器在转发数据包之前至少将数据包上的 TTL 递减 1。数据包上的 TTL 减为 0 时，路由器应该将“ICMP 已超时”的消息发回源系统。
</div> 
<div> 
</div> 
<div>
  Tracert 先发送 TTL 为 1 的回应数据包，并在随后的每次发送过程将 TTL 递增 1，直到目标响应或 TTL 达到最大值，从而确定路由。通过检查中间路由器发回的“ICMP 已超时”的消息确定路由。某些路由器不经询问直接丢弃 TTL 过期的数据包，这在Tracert 实用程序中看不到。
</div> 
<div> 
</div> 
<div>
  Tracert 命令按顺序打印出返回“ICMP 已超时”消息的路径中的近端路由器接口列表。如果使用 -d 选项，则 Tracert 实用程序不在每个 IP 地址上查询 DNS。
</div> 
<div> 
</div> 
<div>
  在下例中，数据包必须通过两个路由器（10.0.0.1 和 192.168.0.1）才能到达主机172.16.0.99。主机的默认网关是 10.0.0.1，192.168.0.0 网络上的路由器的 IP地址是 192.168.0.1。
</div> 
<div> 
</div> 
<div>
  C:\&gt;tracert 172.16.0.99 -d 
 <br /> Tracing route to 172.16.0.99 over a maximum of 30 hops 
 <br /> 1 2s 3s 2s 10,0.0,1 
 <br /> 2 75 ms 83 ms 88 ms 192.168.0.1 
 <br /> 3 73 ms 79 ms 93 ms 172.16.0.99 
 <br /> Trace complete. 
 <br /> 用 tracert 解决问题 
 <br /> 可以使用 tracert 命令确定数据包在网络上的停止位置。下例中，默认网关确定 192.168.10.99 主机没有有效路径。这可能是路由器配置的问题，或者是 192.168.10.0 网络不存在（错误的 IP 地址）。
</div> 
<div> 
</div> 
<div>
  C:\&gt;tracert 192.168.10.99
</div> 
<div> 
</div> 
<div>
  Tracing route to 192.168.10.99 over a maximum of 30 hops
</div> 
<div> 
</div> 
<div>
  1 10.0.0.1 reportsestination net unreachable.
</div> 
<div> 
</div> 
<div>
  Trace complete.
</div> 
<div> 
</div> 
<div>
  Tracert 实用程序对于解决大网络问题非常有用，此时可以采取几条路径到达同一个点。
</div> 
<div> 
</div> 
<div>
  Tracert 命令行选项 
 <br /> Tracert 命令支持多种选项，如下表所示。
</div> 
<div> 
</div> 
<div>
  tracert [-d] [-h maximum_hops] [-j host-list] [-w timeout] target_name
</div> 
<div> 
</div> 
<div>
  选项 描述 
 <br /> -d 指定不将 IP 地址解析到主机名称。 
 <br /> -h maximum_hops 指定跃点数以跟踪到称为 target_name 的主机的路由。 
 <br /> -j host-list 指定 Tracert 实用程序数据包所采用路径中的路由器接口列表。 
 <br /> -w timeout 等待 timeout 为每次回复所指定的毫秒数。 
 <br /> target_name 目标主机的名称或 IP地址。
</div> 
<div> 
</div> 
<div>
  详细信息，请参阅使用 tracert 命令跟踪路径。
</div> 
<div> 
</div> 
<div>
  使用 pathping 测试路由器 
 <br /> pathping 命令是一个路由跟踪工具，它将 ping 和 tracert 命令的功能和这两个工具所不提供的其他信息结合起来。pathping 命令在一段时间内将数据包发送到到达最终目标的路径上的每个路由器，然后基于数据包的计算机结果从每个跃点返回。由于命令显示数据包在任何给定路由器或链接上丢失的程度，因此可以很容易地确定可能导致网络问题的路由器或链接。某些选项是可用的，如下表所示。
</div> 
<div> 
</div> 
<div>
  选项 名称 功能 
 <br /> -n Hostnames 不将地址解析成主机名。 
 <br /> -h Maximum hops 搜索目标的最大跃点数。 
 <br /> -g Host-list 沿着路由列表释放源路由。 
 <br /> -p Period 在 ping 之间等待的毫秒数。 
 <br /> -q Num_queries 每个跃点的查询数。 
 <br /> -w Time-out 为每次回复所等待的毫秒数。 
 <br /> -T Layer 2 tag 将第 2 层优先级标记（例如，对于 IEEE 802.1p）连接到数据包并将它发送到路径中的每个网络设备。这有助于标识没有正确配置第 2 层优先级的网络设备。-T 开关用于测试服务质量 (QoS) 连通性。 
 <br /> -R RSVP isbase Che检查以确定路径中的每个路由器是否支持“资源保留协议 (RSVP)”，此协议允许主机为数据流保留一定量的带宽。 -R 开关用于测试服务质量 (QoS) 连通性。
</div> 
<div> 
</div> 
<div>
  默认的跃点数是 30，并且超时前的默认等待时间是 3 秒。默认时间是 250 毫秒，并且沿着路径对每个路由器进行查询的次数是 100。
</div> 
<div> 
</div> 
<div>
  以下是典型的 pathping 报告。跃点列表后所编辑的统计信息表明在每个独立路由器上数据包丢失的情况。
</div> 
<div> 
</div> 
<div>
 <br /> D:\&gt;pathping -n msw
</div> 
<div> 
</div> 
<div>
  Tracing route to msw [7.54.1.196] 
 <br /> over a maximum of 30 hops: 
 <br /> 0 172.16.87.35 
 <br /> 1 172.16.87.218 
 <br /> 2 192.68.52.1 
 <br /> 3 192.68.80.1 
 <br /> 4 7.54.247.14 
 <br /> 5 7.54.1.196
</div> 
<div> 
</div> 
<div>
  Computing statistics for 125 seconds... 
 <br /> Source to Here This Node/Link 
 <br /> Hop RTT Lost/Sent = Pct Lost/Sent = Pct Address 
 <br /> 0 172.16.87.35 
 <br /> 0/ 100 = 0% | 
 <br /> 1 41ms 0/ 100 = 0% 0/ 100 = 0% 172.16.87.21813/ 100 = 13% | 
 <br /> 2 22ms 16/ 100 = 16% 3/ 100 = 3% 192.68.52.10/ 100 = 0% | 
 <br /> 3 24ms 13/ 100 = 13% 0/ 100 = 0% 192.68.80.1 0/ 100 = 0% | 
 <br /> 4 21ms 14/ 100 = 14% 1/ 100 = 1% 10.54.247.14 0/ 100 = 0% | 
 <br /> 5 24ms 13/ 100 = 13% 0/ 100 = 0% 10.54.1.196
</div> 
<div> 
</div> 
<div>
  Trace complete.
</div> 
<div> 
</div> 
<div>
  当运行 pathping 时，在测试问题时首先查看路由的结果。此路径与 tracert 命令所显示的路径相同。然后 pathping 命令对下一个 125 毫秒显示忙消息（此时间根据跃点计数变化）。在此期间，pathping 从以前列出的所有路由器和它们之间的链接之间收集信息。在此期间结束时，它显示测试结果。
</div> 
<div> 
</div> 
<div>
  最右边的两栏 This Node/Link Lost/Sent=Pct 和 Address 包含的信息最有用。172.16.87.218（跃点 1）和 192.68.52.1（跃点 2）丢失 13% 的数据包。 所有其他链接工作正常。在跃点 2 和 4 中的路由器也丢失寻址到它们的数据包（如 This Node /Link 栏中所示），但是该丢失不会影响转发的路径。
</div> 
<div> 
</div> 
<div>
 对链接显示的丢失率（在最右边的栏中标记为 |）表明沿路径转发丢失的数据包。该丢失表明链接阻塞。对路由器显示的丢失率（通过最右边栏中的 IP 地址显示）表明这些路由器的 CPU 可能超负荷运行。这些阻塞的路由器可能也是端对端问题的一个因素，尤其是在软件路由器转发数据包时。
</div> 
<div> 
</div> 
<div> 
</div></div></body></html>