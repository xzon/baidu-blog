<html><head><title><div class="tit">
  操作系统页面置换算法模拟-C++源代码
</div></title></head><body><div id='tit'>操作系统页面置换算法模拟-C++源代码</div><div id='cate'>存档&middot;垃圾</div><div id='date'>2008年01月18日 星期五 10:45 P.M.</div><div id='page'>178</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/809caaaf46f5ebc87cd92ab3.html'>http://hi.baidu.com/hxzon/blog/item/809caaaf46f5ebc87cd92ab3.html</a><div id='cnt'><h1>操作系统页面置换算法模拟-C++源代码</h1> 
<p>#include &lt;stdio.h&gt;<br /> <br /> int work[20];<br /> int pos=0;<br /> struct Page{<br /> int id;<br /> int cout;<br /> }page[3];<br /> <br /> int max() //找出在内存中存在时间最长的或最长未用的页面<br /> {<br /> int m=-1,t,MAX;<br /> for(t=0;t&lt;3;t++)<br /> if(m&lt;page[t].cout)<br /> {<br /> m=page[t].cout;<br /> MAX=t;<br /> }<br /> return MAX;<br /> }<br /> <br /> int check(int i) //查询当前访问页面是否在内存中<br /> {<br /> int t;<br /> for(t=0;t&lt;pos;t++)<br /> if(work[i]==page[t].id)return t;<br /> if(t==pos)return -1;<br /> }<br /> <br /> int find(int p,int i) //理想算法中找出内存页面在以后被访问的时间<br /> {<br /> for(;i&lt;20;i++)<br /> if(page[p].id==work[i])return i;<br /> if(i==20)<br /> return 20;<br /> }<br /> <br /> void fifo() //先进先出<br /> {<br /> int i,j;<br /> for(i=0;i&lt;20;i++)<br /> {<br /> if(pos&lt;3)<br /> {<br /> if(check(i)==-1)<br /> {<br /> page[pos].id=work[i];<br /> page[pos].cout=0;<br /> pos++;<br /> }<br /> for(j=0;j&lt;=pos;j++)<br /> page[j].cout+=1;<br /> }<br /> else<br /> {<br /> if(check(i)==-1)<br /> {<br /> j=max();<br /> page[j].id=work[i];<br /> page[j].cout=0;<br /> }<br /> for(j=0;j&lt;3;j++)<br /> page[j].cout+=1;<br /> }<br /> printf(&quot;%d|&quot;,work[i]);<br /> for(j=0;j&lt;pos;j++)<br /> printf(&quot;%d &quot;,page[j].id);<br /> printf(&quot;\n&quot;);<br /> }<br /> }<br /> <br /> void longest() //最近最久未使用<br /> {<br /> int i,j;<br /> for(i=0;i&lt;20;i++)<br /> {<br /> if(pos&lt;3)<br /> {<br /> if(check(i)==-1)<br /> {<br /> page[pos].id=work[i];<br /> page[pos].cout=0;<br /> pos++;<br /> }<br /> else<br /> page[check(i)].cout=0;<br /> for(j=0;j&lt;=pos;j++)<br /> page[j].cout+=1;<br /> }<br /> else<br /> {<br /> if(check(i)==-1)<br /> {<br /> j=max(page);<br /> page[j].id=work[i];<br /> page[j].cout=0;<br /> }<br /> else<br /> page[check(i)].cout=0;<br /> for(j=0;j&lt;3;j++)<br /> page[j].cout+=1;<br /> }<br /> printf(&quot;%d|&quot;,work[i]);<br /> for(j=0;j&lt;pos;j++)<br /> printf(&quot;%d &quot;,page[j].id);<br /> printf(&quot;\n&quot;);<br /> }<br /> }<br /> <br /> void best() //理想置换算法<br /> {<br /> int i,j,k;<br /> int last,a,b,c;<br /> for(i=0;i&lt;19;i++)<br /> {<br /> if(pos&lt;3)<br /> {<br /> if(check(i)==-1)<br /> {<br /> page[pos].id=work[i];<br /> pos++;<br /> }<br /> }<br /> else<br /> if(check(i)==-1)<br /> {<br /> a=find(0,i+1);<br /> b=find(1,i+1);<br /> c=find(2,i+1);<br /> last=a;<br /> k=0;<br /> if(last&lt;b){last=b;k=1;}<br /> if(last&lt;c){last=c;k=2;}<br /> page[k].id=work[i];<br /> }<br /> printf(&quot;%d|&quot;,work[i]);<br /> for(j=0;j&lt;pos;j++)<br /> printf(&quot;%d &quot;,page[j].id);<br /> printf(&quot;\n&quot;);<br /> }<br /> if(check(19)==-1)<br /> page[rand()%3].id=work[19];<br /> printf(&quot;%d|%d %d %d&quot;,work[19],page[0].id,page[1].id,page[2].id);<br /> }<br /> <br /> main()<br /> {<br /> int i;<br /> FILE *pfile;<br /> char choice;<br /> if(!(pfile=fopen(&quot;work.txt&quot;,&quot;r&quot;)))<br /> {<br /> printf(&quot;Open file failed!&quot;);<br /> exit(0);<br /> }<br /> for(i=0;i&lt;20;i++) //从文件获取请求页面序列<br /> {<br /> fscanf(pfile,&quot;%d &quot;,&amp;work[i]);<br /> printf(&quot;%d &quot;,work[i]);<br /> }<br /> do{<br /> printf(&quot;Please choice:&quot;);<br /> scanf(&quot;%s&quot;,&amp;choice);<br /> switch(choice)<br /> {<br /> case 'f':<br /> pos=0;<br /> fifo();<br /> break;<br /> case 'b':<br /> pos=0;<br /> best();<br /> break;<br /> case 'l':<br /> pos=0;<br /> longest();<br /> break;<br /> case 'q':<br /> break;<br /> default:<br /> printf(&quot;Input error!\n&quot;);<br /> break;<br /> }<br /> }while(choice!='q');<br /> }</p></div></body></html>