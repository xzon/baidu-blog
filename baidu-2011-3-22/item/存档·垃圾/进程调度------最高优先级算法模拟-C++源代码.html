<html><head><title><div class="tit">
  进程调度------最高优先级算法模拟-C++源代码
</div></title></head><body><div id='tit'>进程调度------最高优先级算法模拟-C++源代码</div><div id='cate'>存档&middot;垃圾</div><div id='date'>2008年01月18日 星期五 10:58 P.M.</div><div id='page'>178</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/880384263ed356138a82a1bb.html'>http://hi.baidu.com/hxzon/blog/item/880384263ed356138a82a1bb.html</a><div id='cnt'><h1>进程调度------最高优先级算法模拟-C++源代码</h1> 
<p>本程序是操作系统的一个实验，程序本身就是一个数据结构的队列问题，<br /> <br /> 比较简单，就不进行说明了。 <br /> <br /> #include &lt;iostream&gt;<br /> using namespace std;<br /> #define error 0<br /> #define ok 1<br /> #define NULL 0<br /> enum process_state{W,R,F}; //状态枚举类型（等待，运行，就绪）<br /> <br /> typedef struct PCBNode //PCB结构体<br /> {<br /> char name; //名字<br /> int priority; //权限<br /> int arrive; <br /> int demand;<br /> int use;<br /> process_state state; //状态<br /> }PCBNode,*pcb;<br /> <br /> InitPcb(pcb &amp;L) //初始化PCB指针<br /> {<br /> L=(PCBNode*)malloc(sizeof(PCBNode));<br /> if(!L) <br /> return error;<br /> return ok;<br /> }<br /> <br /> typedef struct PNode //PCB链表结点结构体<br /> {<br /> pcb process;<br /> struct PNode *next;<br /> }PNode;<br /> <br /> typedef struct //带头结点的PCB链表指针<br /> {<br /> PNode* head;<br /> }pcblist;<br /> <br /> InitPcbList(pcblist &amp;L) //初始化PCB链表<br /> {<br /> L.head=(PNode*)malloc(sizeof(PNode));<br /> if (L.head)<br /> L.head-&gt;next=NULL;<br /> else<br /> return error;<br /> return ok;<br /> }<br /> <br /> int pcblistinsert(pcblist &amp;L,pcb e) //PCB链表中插入新的结点<br /> {<br /> PNode *p,*s;<br /> p=L.head;<br /> while (p-&gt;next&amp;&amp;e-&gt;priority &lt; p-&gt;next-&gt;process-&gt;priority)<br /> {<br /> p=p-&gt;next;<br /> }<br /> s=(PNode*)malloc(sizeof(PCBNode));<br /> s-&gt;process=e;<br /> s-&gt;next=p-&gt;next;<br /> p-&gt;next=s;<br /> return ok;<br /> }<br /> <br /> int main()<br /> {<br /> pcblist L;<br /> InitPcbList(L);<br /> pcb x;<br /> x=(pcb)malloc(sizeof(PCBNode));<br /> char c,d;<br /> int i=1,j;<br /> PNode* h;<br /> pcb P[5];<br /> for (j=0;j&lt;5;j++)<br /> InitPcb(P[j]);<br /> for (j=0;j&lt;5;j++)<br /> {<br /> cout&lt;&lt;&quot;进程名:&quot;;cin&gt;&gt;P[j]-&gt;name;<br /> cout&lt;&lt;&quot;优先级:&quot;;cin&gt;&gt;P[j]-&gt;priority;<br /> cout&lt;&lt;&quot;到达时间:&quot;;cin&gt;&gt;P[j]-&gt;arrive;<br /> cout&lt;&lt;&quot;需要运行时间:&quot;;cin&gt;&gt;P[j]-&gt;demand;<br /> P[j]-&gt;use=0;<br /> P[j]-&gt;state=W;<br /> /* cout&lt;&lt;&quot;use:&quot;;cin&gt;&gt;P[j]-&gt;use;<br /> cout&lt;&lt;&quot;state:&quot;;cin&gt;&gt;(int&amp;)P[j]-&gt;state;*/ //枚举类型的输入<br /> cout&lt;&lt;endl; <br /> }<br /> <br /> while (P[0]-&gt;state!=F||P[1]-&gt;state!=F||P[2]-&gt;state!=F||P[3]-&gt;state!=F||P[4]-&gt;state!=F)<br /> {<br /> h=L.head;<br /> c='a';<br /> for (j=0;j&lt;5;j++)<br /> if (P[j]-&gt;arrive==i)<br /> pcblistinsert(L,P[j]);<br /> if(h-&gt;next==NULL)<br /> {<br /> i++;<br /> continue;<br /> }<br /> x=h-&gt;next-&gt;process;<br /> x-&gt;state=R;<br /> cout&lt;&lt;&quot;~~~~~~~~~~~~~~~~~~~~~~~&quot;&lt;&lt;endl&lt;&lt;endl;<br /> cout&lt;&lt;&quot;name priority arrive demand used state &quot;&lt;&lt;endl;<br /> for (j=0;j&lt;5;j++)<br /> { <br /> switch (P[j]-&gt;state)<br /> {<br /> case W:d='W';break;<br /> case R:d='R';break;<br /> case F:d='F';break;<br /> }<br /> cout&lt;&lt;P[j]-&gt;name&lt;&lt;&quot; &quot;&lt;&lt;P[j]-&gt;priority&lt;&lt;&quot; &quot;&lt;&lt;P[j]-&gt;arrive&lt;&lt;&quot; &quot;&lt;&lt;P[j]-&gt;demand&lt;&lt;&quot; &quot;&lt;&lt;P[j]-&gt;use&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;endl;<br /> }<br /> x-&gt;priority--;<br /> x-&gt;use++;<br /> if(x-&gt;use==x-&gt;demand)<br /> x-&gt;state=F;<br /> else x-&gt;state=W;<br /> L.head=L.head-&gt;next;<br /> if(x-&gt;state!=F)<br /> {<br /> pcblistinsert(L,x);<br /> }<br /> i++; //时间片加1<br /> cout&lt;&lt;&quot;按任意键继续&quot;&lt;&lt;endl;<br /> c=getchar(); //控制时间片间隔显示<br /> }<br /> return 0;<br /> }</p></div></body></html>