<html><head><title><div class="tit">
  进程调度算法实现-C++源代码
</div></title></head><body><div id='tit'>进程调度算法实现-C++源代码</div><div id='cate'>存档&middot;垃圾</div><div id='date'>2008年01月18日 星期五 10:47 P.M.</div><div id='page'>178</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/00b94f549b0a9550564e00bc.html'>http://hi.baidu.com/hxzon/blog/item/00b94f549b0a9550564e00bc.html</a><div id='cnt'><h1>进程调度算法实现-C++源代码</h1> 
<p>//////////////////////////////////////////////////////////////////////////////////<br /> //数据：进程，队列结构<br /> //处理流程：<br /> //1 初始化--进程队列结构（包括：就绪队列，等待队列，运行队列）等必要的数据结构 init();<br /> //2 进入无限循环，反复调度队列<br /> /////////////////////////////////////////////////////////////////////////<br /> <br /> #define MAX 5<br /> #include&lt;stdio.h&gt;<br /> #include&lt;stdlib.h&gt;<br /> <br /> int total_time=20;<br /> int time_slice=3;<br /> <br /> typedef struct process { // 进程控制块<br /> char pname[10];<br /> int WaitTime;<br /> int BurstTime;<br /> int priority; // 数字越小优先级越高<br /> struct process *next;<br /> }PROCESS;<br /> <br /> //typedef struct process PROCESS;<br /> <br /> PROCESS * in_queue(PROCESS *head,PROCESS *p); //声明<br /> <br /> PROCESS *init() //进程初始化<br /> {<br /> int i=0;<br /> char a;<br /> PROCESS *head_new; //队列的队头<br /> head_new=(struct process*)malloc(sizeof(struct process));<br /> if(!head_new) exit(1);<br /> head_new=NULL;<br /> <br /> <br /> do<br /> {<br /> struct process *s;<br /> printf(&quot;initialize the process:\n&quot;);<br /> s=(struct process *)malloc(sizeof(struct process));<br /> if(!s) exit(1);<br /> printf(&quot;please input the pname:WaitTime: BurstTime: priority:\n&quot;);<br /> scanf(&quot;%c&quot;,&amp;(s-&gt;pname));<br /> scanf(&quot;%d&quot;,&amp;(s-&gt;WaitTime));<br /> scanf(&quot;%d&quot;,&amp;(s-&gt;BurstTime));<br /> scanf(&quot;%d&quot;,&amp;(s-&gt;priority));<br /> s-&gt;next=NULL;<br /> in_queue(head_new,s);<br /> i++;<br /> <br /> printf(&quot;do u want to insert process more ?? 'Y'or'N'\n&quot;);<br /> printf(&quot;----------------------------------------'\n&quot;);<br /> <br /> scanf(&quot;%c&quot;,&amp;a);<br /> scanf(&quot;%c&quot;,&amp;a);<br /> // if(a=='Y'||a=='y') continue;<br /> // else if(a=='N'||a=='n') break;<br /> }while((i&lt;MAX) &amp;&amp;(a=='Y'||a=='y'));<br /> <br /> return head_new;<br /> }<br /> <br /> ///////////////////////////////////////////////////////////<br /> <br /> PROCESS *in_queue(PROCESS *head,PROCESS *p) //入队函数<br /> {<br /> if(head==NULL)<br /> {<br /> head=p;<br /> p-&gt;next=NULL;<br /> }<br /> else <br /> {<br /> p-&gt;next=head;<br /> head=p;<br /> }<br /> // printf(&quot;the process insert into the mothball queue :\n&quot;);<br /> return head;<br /> <br /> }<br /> <br /> /////////////////////////////////////////////////////////////<br /> /*<br /> void new_queue() //后备队列 先来先服务方式进入就绪<br /> {<br /> <br /> return *head_new;<br /> }<br /> */<br /> <br /> PROCESS *FCFS_process()<br /> {<br /> PROCESS *p,*q,*a; //a用来记录选中结点的前一个结点<br /> q=p=init(); //这里是不是有个问题？？<br /> while(p-&gt;next!=NULL)<br /> {<br /> a=p;<br /> if(p-&gt;WaitTime&gt;=q-&gt;WaitTime)<br /> {<br /> q=p;<br /> p=p-&gt;next;<br /> }<br /> }<br /> <br /> q-&gt;WaitTime--;<br /> if(q-&gt;WaitTime==0) //如果等待时间为0则把该进程从后备队列中移除<br /> {<br /> a-&gt;next=p-&gt;next;<br /> free(p);<br /> }<br /> return q; //选择等待时间最久的）<br /> }<br /> <br /> <br /> //////////////////////就绪队列，入口函数为就绪队列的头指针/////////////<br /> <br /> <br /> int count=0;<br /> PROCESS *ready_queue(PROCESS *head) //就绪队列 优先级进入运行 4道<br /> { <br /> PROCESS *p;<br /> while(count&lt;4)<br /> {<br /> p=FCFS_process();<br /> p-&gt;next=head-&gt;next;<br /> head=p;<br /> count++;<br /> <br /> printf(&quot;the process has inserted into the ready queue :\n&quot;);<br /> }<br /> return head;<br /> }<br /> <br /> <br /> //insert_ready() //<br /> PROCESS *high_priority(PROCESS *P) //选择优先级最高的进程<br /> {<br /> PROCESS *q,*p; //问题，入口形参中<br /> q=p;<br /> <br /> while(p-&gt;next!=NULL)<br /> { <br /> if(q-&gt;priority&gt;p-&gt;priority)<br /> q=p;<br /> p=p-&gt;next;<br /> }<br /> return q;<br /> }<br /> <br /> <br /> PROCESS *pick_ready(PROCESS *a) //从就绪队列中选择进程运行<br /> {<br /> PROCESS *p=ready_queue(a);<br /> PROCESS *b=high_priority(p);<br /> return b;<br /> }<br /> <br /> void run(PROCESS *a) //运行一个时间片<br /> {<br /> while((time_slice&gt;0)&amp;&amp;(a-&gt;BurstTime&gt;0)) //指针用-&gt; 变量用.<br /> {<br /> printf(&quot;the process %c is runing&quot;,a-&gt;pname);<br /> printf(&quot;the process BurstTime time is %d &quot;,a-&gt;WaitTime);<br /> printf(&quot;the process BurstTime time is %d &quot;,a-&gt;BurstTime);<br /> printf(&quot;the process priority is %d &quot;,a-&gt;priority);<br /> a-&gt;BurstTime--;<br /> time_slice--;<br /> } <br /> a-&gt;priority--;<br /> total_time--;<br /> /*<br /> if(a-&gt;runtime&gt;0)<br /> return a;<br /> else return NULL;*/<br /> }<br /> <br /> void main()<br /> {<br /> PROCESS *p;<br /> PROCESS *head=init();<br /> while(total_time!=0)<br /> {<br /> ready_queue(head);<br /> p=pick_ready(head);<br /> <br /> if(p-&gt;BurstTime==0)<br /> {<br /> p=p-&gt;next;<br /> free(p);<br /> count--;<br /> }<br /> run(p);<br /> time_slice=3;<br /> <br /> }<br /> }<br /> <br /> <br /> ////////////////////////////////////////////////////////////////////////<br /> //注意的点：<br /> //(1)pedef struct process process; c++ 可以直接用process 定义，但是c 不可以<br /> //(2)返回值一致，PROCESS *MM(){PROCESS *P;return p}<br /> //指针用. 链表用-&gt;</p></div></body></html>