<html><head><title><div class="tit">
  银行家算法源码-C/C++源代码
</div></title></head><body><div id='tit'>银行家算法源码-C/C++源代码</div><div id='cate'>存档&middot;垃圾</div><div id='date'>2008年01月18日 星期五 11:13 P.M.</div><div id='page'>178</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/206eb145ac91ca22cffca38c.html'>http://hi.baidu.com/hxzon/blog/item/206eb145ac91ca22cffca38c.html</a><div id='cnt'><h1>银行家算法源码-C/C++源代码</h1> 
<p>#include&lt;iostream.h&gt;<br /> <br /> struct PCB{<br /> char state;<br /> int request;<br /> int max;<br /> int allocation;<br /> };<br /> <br /> void randomallocation(struct PCB p[],int av);<br /> bool safecheck(struct PCB p[],int av);<br /> void bankallocation(struct PCB p[],int av);<br /> void show(struct PCB p[],int av);<br /> void showorder(int order[]);<br /> void main()<br /> {<br /> struct PCB process[3];<br /> int i;<br /> int j;<br /> int k;<br /> int available=10;<br /> <br /> for(i=0;i&lt;3;i++)<br /> {<br /> cout&lt;&lt;endl;<br /> cout&lt;&lt;&quot;p&quot;&lt;&lt;i&lt;&lt;&quot;-&gt;max: &quot;;<br /> cin&gt;&gt;process[i].max;<br /> if(process[i].max&gt;10)<br /> {<br /> cout&lt;&lt;endl;<br /> cout&lt;&lt;&quot;错误,请重新输入!&quot;;<br /> i--;<br /> }<br /> else<br /> {<br /> do{<br /> cout&lt;&lt;endl&lt;&lt;&quot;-&gt;allocation: &quot;;<br /> cin&gt;&gt;process[i].allocation;<br /> }while((process[i].allocation&gt;process[i].max)||<br /> <br /> (available-process[i].allocation&lt;0));<br /> available=available-process[i].allocation;<br /> process[i].request=0;<br /> process[i].state='R';<br /> }<br /> }<br /> <br /> show(process,available);<br /> cout&lt;&lt;endl&lt;&lt;&quot;1--随机分配算法 2--银行家算法&quot;;<br /> do{<br /> cout&lt;&lt;endl&lt;&lt;&quot;请选择: &quot;;<br /> cin&gt;&gt;i;<br /> }while(!((i==1)||(i==2)));<br /> if(i==1)<br /> randomallocation(process,available);<br /> else<br /> {<br /> do{<br /> if(safecheck(process,available)==false)<br /> {<br /> cout&lt;&lt;endl&lt;&lt;&quot;当前为不安全状态!&quot;;<br /> cout&lt;&lt;endl&lt;&lt;&quot; 1--退出 2--重置&quot;;<br /> do{<br /> cout&lt;&lt;endl&lt;&lt;&quot;选择: &quot;;<br /> cin&gt;&gt;k;<br /> }while((k!=1)&amp;&amp;(k!=2));<br /> if(k==2)<br /> {<br /> available=10;<br /> for(j=0;j&lt;3;j++)<br /> {<br /> cout&lt;&lt;endl&lt;&lt;&quot;p&quot;&lt;&lt;j&lt;&lt;&quot;-&gt;allocation: &quot;;<br /> cin&gt;&gt;process[j].allocation;<br /> available=available-process<br /> <br /> [j].allocation;<br /> }<br /> }<br /> }<br /> else {k=0;break;}<br /> }while(k==2);<br /> if(k==1)return;<br /> else if(k==0)bankallocation(process,available);<br /> }<br /> }<br /> void showorder(int order[]){<br /> int i;<br /> <br /> cout&lt;&lt;endl&lt;&lt;&quot;安全序列为: &quot;;<br /> <br /> for(i=0;i&lt;3;i++)<br /> {<br /> cout&lt;&lt;&quot;p&quot;&lt;&lt;order[i]&lt;&lt;&quot; &quot;;<br /> }<br /> <br /> }<br /> void show(struct PCB p[],int av){<br /> int i;<br /> cout&lt;&lt;endl&lt;&lt;&quot;available=&quot;&lt;&lt;av;<br /> cout&lt;&lt;endl&lt;&lt;&quot;number max request allocation <br /> <br /> state&quot;;<br /> for(i=0;i&lt;3;i++)<br /> {<br /> <br /> <br /> <br /> cout&lt;&lt;endl&lt;&lt;i;<br /> cout&lt;&lt;&quot; &quot;;<br /> cout&lt;&lt;p[i].max;<br /> cout&lt;&lt;&quot; &quot;;<br /> cout&lt;&lt;p[i].request;<br /> cout&lt;&lt;&quot; &quot;;<br /> cout&lt;&lt;p[i].allocation;<br /> cout&lt;&lt;&quot; &quot;;<br /> cout&lt;&lt;p[i].state;<br /> cout&lt;&lt;endl;<br /> }<br /> <br /> }<br /> void randomallocation(struct PCB p[],int av){<br /> int i=0;<br /> int j=0;<br /> int w;<br /> int e;<br /> while(1){<br /> if(i==3) i=i-3;<br /> while(1)<br /> {<br /> if(i==3)i=i-3;<br /> else<br /> if(p[i].state=='R')<br /> {<br /> do{<br /> cout&lt;&lt;endl&lt;&lt;&quot;p&quot;&lt;&lt;i&lt;&lt;&quot;-&gt;request: &quot;;<br /> cin&gt;&gt;p[i].request;<br /> }while(p[i].request&gt;(p[i].max-p<br /> <br /> [i].allocation));<br /> break;<br /> }<br /> else i++;<br /> }<br /> <br /> if(p[i].request&lt;=av)<br /> {<br /> av=av-p[i].request;<br /> p[i].allocation=p[i].allocation+p[i].request;<br /> p[i].request=0;<br /> if(p[i].max==p[i].allocation)<br /> { <br /> av=av+p[i].allocation;<br /> p[i].state='E';<br /> p[i].allocation=0;<br /> p[i].request=0;<br /> <br /> }<br /> j=0;<br /> while(j&lt;3)<br /> {<br /> <br /> if((p[j].request&lt;=av)&amp;&amp;(p[j].state=='W'))<br /> {<br /> av=av+p[j].allocation;<br /> p[j].request=0;<br /> p[j].state='E';<br /> p[j].allocation=0;<br /> <br /> }<br /> if((p[j].max&lt;av+p[j].allocation)&amp;&amp;(p<br /> <br /> [j].state=='W'))<br /> { <br /> p[j].state='R';<br /> }<br /> <br /> j++;<br /> }<br /> show(p,av);<br /> <br /> <br /> }<br /> else<br /> {<br /> p[i].state='W';<br /> show(p,av);<br /> }<br /> <br /> w=0;<br /> e=0;<br /> for(j=0;j&lt;3;j++)<br /> {<br /> if(p[j].state=='W')<br /> w++;<br /> else if(p[j].state=='E')<br /> e++;<br /> else break;<br /> }<br /> <br /> if(((w+e)==3)&amp;&amp;(w!=0))<br /> {<br /> cout&lt;&lt;endl&lt;&lt;&quot;发生死锁!&quot;;<br /> <br /> return;<br /> }<br /> else if(e==3)<br /> {<br /> cout&lt;&lt;endl&lt;&lt;&quot;三个进程顺利执行完!&quot;;<br /> <br /> return;<br /> } <br /> <br /> i++;<br /> }<br /> }<br /> void bankallocation(struct PCB p[],int av){<br /> int k;<br /> int request;<br /> int f;<br /> int i;<br /> show(p,av);<br /> while(1)<br /> {<br /> request=0;<br /> k=-1;<br /> do <br /> {<br /> if(k!=-1)cout&lt;&lt;endl&lt;&lt;&quot;不是安全状态!&quot;;<br /> av=av+request; <br /> p[k].allocation=p[k].allocation-request;<br /> do{<br /> cout&lt;&lt;endl&lt;&lt;&quot;p&quot;&lt;&lt;&quot;-&gt;NO.: &quot;;<br /> cin&gt;&gt;k;<br /> }while(p[k].state!='R');<br /> do<br /> {<br /> cout&lt;&lt;endl&lt;&lt;&quot;p&quot;&lt;&lt;k&lt;&lt;&quot;-&gt;request: &quot;;<br /> cin&gt;&gt;request;<br /> }while(request&gt;(p[k].max-p[k].allocation));<br /> if(request&gt;av)<br /> {<br /> p[k].request=request;<br /> p[k].state='W';<br /> break;<br /> }<br /> p[k].allocation=p[k].allocation+request;<br /> av=av-request;<br /> }while(safecheck(p,av)!=true);<br /> <br /> if(p[k].allocation==p[k].max)<br /> {<br /> p[k].state='E';<br /> av=av+p[k].allocation;<br /> p[k].allocation=0;<br /> }<br /> for(i=0;i&lt;3;i++)<br /> {<br /> if((p[i].state=='W')&amp;&amp;(p[i].request&lt;=av))<br /> {<br /> if(safecheck(p,av)==true)<br /> {<br /> p[i].allocation=p[i].request+p<br /> <br /> [i].allocation;<br /> av=av-p[i].request; <br /> <br /> <br /> p[i].request=0;<br /> p[i].state='R';<br /> <br /> if(p[i].max==p[i].allocation)<br /> {<br /> p[i].state='E';<br /> av=av+p[i].allocation;<br /> p[i].allocation=0;<br /> }<br /> }<br /> else<br /> {<br /> cout&lt;&lt;endl&lt;&lt;&quot;不是安全状态！原请求资源量无效<br /> <br /> 。&quot;;<br /> p[i].request=0;<br /> p[i].state='R';<br /> }<br /> }<br /> }<br /> show(p,av);<br /> f=0;<br /> for(i=0;i&lt;3;i++)<br /> {<br /> if(p[i].state=='E')f++;<br /> }<br /> if(f==3)<br /> {<br /> cout&lt;&lt;endl&lt;&lt;&quot;所有进程顺利执行完!&quot;; <br /> break;<br /> }<br /> }<br /> }<br /> bool safecheck(struct PCB p[],int av)<br /> {<br /> <br /> bool finish[3];<br /> int order[3];<br /> int i;<br /> int j=0;<br /> int f=0;<br /> int k=0;<br /> <br /> int work;<br /> int temp;<br /> work=av;<br /> for(i=0;i&lt;3;i++)<br /> {<br /> order[i]=0;<br /> if(p[i].state=='E')<br /> finish[i]=true;<br /> else<br /> finish[i]=false;<br /> }<br /> while(k&lt;3){<br /> for(i=0;i&lt;3;i++)<br /> {<br /> if((p[i].state=='W')&amp;&amp;(p[i].request&lt;=work)&amp;&amp;(finish[i]<br /> <br /> ==false))<br /> {<br /> temp=p[i].allocation;<br /> p[i].allocation=p[i].request+p[i].allocation;<br /> <br /> } <br /> if(((p[i].allocation+work)&gt;=p[i].max)&amp;&amp;(finish[i]==false))<br /> {<br /> <br /> work=p[i].allocation+work;<br /> finish[i]=true;<br /> order[j]=i;<br /> j++;<br /> <br /> if(p[i].state=='W')p[i].allocation=temp;<br /> }<br /> <br /> }<br /> k++;<br /> }<br /> for(i=0;i&lt;3;i++)<br /> if(finish[i]==true)<br /> f++;<br /> if(f==3)<br /> {<br /> //showorder(order);<br /> return true;<br /> }<br /> else<br /> return false;<br /> }</p></div></body></html>