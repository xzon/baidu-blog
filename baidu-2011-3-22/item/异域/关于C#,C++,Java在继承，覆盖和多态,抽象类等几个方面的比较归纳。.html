<html><head><title><div class="tit">
  关于C#,C++,Java在继承，覆盖和多态,抽象类等几个方面的比较归纳。
</div></title></head><body><div id='tit'>关于C#,C++,Java在继承，覆盖和多态,抽象类等几个方面的比较归纳。</div><div id='cate'>异域</div><div id='date'>2007年12月18日 星期二 08:23 P.M.</div><div id='page'>189</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/3650a9513e5f498c8d543054.html'>http://hi.baidu.com/hxzon/blog/item/3650a9513e5f498c8d543054.html</a><div id='cnt'><div class="tit">
 <font size="3">关于C#,C++,Java在继承，覆盖和多态,抽象类等几个方面的比较归纳。</font>
</div> 
<div class="date"> 
</div> 
<table style="table-layout: fixed" class="FCK__ShowTableBorders"> 
 <tbody> 
  <tr> 
   <td> 
    <div class="cnt"> 
     <p><font size="3">关于C#,C++,Java在继承，覆盖和多态,抽象类等几个方面的比较归纳。<br /> C#,C++用visual studio2005编译通过；java代码用JDK1.4.2编译通过。</font></p> 
     <p><br /> <font size="3">一、继承中的带参数构造函数<br /> =============================<br /> C#示例：<br /> //myClass.cs</font></p> 
     <p><font size="3">using System;<br /> using System.Collections.Generic;<br /> using System.Text;</font></p> 
     <p><font size="3">namespace myClass<br /> &nbsp;&nbsp;&nbsp; class myFirst{<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value_myFirst;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public myFirst(int f)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myFirst = f;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; class mySecond : myFirst{<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value_mySecond;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //构造函数传递参数时，采用base关键字，s在base()中不需重新声明类型int<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public mySecond(int s)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : base(s)&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; class Program<br /> &nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static void Main(string[] args)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; }<br /> }</font></p> 
     <p><br /> <font size="3">============================</font></p> 
     <p><font size="3">C++示例：<br /> ＃i nclude &quot;stdafx.h&quot;</font></p> 
     <p><font size="3">class myFirst{<br /> private:<br /> &nbsp;&nbsp;&nbsp; int value_myFirst;<br /> public:<br /> &nbsp;&nbsp;&nbsp; myFirst(int f){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myFirst = f;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }<br /> };</font></p> 
     <p><font size="3">//继承需要声明继承的方式，此处是public<br /> class mySecond : public myFirst{ <br /> private:<br /> &nbsp;&nbsp;&nbsp; int value_mySecond;<br /> public:<br /> &nbsp;&nbsp;&nbsp; //构造函数传递参数时，用基类类名，s基类类名()中不需声明类型int<br /> &nbsp;&nbsp;&nbsp; mySecond(int s) : myFirst(s){ <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }<br /> };</font></p> 
     <p><font size="3">int _tmain(int argc, _TCHAR* argv[])<br /> {<br /> return 0;<br /> }</font></p> 
     <p><font size="3">=============================</font></p> 
     <p><font size="3">java示例：<br /> package com;</font></p> 
     <p><font size="3">class myFirst{<br /> &nbsp;&nbsp;&nbsp; int value_myFirst;<br /> &nbsp;&nbsp;&nbsp; public myFirst(int f){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myFirst = f;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }<br /> }</font></p> 
     <p><font size="3">//继承采用extends关键字<br /> class mySecond extends myFirst{<br /> &nbsp;&nbsp;&nbsp; int value_mySecond;<br /> &nbsp;&nbsp;&nbsp; public mySecond(int s){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //传递给基类构造函数时，采用super关键字，而且必须是第一条语句。<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(s); <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }<br /> }</font></p> 
     <p><font size="3">public class myCon{<br /> &nbsp;&nbsp;&nbsp; public static void main(String[] args){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }<br /> }</font></p> 
     <p><font size="3">注意：<br /> 1.注释中给出了三者的不同点。<br /> 2.另外，C++语法中定义的类后面必须加上分号&quot;;&quot;<br /> 3.访问控制权限public等的格式，C#和java比较类似，C++相差很大。</font></p> 
     <p> </p> 
     <p><font size="3">二、方法覆盖与多态</font></p> 
     <p><font size="3">C#示例：<br /> //myClass.cs</font></p> 
     <p><font size="3">using System;<br /> using System.Collections.Generic;<br /> using System.Text;</font></p> 
     <p><font size="3">namespace myClass<br /> {<br /> &nbsp;&nbsp;&nbsp; class myFirst<br /> &nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value_myFirst;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public myFirst(int f)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myFirst = f;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void f1()<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine(&quot;myFirst.f1()!&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public virtual void f2() //virtual也可以提到最前面<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine(&quot;myFirst.f2()!&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; }</font></p> 
     <p><font size="3">&nbsp;&nbsp;&nbsp; class mySecond : myFirst<br /> &nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value_mySecond;</font></p> 
     <p><font size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public mySecond(int s)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : base(s)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //使用关键字new覆盖基类中的同名方法<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public new void f1()&nbsp;&nbsp;&nbsp;&nbsp; //new也可以提到最前面<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine(&quot;mySeconde.f1()!&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //error当基类函数myFirst.f1()没有声明为virtual,abstract时不能override！<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //public override void f1() <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //{<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; System.Console.WriteLine(&quot;mySeconde.f1()!&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //}<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //基类函数中虽然声明是virtual，但是仍然可以用new覆盖。<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //public new void f2()<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //{<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; System.Console.WriteLine(&quot;mySeconde.f2()!&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //}<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ////基类函数中虽然声明是virtual，用override覆盖。<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public override void f2()&nbsp;&nbsp; //override也可以提到最前面<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine(&quot;mySeconde.f2()!&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; }</font></p> 
     <p><font size="3">&nbsp;&nbsp;&nbsp; class Program<br /> &nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static void Main(string[] args)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myFirst mf = new myFirst(1);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mySecond ms = new mySecond(2);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf.f1(); //myFirst.f1()!<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf.f2(); //myFirst.f2()!<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.f1(); //mySeconde.f1()!<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.f2(); //mySeconde.f2()!</font></p> 
     <p><font size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf = ms; //向上转型之后<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf.f1(); //myFirst.f1()!<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mySeconde.f2()! 这是用override的运行结果；<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果是new那么，结果是myFirst.f2()!<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf.f2(); <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; }<br /> }</font></p> 
     <p><font size="3">=============================</font></p> 
     <p><font size="3">C++示例</font></p> 
     <p><font size="3">＃i nclude &quot;stdafx.h&quot;<br /> ＃i nclude &lt;iostream&gt;<br /> using namespace std;</font></p> 
     <p><font size="3">class myFirst{<br /> private:<br /> &nbsp;&nbsp;&nbsp; int value_myFirst;<br /> public:<br /> &nbsp;&nbsp;&nbsp; myFirst(int f){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myFirst = f;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }</font></p> 
     <p><font size="3">void f1(){<br /> cout&lt;&lt;&quot;myFirst.f1()!&quot;&lt;&lt;endl;<br /> }<br /> vitual void f2(){ //声明为虚函数<br /> cout&lt;&lt;&quot;myFirst.f2()!&quot;&lt;&lt;endl;<br /> }<br /> };</font></p> 
     <p><font size="3">class mySecond : public myFirst{<br /> private:<br /> &nbsp;&nbsp;&nbsp; int value_mySecond;<br /> public:<br /> &nbsp;&nbsp;&nbsp; mySecond(int s) : myFirst(s){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; //直接覆盖基类函数，无需C#中的new<br /> void f1(){<br /> cout&lt;&lt;&quot;mySecond.f1()!&quot;&lt;&lt;endl;<br /> }<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; //覆盖基类需函数<br /> void f2(){<br /> cout&lt;&lt;&quot;mySecond.f2()!&quot;&lt;&lt;endl;<br /> }<br /> };</font></p> 
     <p><font size="3">int _tmain(int argc, _TCHAR* argv[])<br /> {<br /> myFirst *mf = new myFirst(1);<br /> mySecond *ms = new mySecond(1);<br /> mf-&gt;f1(); //myFirst.f1()!<br /> mf-&gt;f2(); //myFirst.f2()!</font></p> 
     <p><font size="3">ms-&gt;f1(); //mySecond.f1()! <br /> ms-&gt;f2(); //mySecond.f2()!</font></p> 
     <p><font size="3">mf = ms; //向上转型<br /> mf-&gt;f1(); //myFirst.f1()!<br /> mf-&gt;f2(); //mySecond.f2()!<br /> <br /> myFirst mf1(1); //也可以<br /> mf1.f1();<br /> <br /> return 0;<br /> }</font></p> 
     <p><font size="3">=============================</font></p> 
     <p><font size="3">java示例<br /> //myCon.java</font></p> 
     <p><font size="3">package com;</font></p> 
     <p><font size="3">class myFirst{<br /> &nbsp;&nbsp;&nbsp; int value_myFirst;<br /> &nbsp;&nbsp;&nbsp; public myFirst(int f){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myFirst = f;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; public void f1(){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;myFirst.f1()!&quot;);&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> }</font></p> 
     <p><br /> <font size="3">class mySecond extends myFirst{<br /> &nbsp;&nbsp;&nbsp; int value_mySecond;<br /> &nbsp;&nbsp;&nbsp; public mySecond(int s){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(s); <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; public void f1(){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;mySecond.f1()!&quot;);&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; <br /> }</font></p> 
     <p><font size="3">class myThird extends myFirst{<br /> &nbsp;&nbsp;&nbsp; int value_myThird;<br /> &nbsp;&nbsp;&nbsp; public myThird(int t){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(t); <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myThird = t;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; public void f1(){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;myThird.f1()!&quot;);&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp; <br /> }</font></p> 
     <p><font size="3">public class myCon{<br /> &nbsp;&nbsp;&nbsp; public static void main(String[] args){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myFirst mf = new myFirst(1);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mySecond ms = new mySecond(1);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myThird mt = new myThird(1);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf.f1(); //myFirst.f1()!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.f1(); //mySecond.f1()!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mt.f1(); //myThird.f1()!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //向上转型，由于java的动态绑定机制，<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //使得java能够调用派生类mySecond的f1()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf = ms; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf.f1(); //mySecond.f1()!<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf = mt;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf.f1(); //myThird.f1()!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }<br /> }</font></p> 
     <p><font size="3">为了实现多态：<br /> 1.C#基类方法要声明为virtual，派生类覆盖时要用override；<br /> 2.C++基类方法要声明为virtual，派生类方法直接覆盖；<br /> 3.java直接覆盖就可以实现多态。</font></p> 
     <p> </p> 
     <p><font size="3">三、抽象类</font></p> 
     <p><font size="3">C#示例<br /> 上面已经说明，虽然基类方法声明为virtual，以便派生类用override覆盖，但是派生类仍然可以用<br /> new关键字覆盖(不具有多态性)。<br /> 可以强制让派生类覆盖基类的方法，将基类方法声明为抽象的，采用abstract关键字。<br /> 抽象方法没有方法体，由派生类来提供。</font></p> 
     <p><font size="3">如果派生类不实现基类的抽象方法，则派生类也需要声明为abstract类</font></p> 
     <p><font size="3">//myClass.cs</font></p> 
     <p><font size="3">using System;<br /> using System.Collections.Generic;<br /> using System.Text;</font></p> 
     <p><font size="3">namespace myClass{<br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; //类中只要存在抽象方法，就必须声明为抽象类<br /> &nbsp;&nbsp;&nbsp; abstract class myFirst <br /> &nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value_myFirst;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public myFirst(int f)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myFirst = f;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //抽象方法没有方法体，以分号结尾。<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public abstract void f1();<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void f2()<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine(&quot;myFirst.f2()!&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font></p> 
     <p><font size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public virtual void f3()<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine(&quot;myFirst.f3()!&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; }</font></p> 
     <p><font size="3">&nbsp;&nbsp;&nbsp; class mySecond : myFirst<br /> &nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value_mySecond;</font></p> 
     <p><font size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public mySecond(int s)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : base(s)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //覆盖基类抽象方法<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public override void f1()&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine(&quot;mySeconde.f1()!&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //覆盖基类一般方法&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public new void f2()<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine(&quot;mySeconde.f2()!&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font></p> 
     <p><font size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //覆盖基类虚拟方法<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public override void f3()<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine(&quot;mySecond.f3()!&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; }</font></p> 
     <p><font size="3">&nbsp;&nbsp;&nbsp; class Program<br /> &nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static void Main(string[] args)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //抽象类和接口不能声明对象<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //myFirst mf = new myFirst(1); <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mySecond ms = new mySecond(2);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.f1(); //mySeconde.f1()!<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.f2(); //mySeconde.f2()!<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.f3(); //mySecond.f3()!</font></p> 
     <p><font size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //这里向上转型采用强类型转换的方式<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((myFirst)ms).f1();&nbsp;&nbsp; //mySeconde.f1()! <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((myFirst)ms).f2();&nbsp;&nbsp; //myFirst.f2()!<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((myFirst)ms).f3();&nbsp;&nbsp; //mySecond.f3()!<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; }<br /> }</font></p> 
     <p><font size="3">=============================</font></p> 
     <p><font size="3">C++示例</font></p> 
     <p><font size="3">纯虚函数是在基类中只宣布某个虚函数的原型，并且为了明确通知编译系统，<br /> 该虚函数在基类中不再定义具体操作代码，而在函数原型结束分号的左侧写<br /> &quot;=0&quot;标识。这个不包含任何代码的虚函数被成为纯虚函数。</font></p> 
     <p><font size="3">抽象类是含有纯虚函数的类，这种类不能声明任何对象，其作用就是为它的<br /> 派生类提供一种规定输入数据和返回类型接口的模板。</font></p> 
     <p><font size="3">从抽象类派生的派生类，必须对基类的纯虚函数进行覆盖；否则编译系统将<br /> 报错。</font></p> 
     <p><font size="3">基类中虚函数被派生类覆盖，则派生类对象调用的是派生类中重新定义的函<br /> 数代码。<br /> 基类中虚函数没有被派生类覆盖，则派生类对象调用的是基类中定义的函数<br /> 代码。<br /> 基类的纯虚函数在其派生类中必须被覆盖。</font></p> 
     <p><font size="3">＃i nclude &quot;stdafx.h&quot;<br /> ＃i nclude &lt;iostream&gt;<br /> using namespace std;</font></p> 
     <p><font size="3">class myFirst{&nbsp;&nbsp; //抽象类<br /> private:<br /> &nbsp;&nbsp;&nbsp; int value_myFirst;<br /> public:<br /> &nbsp;&nbsp;&nbsp; myFirst(int f){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myFirst = f;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }</font></p> 
     <p><font size="3">void f1(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //一般函数<br /> cout&lt;&lt;&quot;myFirst.f1()!&quot;&lt;&lt;endl;<br /> }<br /> virtual void f2(){&nbsp;&nbsp; //虚函数<br /> cout&lt;&lt;&quot;myFirst.f2()!&quot;&lt;&lt;endl;<br /> }</font></p> 
     <p><font size="3">virtual void f3()=0; //纯虚函数<br /> };</font></p> 
     <p><font size="3">class mySecond : public myFirst{<br /> private:<br /> &nbsp;&nbsp;&nbsp; int value_mySecond;<br /> public:<br /> &nbsp;&nbsp;&nbsp; mySecond(int s) : myFirst(s){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }</font></p> 
     <p><font size="3">void f1(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //覆盖基类一般函数<br /> cout&lt;&lt;&quot;mySecond.f1()!&quot;&lt;&lt;endl;<br /> }</font></p> 
     <p><font size="3">void f2(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //覆盖基类虚函数<br /> cout&lt;&lt;&quot;mySecond.f2()!&quot;&lt;&lt;endl;<br /> }<br /> void f3(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //覆盖基类纯虚函数<br /> cout&lt;&lt;&quot;mySecond.f3()!&quot;&lt;&lt;endl;<br /> }<br /> };</font></p> 
     <p><font size="3">int _tmain(int argc, _TCHAR* argv[])<br /> {<br /> //myFirst *mf = new myFirst(1); //抽象类不能创建对象<br /> mySecond *ms = new mySecond(1);</font></p> 
     <p><font size="3">ms-&gt;f1(); //mySecond.f1()!<br /> ms-&gt;f2(); //mySecond.f2()!<br /> ms-&gt;f3(); //mySecond.f3()!</font></p> 
     <p><font size="3">&nbsp;&nbsp;&nbsp; //向上转型采用强类型转换<br /> ((myFirst *)ms)-&gt;f1(); //myFirst.f1()!<br /> ((myFirst *)ms)-&gt;f2(); //mySecond.f2()!<br /> ((myFirst *)ms)-&gt;f3(); //mySecond.f3()!</font></p> 
     <p><font size="3">return 0;<br /> }</font></p> 
     <p><font size="3">=============================</font></p> 
     <p><font size="3">java示例</font></p> 
     <p><font size="3">java提供了抽象方法的机制abstract method，这种方法不完整，仅有声明<br /> 没有方法体<br /> abstract void f();<br /> 包含抽象方法的类叫抽象类，如果类中包含一个或多个抽象方法，则该类必<br /> 须被声明为抽象类，用abstract来修饰抽象类。<br /> 如果从一个抽象类继承，并创建这个新类的对象，必须给抽象基类中所有抽<br /> 象方法提供方法定义，否则，派生类也是抽象类，也用abstract修饰。</font></p> 
     <p><font size="3">package com;</font></p> 
     <p><font size="3">abstract class myFirst{<br /> &nbsp;&nbsp;&nbsp; int value_myFirst;<br /> &nbsp;&nbsp;&nbsp; public myFirst(int f){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myFirst = f;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; public void f1(){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;myFirst.f1()!&quot;);&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; } <br /> &nbsp;&nbsp;&nbsp; public abstract void f2();&nbsp;&nbsp;&nbsp; //抽象方法&nbsp;&nbsp; <br /> }</font></p> 
     <p><font size="3">//继承采用extends关键字<br /> class mySecond extends myFirst{<br /> &nbsp;&nbsp;&nbsp; int value_mySecond;<br /> &nbsp;&nbsp;&nbsp; public mySecond(int s){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //传递给基类构造函数时，采用super关键字，而且必须是第一条语句。<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(s); <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; public void f1(){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;mySecond.f1()!&quot;);&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; } <br /> &nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; public void f2(){ //覆盖基类抽象方法<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;mySecond.f2()!&quot;);&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp; <br /> }</font></p> 
     <p><font size="3">//如果不实现基类抽象方法，那么此派生类也必须用abstract修饰<br /> abstract class myThird extends myFirst{ <br /> &nbsp;&nbsp;&nbsp; int value_myThird;<br /> &nbsp;&nbsp;&nbsp; public myThird(int t){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(t); <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myThird = t;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; public void f1(){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;myThird.f1()!&quot;);&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp; <br /> }</font></p> 
     <p><font size="3">public class myCon{<br /> &nbsp;&nbsp;&nbsp; public static void main(String[] args){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //myFirst mf = new myFirst(1); //抽象函数不能创建对象<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mySecond ms = new mySecond(1);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //myThird mt = new myThird(1); <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.f1(); //mySecond.f1()!<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.f2(); //mySecond.f2()!<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((myFirst)ms).f1(); //mySecond.f1()!<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((myFirst)ms).f2(); //mySecond.f2()!<br /> &nbsp;&nbsp;&nbsp; }<br /> }</font></p> 
     <p><br /> <font size="3">关于抽象方法和抽象类java和C#比较类似；<br /> 而C++叫纯虚函数和抽象类。</font></p> 
     <p><br /> <font size="3">四、接口<br /> C++中的没有接口的概念，它本身就可以多继承。</font></p> 
     <p><font size="3">java中接口interface比抽象类abstract更进了一步，可看做&quot;纯粹的抽象类&quot;。<br /> 它允许创建者为一个类建立其形式，方法名，参数列表，返回类型，但没有<br /> 任何方法体。接口中也可以包含成员函数，但是他们都是隐含的public和<br /> final。</font></p> 
     <p><font size="3">创建接口时用interface来代替class，前面可以有public，如果不加访问权<br /> 限，那么它就是默认的包访问权限。<br /> 接口中的方法默认为public。</font></p> 
     <p><font size="3">类实现接口要用implements关键字。</font></p> 
     <p><font size="3">接口便于实现多重继承的效果,此处不作具体讨论。</font></p> 
     <p><font size="3">package com;</font></p> 
     <p><font size="3">interface myFirst{<br /> &nbsp;&nbsp;&nbsp; int value_myFirst=1;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; public void f1();<br /> }</font></p> 
     <p><font size="3">class mySecond implements myFirst{<br /> &nbsp;&nbsp;&nbsp; int value_mySecond;<br /> &nbsp;&nbsp;&nbsp; public mySecond(int s){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; public void f1(){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;mySecond.f1()!&quot;);&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }<br /> }</font></p> 
     <p><font size="3">public class myCon{<br /> &nbsp;&nbsp;&nbsp; static void play(myFirst mf){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf.f1();&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; public static void main(String[] args){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //myFirst mf = new myFirst(1);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mySecond ms = new mySecond(1); <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.f1();&nbsp;&nbsp; //mySecond.f1()!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; play(ms); //向上转型 mySecond.f1()!<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((myFirst)ms).f1(); ////向上转型 mySecond.f1()!<br /> &nbsp;&nbsp;&nbsp; }<br /> }</font></p> 
    </div> </td> 
  </tr> 
 </tbody> 
</table> 
<br /> 
<a href="http://hi.baidu.com/knowtohow"><font size="3">http://hi.baidu.com/knowtohow</font></a></div></body></html>