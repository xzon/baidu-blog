<html><head><title><div class="tit">
  框架设计（第2版）：CLR Via C# 第10章 事件
</div></title></head><body><div id='tit'>框架设计（第2版）：CLR Via C# 第10章 事件</div><div id='cate'>异域</div><div id='date'>2008年03月08日 星期六 01:41 P.M.</div><div id='page'>166</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/95758bb1eb40f15008230266.html'>http://hi.baidu.com/hxzon/blog/item/95758bb1eb40f15008230266.html</a><div id='cnt'><p><a href="http://book.csdn.net/bookfiles/154"><font color="#666699">框架设计（第2版）：CLR Via C#</font></a></p> 
<h4 style="text-indent: 21pt"><span>本章内容</span></h4> 
<p class="1"><span style="font-size: 9pt">l<span style="font: 7pt Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>设计一个对外提供事件的类型</span></p> 
<p class="1"><span style="font-size: 9pt">l<span style="font: 7pt Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>如何实现事件</span></p> 
<p class="1"><span style="font-size: 9pt">l<span style="font: 7pt Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>设计一个监听事件的类型</span></p> 
<p class="1"><span style="font-size: 9pt">l<span style="font: 7pt Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>事件与线程安全</span></p> 
<p class="1"><span style="font-size: 9pt">l<span style="font: 7pt Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>显式控制事件的订阅与注销</span></p> 
<p class="1"><span style="font-size: 9pt">l<span style="font: 7pt Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>设计一个定义多个事件的类型</span></p> 
<p style="text-indent: 21pt" class="af0"> </p> 
<p style="text-indent: 21pt" class="MsoNormal"><span>本章将讨论类型中可以定义的最后一种成员：事件。定义了事件成员的类型允许类型</span><span>(</span><span>或者类型的实例</span><span>)</span><span>在某些特定事情发生时通知其他对象。例如，假设</span><span>Button</span><span>类提供了一个名为</span><span>Click</span><span>的事件，当单击</span><span>Button</span><span>对象时，应用程序中的一个</span><span>或者多个对象可能希望能收到一个关于这个事件的通知，从而执行一些动作。事件作为类型成员，它允许进行这种交互。具体而言，定义一个事件成员意味着类型为我们提供了以下三种能力。</span></p> 
<p class="1"><span style="font-size: 9pt">l<span style="font: 7pt Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>类型的静态方法或者对象的实例方法可以订阅类型事件。</span></p> 
<p class="1"><span style="font-size: 9pt">l<span style="font: 7pt Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>类型的静态方法或者对象的实例方法可以注销类型事件。</span></p> 
<p class="1"><span style="font-size: 9pt">l<span style="font: 7pt Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>事件发生时通知已订阅事件的方法。</span></p> 
<p style="text-indent: 21pt" class="MsoNormal"><span>定义事件时，类型可以提供第</span><span>3</span><span>种功能，因为类型中存放了一个已订阅事件的方法的列表。当事件发生时，类型通知列表中已订阅事件的所有方法。</span></p> 
<p style="text-indent: 21pt" class="MsoNormal"><span>公共语言运行库</span><span>(Common Language Runtime</span><span>，</span><span>CLR)</span><span>的事件模型建立在委托</span><span>(delegate)</span><span>这一机制之上。委托是一种类型安全的调用回调方法</span><span>(callback method)</span><span>的方式。回调方法意味着哪个对象接收对象所订阅事件的通知。本章中，我们将使用委托，但深入而全面的解释将在第</span><span>15</span><span>章进行介绍。</span></p> 
<p style="text-indent: 21pt" class="MsoNormal"><span>为了帮助大家完全理解</span><span>CLR</span><span>事件的工作机制，我们先描述一个使用事件的场景。假设我们希望设计一个电子邮件应用程序。当一个电子邮件消息到达时，用户可能希望该消息转发给传真机</span><span>(</span><span>Fax</span><span>)</span><span>或者寻呼机</span><span>(</span><span>Pager</span><span>)</span><span>。在构建应用程序结构时，假设我们首先设计一个名</span><span>为</span><span>MailManager</span><span>的类型负责接收发进来的电子邮件消息。然后再为</span><span>MailManager</span><span>类型定义一个对外提供的名为</span><span>NewMail</span><span>的事</span><span>件。其他类型</span><span>(</span><span>如</span><span>Fax</span><span>和</span><span>Pager</span><span>)</span><span>可以订阅该事件。</span><span>MailManager</span><span>接收到</span><span>一个新的电子邮件消息时，它会引发该事件，将消息分发给每一个已订阅事件的对象。各个对象则以自己期望的方式来处理该消息。</span></p> 
<p style="text-indent: 21pt" class="MsoNormal"><span>应用程序初始化时，仅需实例化一</span><span>个</span><span>MailManager</span><span>实例——应用程序随后可以实例化任意数量的</span><span>Fax</span><span>类型和</span><span>Pager</span><span>类</span><span>型。图</span><span>10.1</span><span>示范了应用程序的初始化过程，以及当一个新的电子邮件消息到达时发生的事情。</span></p> 
<p align="center"><span><img width="438" height="334" src="image/框架设计（第2版）：CLR Via C#.image011.jpg" /><p class="origImg">http://book.csdn.net/bookfiles/154/00/image011.jpg</p></span></p> 
<p align="center">图<span>10.1 </span>构建一个使用事件的应用程序的结构</p> 
<p style="text-indent: 21pt" class="MsoNormal"><span>图</span><span>10.1</span><span>所描述的应用程序的工作过程如下所示：首先，应用程序通过创建一个</span><span>MailManager</span><span>的实例来进行初始化。接</span><span>着，</span><span>MailManager</span><span>提供了一个</span><span>NewMail</span><span>事件。当</span><span>Fax</span><span>和</span><span>Pager</span><span>对象被构建时，</span><span>Fax</span><span>和</span><span>Pager</span><span>对象将订阅</span><span>MailManager</span><span>的</span><span>NewMail</span><span>事件，这样一来在新的电子邮件消息到达时，</span><span>MailManager</span><span>便会通知</span><span>Fax</span><span>和</span><span>Pager</span><span>对象。当</span><span>MailManager</span><span>接</span><span>收到一个新的电子邮件消息时</span><span>(</span><span>将来的某个时候</span><span>)</span><span>，</span><span>MailManager</span><span>会引发</span><span>NewMail</span><span>事件，从而使所有已订阅事件的对象都</span><span>有机会以它们自己期望的方式来处理新消息。</span></p> 
<h3><span>10.1 </span><span>设计一个对外提供事件的类型</span></h3> 
<p style="text-indent: 21pt" class="MsoNormal"><span>为了定义一个对外提供一个或者多个事件的类型，开发人员必须遵守相关设计步骤。本节将按照必需的设计步骤一步一步地设计一个对外提供事件的类型。</span><span>MailManager</span><span>范例应用程序</span><span>(</span><span>可以从</span><em><span><a href="http://wintellect.com/">http://wintellect.com</a></span></em><span>下载</span><span>)</span><span>中示范了</span><span>MailManager</span><span>类型、</span><span>Fax</span><span>类型以及</span><span>Pager</span><span>类型的所有的源代码。注意</span><span>Pager</span><span>类型实际上和</span><span>Fax</span><span>类型相同。</span></p> 
<span> <h3><span>10.1.1 </span><span>第一步：定义一个类型用于存放所有需要发送给事件</span><span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>通知接收者的附加信息</span></h3> <p style="text-indent: 21pt" class="MsoNormal"><span>当事件引发时，引发事件的对象可能希望向接收事件通知的对象传递一些额外的信息。这些额外的信息需要密封在它自己的类中，通常包含一组私有字段以及一些对外提供这些字段的只读的公共属性。按照约定，所有传递给事件处理程序的用于存放事件信息的类都应该继承</span><span>自</span><span>System.EventArgs</span><span>，并且类的名称应该以</span><span>EventArgs</span><span>结束。在本例中，</span><span>NewMailEventArgs</span><span>类拥有一个</span><span>字段来标识消息的发送者</span><span>(</span><span>m_from</span><span>)</span><span>、消息的接收者</span><span>(</span><span>m_to</span><span>)</span><span>以及消息的主题</span><span>(</span><span>m_subject</span><span>)</span><span>。</span></p> <p style="text-indent: 21pt" class="af0"> </p> <p style="margin-left: 21pt" class="ab"><span>//</span><span>第一步：定义一个类型用于存放所有需要发送给事件通知接收者的附加信息</span></p> <p style="margin-left: 21pt" class="ab"><span>internal class NewMailEventArgs : EventArgs {</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; private readonly String m_from, m_to, m_subject;</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; public NewMailEventArgs(String from, String to, String subject) {</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_from = from; m_to = to; m_subject = subject;</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; }</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; public String From { get { return m_from; } }</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; public String To { get { return m_to; } }</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; public String Subject { get { return m_subject; } }</span></p> <p style="margin-left: 21pt" class="ab"><span>}</span></p> <p style="text-indent: 21pt" class="af0"> </p> <p class="MsoList2"><sub><span><img width="18" height="27" src="image/框架设计（第2版）：CLR Via C#.image006.jpg" /><p class="origImg">http://book.csdn.net/bookfiles/154/00/image006.jpg</p></span></sub><span> </span><span>注意</span><span>&nbsp;&nbsp;&nbsp; </span><span>类</span><span>EventArgs</span><span>在</span><span>Microsoft .NET</span><span>框架类库</span><span>(Microsoft .NET Framework Class Library</span><span>，</span><span>FCL)</span><span>中定义，其实现如下：</span></p> <p style="margin-left: 58.8pt" class="ab"><span>[ComVisible(true)] </span></p> <p style="margin-left: 58.8pt" class="ab"><span>[Serializable]</span></p> <p style="margin-left: 58.8pt" class="ab"><span>public class EventArgs {</span></p> <p style="margin-left: 58.8pt" class="ab"><span>&nbsp;&nbsp;&nbsp; public static readonly EventArgs Empty = new EventArgs();</span></p> <p style="margin-left: 58.8pt" class="ab"><span>&nbsp;&nbsp;&nbsp; public EventArgs() { }</span></p> <p style="margin-left: 58.8pt" class="ab"><span>}</span></p> <p class="MsoList2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>可以看出，该类型的实现非常简单。它只是作为一个让其他类型可以继承的基础类型。许多事件都没有额外的信息需要传递。例如，当一个</span><span>Button</span><span>通知其已订阅事件接收者自己已被单击时，简单地调用回调方法就足够了。定义一个不需要传递任何额外信息的事件时，可以直接使用</span><span>EventArgs.Empty</span><span>，不用构建一个新的</span><span>EventArgs</span><span>对象。</span></p> <span> <h3><span>10.1.2 </span><span>第二步：定义事件成员</span></h3> <p style="text-indent: 21pt" class="MsoNormal"><span>事件成员使用</span><span>C#</span><span>关键字</span><span>event</span><span>定</span><span>义。每个事件成员都有一个给定的可访问性</span><span>(</span><span>通常都</span><span>为</span><span>public</span><span>，以便于其他代码也可以访问这个事件成员</span><span>)</span><span>、一个表示即将被调用方法的原型的委托类型以及一个名称</span><span>(</span><span>可以是任意有效的标识符</span><span>)</span><span>。</span><span>NewMail</span><span>类</span><span>中事件成员的形式如下：</span></p> <p style="text-indent: 21pt" class="af0"> </p> <p style="margin-left: 21pt" class="ab"><span>internal class MailManager {</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; //</span><span>第二步：定义事件成员</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; public event EventHandler&lt;NewMailEventArgs&gt; NewMail;</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; ...</span></p> <p style="margin-left: 21pt" class="ab"><span>} </span></p> <p style="text-indent: 21pt" class="af0"> </p> <p style="text-indent: 20.6pt" class="MsoNormal"><span style="letter-spacing: -0.1pt">NewMail</span><span style="letter-spacing: -0.1pt">是事件的名称。事件成员的类型是</span><span style="letter-spacing: -0.1pt">EventHandler&lt;NewMailEventArgs&gt;</span><span>，其含义为所有事件通知的接收者都必须提供一个原型和</span><span>EventHandler &lt;NewMailEventArgs&gt;</span><span>委托类型相匹配的回调方法。由于泛型</span><span>System.EventHandler</span><span>委托类</span><span>型的定义如下：</span></p> <p style="text-indent: 21pt" class="af0"> </p> <p style="margin-left: 21pt" class="ab"><span>public delegate void EventHandler&lt;TEventArgs&gt;</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp; (Object sender, TEventArgs e) where TEventArgs: EventArgs;</span></p> <p style="text-indent: 21pt" class="af0"> </p> <p style="text-indent: 0cm" class="MsoNormal"><span>因此方法原型必须具有下述形式：</span></p> <p style="text-indent: 21pt" class="af0"> </p> <p style="margin-left: 21pt" class="ab"><span>void MethodName(Object sender, NewMailEventArgs e);</span></p> <p class="MsoList2"><sub><span><img width="18" height="27" src="image/框架设计（第2版）：CLR Via C#.image005.jpg" /><p class="origImg">http://book.csdn.net/bookfiles/154/00/image005.jpg</p></span></sub><span> </span><span>注意</span><span>&nbsp;&nbsp;&nbsp; </span><span>许多人可能会觉得奇怪，为什么事件模式要求</span><span>sender</span><span>参数的类型始终为</span><span>Object</span><span>。毕竟，因为</span><span>MailManager</span><span>是惟一一个引发拥有</span><span>NewMailEventArgs</span><span>对象的事件类型，所以回调方法的原型如下：</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void MethodName(MailManager sender, NewMailEventArgs e);</span></p> <p style="line-height: 15.4pt" class="MsoList2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>因为继承的缘故，该模式中要求</span><span>sender</span><span>参数的类型为</span><span>Object</span><span>。但是如果</span><span>MailManager</span><span>用作</span><span>SmtpMailManager</span><span>的基类，情况又会怎么样呢？在这种情况下，回调方法应使</span><span>sender</span><span>参数的原型为</span><span>SmtpMailManager</span><span>，而不是</span><span>MailManager</span><span>，但这种情况不会发生，因为</span><span>SmtpMailManager</span><span>只继承了</span><span>NewMail</span><span>事件。因此，希望使用</span><span>SmtpMailManager</span><span>引发事件的代码必须将</span><span>sender</span><span>参数的类型强制转换为</span><span>SmtpMailManager</span><span>。换句话说，类型间的强制转换仍然需要，因此，</span><span>sender</span><span>参数的类型也可能转换为</span><span>Object</span><span>。</span><span><br /> </span><span>其次，将</span><span>sender</span><span>参数的类型转换为</span><span>Object</span><span>仅仅是为了灵活。这样可以<span style="letter-spacing: -0.2pt">允许多个类型使用同一个委托，这个委托提供了一个传递</span></span><span style="letter-spacing: -0.2pt">NewMailEventArgs</span><span>对象的事件。例如，尽管</span><span>PopMailManager</span><span>类不是从</span><span>MailManager</span><span>类派生的，但是</span><span>PopMailManager</span><span>类也可以使用这个委托。</span><span><br /> </span><span>此外，事件模式同样要求委托定义和回调方法将派生自</span><span>EventArgs</span><span>的参数命名为</span><span>e</span><span>。上述情况的惟一解释就是为了对模式增加一致性，使开发人员可以比较容易地学习和实现模式。生成源代码的工具</span><span>(</span><span>例如</span><span>Microsoft</span><span>的</span><span>Visual Studio)</span><span>同样知道调用参数</span><span>e</span><span>。</span><span><br /> </span><span>最后，事件模式要求所有的事件处理程序的返回类型都为</span><span>void</span><span>。必须这样做的原因是引发事件后可能要调用几个回调方法，因此不可能使每个回调方法都返回一个值。让返回类型为</span><span>void</span><span>就不会允许回调返回值。然而，在</span><span>Microsoft.NET Framework</span><span>类库中有一些事件处理程序，例如</span><span>ResolveEventHandler</span><span>，就没有遵守</span><span>Microsoft</span><span>自己规定的模式，因为</span><span>ResolveEventHandler</span><span>事件处理程序返回一个类型为</span><span>Assembly</span><span>的对象。</span></p> <span> <h3 style="line-height: 15.4pt; margin: 2.5pt 0cm"><span>10.1.3 </span><span>第三步：定义一个负责引发事件的方法来通知已订阅</span><span><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>事件的对象事件已经发生</span></h3> <p style="line-height: 15.4pt; text-indent: 21pt; margin: 2.5pt 0cm" class="MsoNormal"><span>按照约定，类应定义一个受保护的虚方法，当引发事件时，这个类及其派生类中的代码可以调用这个虚方法。该方法有一个参数，</span><span>即</span><span>NewMailEventArgs</span><span>对象，</span><span>这一对象包含了传递给接收通知的对象的信息。它的默认实现仅仅检查是否有对象已经订阅了事件，如果存在这种对象，则事件将被引发，因此需要通知已订阅事件的方法事件已经发生。</span><span>MailManager</span><span>类中</span><span>的该方法如下所示：</span></p> <p style="text-indent: 21pt" class="af0"> </p> <p style="margin-left: 21pt" class="ab"><span>internal class MailManager {</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; ...</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; //</span><span>第三步：定义一个负责引发事件的方法，来通知已订阅事件的对象事件已经发生。如果类是封装的，</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; //</span><span>则需要将方法声明为</span><span>private</span><span>和</span><span>non-virtual</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; protected virtual void OnNewMail(NewMailEventArgs e) {</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span>出于线程安全的考虑，将委托字段保存到一个临时字段中</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EventHandler&lt;NewMailEventArgs&gt; temp = NewMail;</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span>通知所有已订阅事件的对象</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (temp != null) temp(this, e);</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; }</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; ...</span></p> <p style="margin-left: 21pt" class="ab"><span>} </span></p> <p style="text-indent: 21pt" class="af0"> </p> <p style="line-height: 16pt; text-indent: 21pt" class="MsoNormal"><span>注</span><span>意，</span><span>OnNewMail</span><span>方法定义了一个临时局部变量</span><span>temp</span><span>，这个变量将被初始化为事件成员本身。然后，变量</span><span>temp</span><span>与</span><span>null</span><span>比较。如果</span><span>temp</span><span>不等于</span><span>null</span><span>，那么可以使用它来引发事件。必须定义这个临时变量就是为了防止一个可能存在的线程同步问题。如代码中所示，如果不使用变量</span><span>temp</span><span>，那么方法将只引用</span><span>NewMail</span><span>，这样就有可能使线程在知道</span><span>NewMail</span><span>不为</span><span>null</span><span>从而准备引发事件时，另外一个线程将</span><span>NewMail</span><span>变</span><span>为</span><span>null</span><span>，</span><span>这会导致前者无法引发事件。如果发生这种情况，试图引发事件将导致</span><span>CLR</span><span>抛出</span><span>NullReferenceException</span><span>异常。使用临时变量</span><span>temp</span><span>可</span><span>以解决这个问题，</span><span>CLR</span><span>不会抛</span><span>出</span><span>NullReferenceException</span><span>异常。</span></p> <p style="line-height: 16pt; text-indent: 21pt" class="MsoNormal"><span>使用</span><span>MailManager</span><span>作为基类的类不用重写</span><span>OnNewMail</span><span>方法。这种能力使派生类可以直接控制事件的引发。派生类可以以任何合适的方式来处理新的电子邮件消息。通常，派生类型调用基础类型的</span><span>OnNewMail</span><span>方法</span><span>，以便已订阅事件的方法接收通知消息。但是，派生类可以决定不允许事件进行转发。</span></p> <span> <h3><span>10.1.4 </span><span>第四步：定义一个方法，将输入转化为期望事件</span></h3> <p style="line-height: 16pt; text-indent: 21pt" class="MsoNormal"><span>在</span><span>定义的类中，必须还有一些方法可以将外部的输入转换为引发事件的动作。在</span><span>MailManager</span><span>范例中，</span><span>调用</span><span>SimulateNewMail</span><span>方法表示一个新的电子邮件消息到达</span><span>MailManager</span><span>：</span></p> <p style="text-indent: 21pt" class="af0"> </p> <p style="margin-left: 21pt" class="ab"><span>internal class MailManager {</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; //</span><span>第四步：定义一个方法，将输入转化为期望事件</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; public void SimulateNewMail(String from, String to, String subject) {</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span>构建一个对象来存放我们希望传递给通知接收者的信息</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NewMailEventArgs e = new NewMailEventArgs(from, to, subject);</span></p> <p style="margin-left: 21pt" class="ab"> </p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span>调用虚方法以通知对象事件已经发生</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span>如果没有对象重写该方法，那么该对象将通知所有订阅该事件的对象</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnNewMail(e);</span></p> <p style="margin-left: 21pt" class="ab"><span>&nbsp;&nbsp;&nbsp; }</span></p> <p style="margin-left: 21pt" class="ab"><span>} </span></p> <p style="text-indent: 21pt" class="af0"> </p> <p style="line-height: 16pt; text-indent: 21pt" class="MsoNormal"><span>SimulateNewMail</span><span>接收一些关于消息的信息，然后构建一个</span><span>NewMailEventArgs</span><span>对象，并将消息信息传递给它的构造器。接着调用</span><span>MailManager</span><span>自己的虚方法</span><span>OnNewMail</span><span>来正式通知</span><span>MailManager</span><span>对象已收到新的电子邮件消息。通常情况下，这样的调</span><span>用将导致事件被引发，从而使所有已订阅事件的对象都接收到通知。</span><span>(</span><span>如前所述，一</span><span>个将</span><span>MailManager</span><span>作为基</span><span>类的类可以重写这个方法。</span><span>)</span></p> <span> <h3> </h3> </span></span></span></span></span></div></body></html>