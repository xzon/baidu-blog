<html><head><title><div class="tit">
  自己动手写操作系统-hxzon爱读书
</div></title></head><body><div id='tit'>自己动手写操作系统-hxzon爱读书</div><div id='cate'>无分类</div><div id='date'>2008年03月16日 星期日 08:59 P.M.</div><div id='page'>160</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/6db4aed3dcc28a30960a16e8.html'>http://hi.baidu.com/hxzon/blog/item/6db4aed3dcc28a30960a16e8.html</a><div id='cnt'>自己动手写操作系统-hxzon爱读书
<br /> 
<br /> 【作者】于渊 编著
<br /> 
<br /> 【出版社】电子工业出版社
<br /> 
<br /> 【ISBN】7121015773
<br /> 
<br /> 【出版日期】2005年08月
<br /> 
<br /> 【开本】787*1092 1/16 
<br /> 
<br /> 【版别版次】2005年8月第1版第1次印刷
<br /> 
<br /> 
<br /> 【分类】操作系统→综合
<br /> 
<br /> 【页数】374
<br /> 
<br /> 【《自己动手写操作系统 》图书目录】 第1章&nbsp;&nbsp; 马上动手写一个最小的“操作系统” 1
<br /> 1.1&nbsp;&nbsp; 准备工作 1
<br /> 1.2&nbsp;&nbsp; 10分钟完成的操作系统 1
<br /> 1.3&nbsp;&nbsp; Boot Sector 3
<br /> 1.4&nbsp;&nbsp; 代码解释 3
<br /> 1.5&nbsp;&nbsp; 水面下的冰山 5
<br /> 1.6&nbsp;&nbsp; 回顾 6
<br /> 第2章&nbsp;&nbsp; 搭建你的工作环境 7
<br /> 2.1&nbsp;&nbsp; 虚拟计算机（Virtual PC） 7
<br /> 2.1.1&nbsp;&nbsp; Virtual PC初体验 8
<br /> 2.1.2&nbsp;&nbsp; 创建你的第一个Virtual PC 9
<br /> 2.1.3&nbsp;&nbsp; 虚拟软盘研究 12
<br /> 2.1.4&nbsp;&nbsp; 虚拟软盘实战 14
<br /> 2.2&nbsp;&nbsp; 编译器（NASM &amp; GCC） 18
<br /> 2.3&nbsp;&nbsp; 安装虚拟Linux 19
<br /> 2.4&nbsp;&nbsp; 在虚拟Linux上访问Windows文件夹 26
<br /> 2.5&nbsp;&nbsp; 安装虚拟PCDOS 26
<br /> 2.6&nbsp;&nbsp; 其他要素 29
<br /> 2.7&nbsp;&nbsp; Bochs 29
<br /> 2.7.1&nbsp;&nbsp; Bochs vs. Virtual PC vs. VMware 30
<br /> 2.7.2&nbsp;&nbsp; Bochs的使用方法 31
<br /> 2.7.3&nbsp;&nbsp; 用Bochs进行调试 33
<br /> 2.7.4&nbsp;&nbsp; 在Linux上开发 34
<br /> 2.8&nbsp;&nbsp; 总结与回顾 36
<br /> 第3章&nbsp;&nbsp; 保护模式（Protect Mode） 37
<br /> 3.1&nbsp;&nbsp; 认识保护模式 37
<br /> 3.1.1&nbsp;&nbsp; GDT(Global Descriptor Table)&nbsp;&nbsp; 42
<br /> 3.1.2&nbsp;&nbsp; 实模式到保护模式，不一般的jmp 45
<br /> 3.1.3&nbsp;&nbsp; 描述符属性 47
<br /> 3.2&nbsp;&nbsp; 保护模式进阶 50
<br /> 3.2.1&nbsp;&nbsp; 海阔凭鱼跃 50
<br /> 3.2.2&nbsp;&nbsp; LDT（Local Descriptor Table） 58
<br /> 3.2.3&nbsp;&nbsp; 特权级 62
<br /> 3.3&nbsp;&nbsp; 页式存储 82
<br /> 3.3.1&nbsp;&nbsp; 分页机制概述 83
<br /> 3.3.2&nbsp;&nbsp; 编写代码启动分页机制 84
<br /> 3.3.3&nbsp;&nbsp; PDE和PTE 85
<br /> 3.3.4&nbsp;&nbsp; cr3 88
<br /> 3.3.5&nbsp;&nbsp; 回头看代码 88
<br /> 3.3.6&nbsp;&nbsp; 克勤克俭用内存 90
<br /> 3.3.7&nbsp;&nbsp; 进一步体会分页机制 100
<br /> 3.4&nbsp;&nbsp; 中断和异常 107
<br /> 3.4.1&nbsp;&nbsp; 中断和异常机制 109
<br /> 3.4.2&nbsp;&nbsp; 外部中断 111
<br /> 3.4.3&nbsp;&nbsp; 编程操作8259A 113
<br /> 3.4.4&nbsp;&nbsp; 建立IDT 116
<br /> 3.4.5&nbsp;&nbsp; 实现一个中断 117
<br /> 3.4.6&nbsp;&nbsp; 时钟中断试验 119
<br /> 3.4.7&nbsp;&nbsp; 几点额外说明 121
<br /> 3.5&nbsp;&nbsp; 保护模式下的I/O 122
<br /> 3.5.1&nbsp;&nbsp; IOPL 122
<br /> 3.5.2&nbsp;&nbsp; I/O许可位图（I/O Permission Bitmap） 123
<br /> 3.6&nbsp;&nbsp; 保护模式小结 123
<br /> 第4章&nbsp;&nbsp; 让操作系统走进保护模式 125
<br /> 4.1&nbsp;&nbsp; 突破512字节的限制 125
<br /> 4.1.1&nbsp;&nbsp; FAT12 126
<br /> 4.1.2&nbsp;&nbsp; DOS可以识别的引导盘 131
<br /> 4.1.3&nbsp;&nbsp; 一个最简单的Loader 132
<br /> 4.1.4&nbsp;&nbsp; 加载Loader入内存 133
<br /> 4.1.5&nbsp;&nbsp; 向Loader交出控制权 142
<br /> 4.1.6&nbsp;&nbsp; 整理boot.asm 142
<br /> 4.2&nbsp;&nbsp; 保护模式下的“操作系统”&nbsp;&nbsp; 144
<br /> 第5章&nbsp;&nbsp; 内核雏形 146
<br /> 5.1&nbsp;&nbsp; 用NASM在Linux下写Hello World 146
<br /> 5.2&nbsp;&nbsp; 再进一步，汇编和C同步使用 148
<br /> 5.3&nbsp;&nbsp; ELF（Executable and Linkable Format） 150
<br /> 5.4&nbsp;&nbsp; 从Loader到内核 155
<br /> 5.4.1&nbsp;&nbsp; 用Loader加载ELF 155
<br /> 5.4.2&nbsp;&nbsp; 跳入保护模式 161
<br /> 5.4.3&nbsp;&nbsp; 重新放置内核 170
<br /> 5.4.4&nbsp;&nbsp; 向内核交出控制权 175
<br /> 5.4.5&nbsp;&nbsp; 操作系统的调试方法 176
<br /> 5.5&nbsp;&nbsp; 扩充内核 184
<br /> 5.5.1&nbsp;&nbsp; 切换堆栈和GDT 184
<br /> 5.5.2&nbsp;&nbsp; 整理我们的文件夹 191
<br /> 5.5.3&nbsp;&nbsp; Makefile 191
<br /> 5.5.4&nbsp;&nbsp; 添加中断处理 200
<br /> 5.5.5&nbsp;&nbsp; 两点说明 218
<br /> 5.6&nbsp;&nbsp; 小结 219
<br /> 第6章&nbsp;&nbsp; 进程 221
<br /> 6.1&nbsp;&nbsp; 迟到的进程 221
<br /> 6.2&nbsp;&nbsp; 概述 222
<br /> 6.2.1&nbsp;&nbsp; 进程介绍 222
<br /> 6.2.2&nbsp;&nbsp; 未雨绸缪——形成进程的必要考虑 222
<br /> 6.2.3&nbsp;&nbsp; 参考的代码 224
<br /> 6.3&nbsp;&nbsp; 最简单的进程 224
<br /> 6.3.1&nbsp;&nbsp; 简单进程的关键技术预测 225
<br /> 6.3.2&nbsp;&nbsp; 第一步——ring0→ring1 227
<br /> 6.3.3&nbsp;&nbsp; 第二步——丰富中断处理程序 243
<br /> 6.3.4&nbsp;&nbsp; 进程体设计技巧 254
<br /> 6.4&nbsp;&nbsp; 多进程 256
<br /> 6.4.1&nbsp;&nbsp; 添加一个进程体 256
<br /> 6.4.2&nbsp;&nbsp; 相关的变量和宏 257
<br /> 6.4.3&nbsp;&nbsp; 进程表初始化代码扩充 258
<br /> 6.4.4&nbsp;&nbsp; LDT 260
<br /> 6.4.5&nbsp;&nbsp; 修改中断处理程序 261
<br /> 6.4.6&nbsp;&nbsp; 添加一个任务的步骤总结 263
<br /> 6.4.7&nbsp;&nbsp; 号外：Minix的中断处理 265
<br /> 6.4.8&nbsp;&nbsp; 代码回顾与整理 269
<br /> 6.5&nbsp;&nbsp; 系统调用 280
<br /> 6.5.1&nbsp;&nbsp; 实现一个简单的系统调用 280
<br /> 6.5.2&nbsp;&nbsp; get_ticks的应用 286
<br /> 6.6&nbsp;&nbsp; 进程调度 292
<br /> 6.6.1&nbsp;&nbsp; 避免对称——进程的节奏感 292
<br /> 6.6.2&nbsp;&nbsp; 优先级调度总结 300
<br /> 第7章&nbsp;&nbsp; 输入/输出系统 302
<br /> 7.1&nbsp;&nbsp; 键盘 302
<br /> 7.1.1&nbsp;&nbsp; 从中断开始——键盘初体验 302
<br /> 7.1.2&nbsp;&nbsp; AT、PS/2键盘 304
<br /> 7.1.3&nbsp;&nbsp; 键盘敲击的过程 304
<br /> 7.1.4&nbsp;&nbsp; 解析扫描码 309
<br /> 7.2&nbsp;&nbsp; 显示器 325
<br /> 7.2.1&nbsp;&nbsp; 初识TTY 325
<br /> 7.2.2&nbsp;&nbsp; 基本概念 326
<br /> 7.2.3&nbsp;&nbsp; 寄存器 328
<br /> 7.3&nbsp;&nbsp; TTY任务 332
<br /> 7.3.1&nbsp;&nbsp; TTY任务框架的搭建 334
<br /> 7.3.2&nbsp;&nbsp; 多控制台 340
<br /> 7.3.3&nbsp;&nbsp; 完善键盘处理 346
<br /> 7.3.4&nbsp;&nbsp; TTY任务总结 354
<br /> 7.4&nbsp;&nbsp; 区分任务和用户进程 354
<br /> 7.5&nbsp;&nbsp; printf 357
<br /> 7.5.1&nbsp;&nbsp; 为进程指定TTY 357
<br /> 7.5.2&nbsp;&nbsp; printf()的实现 358
<br /> 7.5.3&nbsp;&nbsp; 系统调用write() 361
<br /> 7.5.4&nbsp;&nbsp; 使用printf() 363
<br /> 后记 366
<br /> 参考文献 369
<br /> 附录&nbsp;&nbsp; 书中的章节和代码对照表 370
<br /></div></body></html>