<html><head><title><div class="tit">
  WebWork In Action - Appendix:WebWork architecture
</div></title></head><body><div id='tit'>WebWork In Action - Appendix:WebWork architecture</div><div id='cate'>源码品读</div><div id='date'>2010年06月25日 星期五 09:50 A.M.</div><div id='page'>12</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/92443b6d7659f9f64216943e.html'>http://hi.baidu.com/hxzon/blog/item/92443b6d7659f9f64216943e.html</a><div id='cnt'><br /> 
<p>WebWork In Action - Appendix:WebWork architecture</p> 
<p>《WebWork In Action》 pdf hxzon gbook</p> 
<p>WebWork源码品读 WebWork设计模式</p> 
<p>------------------------------------------------</p> 
<p>Appendix:WebWork architecture</p> 
<p>As you first learned way back in chapter 1, “An overview of WebWork,” WebWork<br /> is made up of two parts. The foundation of WebWork is XWork, a generic Com-<br /> mand pattern framework. WebWork adds an MVC web application framework<br /> implemented as a wrapper on top of XWork. The core concepts of the framework,<br /> including actions, interceptors, and results, are defined by XWork. WebWork<br /> extends the basic implementations of these concepts to support web application<br /> development. This appendix discusses the core design of XWork and WebWork.<br /> We laid out the separation between XWork and WebWork in chapter 1, so in<br /> this appendix we’ll discuss the framework architecture without too much focus on<br /> which parts are XWork and which are WebWork.</p> 
<h2>A.1 Implementing the Command pattern</h2> 
<p>At its core, WebWork is a Command pattern implementation. The Command pat-<br /> tern takes units of code that would be methods in normal functional or OO pro-<br /> gramming, and makes them into classes called commands or actions, which all<br /> implement a common interface. As you can see in figure A.1, action instances can<br /> then be created and passed to be executed by code that doesn’t have to know which<br /> command class it’s executing, as long as it implements the command interface.<br /> If you use a command execution framework, the framework can encapsulate the<br /> execution of the action. Because you’re calling actions through a framework, you<br /> can configure the framework to add services around the call, like saving the com-<br /> mand objects to replay them backward for undo, or saving them to a log, or sending<br /> them off to be executed somewhere else. The client code, which executes the<br /> action through the framework, doesn’t need to know what other services may be<br /> called, or even which action class is being executed, as you can see in figure A.2.<br /> Because you don’t directly call the classes, but rather make the calls through<br /> the framework, you can change the behavior of your commands by configuring<br /> the framework without having to change your command classes. How the frame-<br /> work is configured and what services are available is implementation specific; but<br /> as we discuss in chapter 3, “Setting up WebWork,” WebWork actions are config-<br /> ured in an XML file named xwork.xml.</p> 
<p><span><img class="blogimg" border="0" small="0" src="image/WebWork In Action - .c350573d1ed46ad03c6d9748.jpg" /><p class="origImg">http://hiphotos.baidu.com/hxzon/pic/item/c350573d1ed46ad03c6d9748.jpg</p><br /> </span><span><img class="blogimg" border="0" small="0" src="image/WebWork In Action - .5c81d207ddbed5f37a894749.jpg" /><p class="origImg">http://hiphotos.baidu.com/hxzon/pic/item/5c81d207ddbed5f37a894749.jpg</p><br /> </span></p> 
<p> </p> 
<p> </p> 
<h3>A.1.1 Basic Command pattern features</h3> 
<p>WebWork provides the standard features of a Command pattern framework, as<br /> well as advanced features not found in any other command framework. The stan-<br /> dard features of a Command pattern implementation include the following:<br /> ■ Configuring an action class to be executed based on an alias name, decoupling<br /> the caller from the implementing command object. This is done through the<br /> xwork.xml configuration file, which we look at in detail in chapter 3.<br /> ■ Allowing configuration-time parameters to be set onto the action instance<br /> before execution. These parameters can be set in the xwork.xml file. See chap-<br /> ters 3 and 5 (“Adding functionality with interceptors”) for more information. <br /> ■ Setting request-specific parameters onto the action instance before execu-<br /> tion. This is handled by an interceptor, as discussed in chapter 5.<br /> ■ Providing a mapping between command return codes and a result to be exe-<br /> cuted. This mapping is done in the xwork.xml file, also discussed in chapter 3.<br /> ■ Chaining multiple commands together via configuration to provide support<br /> for composition of macros from many actions. This is handled by the com-<br /> bination of a result mapped in xwork.xml and an interceptor. Action chain-<br /> ing is covered in detail in chapter 7, “Using results.”</p> 
<h3>A.1.2 Advanced Command pattern features</h3> 
<p>WebWork also provides many advanced features, some of which aren’t found in<br /> any other command framework:<br /> ■ Per-class and per-property type conversion support when you’re setting<br /> properties onto the action instance. This flexible type conversion allows you<br /> to use domain objects with more complicated property types, rather than all<br /> String FormBeans as in Struts or other frameworks. Type conversion is cov-<br /> ered in detail in chapter 12.<br /> ■ Localized text message support with a message inheritance model based on<br /> action class hierarchies. Internationalization support is covered in chapter 14.<br /> ■ Error message support at the class instance and field level. This allows you<br /> to save error messages for display to the user at either the action level or at<br /> the per-field level. Managing error messages is covered in chapter 4, “Imple-<br /> menting WebWork actions.”<br /> ■ Configurable interceptors to provide before and after processing around<br /> the execution of the action instance. Interceptors are configured via the<br /> xwork.xml file and are discussed in detail in chapter 5.<br /> ■ An XML metadata-driven validation framework to validate action and<br /> domain object values. This lets you define your validations external to your<br /> code and provide different validations for different usage scenarios. Valida-<br /> tion is covered in chapter 13.</p> 
<h2>A.2 Actions</h2> 
<p>The core unit of functionality in WebWork is the action. Actions are the com-<br /> mand objects in WebWork’s implementation of the Command pattern discussed<br /> in section A.1. Actions implement the com.opensymphony.xwork.Action interface,<br /> which defines only one method:<br /> public String execute() throws Exception<br /> This method is the default entry point (the method the framework calls when exe-<br /> cuting the action) for execution in your action classes. You can configure your<br /> action alias to call a method other than execute(), and even have multiple differ-<br /> ent action aliases pointing to different methods in the same action class with dif-<br /> ferent interceptors, results, and so on. <br /> The com.opensymphony.xwork.ActionSupport class implements Action and sev-<br /> eral optional interfaces and can be used as a base class for your own action classes<br /> to extend to inherit implementations of these interfaces. In chapter 4, we look in<br /> detail at implementing your own actions and the default implementations pro-<br /> vided by ActionSupport.</p> 
<h2>A.3 Interceptors</h2> 
<p>Interceptors in WebWork allow you to encapsulate code to be executed around<br /> the execution of an action. These are extra services the Command pattern frame-<br /> work can provide, transparently,<br /> 1<br /> to the execution of your actions. They’re<br /> defined outside the action class, yet have access to the action and the action exe-<br /> cution environment at runtime, letting you componentize cross-cutting code and<br /> provide separation of concerns. Cross-cutting code can be anything from timing<br /> and logging your action execution to setting up resources such as database con-<br /> nections and transactions and cleaning them up after execution. Many WebWork<br /> features, including core functionality like setting properties on the action<br /> instance, are implemented as interceptors. This is code many of your actions will<br /> need, but you don’t want to be forced to see it in every action, either through cut-<br /> and-paste or complex class inheritance hierarchies. Instead, the modular<br /> approach to executing an action allows you to customize the action execution to<br /> do just the pieces you need. <br /> If you think this sounds like Aspect-Oriented Programming (AOP), you’re right.<br /> It shares many concepts with the idea of method interception from AOP; but it<br /> doesn’t require any preprocessing or byte-code modification, because the callers<br /> and called actions are decoupled and the interception is internal to the framework.<br /> We take a detailed look at interceptors in chapter 5, and we’ll examine a sequence<br /> diagram of the interactions that occur in executing an action later in this appendix<br /> when we discuss what happens inside the ActionProxy and ActionInvocation.</p> 
<p>1<br /> The level of transparency depends on what the interceptor is doing. Some interceptors, like timer and<br /> logger, don’t change the behavior of the action at all. Other interceptors, like parameter and prepare,<br /> may be key to the operation of the action, and not including them would break things.</p> 
<h2>A.4 Results</h2> 
<p>The com.opensymphony.xwork.Result interface represents a generic outcome of<br /> an action execution. This is basically anything you want to happen after the action<br /> is executed. The Result interface defines only one method:<br /> public void execute(ActionInvocation invocation) throws Exception<br /> Results can be used to produce any kind of output needed from the action execu-<br /> tion, such as displaying a web page, generating a report, or sending an email.<br /> WebWork provides results for doing servlet dispatch (used to dispatch to a JSP for<br /> rendering), servlet redirects, Velocity, FreeMarker, JasperReports (which allows<br /> you to generate PDF, CSV, XML, and so on), XSLT rendering, and the Action-<br /> ChainResult, which can be used to chain processing from the current action to<br /> another action. <br /> Results are mapped to a result code in your action configuration in xwork.xml.<br /> We discuss this in detail in chapter 3; but for now, all you need to know is that you<br /> can tell WebWork to execute a different result based on the return code of your<br /> action’s execute() method. Each different return code can have its own result to<br /> be executed. Results are discussed in detail in chapter 7.</p> 
<h2>A.5 Value stack</h2> 
<p>The value stack is central to the dynamic context-driven nature of XWork and<br /> WebWork. It’s a stack of objects against which expressions can be evaluated to find<br /> property values dynamically, by searching for the first object (from the top of the<br /> stack down) that has a property of that name. WebWork builds up the value stack<br /> during execution by pushing the action onto the stack. <br /> Many WebWork JSP tags and Velocity macros access the value stack and may<br /> push or pop objects to/from it. The value stack is built on and around Object<br /> Graph Navigation Language (OGNL) and acts as an extension of OGNL’s single-<br /> object root concept to support the multiple-object stack. We’ll discuss OGNL and<br /> the interaction between OGNL and the value stack more in the next section.</p> 
<h3>A.5.1 OGNL</h3> 
<p>OGNL (see http://www.opensymphony.com/ognl) lets you evaluate expressions<br /> to navigate properties on JavaBeans for either getting or setting property values.<br /> OGNL also provides advanced expression features such as static or instance<br /> method execution, projection across a collection, and lambda expression<br /> definition for expression reuse. OGNL also provides a rich type-conversion model<br /> that has been extended in XWork and WebWork. Type conversion is covered in<br /> detail in chapter 12.<br /> The basics of the OGNL language are simple and should cover 90 percent of<br /> common usages. Basic bean properties are accessed using the property name. For<br /> example, the expression count is evaluated by trying to find a getter for a property<br /> named count, like getCount(). Similarly, the expression address.street calls<br /> getAddress().getStreet() if you’re getting a property, or getAddress().set-<br /> Street() if you’re setting a property. Other features of OGNL are similarly<br /> straightforward; for instance, the expression hashCode() calls the hash code<br /> method on the current object in the OGNL context. <br /> We discuss OGNL syntax in detail in chapter 8, including the WebWork exten-<br /> sions to OGNL. But for now the expressions used in the examples should be self-<br /> explanatory, and we’ll comment them where they’re not.</p> 
<h2>A.6 ActionProxy / ActionInvocation</h2> 
<p>The ActionProxy serves as client code’s<br /> handle to execute an action. Because<br /> you’re executing the action through the<br /> framework, you use this proxy rather than<br /> the action instance itself so that it may<br /> encapsulate the extra functionality of the<br /> interceptors, results, and so on. Figure A.3<br /> shows the relationship between the<br /> ActionProxy, the ActionInvocation, the<br /> action instance, the interceptors, the<br /> results, and the ActionContext (which<br /> we’ll cover in the next section).<br /> The ActionProxy holds an ActionIn-<br /> vocation, which represents the current<br /> state of the execution of the action. The<br /> ActionInvocation holds the action<br /> instance, the interceptors to be applied<br /> (in order), the map of results (mapped<br /> from return code to result instance), and<br /> an ActionContext (more on this in the<br /> next section).</p> 
<p><span><img class="blogimg" border="0" small="0" src="image/WebWork In Action - .ae920ad7e16ba4e3a044df55.jpg" /><p class="origImg">http://hiphotos.baidu.com/hxzon/pic/item/ae920ad7e16ba4e3a044df55.jpg</p><br /> </span><span><img class="blogimg" border="0" small="0" src="image/WebWork In Action - .b49461090d7643f13ac76350.jpg" /><p class="origImg">http://hiphotos.baidu.com/hxzon/pic/item/b49461090d7643f13ac76350.jpg</p><br /> </span></p> 
<p> </p> 
<p>The ActionProxy is created by a dispatcher—such as the ServletDispatcher in<br /> WebWork—using the static ActionProxyFactory instance, in this way:<br /> ActionProxy proxy = ActionProxyFactory.getFactory()<br /> &nbsp;&nbsp;&nbsp; .createActionProxy(namespace, actionName, context);<br /> After creating the ActionProxy with the context (which includes the request<br /> parameters, the application map, the session map, the locale, and the ServletRe-<br /> quest and ServletResponse), the ServletDispatcher executes the ActionProxy by<br /> calling the execute() method. Figure A.4 shows the sequence of calls in the exe-<br /> cute() method of the DefaultActionProxy (the default implementation of the<br /> ActionProxy interface). <br /> The ActionProxy sets up the execution context for the ActionInvocation<br /> (you’ll see more about this in a moment when we discuss the ActionContext) and<br /> then calls invoke() on the ActionInvocation. The ActionInvocation invoke()<br /> method finds the next interceptor that hasn’t been executed and calls inter-<br /> cept() on it. The interceptor can do any preprocessing using the ActionInvoca-<br /> tion before calling invoke() again on the ActionInvocation. This reentrant<br /> behavior can make ActionInvocation somewhat confusing. The ActionInvoca-<br /> tion maintains its state to know which interceptors have been executed; and, if<br /> there are more interceptors, it calls intercept() on the next one. If there are no<br /> more interceptors to be called, the action instance is executed. The return code<br /> from the action is used to look up the result to use, and it’s executed. Finally, the<br /> invoke() method returns, returning control to the last interceptor in the stack.<br /> This interceptor can do any post-processing necessary and then return from the<br /> invoke() method, allowing the previous interceptor to do its post-processing, and<br /> so on, until all the interceptors have returned. Finally, the ActionProxy cleans up<br /> some state and returns.<br /> One consequence of passing the ActionInvocation into the interceptors and<br /> depending on it to continue processing the other interceptors and finally the<br /> action is that interceptors can choose to not continue processing (thus shortcut-<br /> ting action execution) and just return a result code. This allows, as an example, a<br /> SecurityInterceptor to prevent action execution if the user doesn’t have permis-<br /> sions to the action.<br /> The ActionProxyFactory/ActionProxy/ActionInvocation architecture also<br /> allows for different strategies for executing actions. For example, using this archi-<br /> tecture, you could build a Java Message Service (JMS) dispatcher to allow asynchro-<br /> nous action processing and a client dispatcher that allows rich clients to call to a<br /> server, to have actions executed on the server side with the required parameters and<br /> then return to the client to be rendered for the user. This is already being done for<br /> the project MessageWork, which was recently added to http://dev.java.net.</p> 
<h2>A.7 ActionContext</h2> 
<p>The ActionContext is a ThreadLocal Map with helpers for getting and setting pre-<br /> defined values such as the application and session maps, the ActionInvocation,<br /> request parameters, the locale, and so on. An ActionContext is associated with a<br /> particular ActionInvocation/ActionProxy pair and is associated with the Thread<br /> during the execution of that ActionInvocation.</p> 
<p>In the previous section, we said that the ActionProxy sets up some state before<br /> invoking the ActionInvocation and cleans up some state afterward. This setup<br /> associates the ActionContext with the current Thread so that it’s available during<br /> the ActionInvocation execution. Let’s look at what the ActionProxy is doing<br /> before and after invoking the ActionInvocation; see figure A.5.</p> 
<p><span><img class="blogimg" border="0" small="0" src="image/WebWork In Action - .ecd5982f19591b061e30895e.jpg" /><p class="origImg">http://hiphotos.baidu.com/hxzon/pic/item/ecd5982f19591b061e30895e.jpg</p><br /> </span></p> 
<p>Figure A.5 shows the sequence of calls made by the DefaultActionProxy before<br /> and after the ActionInvocation’s invoke() method is called. The ActionContext is<br /> created during the ActionInvocation and ActionProxy construction and stored<br /> until the ActionProxy is executed, when it’s associated with the Thread. During<br /> interceptor, action, and result execution, your code can use the ActionCon-<br /> text.getContext() method to get the ActionContext from the ThreadLocal and<br /> thus get the current execution context. <br /> The ActionContext contains valuable information about the environment dur-<br /> ing execution. These context values are set up by the ServletDispatcher before<br /> creating the ActionProxy and are passed in the extraContext Map to the createAc-<br /> tionProxy() method on the ActionProxyFactory. The properties found in the<br /> ActionContext are as follows:<br /> ■ ActionInvocation—getActionInvocation() gives access to the current<br /> ActionInvocation, which is associated with this ActionContext.<br /> ■ Application—getApplication() gives you a java.util.Map implementa-<br /> tion that wraps the application scope using the ServletContext. You can<br /> read and write to the application scope using this map.<br /> ■ ConversionErrors—getConversionErrors() returns a Map of field name to<br /> field value pairs for all fields that had type-conversion errors. We discuss this<br /> in detail in chapter 12.<br /> ■ Locale—getLocale() gets the locale of the current request. This locale is<br /> used for finding localized text messages, as you see in detail in chapter 14.<br /> ■ Name—getName() gets the name of the current action. This is from the part<br /> of the request that identifies the action to execute and corresponds to the<br /> action name mapped in the xwork.xml file.<br /> ■ Parameters—getParameters() returns the Map of parameters from the<br /> request. This Map is from String parameter names to String[] values—<br /> because the parameters from an HttpServletRequest can have multiple val-<br /> ues for each parameter name, the Map gives you String arrays.<br /> ■ Session—getSession() returns a java.util.Map implementation that<br /> wraps the HttpSession attributes. You can get and set values to/from the<br /> session using this Map.<br /> ■ ValueStack—getValueStack() returns the value stack of the current request. <br /> Along with these predefined values, you can use the put() and get() methods to set<br /> your own values into the ActionContext to be available later, without having to pass<br /> the values explicitly. You could do so, for instance, to associate a database connec-<br /> tion to be used during processing of the interceptors and the action with the cur-<br /> rent ActionContext ThreadLocal. In that way, your code can retrieve the database<br /> connection anywhere it’s needed without having to pass it in every method call.<br /> Your code can also skip the thread-safety that would be needed for a static storage<br /> solution, because the ActionContext is associated with only one Thread.</p> 
<h3>A.7.1 ThreadLocal storage</h3> 
<p>The ActionContext is implemented as a ThreadLocal so that it’s always available<br /> without having to be passed along in every method call. ThreadLocals<br /> (java.lang.ThreadLocal) were added in Java 1.2. They provide Thread-specific<br /> storage, where each Thread has its own instance of the Object. Accessors for get-<br /> ting the ThreadLocal value can be static methods, allowing the ThreadLocal value<br /> to be retrieved anywhere; it need not be passed as a method parameter.<br /> Listing A.1 shows the ThreadLocal-specific code in ActionContext.</p> 
<p>Listing A.1 ActionContext’s ThreadLocal-specific code</p> 
<pre>static ThreadLocal actionContext = new ActionContextThreadLocal();<br />public static void setContext(ActionContext aContext) {<br />    actionContext.set(aContext);<br />}<br />/**<br /> * Returns the ActionContext specific to the current thread.<br /> *<br /> * @return ActionContext for the current thread<br /> */<br />public static ActionContext getContext() {<br />    ActionContext context = (ActionContext) actionContext.get();<br />    if (context == null) {<br />        OGNLValueStack vs = new OGNLValueStack();<br />        context = new ActionContext(vs.getContext());<br />        setContext(context);<br />    }<br />    return context;<br />}<br />private static class ActionContextThreadLocal extends ThreadLocal {<br />    protected Object initialValue() {<br />        OGNLValueStack vs = new OGNLValueStack();
        return new ActionContext(vs.getContext());<br />    }<br />}</pre> 
<p>Looking at the getContext() and setContext() methods, you see that they use the<br /> ThreadLocal set() and get() methods. The ThreadLocal set() method associates<br /> an Object with the ThreadLocal for later retrieval. The ThreadLocal get() method<br /> retrieves the Object currently associated with the ThreadLocal for this Thread. <br /> The only other implementation detail is the ActionContextThreadLocal inner<br /> class. It’s a specialized subclass of ThreadLocal that overrides the initialValue()<br /> method from ThreadLocal to set up a default value for the ThreadLocal, so that<br /> the first call to get() on the ThreadLocal doesn’t return null.<br /> One note about using ThreadLocals: They’re notoriously tricky in unit testing.<br /> Take proper care to set up and tear down ThreadLocals before and after unit tests,<br /> to ensure that the tests don’t interfere with one another. If you look at the unit<br /> tests in XWork and WebWork, you can see the effort involved to make sure the<br /> unit tests don’t leave any side effects that can cause unforeseen interactions.</p> 
<h2>A.8 The servlet dispatcher</h2> 
<p>The ServletDispatcher is the main entry point of requests in WebWork. It’s a serv-<br /> let that is normally mapped to an extension (typically *.action, although *.jspa is<br /> another common extension used by the WebWork community). It uses the request<br /> path to determine which action to execute, as discussed in section 3.2.2 on<br /> namespaces. The ServletDispatcher serves as the adapter between the HTTP<br /> request/response world of servlets and WebWork and the generic Command pat-<br /> tern action/result world of XWork. <br /> The ServletDispatcher creates the context for executing an action by setting<br /> up java.util.Map implementations that wrap the application-, session-, and<br /> parameter-scoped attributes. It then uses the ActionProxyFactory to create an<br /> ActionProxy, returning an error to the user if no action is mapped to the<br /> requested name. Finally, the ServletDispatcher executes the ActionProxy, which,<br /> as you saw earlier, includes executing any associated interceptors, the action itself,<br /> and whichever result is mapped to the result code returned from the action. This<br /> result could, for instance, render a web page or create a PDF document. The<br /> ServletDispatcher also handles wrapping the request for multipart file-upload<br /> requests (discussed in chapter 4) and handling error codes, and is generally the<br /> glue that ties WebWork together.</p> 
<h2>A.9 Summary</h2> 
<p>At its heart, WebWork is a Command pattern implementation (XWork) wrapped<br /> with an MVC web application framework (WebWork). The framework handles<br /> command execution, allowing the calling code to be decoupled from the con-<br /> crete action classes and allowing the framework to add services around the action<br /> execution. These services are provided in the form of interceptors in WebWork,<br /> and they handle much of the framework’s core functionality. <br /> In order to add these services, the framework encapsulates the execution of an<br /> action in an ActionProxy/ActionInvocation pair. The ActionProxy/ActionInvoca-<br /> tion wraps the action, includes the interceptors and the result, and manages when<br /> each is called during execution. Interceptors are called in order and can do what-<br /> ever they need to before and after executing the rest of the ActionInvocation<br /> (including the other interceptors). During the action execution, the action, inter-<br /> ceptors, and result can access a ThreadLocal storage space called the Action-<br /> Context, which is managed by the ActionProxy and is available only during the<br /> ActionProxy.execute() method. <br /> ActionProxy instances are created by the ServletDispatcher using the static<br /> ActionProxyFactory instance. The ServletDispatcher maps HTTP requests com-<br /> ing into an action namespace and action alias, which are used to create the cor-<br /> rect ActionProxy by the ActionProxyFactory. The ServletDispatcher then<br /> executes the ActionProxy, which handles executing the interceptors, action, and<br /> result (such as a web page or a PDF).</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p><img border="0" align="absMiddle" src="image/WebWork In Action - .4a90f60324ce10493912bbe6.jpg" /><p class="origImg">http://hiphotos.baidu.com/hxzon/pic/item/4a90f60324ce10493912bbe6.jpg</p></p></div></body></html>