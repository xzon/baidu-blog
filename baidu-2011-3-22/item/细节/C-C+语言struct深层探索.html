<html><head><title><div class="tit">
  C/C+语言struct深层探索
</div></title></head><body><div id='tit'>C/C+语言struct深层探索</div><div id='cate'>细节</div><div id='date'>2008年03月27日 星期四 08:16 P.M.</div><div id='page'>154</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/eeb593cadfff4382c9176882.html'>http://hi.baidu.com/hxzon/blog/item/eeb593cadfff4382c9176882.html</a><div id='cnt'><p><u><font color="#810081">C/C+语言struct深层探索 </font></u></p> 
<p>1. struct的巨大作用<br /> 面对一个人的大型C/C++程序时，只看其对struct的使用情况我们就可以对其编写者的编程经验进行评估。 因为一个大型的C/C++程序，势必要涉及一些(甚至大量)进行数据组合的结构体，这些结构体可以将原本意义属于一个整体的数据组合在一起。从某种程度上 来说，会不会用struct，怎样用struct是区别一个开发人员是否具备丰富开发经历的标志。<br /> <br /> 在网络协议、通信控制、嵌入式系统的C/C++编程中，我们经常要传送的不是简单的字节流（char型数组），而是多种数据组合起来的一个整体，其表现形式是一个结构体。<br /> <br /> 经验不足的开发人员往往将所有需要传送的内容依顺序保存在char型数组中，通过指针偏移的方法传送网络报文等信息。这样做编程复杂，易出错，而且一旦控制方式及通信协议有所变化，程序就要进行非常细致的修改。<br /> <br /> 一个有经验的开发者则灵活运用结构体，举一个例子，假设网络或控制协议中需要传送三种报文，其格式分别为packetA、packetB、packetC：<br /> <br /> struct structA <br /> {<br /> int a;<br /> char b;<br /> };<br /> <br /> struct structB <br /> {<br /> char a;<br /> short b;<br /> };<br /> <br /> struct structC<br /> {<br /> int a;<br /> char b;<br /> float c;<br /> }<br /> 优秀的程序设计者这样设计传送的报文：<br /> <br /> struct CommuPacket<br /> {<br /> int iPacketType; //报文类型标志<br /> union //每次传送的是三种报文中的一种，使用union<br /> {<br /> &nbsp;&nbsp; struct structA packetA;<br /> &nbsp;&nbsp; struct structB packetB;<br /> &nbsp;&nbsp; struct structC packetC;<br /> }<br /> };<br /> 在进行报文传送时，直接传送struct CommuPacket一个整体。<br /> <br /> 假设发送函数的原形如下：<br /> <br /> // pSendData：发送字节流的首地址，iLen：要发送的长度<br /> Send(char * pSendData, unsigned int&nbsp;&nbsp; iLen);<br /> 发送方可以直接进行如下调用发送struct CommuPacket的一个实例sendCommuPacket：<br /> Send( (char *)&amp;sendCommuPacket , sizeof(CommuPacket) );<br /> 假设接收函数的原形如下：<br /> // pRecvData：发送字节流的首地址，iLen：要接收的长度<br /> //返回值：实际接收到的字节数<br /> unsigned int Recv(char * pRecvData, unsigned int&nbsp;&nbsp; iLen)；<br /> 接收方可以直接进行如下调用将接收到的数据保存在struct CommuPacket的一个实例recvCommuPacket中：<br /> <br /> Recv( (char *)&amp;recvCommuPacket , sizeof(CommuPacket) );<br /> 接着判断报文类型进行相应处理：<br /> <br /> switch(recvCommuPacket. iPacketType)<br /> {<br /> &nbsp;&nbsp;&nbsp;&nbsp; case PACKET_A:<br /> &nbsp;&nbsp;&nbsp;&nbsp; …&nbsp;&nbsp;&nbsp;&nbsp; //A类报文处理<br /> &nbsp;&nbsp;&nbsp;&nbsp; break;<br /> &nbsp;&nbsp;&nbsp;&nbsp; case PACKET_B:<br /> &nbsp;&nbsp;&nbsp;&nbsp; … &nbsp;&nbsp; //B类报文处理<br /> &nbsp;&nbsp;&nbsp;&nbsp; break;<br /> &nbsp;&nbsp;&nbsp;&nbsp; case PACKET_C:<br /> &nbsp;&nbsp;&nbsp;&nbsp; …&nbsp;&nbsp;&nbsp; //C类报文处理<br /> &nbsp;&nbsp;&nbsp;&nbsp; break;<br /> }<br /> 以上程序中最值得注意的是<br /> <br /> Send( (char *)&amp;sendCommuPacket , sizeof(CommuPacket) );<br /> Recv( (char *)&amp;recvCommuPacket , sizeof(CommuPacket) );<br /> 中的强制类型转换：(char *)&amp;sendCommuPacket、(char *)&amp;recvCommuPacket，先取地址，再转化为char型指针，这样就可以直接利用处理字节流的函数。<br /> <br /> 利用这种强制类型转化，我们还可以方便程序的编写，例如要对sendCommuPacket所处内存初始化为0，可以这样调用标准库函数memset()：<br /> <br /> memset((char *)&amp;sendCommuPacket,0, sizeof(CommuPacket));<br /> <br /> 2. struct的成员对齐<br /> Intel、微软等公司曾经出过一道类似的面试题：<br /> <br /> 1. #include &lt;iostream.h&gt;<br /> <br /> 2. #pragma pack(8)<br /> 3. struct example1<br /> 4. {<br /> 5. short a;<br /> 6. long b;<br /> 7. };<br /> <br /> 8. struct example2<br /> 9. {<br /> 10. char c;<br /> 11. example1 struct1;<br /> 12. short e;&nbsp;&nbsp;&nbsp;&nbsp;<br /> 13. };<br /> 14. #pragma pack()<br /> <br /> 15. int main(int argc, char* argv[])<br /> 16. {<br /> 17. example2 struct2;<br /> <br /> 18. cout &lt;&lt; sizeof(example1) &lt;&lt; endl;<br /> 19. cout &lt;&lt; sizeof(example2) &lt;&lt; endl;<br /> 20. cout &lt;&lt; (unsigned int)(&amp;struct2.struct1) - (unsigned int)(&amp;struct2) <br /> &lt;&lt; endl;<br /> <br /> 21. return 0;<br /> 22. }<br /> 问程序的输入结果是什么？<br /> <br /> 答案是：<br /> <br /> 8<br /> 16<br /> 4<br /> <br /> 不明白？还是不明白？下面一一道来：<br /> <br /> 2.1 自然对界<br /> <br /> struct是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如 array、struct、union等）的数据单元。对于结构体，编译器会自动进行成员变量的对齐，以提高运算效率。缺省情况下，编译器为结构体的每个 成员按其自然对界（natural alignment）条件分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。<br /> <br /> 自然对界(natural alignment)即默认对齐方式，是指按结构体的成员中size最大的成员对齐。<br /> <br /> 例如：<br /> <br /> struct naturalalign<br /> {<br /> char a;<br /> short b;<br /> char c;<br /> };<br /> 在上述结构体中，size最大的是short，其长度为2字节，因而结构体中的char成员a、c都以2为单位对齐，sizeof(naturalalign)的结果等于6；<br /> <br /> 如果改为：<br /> <br /> struct naturalalign<br /> {<br /> char a;<br /> int b;<br /> char c;<br /> };<br /> 其结果显然为12。<br /> <br /> 2.2指定对界<br /> <br /> 一般地，可以通过下面的方法来改变缺省的对界条件：<br /> <br /> &middot; 使用伪指令#pragma pack (n)，编译器将按照n个字节对齐；<br /> &middot; 使用伪指令#pragma pack ()，取消自定义字节对齐方式。<br /> <br /> 注意：如果#pragma pack (n)中指定的n大于结构体中最大成员的size，则其不起作用，结构体仍然按照size最大的成员进行对界。<br /> <br /> 例如：<br /> <br /> #pragma pack (n)<br /> struct naturalalign<br /> {<br /> char a;<br /> int b;<br /> char c;<br /> };<br /> #pragma pack ()<br /> 当n为4、8、16时，其对齐方式均一样，sizeof(naturalalign)的结果都等于12。而当n为2时，其发挥了作用，使得sizeof(naturalalign)的结果为8。<br /> <br /> 在VC++ 6.0编译器中，我们可以指定其对界方式，其操作方式为依次选择projetct &gt; setting &gt; C/C++菜单，在struct member alignment中指定你要的对界方式。<br /> <br /> 另外，通过__attribute((aligned (n)))也可以让所作用的结构体成员对齐在n字节边界上，但是它较少被使用，因而不作详细讲解。<br /> <br /> 2.3 面试题的解答<br /> <br /> 至此，我们可以对Intel、微软的面试题进行全面的解答。<br /> <br /> 程序中第2行#pragma pack (8)虽然指定了对界为8，但是由于struct example1中的成员最大size为4（long变量size为4），故struct example1仍然按4字节对界，struct example1的size为8，即第18行的输出结果；<br /> <br /> struct example2中包含了struct example1，其本身包含的简单数据成员的最大size为2（short变量e），但是因为其包含了struct example1，而struct example1中的最大成员size为4，struct example2也应以4对界，#pragma pack (8)中指定的对界对struct example2也不起作用，故19行的输出结果为16；<br /> <br /> 由于struct example2中的成员以4为单位对界，故其char变量c后应补充3个空，其后才是成员struct1的内存空间，20行的输出结果为4。<br /> <br /> <br /> 3. C和C++间struct的深层区别<br /> 在C++语言中struct具有了“类” 的功能，其与关键字class的区别在于struct中成员变量和函数的默认访问权限为public，而class的为private。<br /> <br /> 例如，定义struct类和class类：<br /> <br /> struct structA<br /> {<br /> char a;<br /> …<br /> }<br /> class classB<br /> {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; …<br /> }<br /> 则：<br /> <br /> struct A a;<br /> a.a = 'a';&nbsp;&nbsp;&nbsp;&nbsp; //访问public成员，合法<br /> classB b;<br /> b.a = 'a';&nbsp;&nbsp;&nbsp;&nbsp; //访问private成员，不合法<br /> 许多文献写到这里就认为已经给出了C++中struct和class的全部区别，实则不然，另外一点需要注意的是：<br /> <br /> C++中的struct保持了对C中struct的全面兼容（这符合C++的初衷——“a better c”），因而，下面的操作是合法的：<br /> <br /> //定义struct<br /> struct structA<br /> {<br /> char a;<br /> char b;<br /> int c;<br /> };<br /> structA a = {'a' , 'a' ,1};&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; 定义时直接赋初值<br /> 即struct可以在定义的时候直接以{ }对其成员变量赋初值，而class则不能，在经典书目《thinking C++ 2nd edition》中作者对此点进行了强调。<br /> <br /> 4. struct编程注意事项<br /> 看看下面的程序：<br /> <br /> 1. #include &lt;iostream.h&gt;<br /> <br /> 2. struct structA<br /> 3. {<br /> 4. int iMember;<br /> 5. char *cMember;<br /> 6. };<br /> <br /> 7. int main(int argc, char* argv[])<br /> 8. {<br /> 9. structA instant1,instant2;<br /> 10.char c = 'a';<br /> &nbsp;&nbsp;&nbsp;&nbsp;<br /> 11. instant1.iMember = 1;<br /> 12. instant1.cMember = &amp;c; <br /> <br /> 13.instant2 = instant1;<br /> <br /> 14.cout &lt;&lt; *(instant1.cMember) &lt;&lt; endl;<br /> <br /> 15.*(instant2.cMember) = 'b';<br /> <br /> 16. cout &lt;&lt; *(instant1.cMember) &lt;&lt; endl;<br /> <br /> 17. return 0;<br /> }<br /> 14行的输出结果是：a<br /> 16行的输出结果是：b<br /> <br /> Why?我们在15行对instant2的修改改变了instant1中成员的值！<br /> <br /> 原因在于13行的instant2 = instant1赋值语句采用的是变量逐个拷贝，这使得instant1和instant2中的cMember指向了同一片内存，因而对instant2的修改也是对instant1的修改。<br /> <br /> 在C语言中，当结构体中存在指针型成员时，一定要注意在采用赋值语句时是否将2个实例中的指针型成员指向了同一片内存。<br /> <br /> 在C++语言中，当结构体中存在指针型成员时，我们需要重写struct的拷贝构造函数并进行“=”操作符重载。 <br /> <a href="http://blog.csdn.net/qianling3439/archive/2008/03/20/2199140.aspx">http://blog.csdn.net/qianling3439/archive/2008/03/20/2199140.aspx</a></p></div></body></html>