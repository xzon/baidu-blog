<html><head><title><div class="tit">
  Variant 用法详解
</div></title></head><body><div id='tit'>Variant 用法详解</div><div id='cate'>细节</div><div id='date'>2008年03月21日 星期五 12:28 P.M.</div><div id='page'>157</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/1c607dcbad1a271bbf09e668.html'>http://hi.baidu.com/hxzon/blog/item/1c607dcbad1a271bbf09e668.html</a><div id='cnt'><p>Variant 用法详解</p> 
<p class="docText">在你的程序中使用 <tt><font face="NSimsun">variant</font></tt>，要包含头文件 <tt><font face="NSimsun">&quot;boost/variant.hpp&quot;</font></tt>。这个头文件包含了整个库，所以你不必知道要使用哪些单独的特性；以后，如果你要降低相关性，可以只包含那些解决问题所要的头文件。声明一个 <tt><font face="NSimsun">variant</font></tt> 类型时，我们必须定义一组它可以存储的类型。最常用的办法是使用模板参数。一个可以持有类型为 <tt><font face="NSimsun">int</font></tt>, <tt><font face="NSimsun">std::string</font></tt>, 或 <tt><font face="NSimsun">double </font></tt>的值的 <tt><font face="NSimsun">variant</font></tt> 声明如下。</p> 
<pre>boost::variant&lt;int,std::string,double&gt; my_first_variant;</pre> 
<p class="docText">当变量 <tt><font face="NSimsun">my_first_variant</font></tt> 被创建时，它含有一个缺省构造的 <tt><font face="NSimsun">int</font></tt>, 因为 <tt><font face="NSimsun">int</font></tt> 是这个 <tt><font face="NSimsun">variant</font></tt> 可以持有的类型中的第一种类型。我们也可以传递一个可以转换为可用类型之一的值来初始化 <tt><font face="NSimsun">variant</font></tt>.</p> 
<pre>boost::variant&lt;int,std::string,double&gt;<br /> my_first_variant(&quot;Hello world&quot;);</pre> 
<p class="docText">我们可以随时赋给新的值，只要这个新值有确定的类型并且可以转换为 <tt><font face="NSimsun">variant</font></tt> 可以持有的类型中的某一种，它可以很好地工作。</p> 
<pre>my_first_variant=24;<br />my_first_variant=2.52;<br />my_first_variant=&quot;Fabulous!&quot;;<br />my_first_variant=0;</pre> 
<p class="docText">在第一个赋值后，所含值的类型为 <tt><font face="NSimsun">int</font></tt>; 第二个赋值后，类型为 <tt><font face="NSimsun">double</font></tt>; 第三个后，类型为 <tt><font face="NSimsun">std::string</font></tt>; 最后，又变回 <tt><font face="NSimsun">int</font></tt>. 如果我们想看看，我们可以用函数 <tt><font face="NSimsun">boost::get</font></tt> 取出这个值，如下：</p> 
<pre>assert(boost::get&lt;int&gt;(my_first_variant)==0);</pre> 
<p class="docText">注意，如果调用 <tt><font face="NSimsun">get</font></tt> 失败(当 <tt><font face="NSimsun">my_first_variant</font></tt> 所含值不是类型 <tt><font face="NSimsun">int</font></tt> 时就会发生)，会抛出一个类型为 <tt><font face="NSimsun">boost::bad_get</font></tt> 的异常。为了避免在失败时得到一个异常，我们可以传给 <tt><font face="NSimsun">get</font></tt> 一个 <tt><font face="NSimsun">variant</font></tt> 指针，这样 <tt><font face="NSimsun">get</font></tt> 将返回一个指向它所含值的指针，或者如果给定类型与 <tt><font face="NSimsun">variant </font></tt>的值的类型不符则返回空指针。以下是它的用法：</p> 
<pre>int* val=boost::get&lt;int&gt;(&amp;my_first_variant);<br />assert(val &amp;&amp; (*val)==0);</pre> 
<p class="docText">函数 <tt><font face="NSimsun">get</font></tt> 是访问所含值的一种直接方法，事实上它与 <tt><font face="NSimsun">boost::any </font></tt>的 <tt><font face="NSimsun">any_cast </font></tt>很相似。注意，类型必须完全符合，包括相同的 cv-限定符(<tt><font face="NSimsun">const</font></tt> 和 <tt><font face="NSimsun">volatile</font></tt>)。但是，可以使用限制更多的 cv-限定符。如果类型不匹配且传给 <tt><font face="NSimsun">get </font></tt>的是一个 <tt><font face="NSimsun">variant</font></tt> 指针，将返回空指针。否则，抛出一个类型为 <tt><font face="NSimsun">bad_get</font></tt> 的异常。</p> 
<pre>const int&amp; i=boost::get&lt;const int&gt;(my_first_variant);</pre> 
<p class="docText">过分依赖于 <tt><font face="NSimsun">get </font></tt>的代码很容易变得脆弱；如果我们不知道所含值的类型，我们可能会想测试所有可能的组合，就如下面这个例子的做法。</p> 
<pre>#include &lt;iostream&gt;<br />#include &lt;string&gt;<br />#include &quot;boost/variant.hpp&quot;<br /><br />template &lt;typename V&gt; void print(V&amp; v) {<br />  if (int* pi=boost::get&lt;int&gt;(&amp;v))<br />    std::cout &lt;&lt; &quot;It's an int: &quot; &lt;&lt; *pi &lt;&lt; '\n';<br />  else if (std::string* ps=boost::get&lt;std::string&gt;(&amp;v))<br />    std::cout &lt;&lt; &quot;It's a std::string: &quot; &lt;&lt; *ps &lt;&lt; '\n';<br />  else if (double* pd=boost::get&lt;double&gt;(&amp;v))<br />    std::cout &lt;&lt; &quot;It's a double: &quot; &lt;&lt; *pd &lt;&lt; '\n';<br /><br />  std::cout &lt;&lt; &quot;My work here is done!\n&quot;;<br />}<br /><br />int main() {<br />  boost::variant&lt;int,std::string,double&gt;<br />    my_first_variant(&quot;Hello there!&quot;);<br />  print(my_first_variant);<br />  my_first_variant=12;<br />  print(my_first_variant);<br />  my_first_variant=1.1;<br />  print(my_first_variant);<br />}</pre> 
<p class="docText">函数 <tt><font face="NSimsun">print</font></tt> 现在可以正确工作，但如果我们决定改变 <tt><font face="NSimsun">variant</font></tt> 的类型组的话会怎样？我们将引入一个微妙的bug，而不能在编译期捉住它；函数 <tt><font face="NSimsun">print</font></tt> 不能打印任何其它我们没有预先想到的类型的值。如果我们没有使用模板函数，而是要求一个明确的 <tt><font face="NSimsun">variant</font></tt> 类型，我们就要为不同类型的 <tt><font face="NSimsun">variant</font></tt> 重载多个相同功能的函数。下一节将讨论访问 <tt><font face="NSimsun">variant </font></tt>的概念，以及这种(类型安全的)访问机制解决的问题。</p> 
<a name="ch07lev2sec3"></a> 
<h4 class="docSection2Title">访问Variants</h4> 
<p class="docText">让我们从一个例子开始，它解释了为什么使用 <tt><font face="NSimsun">get</font></tt> 并没有你想要的那么可靠。从前面父子的代码开始，我们来修改一下 <tt><font face="NSimsun">variant</font></tt> 可以包含的类型，并对 <tt><font face="NSimsun">variant </font></tt>的一个 <tt><font face="NSimsun">char </font></tt>值来调用 <tt><font face="NSimsun">print</font></tt> 。</p> 
<pre>int main() {<br />  boost::variant&lt;int,std::string,double,char&gt;<br />    my_first_variant(&quot;Hello there!&quot;);<br /> <br />  print(my_first_variant);<br />  my_first_variant=12;<br />  print(my_first_variant);<br />  my_first_variant=1.1;<br />  print(my_first_variant);<br />  my_first_variant='a';<br />  print(my_first_variant);<br />}</pre> 
<p class="docText">虽然我们给 <tt><font face="NSimsun">variant</font></tt> 的类型组增加了 <tt><font face="NSimsun">char</font></tt> ，并且程序的最后两行设置了一个 <tt><font face="NSimsun">char</font></tt> 值并调用 <tt><font face="NSimsun">print</font></tt> ，编译器也不会有意见 (注意，<tt><font face="NSimsun">print</font></tt> 是以 <tt><font face="NSimsun">variant</font></tt> 的类型来特化的，所以它可以很容易适应新的 <tt><font face="NSimsun">variant</font></tt> 定义)。以下是这个程序的运行结果：</p> 
<pre>It's a std::string: Hello there!<br />My work here is done!<br />It's an int: 12<br />My work here is done!<br />It's a double: 1.1<br />My work here is done!<br />My work here is done!</pre> 
<p class="docText">这个输出显示了一个问题。最后一个&quot;My work here is done!&quot;之前没有值的报告。原因是很简单，<tt><font face="NSimsun">print</font></tt> 不能输出除了它原来设计好的那些类型(<tt><font face="NSimsun">std::string</font></tt>, <tt><font face="NSimsun">int</font></tt>, 和 <tt><font face="NSimsun">double</font></tt>)以外的任何值，但它可以干净地编译和运行。如果 <tt><font face="NSimsun">variant </font></tt>的当前类型不被 <tt><font face="NSimsun">print </font></tt>支持，它的值就会被简单地忽略掉。使用 <tt><font face="NSimsun">get</font></tt> 还有更多潜在的问题，例如 if 语句的顺序要与类的层次相一致。注意，这并不是说你应该完全避免使用 <tt><font face="NSimsun">get</font></tt>；它只是说有些时候它不是最好的方法。有一种更好的机制，可以允许我们规定哪些类型的值可以接受，并且这些规定是在编译期生效的。这是就 <tt><font face="NSimsun">variant</font></tt> 访问机制的作用。通过把一个访问器应用到 <tt><font face="NSimsun">variant</font></tt>，编译器可以保证它们完全兼容。Boost.Variant 中这些访问器是带有一些函数调用操作符的函数对象，这些函数调用操作符接受与它们所访问的 <tt><font face="NSimsun">variant </font></tt>可以包含的类型组相对应的参数。</p> 
<p class="docText">现在我们用访问器来重写那个声名狼籍的函数 <tt><font face="NSimsun">print</font></tt> ，如下：</p> 
<pre>class print_visitor : public boost::static_visitor&lt;void&gt; {<br />public:<br />  void operator()(int i) const {<br />    std::cout &lt;&lt; &quot;It's an int: &quot; &lt;&lt; i &lt;&lt; '\n';<br />  }<br /><br />  void operator()(std::string s) const {<br />    std::cout &lt;&lt; &quot;It's a std::string: &quot; &lt;&lt; s &lt;&lt; '\n';<br />  }<br /><br />  void operator()(double d) const {<br />    std::cout &lt;&lt; &quot;It's a double: &quot; &lt;&lt; d &lt;&lt; '\n';<br />  }<br /><br />};</pre> 
<p class="docText">要让 <tt><font face="NSimsun">print_visitor</font></tt> 成为 <tt><font face="NSimsun">variant</font></tt> 的一个访问器，我们要让它派生自 <tt><font face="NSimsun">boost::static_visitor</font></tt> 以获得正确的 <tt><font face="NSimsun">typedef</font></tt> (<tt><font face="NSimsun">result_type</font></tt>), 并明确地声明这个类是一个访问器类型。这个类实现了三个重载版本的函数调用操作符，分别接受一个 <tt><font face="NSimsun">int</font></tt>, 一个 <tt><font face="NSimsun">std::string</font></tt>, 和一个 <tt><font face="NSimsun">double</font></tt> 。为了访问 <tt><font face="NSimsun">variant</font></tt>, 你要用函数 <tt><font face="NSimsun">boost::apply_visitor</font></tt>(<span class="docEmphasis">visitor, variant</span>). 如果我们用对 <tt><font face="NSimsun">apply_visitor</font></tt>的调用来替换前面的 <tt><font face="NSimsun">print</font></tt> 调用，我们可以得到如下代码：</p> 
<pre>int main() {<br />  boost::variant&lt;int,std::string,double,char&gt;<br />    my_first_variant(&quot;Hello there!&quot;);<br /> <br />  print_visitor v;<br /> <br />  boost::apply_visitor(v,my_first_variant);<br />  my_first_variant=12;<br />  boost::apply_visitor(v,my_first_variant);<br />  my_first_variant=1.1;<br />  boost::apply_visitor(v,my_first_variant);<br />  my_first_variant='a';<br />  boost::apply_visitor(v,my_first_variant);<br />}</pre> 
<p class="docText">这里，我们创建了一个 <tt><font face="NSimsun">print_visitor</font></tt>, 名为 <tt><font face="NSimsun">v</font></tt>, 并把它应用于赋值后的 <tt><font face="NSimsun">my_first_ variant</font></tt> 。因为我们没有一个函数调用操作符接受 <tt><font face="NSimsun">char</font></tt>, 这段代码会编译失败，是吗？错！一个 <tt><font face="NSimsun">char</font></tt> 可以转换为一个 <tt><font face="NSimsun">int</font></tt>, 所以这个访问器可以兼容我们的 <tt><font face="NSimsun">variant</font></tt> 类型。以下是程序运行的结果。</p> 
<pre>It's a std::string: Hello there!<br />It's an int: 12<br />It's a double: 1.1<br />It's an int: 97</pre> 
<p class="docText">这里我们可以学到两件事情：第一个是字母 <tt><font face="NSimsun">a</font></tt> 的 ASCII 码值为 97, 更重要的是第二个，如果一个访问器以传值的方式传递参数，则传送的值可以应用隐式转换。如果我们想访问器只能使用精确的类型(同时也避免拷贝从 <tt><font face="NSimsun">variant</font></tt> 得到的值)，我们必须修改访问器的调用操作符传递参数的方式。以下这个版本的 <tt><font face="NSimsun">print_visitor</font></tt> 只能使用类型 <tt><font face="NSimsun">int</font></tt>, <tt><font face="NSimsun">std::string</font></tt>, 和 <tt><font face="NSimsun">double</font></tt>; 以及可以隐式转换到这些类型的引用的其它类型。</p> 
<pre>class print_visitor : public boost::static_visitor&lt;void&gt; {<br />public:<br />  void operator()(int&amp; i) const {<br />    std::cout &lt;&lt; &quot;It's an int: &quot; &lt;&lt; i &lt;&lt; '\n';<br />  }<br /><br />  void operator()(std::string&amp; s) const {<br />    std::cout &lt;&lt; &quot;It's a std::string: &quot; &lt;&lt; s &lt;&lt; '\n';<br />  }<br /><br />  void operator()(double&amp; d) const {<br />    std::cout &lt;&lt; &quot;It's a double: &quot; &lt;&lt; d &lt;&lt; '\n';<br />  }<br />};</pre> 
<p class="docText">如果再编译一下这个程序，编译器就不高兴了，它会输出如下信息：</p> 
<pre>c:/boost_cvs/boost/boost/variant/variant.hpp:<br />In member function `typename Visitor::result_type boost::detail:: variant::<br />invoke_visitor&lt;Visitor&gt;::internal_visit(T&amp;, int)<br />[with T = char, Visitor = print_visitor]':<br /><br />[Snipped lines of irrelevant information here]<br /><br />c:/boost_cvs/boost/boost/variant/variant.hpp:807:<br />error: no match for call to `(print_visitor) (char&amp;)'<br />variant_sample1.cpp:40: error: candidates are:<br /> void print_visitor::operator()(int&amp;) const<br />variant_sample1.cpp:44: error:<br /> void print_visitor::operator()(std::string&amp;) const<br />variant_sample1.cpp:48: error:<br /> void print_visitor::operator()(double&amp;) const</pre> 
<p class="docText">这个错误指出了问题：没有一个候选的函数接受 <tt><font face="NSimsun">char</font></tt> 参数！为什么说类型安全的编译期访问机制是一个强大的机制，这正是一个重要的原因。它使得访问机制强烈依赖于类型，避免了讨厌的类型变换。创建访问器与创建其它函数对象一样容易，因此学习曲线并不陡峭。当 <tt><font face="NSimsun">variant </font></tt>中的类型组可能会改变时(它们总是倾向于变化！)，创建访问器要比单单依赖 <tt><font face="NSimsun">get</font></tt> 更可靠。虽然开始需要更高的代价，但绝对是值得的。</p> 
<a name="ch07lev2sec4"></a> 
<h4 class="docSection2Title">泛型访问器</h4> 
<p class="docText">通过使用访问器机制和泛型的调用操作符，可以创建能够接受任意类型的泛型访问器(无论是在语法上还是语义上，都可以实现泛型调用操作符)。这对于统一地处理不同的类型非常有用。C++的操作符就是&quot;通用&quot;性的一个典型例子，如算术和IO流的位移操作符。以下例子使用 <tt><font face="NSimsun">operator&lt;&lt;</font></tt> 来输出 <tt><font face="NSimsun">variant</font></tt> 的值到一个流。</p> 
<pre>#include &lt;iostream&gt;<br />#include &lt;sstream&gt;<br />#include &lt;string&gt;<br />#include &lt;sstream&gt;<br />#include &quot;boost/variant.hpp&quot;<br /><br />class stream_output_visitor :<br />  public boost::static_visitor&lt;void&gt; {<br />  std::ostream&amp; os_;<br />public:<br />  stream_output_visitor(std::ostream&amp; os) : os_(os) {}<br /><br />  template &lt;typename T&gt; void operator()(T&amp; t) const {<br />    os_ &lt;&lt; t &lt;&lt; '\n';<br />  }<br />};<br /><br />int main() {<br />  boost::variant&lt;int,std::string&gt; var;<br />  var=100;<br />  boost::apply_visitor(stream_output_visitor(std::cout),var);<br />  var=&quot;One hundred&quot;;<br />  boost::apply_visitor(stream_output_visitor(std::cout),var);<br />}</pre> 
<p class="docText">主要思想是 <tt><font face="NSimsun">stream_output_visitor </font></tt>中的调用操作符是一个成员函数模板，它在访问每一种类型(本例中是 <tt><font face="NSimsun">int</font></tt> 和 <tt><font face="NSimsun">std::string</font></tt>)时分别实例化。因为 <tt><font face="NSimsun">std::cout &lt;&lt; 100</font></tt> 和 <tt><font face="NSimsun">std::cout &lt;&lt; std::string(&quot;One hundred&quot;)</font></tt> 都已经有定义了，所以这段代码可以编译并工作良好。</p> 
<p class="docText">当然，操作符仅是可以使用泛型访问器的一个例子；它们常常应用于更多的类型。在某些值上调用函数，或者将它们作为参数传给其它的函数时，要求就是对于所有传给操作符的类型都要有相应的成员函数存在，并且对于被调用的函数要有合适的重载。这种泛型调用操作符的另一个有趣的方面是，可以对某些类型特化其行为，但对于其余类型则仍允许泛型的实现。在某种意义上，这涉及到模板特化，即基于类型信息的行为特殊化。</p> 
<a name="ch07lev2sec5"></a> 
<h4 class="docSection2Title">二元访问器</h4> 
<p class="docText">我们前面看到的访问器都是一元的，即它们只接受一个 <tt><font face="NSimsun">variant</font></tt> 作为唯一的参数。二元访问器接受两个(可能是不同的) <tt><font face="NSimsun">variant</font></tt>. 这种概念对于实现两个 <tt><font face="NSimsun">variant </font></tt>间的关系很有用。作为例子，我们为 <tt><font face="NSimsun">variant </font></tt>类型将创建一个按字典顺序的排序。为此，我们使用一个来自于标准库的非常有用的组件：<tt><font face="NSimsun">std::ostringstream</font></tt>. 它接受任意可流输出的东西，并且在需要时产生一个独立的 <tt><font face="NSimsun">std::string</font></tt> 。我们从而可以按字典序比较完全不同的 <tt><font face="NSimsun">variant</font></tt> 类型，只要假设所有限定的类型都支持流输出。和普通的访问器一样，二元访问器也派生自 <tt><font face="NSimsun">boost::static_visitor</font></tt>, 并且用模板参数表示调用操作符的返回类型。因为我们是创建一个谓词，因此返回类型为 <tt><font face="NSimsun">bool</font></tt>. 以下是一个我们即将用到的二元谓词。</p> 
<pre>class lexicographical_visitor :<br />  public boost::static_visitor&lt;bool&gt; {<br />public:<br />  template &lt;typename LHS,typename RHS&gt;<br />  bool operator()(const LHS&amp; lhs,const RHS&amp; rhs) const {<br />    return get_string(lhs)&lt;get_string(rhs);<br />  }<br />private:<br />  template &lt;typename T&gt; static std::string<br />  get_string(const T&amp; t) {<br />    std::ostringstream s;<br />    s &lt;&lt; t;<br />    return s.str();<br />  }<br /><br />  static const std::string&amp; get_string(const std::string&amp; s) {<br />    return s;<br />  }<br />};</pre> 
<p class="docText">这里的调用操作符泛化了它的两个参数，这意味着它接受任意两种类型的组合。对于 <tt><font face="NSimsun">variant</font></tt> 的可用类型组的要求就是它们必须是可流输出(<span class="docEmphasis">OutputStreamable</span>)的。成员函数模板 <tt><font face="NSimsun">get_string</font></tt> 使用一个 <tt><font face="NSimsun">std::ostringstream</font></tt> 来把它的参数转换为字符串表示，所以要求参数必须是可流输出的(为了使用 <tt><font face="NSimsun">std::ostringstream</font></tt>, 记得要包含头文件 <tt><font face="NSimsun">&lt;sstream&gt;</font></tt>)。成员函数 <tt><font face="NSimsun">get_string</font></tt> 针对类型为 <tt><font face="NSimsun">std::string</font></tt> 的参数进行特化，由于类型已经符合要求，所以它跳过了 <tt><font face="NSimsun">std::ostringstream</font></tt> 而直接返回它的参数。在两个参数都转为 <tt><font face="NSimsun">std::string</font></tt> 以后，剩下的就是使用 <tt><font face="NSimsun">operator&lt;</font></tt> 来比较它们了。现在我们把这个访问器放入测试代码，来对一个容器中的元素进行排序(我们还将重用我们在本章前面创建的 <tt><font face="NSimsun">stream_output_visitor</font></tt> )。</p> 
<pre>#include &lt;iostream&gt;<br />#include &lt;string&gt;<br />#include &lt;vector&gt;<br />#include &lt;algorithm&gt;<br />#include &quot;boost/variant.hpp&quot;<br /><br />int main() {<br />  boost::variant&lt;int,std::string&gt; var1=&quot;100&quot;;<br />  boost::variant&lt;double&gt; var2=99.99;<br /><br />  std::cout &lt;&lt; &quot;var1&lt;var2: &quot; &lt;&lt;<br />    boost::apply_visitor(<br />      lexicographical_visitor(),var1,var2) &lt;&lt; '\n';<br /><br />  typedef std::vector&lt;<br />    boost::variant&lt;int,std::string,double&gt; &gt; vec_type;<br /><br />  vec_type vec;<br />  vec.push_back(&quot;Hello&quot;);<br />  vec.push_back(12);<br />  vec.push_back(1.12);<br />  vec.push_back(&quot;0&quot;);<br /><br />  stream_output_visitor sv(std::cout);<br />  std::for_each(vec.begin(),vec.end(),sv);<br /><br />  lexicographical_visitor lv;<br />  std::sort(vec.begin(),vec.end(),boost::apply_visitor(lv));<br /><br />  std::cout &lt;&lt; '\n';<br />  std::for_each(vec.begin(),vec.end(),sv);<br />};</pre> 
<p class="docText">首先，我们将访问应用于两个 <tt><font face="NSimsun">variants</font></tt>, <tt><font face="NSimsun">var1</font></tt> 和 <tt><font face="NSimsun">var2</font></tt>, 如下：</p> 
<pre>boost::apply_visitor(lexicographical_visitor(),var1,var2)</pre> 
<p class="docText">如你所见，与一元访问器不同的是，有两个 <tt><font face="NSimsun">variant</font></tt> 被传递给函数 <tt><font face="NSimsun">apply_visitor</font></tt>. 一个更为常见的用例是使用这个谓词来对元素进行排序，我们这样来做：</p> 
<pre>lexicographical_visitor lv;<br />std::sort(vec.begin(),vec.end(),boost::apply_visitor(lv));</pre> 
<p class="docText">当 <tt><font face="NSimsun">sort</font></tt> 算法被执行时，它使用我们传入的谓词来比较它的元素，它是一个 <tt><font face="NSimsun">lexicographical_visitor</font></tt> 实例。注意，<tt><font face="NSimsun">boost::variant</font></tt> 已经定义了 <tt><font face="NSimsun">operator&lt;</font></tt>, 所以不使用谓词也可以对容器进行排序。</p> 
<pre>std::sort(vec.begin(),vec.end());</pre> 
<p class="docText">但是这种缺省的排序是首先使用 <tt><font face="NSimsun">which </font></tt>来检查当前值的索引，所以元素的排列顺序将是 <span class="docEmphasis">12, 0, Hello, 1.12,</span> 而我们想要的是按字典序来排序。因为 <tt><font face="NSimsun">variant</font></tt> 类已经提供了 <tt><font face="NSimsun">operator&lt;</font></tt> 和 <tt><font face="NSimsun">operator==</font></tt> ，所以 <tt><font face="NSimsun">variant</font></tt> 可以用作所有标准库容器的元素类型。当缺省的关系比较不够用时，你需要用二元访问器来实现一个。</p> 
<a name="ch07lev2sec6"></a> 
<h4 class="docSection2Title">更多应该知道的事情</h4> 
<p class="docText">我们并没有涉及到 Boost.Variant 库的所有功能。其它更为先进的特性不如我们已经提到的那么常用。但是，我会简要地说一下，因此你将至少知道在需要时可以找到哪些可用的东西。宏 <tt><font face="NSimsun">BOOST_VARIANT_ENUM_PARAMS</font></tt>, 可用于为 <tt><font face="NSimsun">variant </font></tt>类型重载/特化函数和类模板。这个宏用于列举 <tt><font face="NSimsun">variant </font></tt>可以包含的类型组。还有支持使用类型序列来创建 <tt><font face="NSimsun">variant</font></tt> 类型，即通过 <tt><font face="NSimsun">make_variant_over </font></tt>编译期列表来表示 <tt><font face="NSimsun">variant</font></tt> 的类型组。还有递归的 <tt><font face="NSimsun">variant</font></tt> 类型，可用于创建它们自己类型的表达式，递归 <tt><font face="NSimsun">variant</font></tt> 类型使用 <tt><font face="NSimsun">recursive_wrapper</font></tt>, <tt><font face="NSimsun">make_recursive_variant</font></tt>, 和 <tt><font face="NSimsun">make_recursive_variant_over</font></tt>. 如果你需要这些额外的特性，在线文档可以很好地解释它们。</p> 
<p class="docText"><a href="http://hi.baidu.com/_%E2d_%B7%B3_%DE%B2%C2%D2/blog/item/8685ccdd9d7765305982ddba.html">http://hi.baidu.com/_%E2d_%B7%B3_%DE%B2%C2%D2/blog/item/8685ccdd9d7765305982ddba.html</a></p> 
<p class="docText"><a href="http://hi.baidu.com/_%E2d_%B7%B3_%DE%B2%C2%D2/blog/category/boost%BF%E2%D1%A7%CF%B0">http://hi.baidu.com/_%E2d_%B7%B3_%DE%B2%C2%D2/blog/category/boost%BF%E2%D1%A7%CF%B0</a></p> 
<p class="docText"><a href="http://hi.baidu.com/_%E2d_%B7%B3_%DE%B2%C2%D2">http://hi.baidu.com/_%E2d_%B7%B3_%DE%B2%C2%D2</a></p></div></body></html>