<html><head><title><div class="tit">
  六度分隔与最短路径
</div></title></head><body><div id='tit'>六度分隔与最短路径</div><div id='cate'>设计方案</div><div id='date'>2008年07月03日 星期四 00:25 A.M.</div><div id='page'>120</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/33b380185fa507b14bedbcf4.html'>http://hi.baidu.com/hxzon/blog/item/33b380185fa507b14bedbcf4.html</a><div id='cnt'><p><font size="3">六度分隔与最短路径</font></p> 
<p><font size="3">【最短路径】</font></p> 
<p><font size="3">圆明园的北部有一个迷宫，据说古时候每次有庆典在圆明园的时候，皇帝会派一些宫女走迷宫，看谁最先走到迷宫内的亭子，会有不错的奖赏。</font></p> 
<p><font size="3">迷宫问题对数学家们来讲虽然是小儿科但在计算机课程上却非常重要，因为不同的求解会涉及到递归，广度优先和深度优先等算法。</font></p> 
<p><font size="3">迷宫毕竟是一个放置在2维空间的有限联系的网络，也就是说，迷宫里的每一个点，最多只和周围的4个点(上下左右)发生关系，而且这些点的位置是固定的。</font></p> 
<p><font size="3">六度分割通常用来描述一个广阔的社会网路（SN），现在大部分的社会网路服务都提供了搜索功能，即搜索出一个用户到达另外一个用户的最短路径，也就是找出这两个用户之间通过最少的用户的链接。</font></p> 
<p><font size="3">一般的SN提供的搜索都是4度的，也就是例如A-B-C-D-E 称为4度的分隔。提供5度搜索和6度搜索的几乎寥寥无几，当然一方面是5，6度分隔的用户很少，大部分的用户都应该在4度内，另外一个方面是5，6度分隔的搜索在实际计算上也涉及非常大的运算量。</font></p> 
<p><font size="3">【SN搜索算法】</font></p> 
<p><font size="3">如果说寻找两个人之间的最小分隔的路径和寻找最短路径可以类比，那么唯一不同的是SN上每个节点的联系可以非常的广阔，不只是上下左右，而是十个甚至上百个联系。这是是一个多维空间内的最短路径的寻找。假设一个用户平均有n个好友，那么粗略估计一个用户的4度好友大约有n&times;n&times;n&times;n＋n&times;n&times;n+n&times;n+n ~ n^4，无疑是一个非常恐怖的数目。因此采用传统的递归的方法显然是不大现实的。</font></p> 
<p><font size="3">当然，事情并非这么麻烦，有简洁的方法可以加快找到用户之间的最小分隔：不单是从一个用户搜索，而是从两个用户同时搜索，而看两个用户的2度之内的用户是否有相同：<br /> A-B-C<br /> E-D-C<br /> A和E的处在在两度分隔的用户基本上数目估计都在n的平方。问题变成了比较n^2和n^2之间有没有相同，这个计算的时间等同于2&times;n^2的排序所需要的时间。</font></p> 
<p><font size="3">【SN索引】</font></p> 
<p><font size="3">那么能否继续加快速度？<br /> 当然可以，可以提前对用户的好友进行索引，对好友的好友进行索引，这样在未来进行关系的搜索时会大大加快：</font></p> 
<p><font size="3">A: {A1} {A2} A1为A的好友的集合，A2为A的好友的好友的集合<br /> E: {E1} {E2}</font></p> 
<p><font size="3">那么<br /> 1度分隔为： A 属于｛E1｝，等同于E属于 {A1}<br /> 2度分隔为： A 属于｛E2｝，等同于E属于 {A2}，{A1}{E1}有共同项。<br /> 3度分隔为： {A1} ｛E2｝有共同项，等同于A属于 {E2}<br /> 4度分隔为： {A2} ｛E2｝有共同项</font></p> 
<p><br /> <font size="3">【SN关系的更新】</font></p> 
<p><font size="3">当然，发现是一个核心问题，另外一个问题就是更新，因为SN的关系不会是一成不变的，在一个活跃的SN社区里，每天用户之间的关系的更新更是可观。这里只考虑关系添加的例子：</font></p> 
<p><font size="3">A: {A1} {A2} <br /> E: {E1} {E2}</font></p> 
<p><font size="3">当A 与 E 直接建立了好友关系后，应该说整合系统的关系全都变化了，因为这个新的关系一定会导致一些关系的短路，从而导致很多现有的关系的调整。但是因为我们只存储2度分隔以内的关系，也只关心两度分隔以内的关系，因此当发生了一个新的关系后，2度内关系的变化一定是A和E本身或者他们的一度关系的用户，再远的用户将不受这个关系的影响。</font></p> 
<p><font size="3">因此首先 所有｛A1｝的元素的二度分隔集合里要加上E，所有｛E1｝的元素的二度分隔集合里要加上A。</font></p> 
<p><font size="3">然后是二度的修正。分别加上对方的1度。<br /> {A2} = {A2 + E1}<br /> {E2} = {E2 + A1}</font></p> 
<p><font size="3">最后是一度的修正：A, E 的 一度{A1}{E1}需要加入E,A:<br /> {A1} = {A1 + E}<br /> {E1} = {E1 + A}</font></p> 
<p><font size="3">整体操作的量大约在2n次操作，比我们通常认为的要小的多 :) 。 </font></p></div></body></html>