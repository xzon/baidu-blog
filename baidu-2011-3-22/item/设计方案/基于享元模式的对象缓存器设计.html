<html><head><title><div class="tit">
  基于享元模式的对象缓存器设计
</div></title></head><body><div id='tit'>基于享元模式的对象缓存器设计</div><div id='cate'>设计方案</div><div id='date'>2008年04月08日 星期二 09:39 P.M.</div><div id='page'>145</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/b9214110467ccaf9c2ce797a.html'>http://hi.baidu.com/hxzon/blog/item/b9214110467ccaf9c2ce797a.html</a><div id='cnt'><div>
 <font size="3">基于享元模式的对象缓存器设计</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">介绍Flyweight与Singleton模式的应用。<br /> 1.对象缓存器<br /> 当调用对象时，不使用常规的new 构造子的方式，而是通过一个对象缓存器操作。即如果缓存器中存在该对象，则取出；如果不存在，则新建一个对象并存储在缓存器中。当使用完该对象后，则将该对象的归还给缓存器。<br /> 将对象的实例共享的提供，符合Flyweight模式的应用。这里会存在几个问题，必须注意。<br /> Tips 1，考虑多线程状态下的存取对象，会增加一个标志位；<br /> Tips 2，将目标对象群存储在两个数据结构中。结构一，单一的对象，即缓存器中仅存在某类的一个对象时，将其保存为SingleObject类型；结构二，重复的对象，即缓存器中存在多个某类的多个对象时，将其保存为MultiObjectl类型，该类型会有一个List，保存这些同类型对象封装的SingleObject类型；<br /> Tips 3，考虑将缓存器设计为Singleton模式，这样使得内存中仅存在唯一的一份缓存对象的Map。<br /> 2.目标存储对象的结构设计<br /> 针对Tips 2的问题，设计一个接口Objects，以及单一对象封装类SingleObject和多对象封装类MultiObject。这两个类都实现Objects接口。在保存对象时，均保存为Object，为了得到具体类型，还要将类型保存起来。<br /> &lt;!--[if !vml]--&gt;<br /> &lt;!--[endif]--&gt;<br /> &lt;&lt;interface&gt;&gt;Objects.java<br /> package com.zj.objCache;<br /> public interface Objects {<br /> &nbsp;&nbsp;&nbsp; int SINGLE = 1;// 唯一对象类型<br /> &nbsp;&nbsp;&nbsp; int MULTIPLE = 2;// 多对象类型<br /> &nbsp;&nbsp;&nbsp; boolean using();// 标志位<br /> &nbsp;&nbsp;&nbsp; void setUsing(boolean bool);<br /> &nbsp;&nbsp;&nbsp; void renObj(int hashCode) throws InstantiationException,<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IllegalAccessException;// 归还对象<br /> &nbsp;&nbsp;&nbsp; Object getObj() throws IllegalAccessException;// 取出对象<br /> &nbsp;&nbsp;&nbsp; String getClassType();// 类类型<br /> &nbsp;&nbsp;&nbsp; int cacheType();// SINGLE|MULTIPLE<br /> } </font>
</div> 
<div> 
</div> 
<div>
 <font size="3">SingleObject.java<br /> package com.zj.objCache;<br /> import org.apache.log4j.Logger;<br /> public class SingleObject implements Objects {<br /> &nbsp;&nbsp;&nbsp; private static Logger log = Logger.getLogger(SingleObject.class);<br /> &nbsp;&nbsp;&nbsp; private String type;// 类类型<br /> &nbsp;&nbsp;&nbsp; private volatile boolean using;// 标志位<br /> &nbsp;&nbsp;&nbsp; private Object obj;// 对象实例<br /> <br /> &nbsp;&nbsp;&nbsp; public SingleObject(Object object, String classType) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj = object;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type = classType;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using = false;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log.info(&quot;Add Class &quot; + this.type + &quot; 's Object to Cache.&quot;);<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public Object getObj() throws IllegalAccessException {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (using == false) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using = true;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log.info(&quot;Get Class &quot; + this.type + &quot; 's Object from Cache.&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return obj;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new IllegalAccessException();<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public void renObj(int hashCode) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log.info(&quot;Return Class &quot; + this.type + &quot; 's Object to Cache.&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using = false;<br /> &nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; public int cacheType() {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Objects.SINGLE;<br /> &nbsp;&nbsp;&nbsp; }<br /> 。。。。。。<br /> } </font>
</div> 
<div> 
</div> 
<div>
 <font size="3">在SingleObject中，标志位为using,将对象保存为Object，将对象的类型保存为String。在归还对象renObj(int hashCode)方法中，形参hashCode并不起作用。保存对象的hash code在MultiObject中，用于得到同类型对象中确切在使用的那个对象。<br /> <br /> MultiObject.java<br /> package com.zj.objCache;<br /> import java.util.ArrayList;<br /> import java.util.Iterator;<br /> import java.util.List;<br /> import org.apache.log4j.Logger;<br /> <br /> public class MultiObject implements Objects {<br /> &nbsp;&nbsp;&nbsp; private static Logger log = Logger.getLogger(MultiObject.class);<br /> &nbsp;&nbsp;&nbsp; private String type;<br /> &nbsp;&nbsp;&nbsp; private volatile boolean using;<br /> &nbsp;&nbsp;&nbsp; private List&lt;SingleObject&gt; objs = new ArrayList&lt;SingleObject&gt;();<br /> <br /> &nbsp;&nbsp;&nbsp; public MultiObject(SingleObject object, String classType, boolean bool) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type = classType;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objs.add(object);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using = bool;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log.info(&quot;Get Class &quot; + this.type + &quot; 's Object from Cache.&quot;);<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public MultiObject(String classType) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type = classType;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using = false;<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public Object getObj() throws IllegalAccessException {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (using == false)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return getFreeObj();<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new IllegalAccessException();<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; private Object getFreeObj() throws IllegalAccessException {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SingleObject sobj;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator&lt;SingleObject&gt; i = objs.iterator();<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (i.hasNext()) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sobj = i.next();<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sobj.using() == false) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; checkUsing(i);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return sobj.getObj();<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null;<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; private void checkUsing(Iterator&lt;SingleObject&gt; i) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (i.hasNext()) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i.next().using() == false)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using = true;<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public void renObj(int hashCode) throws InstantiationException,<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IllegalAccessException {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SingleObject sobj;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator&lt;SingleObject&gt; i = objs.iterator();<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (i.hasNext()) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sobj = i.next();<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sobj.getHashCode() == hashCode) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sobj.setUsing(false);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (using == true)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using = false;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log.info(&quot;Return Class &quot; + this.type + &quot; 's Object to Cache.&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new InstantiationException();<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public int cacheType() {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Objects.MULTIPLE;<br /> &nbsp;&nbsp;&nbsp; }<br /> 。。。。。。<br /> } </font>
</div> 
<div> 
</div> 
<div>
 <font size="3">在MultiObject中，通过一个ArrayList保存SimpleObject的实例；当出现MultiObject对象时，表明对象缓存器中某一种类类型存在着多于一个的对象实例，此时将所有的该对象实例封装为SimpleObject，并将这些SimpleObject封装到一个MultiObject对象中。<br /> 注意，在MultiObject中的标注位using为true的情况应该为所有SinpleObject’s using为true；而MultiObject’s using为false的情况应该为所有SinpleObject’s using中有一个为false即可。<br /> 3.应用Flyweight模式与Singleton模式<br /> 使用一个ObjectFactory来提供对象缓存器的接口。其中包含一个HashMap，key为所存储对象的类类型；value为所对象的封装对象，类型由接口Objects标注。<br /> 将ObjectFactory设计为单例模式，这样可以保证只有一份HashMap。<br /> 其中主要的方法有getObject(String name)；该方法通过类名调用缓存器中对象，如果缓存器中不存在该对象，先创建一个，然后提供之；renObject(Object obj)归还对象；removeObject(String name)从缓存器中删除某类型的所有对象；clear()清空缓存器对象列表中的所有对象。<br /> 其中，创建某类型的对象使用Object obj = Class.forName(name).newInstance();即可得到它。<br /> &lt;!--[if !vml]--&gt;<br /> &lt;!--[endif]--&gt;<br /> ObjectFactory.java<br /> package com.zj.objCache;<br /> import java.util.HashMap;<br /> import java.util.Map;<br /> public class ObjectFactory {<br /> &nbsp;&nbsp;&nbsp; private Map&lt;String, Objects&gt; objs = new HashMap&lt;String, Objects&gt;();<br /> &nbsp;&nbsp;&nbsp; private static ObjectFactory instance = new ObjectFactory();<br /> <br /> &nbsp;&nbsp;&nbsp; private ObjectFactory() {<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public static ObjectFactory getInstance() {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return instance;<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public Object getObject(String name) throws IllegalAccessException,<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InstantiationException, ClassNotFoundException {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (objs.containsKey(name)) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (objs.get(name).using() == true)<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return addObj(objs.get(name));<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return objs.get(name).getObj();<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return addObj(name);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public void renObject(Object obj) throws ClassNotFoundException,<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InstantiationException, IllegalAccessException {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (objs.containsKey(obj.getClass().getName()))<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objs.get(obj.getClass().getName()).renObj(obj.hashCode());<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new ClassNotFoundException();<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public void removeObject(String name) throws ClassNotFoundException {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (objs.containsKey(name)) {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objs.remove(name);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new ClassNotFoundException(&quot;No such Class Type.&quot;);<br /> &nbsp;&nbsp;&nbsp; }<br /> <br /> &nbsp;&nbsp;&nbsp; public void clear() {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objs.clear();<br /> &nbsp;&nbsp;&nbsp; }<br /> 。。。。。。<br /> } </font>
</div> 
<div> 
</div> 
<div>
 <font size="3">4.客户端测试<br /> 测试给出两个类com.zj.objCache.A和com.zj.objCache.B。分别调用ObjectFactory中的几个接口模拟取与还对象的过程，通过日志(log4j)信息，可以查看日志结果。<br /> <br /> Client.java<br /> package com.zj.objCache;<br /> <br /> class A {<br /> &nbsp;&nbsp;&nbsp; void sign(){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;sign from A's object&quot;);<br /> &nbsp;&nbsp;&nbsp; }<br /> }<br /> <br /> class B {<br /> &nbsp;&nbsp;&nbsp; void sign(){<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;sign from B's object&quot;);<br /> &nbsp;&nbsp;&nbsp; }<br /> }<br /> <br /> public class Client {<br /> &nbsp;&nbsp;&nbsp; public static void main(String[] args) throws IllegalAccessException,<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InstantiationException, ClassNotFoundException {<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //get&amp;return an object of Class A<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;===TEST 1===&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A a = (A) ObjectFactory.getInstance().getObject(&quot;com.zj.objCache.A&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a.sign();<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectFactory.getInstance().renObject(a);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //get two objects of Class B<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;===TEST 2===&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B b1 = (B) ObjectFactory.getInstance().getObject(&quot;com.zj.objCache.B&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b1.sign();<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B b2 = (B) ObjectFactory.getInstance().getObject(&quot;com.zj.objCache.B&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b2.sign();<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //return b1<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;===TEST 3===&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectFactory.getInstance().renObject(b1);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //get two objects of Class B<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;===TEST 4===&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B b3 = (B) ObjectFactory.getInstance().getObject(&quot;com.zj.objCache.B&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b3.sign();<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B b4 = (B) ObjectFactory.getInstance().getObject(&quot;com.zj.objCache.B&quot;);<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b4.sign();<br /> &nbsp;&nbsp;&nbsp; }<br /> } </font>
</div> 
<div> 
</div> 
<div>
 <font size="3">结果<br /> ===TEST 1===<br /> INFO&nbsp;&nbsp; Add Class com.zj.objCache.A 's Object to Cache.<br /> INFO&nbsp;&nbsp; Get Class com.zj.objCache.A 's Object from Cache.<br /> sign from A's object<br /> INFO&nbsp;&nbsp; Return Class com.zj.objCache.A 's Object to Cache.<br /> ===TEST 2===<br /> INFO&nbsp;&nbsp; Add Class com.zj.objCache.B 's Object to Cache.<br /> INFO&nbsp;&nbsp; Get Class com.zj.objCache.B 's Object from Cache.<br /> sign from B's object<br /> INFO&nbsp;&nbsp; Add Class com.zj.objCache.B 's Object to Cache.<br /> INFO&nbsp;&nbsp; Get Class com.zj.objCache.B 's Object from Cache.<br /> sign from B's object<br /> ===TEST 3===<br /> INFO&nbsp;&nbsp; Return Class com.zj.objCache.B 's Object to Cache.<br /> ===TEST 4===<br /> INFO&nbsp;&nbsp; Get Class com.zj.objCache.B 's Object from Cache.<br /> sign from B's object<br /> INFO&nbsp;&nbsp; Add Class com.zj.objCache.B 's Object to Cache.<br /> INFO&nbsp;&nbsp; Get Class com.zj.objCache.B 's Object from Cache.<br /> sign from B's object<br /> 本文出自 “子 孑” 博客，转载请与作者联系！</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">本文出自 51CTO.COM技术博客&nbsp;&nbsp; </font>
 <a href="http://zhangjunhd.blog.51cto.com/113473/66059"><font size="3">http://zhangjunhd.blog.51cto.com/113473/66059</font></a>
</div></div></body></html>