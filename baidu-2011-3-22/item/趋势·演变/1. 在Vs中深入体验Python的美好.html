<html><head><title><div class="tit">
  1. 在Vs中深入体验Python的美好
</div></title></head><body><div id='tit'>1. 在Vs中深入体验Python的美好</div><div id='cate'>趋势&middot;演变</div><div id='date'>2008年04月05日 星期六 11:04 P.M.</div><div id='page'>147</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/66c4dbc447a97acf38db4946.html'>http://hi.baidu.com/hxzon/blog/item/66c4dbc447a97acf38db4946.html</a><div id='cnt'><h1>1. 在Vs中深入体验Python的美好</h1> 
<ul> 
 <li> <p class="line891"><a href="http://wiki.woodpecker.org.cn/moin/MeAndPyStory">我与Python</a> -- 汇集大家同Python 相会的愉快体验故事</p> </li> 
</ul> 
<p class="line867"> </p> 
<p class="line867"> </p> 
<div dir="ltr"> 
 <p class="line867"> </p> 
 <div class="table-of-contents"> 
  <p class="table-of-contents-heading">目录</p> 
  <ol> 
   <li><a href="http://wiki.woodpecker.org.cn/moin/PythonVsOthers#head-bf5062cd773f8675601ac952963d0ce5757cf277">Py Vs Ruby</a> 
    <ol> 
     <li><a href="http://wiki.woodpecker.org.cn/moin/PythonVsOthers#head-7255ccecbab9a90856fae0a0a902cc3018f7f928">TomZ</a></li> 
     <li><a href="http://wiki.woodpecker.org.cn/moin/PythonVsOthers#head-dfc529ac629361e53d2ddbcb7b18d5f0ff655898">jam.zheng</a></li> 
     <li><a href="http://wiki.woodpecker.org.cn/moin/PythonVsOthers#head-b3a23a4284b9e9891c6fe2f932f6bd8f27243dbf">Xu Leasun</a></li> 
     <li><a href="http://wiki.woodpecker.org.cn/moin/PythonVsOthers#head-58362de5d0aa9a31451272ad2458f2e67161b92a">反馈</a></li> 
    </ol> </li> 
  </ol> 
 </div> 
 <p class="line867"> </p> 
 <h2>1.1. Py Vs Ruby</h2> 
 <p class="line867"> </p> 
 <h3>1.1.1. TomZ</h3> 
 <p class="line867"><strong>python和ruby的相同点：</strong></p> 
 <ul> 
  <li>都强调语法简单，都具有更一般的表达方式。python是缩进，ruby是类basic的表达。都大量减少了符号。</li> 
  <li>都是动态数据类型。都是有丰富的数据结构。</li> 
  <li>都具有c语言扩展能力，都具有可移植性，比perl的可移植性更好。也都可以作为嵌入语言。</li> 
  <li>都是面向对象的语言，都可以作为大项目的开发工具。</li> 
  <li>都有丰富的库支持。</li> 
  <li>也有最宽松的版权许可，除了一些工具属于GNU世界。</li> 
  <li>都有lisp特色的eval函数，也都能把函数作为参数。</li> 
  <li>也有图形界面的ruby的专门编辑器。</li> 
  <li>都获得了广泛的c库的支持。如qt、gtk、tk、SDL、FOX等，ruby计划实现SWIG接口。</li> 
  <li>都有完善的文档。</li> 
 </ul> 
 <p class="line867"><strong>和python相比ruby的优点：</strong></p> 
 <ul> 
  <li>具有正则表达式和嵌入html的功能。python也有正则表达式，但没有ruby的应用方便和广泛。python的嵌入html项目才刚起步。ruby还有apache的mod模块。ruby本身也实现和很多unix工具，如racc，doctools。比python更亲近linux。</li> 
  <li>比python功能更完整的面向对象的语法。 
   <ul> 
    <li>ruby的整个库都是具有类继承的结构。</li> 
    <li>他的基本的数据类型和运算符都是可以重载的。</li> 
    <li>ruby主要的功能都是通过对象的方法调用来实现的，而不是函数。python也在向这方面发展，但没有ruby做的彻底。</li> 
    <li>ruby的类是更规范的单继承，还有接口等概念的实现。</li> 
   </ul> </li> 
  <li>python可以实现在列表内的条件语句、循环语句，而ruby用“块”的方式来实现这个功能，比python的更灵活，更具有通用性。</li> 
  <li>ruby具有类似lisp的彻底的函数方式的条件语句、循环语句等。语句的表达能力更强。</li> 
  <li>附带一些unix工具，如racc等。</li> 
 </ul> 
 <p class="line867"><strong>和python相比ruby的不足：</strong></p> 
 <ul> 
  <li>最大的不足正是因为ruby的强大所引起的。它没有python的简单性好。比较复杂的面向对象语法、“块”语法的引入、正则表达式的引入、一些简写标记都增加了语言的复杂性。</li> 
  <li>python的缩进表达方式比ruby的basic的表达方式更让人悦目，ruby程序的满眼的end让人不舒服。当然，ruby认为end的方式比python更先进。</li> 
  <li>ruby还没有python的“自省”的能力，没有从程序文件中生成文档的能力。</li> 
  <li>ruby没有国际化的支持。国际化支持在ruby的计划中。这是因为ruby的历史比python要短造成的。</li> 
  <li>ruby没有类似jython的东西。</li> 
 </ul> 
 <p class="line867"><strong>python和ruby的语言的选择：</strong></p> 
 <ul> 
  <li style="list-style-type: none;">从简单的就是好的来说，选python是没错的。python适合寻找简单语言的人，这很可能造成python更流行，因此也有更多的支持。但如果要追求更强大的语法功能，则ruby是好的选择。因为ruby和python的哲学有很多相似的地方，先从python入手，尽量用python，如果python的能力不足了，可以在找ruby。</li> 
 </ul> 
 <p class="line862">ruby和python的比较，就像五笔和拼音输入法的比较。拼音作为入门的输入法和长久使用的输入法都没有问题。五笔适合更高要求的情况。如果追求性能的不妨学学ruby(这句不对,python好像比ruby性能更优化,有<a href="http://floss.zoomquiet.org/data/20060920124121/" class="http">Ruby/YARV/Python跨平台性能对比测试报告</a>)。对编程语言感兴趣，想了解各种编程概念的学ruby也会很兴奋。</p> 
 <p class="line867"> </p> 
 <h3>1.1.2. jam.zheng</h3> 
 <p class="line867"> </p> 
 <pre>发件人: jam.zheng &lt;jam.zheng@achievo.com&gt;<br />回复: python-chinese@lists.python.cn<br />收件人: python-chinese@lists.python.cn<br />日期: 2005-11-8 上午9:46<br />主题: [python-chinese] 选Ruby还是选Python？</pre> 
 <p class="line867"> </p> 
 <pre>最近，我需要一种快速开发语言，目前炙手可热的快速开发语言就是Python和Ruby了。Ruby和Python都是非常优秀的脚本语言，虽然他们的设计哲学几乎完全不同，但他们效率差不多，应用领域也差距不大，似乎天生就是竞争对手。到底选那个呢？我做了一些简单的比较。<br /><br />我们比较两种语言的时候，抛开性能问题不说，一般最在意的大概就是资源和学习曲线。<br /><br />总体的印象，用一个不大恰当的比喻：如果Python是Java，那么Ruby就是.net。我们知道，Java世界非常复杂，非常多样性，任何一个需求，都会有很多开源项目，他们用不同的思想来实现，性能特点迥异，到底选那个，总是令人犯难。现在Python也是如此，而由于Python开发难度远远低于Java，导致Python的相关项目比Java还要多得多。<br /><br />资源上，两者社区都很强，有趣的是，现在Java社区存在被Ruby同化的危险，至少我订阅的几个Java blog聚合中谈Ruby比Java还多。Ruby的社区较为集中，Python则比较分散。我总怀疑Ruby的日本用户较多，但因为不懂日文，很难确认这个想法。对于一个母语非英语的创始人，我总是有点恐惧，怕很难理解他，怕很难得到最新消息等等等，虽然这个担心目前看来并无必要，不过，谁知道会怎么样呢。<br /><br />Ruby之所以现在突然变得热门，和rails这套架构是分不开的。考虑Ruby,就要考虑到Ruby on rails。rails提供了一套非常好的web开发框架，开发效率非常高。Python虽然有很多类似的架构实现，但并没有出现一个能够一统江湖的架构。Python的zend虽然完整，但更偏向于web服务器，不能用来和rails比较。<br /><br />Ruby比pyton更容易上手。从语言特征看，Ruby有很多有意思的创造，比如说block，但大规模的应用这些好玩的东西让程序变得混乱。Python语法强调简单，但是由于太灵活，简单得太过分，于是传统程序员经常会看到一些令人大吃一惊的表达方式。我不知道这应该算优点还是缺点，至少我认为语法过于灵活，容易导致不同程序员的代码风格差异过大，增加了学习成本。<br /><br />初期入门，Ruby更容易，但一旦达到一定复杂度，那么Ruby的难度骤然加大。Python入门不容易，复杂的时候也不会太痛苦。rails有入门简单，深入难的问题。rails生成的目录是做什么用途？o/r mapping如何实现的？如何把数据从web中传递到数据库的。这些都是Ruby程序员早晚要面对的问题。  Python则不会这样，如果搞不清楚这些，大概根本没办法开始。集成度太高的快速开发工具都有这个特点，无论是VB、Delphi，还是.net，有多少使用了半年以内的开发人员可以说清楚工程目录下面所有的文件的用途、每个文件中的语法？我相信很多很有经验的用户也未必说的清楚。<br /><br />从架构上看，二者虽然实际上相差甚远，但最后表现出来的结果反而很相似。Ruby是纯粹的OO语言，而Python是函数和OO混合型。虽然Ruby也能用函数风格的编码方式，但实际上是模拟出来的。他们的这个差距对于普通的程序员影响并不大，毕竟看起来差不多。<br /><br />    总体来说，如果是非专业人员初尝开发，Ruby是合适的。对于专业的程序员，我还是建议选择Python。<br /><br />对于未来发展，我认为Python的发展可预见，会较为平稳。Python已经属于一个社区，而非一个人，但Ruby由于种种原因，Ruby的作者maze的意志仍然会对Ruby的发展造成较大影响。Sun控制着Java，但由于sun的资源强大，且组织了jcp进行统筹，所以Java发展很不错，但Ruby能不能作到这一点，还需要时间来证明。</pre> 
 <p class="line867"> </p> 
 <h3>1.1.3. Xu Leasun</h3> 
 <p class="line867"> </p> 
 <pre>好语言就是你用得最好的那个语言。至于这个语言是什么并不重要。</pre> 
 <p class="line867"> </p> 
 <h3>1.1.4. 反馈</h3> 
</div> 
<div>
 {
 <a href="http://wiki.woodpecker.org.cn/moin/PyVsRuby">PyVsRuby</a>
 <a href="http://wiki.woodpecker.org.cn/moin/PyVsRuby?action=edit">}<sup>e</sup></a>
</div> 
<div> 
</div> 
<p class="line867"> </p> 
<p class="line867"> </p> 
<div dir="ltr"> 
 <p class="line867"><strong><a href="http://groups.google.com/group/python-cn/t/4f528b9ecbd9a7fe" class="http">Python vs Haskell (翻译)</a> </strong>::-- <a href="http://wiki.woodpecker.org.cn/moin/ZoomQuiet">ZoomQuiet</a> [2007-04-24 11:29:05]</p> 
 <div class="table-of-contents"> 
  <p class="table-of-contents-heading">目录</p> 
  <ol> 
   <li><a href="http://wiki.woodpecker.org.cn/moin/PythonVsOthers#head-659a676d51bea814458bba3005fc6b5c846359a7">Python vs Haskell (翻译)</a> 
    <ol> 
     <li><a href="http://wiki.woodpecker.org.cn/moin/PythonVsOthers#head-99dd49a0080b8c85cd911fc52919d4efeab3921f">函数式 vs 过程式</a></li> 
     <li><a href="http://wiki.woodpecker.org.cn/moin/PythonVsOthers#head-0cd183e996778e1cb72228f3f9277da8fcda7537">静态类型 vs 动态类型</a></li> 
     <li><a href="http://wiki.woodpecker.org.cn/moin/PythonVsOthers#head-a8fbee3530b325824300073434cc29895484b474">List Comprehension Syntax:</a></li> 
     <li><a href="http://wiki.woodpecker.org.cn/moin/PythonVsOthers#head-e1c5dc3c1a3e7248f6e449947253b629e3f161c2">Significant Whitespace: 缩进语法</a></li> 
     <li><a href="http://wiki.woodpecker.org.cn/moin/PythonVsOthers#head-449a21acc2728a0c5e408a60a20ef128e54cbc77">Learning Curve: 学习曲线</a></li> 
     <li><a href="http://wiki.woodpecker.org.cn/moin/PythonVsOthers#head-5c3d0be7b827a49dcd65d2c9d4d94973c03ee1f3">Using both Python &amp; Haskell with ctypes (-;</a></li> 
    </ol> </li> 
   <li><a href="http://wiki.woodpecker.org.cn/moin/PythonVsOthers#head-73bd425547e8d355c83ae4b829d5e1cb28c21bd0">反馈</a></li> 
  </ol> 
 </div> 
 <p class="line867"> </p> 
 <div dir="ltr"> 
  <div> 
   <table class="FCK__ShowTableBorders"> 
    <tbody> 
     <tr> 
      <td> <p class="line891"><strong>CPUG</strong>联盟::</p> </td> 
      <td> <p class="line891"><strong><a href="http://wiki.woodpecker.org.cn/moin/CPUG" title="self" class="interwiki">CPUG</a></strong>::<a href="http://python.cn/" class="http">门户</a><sup>plone</sup></p> </td> 
      <td> <p class="line891"><strong><a href="http://wiki.woodpecker.org.cn/moin/BPUG" title="self" class="interwiki">BPUG</a></strong></p> </td> 
      <td> <p class="line891"><strong><a href="http://wiki.woodpecker.org.cn/moin/SPUG" title="self" class="interwiki">SPUG</a></strong></p> </td> 
      <td> <p class="line891"><strong><a href="http://wiki.woodpecker.org.cn/moin/ZPUG" title="self" class="interwiki">ZPUG</a></strong></p> </td> 
      <td> <p class="line862"><a href="http://wiki.woodpecker.org.cn/moin/SpreadPython">SpreadPython</a> <sup>Python宣传</sup><em> </em></p> </td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
 </div> 
 <div>
  {
  <a href="http://wiki.woodpecker.org.cn/moin/CPUGnav">CPUGnav</a>
  <a href="http://wiki.woodpecker.org.cn/moin/CPUGnav?action=edit">}<sup>e</sup></a>
 </div> 
 <div> 
 </div> 
 <p class="line867"> </p> 
 <h1>2. Python vs Haskell (翻译)</h1> 
 <ul> 
  <li> <p class="line862">原文： <a href="http://wiki.python.org/moin/PythonVsHaskell" class="http">http://wiki.python.org/moin/PythonVsHaskell</a></p> </li> 
  <li>注：本文是Python官方wiki网站中的一篇文章，比较了Python与Haskell 
   <ul> 
    <li> <p class="line862">更多的关于Python及其他语言的在：<a href="http://wiki.python.org/moin/" class="http">Python与其他语言比较 </a></p> </li> 
   </ul> </li> 
 </ul> 
 <p class="line862">Haskell是一种非常现代的函数式编程语言（像Lisp等）。这门语言并不是很流行但却应用在一些实际的项目中（不只是一种试验性语言）并且在实际行业中应用越来越普遍。比如 darcs 版本管理系统就是用 Haskell 写的。更多信息请看 <a href="http://www.haskell.org/" class="http">http://www.haskell.org</a></p> 
 <p class="line874">Haskell 和 Python之间很难一对一的比较，因为他们在很多方面相当的不同。但是两种语言的大部分用户都会同意他们都设计的非常优雅。</p> 
 <p class="line867"> </p> 
 <h2>2.1. 函数式 vs 过程式</h2> 
 <p class="line867"><strong>Functional vs Procedural: 函数式 vs 过程式</strong></p> 
 <p class="line874">Haskell 是一种Lazy （延迟计算），被称为&quot;纯函数式&quot; （没有赋值或副作用）的语言。它通过类型类来支持参数多态（有些像C++的模板的作用，但比那更强大）和Ad-hoc多态。 Python为程序员提供了丰富的编程范型，包括过程式、函数式与面向对象式。Lazy编程可以通过产生器和迭代器来实现。Python对于函数式编程有一定的支持，但是由于存在大量的副作用以及缺乏对尾递归的内建支持，使得在Python中使用函数式编程显得有些笨拙。Haskell通过Monad(来自范畴论）来支持过程式编程，这也是Haskell的纯函数式世界与现实世界的副作用的桥梁（如图形界面，输入输出，文件系统，socket等）。命令式编程并非Haskell的（主要）意图也并非其强项。不过很多 Haskell程序员声称Haskell是他们最喜欢的命令式语言：） Compiled vs Interpreted: 编译 vs 解释</p> 
 <p class="line874">Python的主要实现是一个解释器。Haskell有一把的实现，包括一些解释器（Hugs, GHCi)和一些生成本地代码的编译器（GHC, nhc98)。Haskell和Python一样都是一种（很）高级的编程语言，所以并不应期待它会像C或者汇编一样的性能。Haskell的类型系统提供了更多的编译时信息，这样大多数情况下haskell的本地代码编译器会比Python更有速度优势： 速度比较</p> 
 <p class="line867"><a href="http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&amp;lang=python" class="http">http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&amp;lang=python</a>...</p> 
 <p class="line874">Pythonic 的编程哲学：把性能关键部分丢给C，同样适用于Haskell。通过 FFI (foreign function interface), haskell的函数可以调用C程序，或者被C程序调用。 另一种可选的做法是通过编译器特定的扩展（特别是ghc）和更严格的标记，这可以让他们之间的变得铁板一块。</p> 
 <p class="line867"> </p> 
 <h2>2.2. 静态类型 vs 动态类型</h2> 
 <p class="line867"><strong>Static vs Dynamic Typing: 静态类型 vs 动态类型</strong></p> 
 <p class="line874">Haskell和Python都具有强类型，也就是说类型的示例不能被用作另一种类型。必须使用显示的转换。不同之处在于 Haskell是静态类型，而Python是动态类型。在Haskell中，</p> 
 <p class="line862">每一个表达式和值（译注<sup><a href="http://wiki.woodpecker.org.cn/moin/PythonVsOthers#fndef-d9fd1b08b85bb4ea8baad301fe9c71377e30b43f-0">注1</a></sup>）的类型在编译时都是已知确定的，而在Python 中表达式和变量并没有类型--他们所引用的对象有类型，但是直到运行时才能知道，并且对象可以通过提供正确的函数（如 <span class="u">length</span> 等) 来假装成另一种类型。因为类型系统是Haskell中非常基础的部分（这使得这门语言写的程序容易被验证），这一点是与Python的一个基础的不同点。不过，对于那些想到每次用一个变量前都要先写 int i就发抖的python用户，大可宽心：Haskell的编译器和解释器足够的聪明几乎总是可以推断出你的表达式的类型，所以你可以不必写他们。</p> 
 <p class="line862">（译注<sup><a href="http://wiki.woodpecker.org.cn/moin/PythonVsOthers#fndef-6d951813778c8218e142fc1d05d1060affd0f015-1">注2</a></sup>） 比如，把5的值分配到一个表示符 'a' ，在Python和Haskell中的代码是完全一样的：</p> 
 <p class="line867"><tt class="backtick"><font face="NSimsun">a = 5 </font></tt>（译注<sup><a href="http://wiki.woodpecker.org.cn/moin/PythonVsOthers#fndef-0aa774ef4af78b6eb073a2cbbaff71be91e5eb43-2">注3</a></sup>） 实际上Haskell编译器把它推断成一个 Integer 类型。</p> 
 <p class="line867"> </p> 
 <h2>2.3. List Comprehension Syntax:</h2> 
 <p class="line874">必须指出的是他们有一个相似点： 列表内涵式语法 Python的列表内涵式语法是直接从Haskell拿过来的。（当然有一些琐碎关键字和符号的修改） 列表内涵这主意实在太棒了没办法拒绝。</p> 
 <p class="line867"> </p> 
 <h2>2.4. Significant Whitespace: 缩进语法</h2> 
 <p class="line874">他们都把缩进作为语法。在Python中， tab/空格是语法，而Haskell中 tab/空格是定义良好的语法糖，（最终）转换成括号和分号的程序块的语法。有人会说Haskell的方式是缩进语法这种想法的一个进步，通过允许程序员使用显式的括号和分号标记的语法块可以避免很多头疼的问题，如在网页上拷贝粘贴代码～～</p> 
 <p class="line867"> </p> 
 <h2>2.5. Learning Curve: 学习曲线</h2> 
 <p class="line874">对于没有函数式编程经验的程序员来说Haskell的学习曲线相当陡峭。很多情况下，延迟计算对命令式语言浸泡出来的大脑来说显得违反直觉和常识，你必须忘却一些阻止你的程序吃光内存的技术。</p> 
 <p class="line874">对我而言（Nioate原作者），学习OCaml让我比较平滑的过渡到Haskell，因为ML有一个和Haskell类似的类型系统。理解了类型系统后，跳入Haskell则是毫不犹豫的， 除了一些新的语法，只需要学习如何利用延迟计算，类型类和Monad。（不要让 Monad 吓到你，先学习List和Maybe monad.）</p> 
 <p class="line862">(译注<sup><a href="http://wiki.woodpecker.org.cn/moin/PythonVsOthers#fndef-892c2806d96e7d64101c77cd0c7ed426a6a8fd40-3">注4</a></sup>)</p> 
 <p class="line874">对我而言（albertlee译作者），学习haskell之前短暂的学习过Erlang ，而在那之前则是Lisp, scheme和Python，尽管为FP做了很多的铺垫，但进入Haskell的世界依然遇到了很多的困难，尤其是Monad， type class 。毕竟国内这方面的中文资料比较少，学习的伙伴也比较少。</p> 
 <p class="line867"> </p> 
 <h2>2.6. Using both Python &amp; Haskell with ctypes (-;</h2> 
 <ul> 
  <li>结合python和Haskell的优点，将Haskell编译成DLL，在Python中使用ctypes调用：</li> 
  <li> <p class="line862">见： <a href="http://www.kamang.net/node/24" class="http">http://www.kamang.net/node/24</a></p> </li> 
 </ul> 
</div></div></body></html>