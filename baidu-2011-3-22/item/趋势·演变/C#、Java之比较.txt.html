<html><head><title><div class="tit">
  C#、Java之比较.txt
</div></title></head><body><div id='tit'>C#、Java之比较.txt</div><div id='cate'>趋势&middot;演变</div><div id='date'>2007年12月17日 星期一 11:47 P.M.</div><div id='page'>190</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/e65fe6fe4e9847325d600808.html'>http://hi.baidu.com/hxzon/blog/item/e65fe6fe4e9847325d600808.html</a><div id='cnt'><div> 
 <p><font size="3">C#、Java之比较.txt</font></p> 
 <p><font size="3">作者：lindows<br /> 日期：2001-2-22 16:52:44<br /> 很多人说C#是微软用来和Java抗衡的武器，因为二者在很大程度上有着惊人的相似，尽管如此，两者不同的地方也很多，所谓“于细微处见差异”。那么两者的相似和区别都在什么地方呢？我们从今天开始，会从各个角度来对比C#和Java的特点，希望能对正在学习、使用C#的朋友有所帮助。</font></p> 
</div> 
<div> 
</div> 
<div>
 <font size="3">1、C#和.NET平台的概貌</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 2000年6月，微软发布C#语言和.NET平台。C#语言是一种强类型的，面向对象的语言，它具有语法简单、表达力强的特点，而.NET平台则是构成微软的“.NET计划”的基石。</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> .NET平台的核心包括两方面，一方面就是著名的通用语言运行机(Common Language Runtime)，虽然这个名词起得晦涩了点，不过大家可以拿它和Java的虚拟机来作比较，二者完成的任务大致相同；另一方面就是一大堆通用函数库，这些库函数可以被多种语言调用，并且通过编译都产生一种共同的中间语言（Intermediate Language），这种语言也可以拿Java的字节码来类比，虽然完成的方式有些不一样。</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">2、C#和Java</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 下面简单地把C#和Java的相似处列出来，虽然在这里我们重点讨论的是C#和Java的不同点，但是了解一下二者的相同之处也是很有必要的。</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 二者都编译成跨平台的、跨语言的代码，并且代码只能在一个受控制的环境中运行</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 自动回收垃圾内存，并且消除了指针（在C#中可以使用指针，不过必须注明unsafe关键字）</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 都不需要头文件，所有的代码都被“包(package)”限制在某个范围内，并且因为没有头文件，所以消除了类定义的循环依赖</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 所有的类都是从对象派生出来，并且必须使用New关键字分配内存</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 用对象加锁的方式来支持多线程</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 都具有接口(interface)的概念</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">内部类</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 继承类的时候不会以某种特定的访问权限来继承；</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 没有全局函数或者常量，一切必须属于类；</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 数组或者字符串都自带长度计算和边界检查；</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 只使用“.”操作符，没有“-&gt;”和“::”；</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> “null”、“boolean”和“bool”成为了关键字；</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 任何变量均在使用前进行初始化；</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 不能使用整数来返回到if条件语句中，必须使用布尔值；</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> “Try”模块后可以有“finally” ；</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">3. 属性（Property）</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 属性的概念对大家来说应该是很熟悉的，类成员函数可以自由地访问本类中的任何属性成员。不过若要从一个类中去访问另一个类中的属性，那就比较麻烦了，所以很多时候我们使用Getxxx和Setxxx方法，这样看起来显得极不自然，比如用Java或者C++，代码是这样的：</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> foo.setSize (getSize () + 1);<br /> label.getFont().setBold (true);</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 但是，在C#中，这样的方法被“属性化”了。同样的代码，在C#就变成了：</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> foo.size++;<br /> label.font.bold = true;</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 可以看出来，C#显然更容易阅读和理解。我们从这个“属性方法”的子程序代码中，也可以看到类似情况：</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">Java/C++:</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">public int getSize()<br /> {<br /> return size;<br /> }</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">public void setSize (int value)<br /> {<br /> size = value;<br /> }</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">C#:<br /> public int Size<br /> {<br /> get{return size;}<br /> set{size = value;}<br /> }</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 为了区分这种属性化的方法和类的属性成员，在C#中把属性成员称作“域(field)”，而“属性”则成为这种“属性化的方法”专用的名词。顺便说一句，其实这样的属性化方法在VB和DELPHI中是经常碰到的，在VB中它也就叫属性。</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 另外，在C#中Get和Set必须成对出现，一种属性不能只有Get而没有Set（在Java和C++中就可以只有Get或者只有Set），C#中这样做的好处在于便于维护，假如要对某种属性进行修改，就会同时注意Get和Set方法，同时修改，不会改了这个忘了那个。</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">4、对象索引机制（Indexer）</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> C#中引入了对象索引机制。说得明白点，对象索引其实就是对象数组。这里和上一节中的属性联系起来讲一下，属性需要隐藏Get和Set方法，而在索引机制中，各个对象的Get或者Set方法是暴露出来的。比如下面的例子就比较清楚地说明了这一点。</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">public class Skyscraper<br /> {<br /> Story[] stories;<br /> public Story this [int index] {<br /> get {<br /> return stories [index];<br /> }<br /> set {<br /> if (value != null) {<br /> stories [index] = value;<br /> }<br /> }<br /> }<br /> ...<br /> }</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">Skyscraper empireState = new Skyscraper (...);<br /> empireState [102] = new Story (&quot;The Top One&quot;, ...);</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 呵呵，有了这种特性，我们就再不用怕课堂上老师叫我们写对象数组这种程序了。 <br /> 5. 指代（Delegate） <br /> 指代这个玩意很特别，它有点象指针，但又不完全是，不过大家还是可以把它理解为一种类型安全的、面向对象的指针。（什么是类型安全和面向对象就不用讲了吧？）顺便提一句，有很多书上把Delegate翻译成代理，我觉得这样翻不够确切，翻译成“指代”更恰当些，道理上吻合，并且还符合它的本来意思——微软本来就是用Delegate来“取代指针”，所以叫“指代”，呵呵。</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 说起指代，也许至今Sun还会对它愤愤不已，为什么呢？因为在Sun的标准Java中是没有这个东西的，它是微软99年发布的MSVJ++6添加的“新特性”。为此，两家公司吵得不亦乐乎，并且还专门在网上写了大量文章互相攻击，有兴趣的朋友可以去看看（只有英文版）。<br /> </font>
 <a href="http://www.javasoft.com/docs/white/delegates.html"><font size="3">http://www.Javasoft.com/docs/white/delegates.html</font></a>
 <font size="3"> <br /> </font>
 <a href="http://msdn.microsoft.com/visualj/technical/articles/delegates/truth.asp"><font size="3">http://msdn.microsoft.com/visualj/technical/articles/delegates/truth.asp</font></a>
 <font size="3"> </font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 话归正传，指代有什么特点呢？一个明显的特点就是它具有了指针的行为，就好象从Java又倒回到了C++。在C#中，指代完成的功能大概和C++里面的指针，以及Java中的接口相当。但是，指代比起C++的“正宗指针”来又要高明一些，因为它可以同时拥有多个方法，相当于C++里面的指针能同时指向多个函数，并且是类型安全的，这一点体现了它的“对象”特性；而比起Java的接口来，指代高明的地方在于它能可以不经过内部类就调用函数，或者用少量代码就能调用多种函数，这一点体现了它的“指针”特性。呵呵，很有“波粒二象性”的味道吧？指代最重要的应用在于对于事件的处理，下一节我们将重点介绍。</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">6、事件（Event）</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> C#对事件是直接支持的（这个特点也是MSVJ所具有的）。当前很多主流程序语言处理事件的方式各不相同，Delphi采用的是函数指针（这在Delphi中的术语是“closure”）、Java用改编类来实现、VC用WindowsAPI的消息系统，而C#则直接使用delegate和event关键字来解决这个问题。下面让我们来看一个例子，例子中会给大家举出声明、调用和处理事件的全过程。</font>
</div> 
<div> 
</div> 
<div>
 <br /> 
 <font size="3">//首先是指代的声明，它定义了唤醒某个函数的事件信号<br /> public delegate void ScoreChangeEventHandler (int newScore, ref bool cancel);</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">//定义一个产生事件的类<br /> public class Game<br /> {<br /> // 注意这里使用了event关键字<br /> public event ScoreChangeEventHandler ScoreChange;<br /> int score;<br /> // Score 属性<br /> public int Score<br /> {<br /> get {<br /> return score;<br /> }<br /> set {<br /> if (score != value)<br /> {<br /> bool cancel = false;<br /> ScoreChange (value, ref cancel);<br /> if (! cancel)<br /> score = value;<br /> }<br /> }<br /> }</font>
</div> 
<div> 
</div> 
<div>
 <br /> 
 <font size="3">// 处理事件的类<br /> public class Referee<br /> {<br /> public Referee (Game game)<br /> {<br /> // 裁判负责调整比赛中的分数变化<br /> game.ScoreChange += new ScoreChangeEventHandler (game_ScoreChange);<br /> }</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> // 注意这里的函数是怎样和ScoreChangeEventHandler的信号对上号的<br /> private void game_ScoreChange (int newScore, ref bool cancel)<br /> {<br /> if (newScore &lt; 100)<br /> System.Console.WriteLine (&quot;Good Score&quot;);<br /> else<br /> {<br /> cancel = true;<br /> System.Console.WriteLine (&quot;No Score can be that high!&quot;);<br /> }<br /> }<br /> }</font>
</div> 
<div> 
</div> 
<div>
 <font size="3">// 主函数类，用于测试上述特性<br /> public class GameTest<br /> {<br /> public static void Main () <br /> {<br /> Game game = new Game ();<br /> Referee referee = new Referee (game);<br /> game.Score = 70;<br /> game.Score = 110;<br /> }<br /> }</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 在主函数中，我们创建了一个game对象和一个裁判对象，然后我们通过改变比赛分数，来观察裁判对此会有什么响应。</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 请注意，我们的这个系统中，Game对象是感觉不到裁判对象的存在的，Game对象在这里只负责产生事件，至于有谁会来倾听这个事件，并为之作出反应，Game对象是不作任何表态的。</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 我们注意到，在裁判类的Referee函数中，Game.ScoreChange后面使用了+=和-=操作符，这是什么意思呢？回到我们定义ScoreChange的地方，可以发现ScoreChange是用event关键字修饰的，那么这里的意思就很明白了：ScoreChange是一个事件，而事件被触发后需要相应的事件处理机制，+=/-=就是为这个事件增加/移除相对应的事件处理程序，而且，并不是一个事件只能对应一个处理程序，我们还可以用这两个操作符为同一事件增加/移除数个事件处理程序。怎么样？很方便吧！</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 在实际应用中，和我们上面讲的（竞赛-裁判）机制很相近的系统就是图形用户界面系统了。Game对象可以看作是图形界面上的小零件，而得分事件就相当于用户输入事件，而裁判就相当于相应的应用程序，用于处理用户输入。</font>
</div> 
<div> 
</div> 
<div>
 <font size="3"> 指代机制的首次亮相是在MSVJ里，它是由Anders Hejlsberg发明的，现在又用到了C#中。指代用在Java语言中的后果，则直接导致了微软和Sun之间对类和指针的关系产生了大量的争论和探讨。有意思的是，Java的发明者James Gosling非常幽默地称呼指代的发明者Anders Hejlsberg为“‘函数指针’先生”，因为Anders Hejlsberg总是想方设法地把指针变相地往各种语言中放；不过有人在看了Java中大量地使用了各种类后，也戏称Java的发明者James Gosling为“‘全都是类’先生”，真是其中滋味，尽在不言中啊。 </font>
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div> 
<div> 
</div></div></body></html>