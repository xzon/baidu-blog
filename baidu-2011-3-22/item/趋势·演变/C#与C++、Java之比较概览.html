<html><head><title><div class="tit">
  C#与C++、Java之比较概览
</div></title></head><body><div id='tit'>C#与C++、Java之比较概览</div><div id='cate'>趋势&middot;演变</div><div id='date'>2007年12月19日 星期三 00:30 A.M.</div><div id='page'>188</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/2e77e11155ff88c5a7ef3fdb.html'>http://hi.baidu.com/hxzon/blog/item/2e77e11155ff88c5a7ef3fdb.html</a><div id='cnt'><p align="center"><span style="font-size: 9pt; font-weight: 700">C#与C++、Java之比较概览</span></p> 
<p align="center"><span style="font-size: 9pt">Ben Albahari 著&nbsp;&nbsp; 荣耀 译</span></p> 
<p align="center"><span style="font-size: 9pt">本文翻译时间较早。欢迎指出任何误失。谢谢。</span></p> 
<p align="left"><span style="font-size: 9pt">转自：<a href="http://www.cnblogs.com/carefree/archive/2006/08/20/481689.aspx">http://www.cnblogs.com/carefree/archive/2006/08/20/481689.aspx</a></span></p> 
<p align="left"><span style="font-size: 9pt">感谢以下人士的支持和反馈（按字母先后顺序）：</span></p> 
<p align="left"><span style="font-size: 9pt">Don Box、C.R. Manning、Joe Nalewabau、John Osborn、Thomas Rhode、Daryl Richter。</span></p> 
<p align="left"><span style="font-size: 9pt">本文以C#提供的新编程方式以及它对两个近邻Java和C++的改进为中心。C#在很多方面采用和Java类似的方式来改进C++，因此，我不打算重复诸如单根对象层次优点之类的东西。正文以对C#和Java的相似点概述开始，然后着重探究C#的新特性。</span></p> 
<p align="left"><span style="font-size: 9pt"><strong>背景</strong></span></p> 
<p align="left"><span style="font-size: 9pt">2000年6月，微软同时宣布了.NET平台和一个名为C#的新编程语言。C#是一个很好地融合简单性、表达力以及性能的强类型面向对象语言。.NET平台以公共语言运行时（类似于Java虚拟机）和一个可被多种语言（它们可以通过编译成中间语言从而可以协同工作）共用的库为中心。C#和.NET有那么一些共生关系：C#的一些特性和.NET协作得很好，反之亦然（尽管.NET的目标是和多种语言很好地协作）。本文主要关注于C#，但视需要偶尔也会提及.NET。C#的设计借鉴了多种语言，但最主要的还是Java和C++。它是由Anders Hejlsberg（大名鼎鼎的Delphi语言设计师）和Scott Wiltamuth共同设计的。</span></p> 
<p align="left"><span style="font-size: 9pt"><strong>目录</strong> </span></p> 
<ol> 
 <li> <p align="left"><span style="font-size: 9pt">C#和Java</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">属性</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">索引器</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">委托 </span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">事件</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">枚举</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">集合和foreach语句 </span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">结构</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">类型一致</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">操作符重载 </span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">多态</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">接口</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">版本处理 </span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">参数修饰符</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">特性（attribute） </span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">选择语句</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">预定义类型 </span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">字段修饰符</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">跳转语句</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">程序集、名字空间和访问级别</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">指针运算</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">多维数组</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">构造器和析构器</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">托管运行环境</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">库</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">互操作性</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">结论 </span></p> </li> 
</ol> 
<p align="left"><span style="font-size: 9pt"><strong>1.C#和Java</strong> </span></p> 
<p align="left"><span style="font-size: 9pt">下面是C#和Java共有的特性列表，目的都是为了改进C++。这些特性虽非本文重点，但了解它们之间的相似之处还是非常重要的。</span></p> 
<ul> 
 <li> <p align="left"><span style="font-size: 9pt">编译为机器独立、语言独立的代码，运行在托管运行环境中</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">采用垃圾收集机制，同时摒弃了指针（C#中，指针被限制在标为unsafe的代码内使用）</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">强有力的反射能力</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">没有头文件，所有代码都在包或装程序集里，不存在类声明的循环依赖问题</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">所有的类都派生自object，且必须用new关键字分配于堆上</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">当进入标以锁定/同步代码时，通过在对象上加锁来支持多线程</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">接口支持：多继承接口、单继承实现</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">内部类</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">类继承时无需指定访问级别 <font color="#000080">[译注：在C++中，你可以这么做：class cls2: private cls1{};等等]</font> </span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">没有全局函数或常量，一切都必须属于类</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">数组和字符串都保存长度记数并具边界检查能力</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">永远使用“.”操作符，不再有“-&gt;”、“::”操作符</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">null和boolean/bool是关键字</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">所有的值在使用前必须被初始化</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">if语句不能使用整数作为判断条件</span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt">try语句块后可以跟finally子句</span></p> </li> 
</ul> 
<p align="left"><span style="font-size: 9pt"><strong>2.属性</strong> </span></p> 
<p align="left"><span style="font-size: 9pt">对于Delphi和Visual Basic用户来说，属性是个熟悉的概念。属性的目的在于将获取器/设置器（getter/setter）的概念正式化，这是一种被广泛使用的模式，在RAD（快速应用开发）工具中尤其如此。</span></p> 
<p align="left"><span style="font-size: 9pt">以下是你可能在Java或C++里写的典型代码： </span></p> 
<p align="left"><span style="font-size: 9pt">foo.setSize(getSize() + 1);<br /> label.getFont().setBold(true);</span></p> 
<p align="left"><span style="font-size: 9pt">同样 的代码在C#里会变成：</span></p> 
<p align="left"><span style="font-size: 9pt">foo.size++; <br /> label.font.bold = true; </span></p> 
<p align="left"><span style="font-size: 9pt">C#代码对于使用foo和label的用户来说更加直观、可读性更好。在属性的实现方面，差不多同样简单： </span></p> 
<p align="left"><span style="font-size: 9pt">Java/C++： </span></p> 
<p align="left"><span style="font-size: 9pt">public int getSize() <br /> { <br /> &nbsp;&nbsp;&nbsp;&nbsp; return size; <br /> } <br /> <br /> public void setSize (int value) <br /> { <br /> &nbsp;&nbsp;&nbsp;&nbsp; size = value; <br /> } <br /> <br /> C#：</span></p> 
<p align="left"><span style="font-size: 9pt">public int Size <br /> { <br /> &nbsp;&nbsp;&nbsp;&nbsp; get {return size;} <br /> &nbsp;&nbsp;&nbsp;&nbsp; set {size = value;} </span></p> 
<p align="left"><span style="font-size: 9pt">} </span></p> 
<p align="left"><span style="font-size: 9pt">特别是对于可读写的属性，C#提供了一个处理此概念的更清爽的方式。在C#中，get和set方法是内在的，而在Java和C++中则需人为维护。C#的处理方式有诸多优点。它鼓励程序员按照属性的方式去思考 — 把这个属性标为可读写的和只读的哪个更自然？或者根本不应该为属性？如果你想改变你的属性的名称，你只要检查一处就可以了（我曾看到过中间隔了几百行代码的获取器和设置器里对同一个数据成员/字段的获取器和设置器]）。注释也只要一处就可以了，这也避免了彼此同步的问题。IDE是可以帮助做这个事的（事实上，我建议微软开发人员这么做），但应该牢记一个基本编程原理：尽力做好模拟我们问题空间的抽象。而一个支持属性的语言将有助于获得更好的抽象。</span></p> 
<p align="left"><font color="#008080"><span style="font-size: 9pt">作者注：关于属性的此项优点的一个反对意见认为：当采用这种语法时，你搞不清是在操纵一个字段还是属性。然而，在Java（当然也包括C#）中，几乎所有真正复杂一点的类都不会有public字段。字段一般都只具有尽可能小的访问级别（private/protected，或语言所定义的 默认的），并且只通过获取器和设置器方法暴露，这也意味着你可以获得优美的语法。让IDE解析代码也是完全可行的：可以采用不同的颜色高亮显示属性，或提供代码完成信息以表明它是否是一个属性。我们还应该看到，如果一个类设计良好，这个类的用户将只关心该类的接口（或 规范），而不是其内部实现。另外一个可能的争论是属性不够有效率。事实上，好的编译器可以内联仅返回某个字段的获取器，这和直接访问字段一样快。说到底，即使使用字段比获取器/设置器来的有效，使用属性还有如下好处：日后可以改变属性 相关联的字段，而不会影响依赖于该属性的代码。</span></font></p> 
<p align="left"><span style="font-size: 9pt; font-weight: 700">3.索引器</span></p> 
<p align="left"><span style="font-size: 9pt">C#通过提供索引器，可以像处理数组那样处理对象。特别是属性，每一个元素都以一个get或set方法暴露。<br /> <br /> public class Skyscraper<br /> { <br /> &nbsp;&nbsp;&nbsp;&nbsp; Story[] stories; <br /> &nbsp;&nbsp;&nbsp;&nbsp; public Story this [int index] <br /> &nbsp;&nbsp;&nbsp;&nbsp; { <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return stories [index]; } <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (value != null) <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stories [index] = value; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br /> &nbsp;&nbsp;&nbsp;&nbsp; } <br /> &nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">//...</font> <br /> } <br /> <br /> Skyscraper empireState = new Skyscraper (<font color="#008000">/*...*/</font>); <br /> empireState [102] = new Story (&quot;The Top One&quot;, <font color="#008000">/*...*/</font>); </span></p> 
<p align="left"><font color="#000080"><span style="font-size: 9pt">译注：索引器最大的好处是使代码看上去更自然，更符合实际的思维模式。</span></font></p> 
<p align="left"><span style="font-size: 9pt"><strong>4.委托</strong></span></p> 
<p align="left"><span style="font-size: 9pt">委托可以被认为是类型安全的、面向对象的函数指针，它可以拥有多个方法。委托处理的问题在C++中可以用函数指针处理，而在Java中则可以用接口处理。它通过提供类型安全和支持多方法改进了函数指针方式；它通过可以进行方法调用而无需内部类适配器或额外的代码去处理多方法调用问题而改进了接口方式。委托最重要 的用途是事件处理，下一节将通过一个例子加以介绍。 </span></p> 
<p align="left"><span style="font-size: 9pt"><strong>5.事件</strong></span></p> 
<p align="left"><span style="font-size: 9pt">C#提供了对事件的直接支持。尽管事件处理一直是编程的基本部分，但令人惊讶的是，大多数语言在正式化这个概念方面所做的努力都微乎其微。如果看看现今主流框架是如何处理事件的，我们可以举出如下例子：Delphi的函数指针（称为闭包）和Java的内部类适配器，当然还有Windows API消息系统。C#使用delegate和event关键字提供了一个清爽的事件处理方案。我认为描述这个机制的最佳办法是举个例子来说明声明、触发和处理事件的过程：</span></p> 
<p align="left"><span style="font-size: 9pt"><font color="#008000">// 委托声明定义了可被调用的方法签名</font> <br /> public delegate void ScoreChangeEventHandler (int newScore, ref bool cancel); <br /> <br /> <font color="#008000">// 产生事件的类</font> <br /> public class Game <br /> { <br /> &nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// 注意使用关键字</font> <br /> &nbsp;&nbsp;&nbsp;&nbsp; public event ScoreChangeEventHandler ScoreChange; <br /> &nbsp;&nbsp;&nbsp;&nbsp; int score; <br /> &nbsp;&nbsp;&nbsp;&nbsp;<br /> &nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// 属性Score</font> <br /> &nbsp;&nbsp;&nbsp;&nbsp; public int Score <br /> &nbsp;&nbsp;&nbsp;&nbsp; { <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return score; } <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (score != value) <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool cancel = false; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScoreChange (value, ref cancel); <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (! cancel) <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; score = value; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br /> &nbsp;&nbsp;&nbsp;&nbsp; } <br /> } <br /> <br /> <font color="#008000">// 处理事件的类</font><br /> public class Referee <br /> { <br /> &nbsp;&nbsp;&nbsp;&nbsp; public Referee (Game game) <br /> &nbsp;&nbsp;&nbsp;&nbsp; { <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// 监视game中的score的分数改变</font><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; game.ScoreChange += new ScoreChangeEventHandler (game_ScoreChange); <br /> &nbsp;&nbsp;&nbsp;&nbsp; } <br /> <br /> &nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// 注意这个方法签名和ScoreChangeEventHandler的方法签名要匹配</font><br /> &nbsp;&nbsp;&nbsp;&nbsp; private void game_ScoreChange (int newScore, ref bool cancel) <br /> &nbsp;&nbsp;&nbsp;&nbsp; { <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (newScore &lt; 100) <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine (&quot;Good Score&quot;); <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cancel = true; <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine (&quot;No Score can be that high!&quot;); <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br /> &nbsp;&nbsp;&nbsp;&nbsp; } <br /> } <br /> <br /> <font color="#008000">// 测试类</font> <br /> public class GameTest<br /> { <br /> &nbsp;&nbsp;&nbsp;&nbsp; public static void Main () <br /> &nbsp;&nbsp;&nbsp;&nbsp; { <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Game game = new Game (); <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Referee referee = new Referee (game); <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; game.Score = 70;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// 译注：输出 Good Score</font><br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; game.Score = 110;&nbsp;&nbsp;&nbsp;<font color="#008000">// 译注：输出 No Score can be that high!</font><br /> &nbsp;&nbsp;&nbsp;&nbsp; } <br /> } </span></p> 
<p align="left"><span style="font-size: 9pt">在GameTest里，我们分别创建了一个game和一个监视game的referee，然后，然后我们改变game的Score去看看referee对此有何反应。在这个系统里，game不知道referee的任何知识，任何类都可以监听并对game的score变化产生反应。关键字event隐藏了除了+=和-=之外的所有委托方法。这两个操作符允许你添加（或移去）处理该事件的多个事件处理器。</span></p> 
<p align="left"><font color="#000080"><span style="font-size: 9pt">译注：我们以下例说明后面这句话的意思：</span></font></p> 
<p align="left"><font color="#000080"><span style="font-size: 9pt">public class Game <br /> { <br /> &nbsp;&nbsp;&nbsp;&nbsp; public event ScoreChangeEventHandler ScoreChange; <br /> &nbsp;&nbsp;&nbsp;&nbsp; protected void OnScoreChange() <br /> &nbsp;&nbsp;&nbsp;&nbsp; { <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ScoreChange != null) ScoreChange(30, ref true);&nbsp;&nbsp;</span> </font><font color="#008000">// 在类内，可以这么使用</font><font color="#000080"><br /> &nbsp;&nbsp;&nbsp;&nbsp; }<br /> }</font></p> 
<p align="left"><font color="#000080"><span style="font-size: 9pt">在这个类外，ScoreChange就只能出现在运算符+=和-=的左边</span></font></p> 
<p align="left"><span style="font-size: 9pt">你可能首先会在图形用户界面框架里遇到这个系统。game好比是用户界面的某个控件，它根据用户输入触发事件，而referee则类似于一个窗体，它负责处理该事件。 </span></p> 
<p align="left"><font color="#008080"><span style="font-size: 9pt">作者注：委托第一次被微软Visual J++引入也是Anders Hejlsberg设计的，同时它也是造成Sun和微软在技术和法律方面争端的起因之一。James Gosling，Java的设计者，对Anders Hejlsberg曾有过一个故作谦虚听起来也颇为幽默的评论，说他因为和Delphi藕断丝连的感情应该叫他“方法指针先生”。在研究Sun对委托的争执后，我觉得称呼Gosling为“一切都是一个类先生”好像公平些:) 过去的这几年里，在编程界，“做努力模拟现实的抽象”已经被很多人代之以“现实是面向对象的，所以，我们应该用面向对象的抽象来模拟它”。</span></font></p> 
<p align="left"><span style="font-size: 9pt">Sun和微软关于委托的争论可以在这儿看到：</span></p> 
<ul> 
 <li> <p align="left"><span style="font-size: 9pt"><a target="_blank" href="http://www.javasoft.com/docs/white/delegates.html"><font color="#5d5d5d">http://www.Javasoft.com/docs/white/delegates.html</font></a></span></p> </li> 
 <li> <p align="left"><span style="font-size: 9pt"><a target="_blank" href="http://msdn.microsoft.com/visualj/technical/articles/delegates/truth.asp"><font color="#5d5d5d">http://msdn.microsoft.com/visualj/technical/articles/delegates/truth.asp</font></a></span></p> </li> 
</ul> 
<p align="left"><span style="font-size: 9pt"><strong>6.枚举</strong> </span></p> 
<p align="left"><span style="font-size: 9pt">枚举使你能够指定一组对象，例如：</span></p> 
<p align="left"><span style="font-size: 9pt">声明： </span></p> 
<p align="left"><span style="font-size: 9pt">public enum Direction {North, East, West, South}; </span></p> 
<p align="left"><span style="font-size: 9pt">使用： </span></p> 
<p align="left"><span style="font-size: 9pt">Direction wall = Direction.North; </span></p> 
<p align="left"><span style="font-size: 9pt">这真是个优雅的概念，这也是C#为什么会决定保留它的原因，但是，为什么Java却选择了抛弃？在Java中，你不得不这么做： </span></p> 
<p align="left"><span style="font-size: 9pt">声明： </span></p> 
<p align="left"><span style="font-size: 9pt">public class Direction<br /> { <br /> &nbsp;&nbsp;&nbsp;&nbsp; public final static int NORTH = 1; <br /> &nbsp;&nbsp;&nbsp;&nbsp; public final static int EAST = 2; <br /> &nbsp;&nbsp;&nbsp;&nbsp; public final static int WEST = 3; <br /> &nbsp;&nbsp;&nbsp;&nbsp; public final static int SOUTH = 4; <br /> } </span></p> 
<p align="left"><span style="font-size: 9pt">使用： </span></p> 
<p align="left"><span style="font-size: 9pt">int wall = Direction.NORTH; </span></p> 
<p align="left"><span style="font-size: 9pt">看起来好像Java版的更富有表达力，但事实并非如此。它不是类型安全的，你可能一不小心会把任何int型的值赋给wall而编译器不会发出任何抱怨。坦白地说，在我的Java编程经历里，我从未因为该处非类型安全而花费太多的时间写一些额外的东西来捕捉错误。但是，能拥有枚举是一件快事。C#带给你的一个惊喜是，当你调试程序时，如果你在使用枚举变量的地方设置断点，调试器将自动译解direction并给你一个可读 性良好的信息，而不是一个你不得不自己译解的数值：</span></p> 
<p align="left"><span style="font-size: 9pt">声明： </span></p> 
<p align="left"><span style="font-size: 9pt">public enum Direction {North=1, East=2, West=4, South=8}; </span></p> 
<p align="left"><span style="font-size: 9pt">使用： </span></p> 
<p align="left"><span style="font-size: 9pt">Direction direction = Direction.North | Direction.West; <br /> if ((direction &amp; Direction.North) != 0) <br /> //.... </span></p> 
<p align="left"><span style="font-size: 9pt">如果你在if语句上设置断点，你将得到一个你可读的direction而不是数值5。</span></p> 
<p align="left"><font color="#000080"><span style="font-size: 9pt">译注：将这个例子略作修改，会更有助于理解：</span></font></p> 
<p align="left"><font color="#000080"><span style="font-size: 9pt">声明： </span></font></p> 
<p align="left"><font color="#000080"><span style="font-size: 9pt">public enum Direction {North=1, East=2, West=4, South=8, Middle = 5</span> </font><font color="#008000">/*注意此处代码*/</font><font color="#000080">};</font></p> 
<p align="left"><font color="#000080"><span style="font-size: 9pt">使用： </span></font></p> 
<p align="left"><span style="font-size: 9pt"><font color="#000080">Direction direction = Direction.North | Direction.West; <br /> if ((direction &amp; Direction.North) != 0) <br /> </font><font color="#008000">//.... </font></span></p> 
<p align="left"><font color="#000080"><span style="font-size: 9pt">如果你在if语句上设置断点，你将得到一个可读性好的direction（即Middle）而不是数值5。</span></font></p> 
<p align="left"><font color="#008080"><span style="font-size: 9pt">作者注：枚举被Java抛弃的原因极有可能是因为它可以用类来代替。正如我上面提到的，单单用类我们不能够象用别的概念一样更好地表达某个特性。Java的“如果它可以用类处理，那就不引入一个新的结构”的哲学的优点何在？看起来最大的优点是简单 — 较短的学习曲线，并且无需程序员去考虑做同一件事的多种方式。实际上，Java语言在很多方面都以简化为目标来改进C++，例如不用指针，不用头文件，以及单根对象层次等。所有这些简化的共性是它们实际上使得编程 — 唔 — 简单了，可是，因为没有我们刚才提到的枚举、属性和事件等等，它反而使你的代码变得更加复杂了。</span></font></p> 
<p align="left"><span style="font-size: 9pt"><strong>7.集合和foreach语句</strong> </span></p> 
<p align="left"><span style="font-size: 9pt">C#提供一个for循环的捷径，而且它还促进了集合类更为一致： </span></p> 
<p align="left"><span style="font-size: 9pt">在Java或C++中： </span></p> 
<p align="left"><span style="font-size: 9pt">1.while (!collection.isEmpty()) <br /> { <br /> &nbsp;&nbsp;&nbsp;&nbsp; Object o = collection.get(); <br /> &nbsp;&nbsp;&nbsp;&nbsp; collection.next();<br /> &nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">//...</font> </span></p> 
<p align="left"><span style="font-size: 9pt">2.for (int i = 0; i &lt; array.length; i++) <font color="#008000">//..</font><font color="#008080">.</font> </span></p> 
<p align="left"><span style="font-size: 9pt">在 C#中： </span></p> 
<p align="left"><span style="font-size: 9pt">1.foreach (object o in collection) <font color="#008000">//...</font><font color="#008080"> </font></span></p> 
<p align="left"><span style="font-size: 9pt">2. foreach (int i in array) <font color="#008000">//...</font> </span></p> 
<p align="left"><span style="font-size: 9pt">C#的for循环将工作于集合对象上（数组实现一个集合）。集合对象有一个GetEnumerator()方法，该方法返回一个Enumerator对象。Enumerator对象有一个MoveNext()方法和一个Current属性。</span></p> 
<p align="left"><span style="font-size: 9pt"><strong>8.结构</strong> </span></p> 
<p align="left"><span style="font-size: 9pt">把C#的结构视为使语言的类型系统更为优雅而不仅仅是一种“如果你需要的话可以利用之编写出真正有效率的代码”的概念，会更好一些。 </span></p> 
<p align="left"><span style="font-size: 9pt">在C++中，结构和类（对象）都可分配在栈或堆上。在C#中，结构永远创建在栈上，类（对象）则永远创建在堆上。使用结构实际上可以生成更有效率的代码： </span></p> 
<p align="left"><span style="font-size: 9pt">public struct Vector <br /> { <br /> &nbsp;&nbsp;&nbsp;&nbsp; public float direction; <br /> &nbsp;&nbsp;&nbsp;&nbsp; public int magnitude; <br /> } <br /> <br /> Vector[] vectors = new Vector [1000]; </span></p> 
<p align="left"><span style="font-size: 9pt">这将把1000个Vector分配在一块空间上，这比我们将Vector声明为类并使用for循环去实例化1000个独立的Vector来得有效率得多。 </span></p> 
<p align="left"><span style="font-size: 9pt">int[] ints = new ints[1000];&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// 译注：此处代码有误，应为int[] ints = new int[1000];</font></span></p> 
<p align="left"><span style="font-size: 9pt">C#完全允许你扩展内建在语言中的基本类型集。实际上，C#所有的基本类型都以结构方式实现的。int只不过是System.Int32结构的别名，long不过是System.Int64结构的别名等等。这些基本类型当然可被编译器特别处理，但是语言本身并无区别<font color="#000080">[译注：意思是语言自身对处理所有类型提供了一致的方法]</font>。在下一节中，我们 将会看到C#是如何做到这一点的。</span></p> 
<p align="left"><span style="font-size: 9pt"><strong>9.类型一致</strong> </span></p> 
<p align="left"><span style="font-size: 9pt">大多数语言都有基本类型（int、long等等）。高级类型最终是由基本类型构成的。能以同样的方式处理基本类型和高级类型通常来说是有用处的。例如，倘若集合可以象包容sting那样 而包容int，是有意义的。为此，Smalltalk通过牺牲些许效率像处理string或Form一样来处理int和long。Java试图避免这个效率损失，它 像C和C++那样处理基本类型，但又为每一个基本类型提供了相应的包装类 — int被包装为Integer，double被包装为Double。C++模板参数可接受任何类型，只要该类型提供了模板 所定义的操作的实现。</span></p> 
<p align="left"><span style="font-size: 9pt">C#对该问题提供了一个不同的解决方案。在上一节里，我介绍了C#中的结构，指出基本类型不过是结构的一个别名而已。既然结构拥有所有对象类型拥有的方法， 那么代码就可以这么写：</span></p> 
<p align="left"><span style="font-size: 9pt">int i = 5; <br /> System.Console.WriteLine(i.ToString()); </span></p> 
<p align="left"><span style="font-size: 9pt">假如我们希望像使用对象那样使用结构，C#会为你将该结构装箱为对象，当你再次需要使用结构时，可以通过拆箱来实现： </span></p> 
<p align="left"><span style="font-size: 9pt">Stack stack = new Stack (); <br /> stack.Push (i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// 装箱</font><br /> int j = (int) stack.Pop();&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// 拆箱</font></span></p> 
<p align="left"><span style="font-size: 9pt">拆箱不仅是类型转换的需要，它也是一个无缝地处理结构和类之间关系的方式。你要清楚装箱是做了创建包装类的工作。另外，CLR可以为被装箱的对象提供额外的优化 处理。 </span></p> 
<p align="left"><span style="font-size: 9pt"><font color="#000080">译注：可以这么认为，在C#中，对于任何值（结构）类型，都存在如下的包装类： </font></span></p> 
<p align="left"><span style="font-size: 9pt"><font color="#000080">class T_Box&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#008000">// T代表任何值类型</font><font color="#000080"> <br /> { <br /> &nbsp;&nbsp;&nbsp;&nbsp; T Value; <br /> &nbsp;&nbsp;&nbsp;&nbsp; T_Box(T t){Value = t;} <br /> } </font></span></p> 
<p align="left"><span style="font-size: 9pt"><font color="#000080">当装箱时，比如： </font></span></p> 
<p align="left"><span style="font-size: 9pt"><font color="#000080">int n = 1; <br /> object box = n; </font></span></p> 
<p align="left"><span style="font-size: 9pt"><font color="#000080">概念上相当于： </font></span></p> 
<p align="left"><span style="font-size: 9pt"><font color="#000080">int n = 1; <br /> object box = new int_Box(i); </font></span></p> 
<p align="left"><span style="font-size: 9pt"><font color="#000080">当拆箱时，比如： </font></span></p> 
<p align="left"><span style="font-size: 9pt"><font color="#000080">object box = 1; <br /> int n = (int)box; </font></span></p> 
<p align="left"><span style="font-size: 9pt"><font color="#000080">概念上相当于： </font></span></p> 
<p align="left"><span style="font-size: 9pt"><font color="#000080">object box = new int_Box(1); <br /> int n = ((int_Box)box).Value;</font></span></p> 
<p align="left"><span style="font-size: 9pt"><font color="#008080">作者注：C#的设计者在设计过程中应该考虑过模板。我怀疑未采用模板有两个原因：第一个是混乱，模板可能很难和面向对象的特性融合在一起，它为程序员的带来了太多的（混乱）设计可能性，而且它很难和反射 机制协作。第二点是，倘若.NET库（例如集合类）没有使用模板的话，模板将不会太有用。不过，果真.NET类使用了它们，那将有20多种使用.NET类的语言不得不也要能和模板协作，这在技术上是非常难以实现的。 <br /> <br /> 注意到模板（泛型）已被Java社团考虑纳入Java语言规范是一件有意思的事。或许每个公司都会各唱各的调，Sun说“.NET患了最小公分母综合症”，而微软则说“Java不支持多 种语言”。 <br /> <br /> （8月10日致歉）看了一篇对Anders Hejlsberg的专访后（<a target="_blank" href="http://windows.oreilly.com/news/hejlsberg_0800.html"><font color="#5d5d5d">http://windows.oreilly.com/news/hejlsberg_0800.html</font></a>），我感觉模板似已浮出地平线。不过C#第一版还没有， 原因正在于我们上面提到的种种困难。看到IL规范是如此写法使得IL码可以展现模板（采用一种非破坏的方式以让反射机制可以很好地工作）而字节码则不可以 ，是一件很有趣的事。在此，我还给出一个关于Java社团考虑要加入泛型功能的链接：<a target="_blank" href="http://jcp.org/jsr/detail/014.jsp"><font color="#5d5d5d">http://jcp.org/jsr/detail/014.jsp</font></a></font></span></p> 
<p align="left"><span style="font-size: 9pt"><strong>10.操作符重载</strong></span></p> 
<p align="left"><span style="font-size: 9pt">利用操作符重载机制，程序员可以创建让人感觉自然的好似简单类型（如int、long等等）的类。C#实现了一个C++操作符重载的限制版，可以使诸如复数类操作符重载这样的精辟的例子表现良好。</span></p> 
<p align="left"><span style="font-size: 9pt">在C#中，操作符==是对象类的非虚方法（操作符不可以为虚的），它是按引用比较的。当你构建一个类时，你可以定义你自己的==操作符。如果你在集合中使用你的类，你应该实现IComparable接口。这个接口有一个叫CompareTo(object)方法，如果“this”大于、小于或等于这个object，它应该相应返回正数、负数或0。假如你希望用户能够用优雅的语法使用你的类， 那么你可以选择定义&lt;、&lt;=、&gt;=、&gt;方法。数值类型（int、long等等）实现了IComparable接口。</span></p> 
<p align="left"><span style="font-size: 9pt">下面是一个如何处理等于和比较操作的简单例子： </span></p> 
<p align="left"><span style="font-size: 9pt">public class Score : IComparable <br /> { <br /> &nbsp;&nbsp;&nbsp;&nbsp; int value;<br /> <br /> &nbsp;&nbsp;&nbsp;&nbsp; public Score (int score) <br /> &nbsp;&nbsp;&nbsp;&nbsp; { <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = score; <br /> &nbsp;&nbsp;&nbsp;&nbsp; } <br /> <br /> &nbsp;&nbsp;&nbsp;&nbsp; public static bool operator == (Score x, Score y) <br /> &nbsp;&nbsp;&nbsp;&nbsp; { <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x.value == y.value; <br /> &nbsp;&nbsp;&nbsp;&nbsp; } <br /> <br /> &nbsp;&nbsp;&nbsp;&nbsp; public static bool operator != (Score x, Score y) <br /> &nbsp;&nbsp;&nbsp;&nbsp; { <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x.value != y.value; <br /> &nbsp;&nbsp;&nbsp;&nbsp; } <br /> <br /> &nbsp;&nbsp;&nbsp;&nbsp; public int CompareTo (object o) <br /> &nbsp;&nbsp;&nbsp;&nbsp; { <br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return value - ((Score)o).value; <br /> &nbsp;&nbsp;&nbsp;&nbsp; } <br /> } <br /> <br /> Score a = new Score (5); <br /> Score b = new Score (5); <br /> Object c = a; <br /> Object d = b; </span></p> 
<p align="left"><span style="font-size: 9pt">按引用比较a和b： </span></p> 
<p align="left"><span style="font-size: 9pt">System.Console.WriteLine ((object)a == (object)b);&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// 结果为false</font> </span></p> 
<p align="left"><span style="font-size: 9pt">比较a和b的值： </span></p> 
<p align="left"><span style="font-size: 9pt">System.Console.WriteLine (a == b);&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// 结果为true</font> </span></p> 
<p align="left"><span style="font-size: 9pt">按引用比较c和d： </span></p> 
<p align="left"><span style="font-size: 9pt">System.Console.WriteLine (c == d);&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// 结果为false</font> </span></p> 
<p align="left"><span style="font-size: 9pt">比较c和d的值： </span></p> 
<p align="left"><span style="font-size: 9pt">System.Console.WriteLine (((IComparable)c).CompareTo (d) == 0);&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">// 结果为true</font> </span></p> 
<p align="left"><span style="font-size: 9pt">你还可以向Score类添加&lt;、&lt;=、&gt;=、&gt;操作符。C#在编译期保证逻辑上要成对出现的操作符（!=和==、&gt;和&lt;、&gt;=和&lt;=）必须一起被定义。 </span></p></div></body></html>