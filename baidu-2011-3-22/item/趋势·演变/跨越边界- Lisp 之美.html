<html><head><title><div class="tit">
  跨越边界: Lisp 之美
</div></title></head><body><div id='tit'>跨越边界: Lisp 之美</div><div id='cate'>趋势&middot;演变</div><div id='date'>2007年12月28日 星期五 00:18 A.M.</div><div id='page'>185</div><a id='url' href='http://hi.baidu.com/hxzon/blog/item/75a36d639bd078640d33fac7.html'>http://hi.baidu.com/hxzon/blog/item/75a36d639bd078640d33fac7.html</a><div id='cnt'><table width="100%" cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
 <tbody> 
  <tr valign="top"> 
   <td width="100%"> <h1><span style="color: rgb(153, 153, 153);">跨越边界: </span>Lisp 之美</h1> <p>编程语言的王道</p> <p><a href="http://www.ibm.com/developerworks/cn/java/j-cb02067.html">http://www.ibm.com/developerworks/cn/java/j-cb02067.html</a></p> <img width="1" height="6" class="display-img" src="image/跨越边界- Lisp 之美.html.c.gif" /><p class="origImg">http://www.ibm.com/i/c.gif</p></td> 
   <td width="192" class="no-print"> </td> 
  </tr> 
 </tbody> 
</table> 
<table width="100%" cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
 <tbody> 
  <tr valign="top"> 
   <td width="10"><img width="10" height="1" src="image/跨越边界- Lisp 之美.html.c.gif" /><p class="origImg">http://www.ibm.com/i/c.gif</p></td> 
   <td width="100%"> <p>级别： 中级</p> <p><a href="http://www.ibm.com/developerworks/cn/java/j-cb02067.html#author"><font color="#996699">Bruce Tate</font></a> (<a href="mailto:bruce.tate@j2life.com?subject=Lisp 之美&amp;cc=bruce.tate@j2life.com"><font color="#5c81a7">bruce.tate@j2life.com</font></a>), CTO, WellGood LLC</p> <p>2007 年 3 月 05 日</p> 
    <blockquote>
     Lisp 长久以来一直被视为伟大的编程语言之一。其漫长的发展过程（接近五十年）中引发的追随狂潮表明：这是一门非同凡响的语言。在 MIT，Lisp 在所有程序员的课程中占了举足轻重的地位。像 Paul Graham 那样的企业家们将 Lisp 卓越的生产力用作他们事业成功起步的推动力。但令其追随者懊恼万分的是，Lisp 从未成为主流编程语言。作为一名 Java™ 程序员，如果您花一点时间研究 Lisp 这座被人遗忘的黄金之城，就会发现许多能够改进编码方式的技术。 
    </blockquote> <p>我最近第一次完成了马拉松赛跑，我发现跑步比我预想的更有价值。我跑了 26.2 英里，通过该步骤，我开始认为这是对身体非常有益的简单活动。一些语言给了我类似的感觉，如 Smalltalk 和 Lisp。对 Smalltalk 来说，引发类似感觉的是对象；Smalltalk 中的一切内容都是在处理对象和消息传递。对于 Lisp 来说，这个至为重要的步骤更为简单。这门语言完全由列表组成。但不要被这个简单的假相所欺骗。这门有着 48 年历史的语言具有难以置信的强大功能和灵活性，这是 Java 语言所不能企及的。</p> <p>第一次和 Lisp 打交道时，我还是在校大学生，但这次不是很顺利。因为我拼命地想把 Lisp 编入到熟悉的过程化范例中，而不是在 Lisp 的函数结构下工作。尽管 Lisp 并不是一门严格的函数语言（因为一些特性，它不符合最严格的术语定义），但 Lisp 的许多习语和特性有着很强的函数风格。从那以后，我学会了利用列表和函数式编程。</p> 
    <table width="40%" cellspacing="0" cellpadding="0" border="0" align="right" class="FCK__ShowTableBorders"> 
     <tbody> 
      <tr> 
       <td width="10"><img width="10" height="1" src="image/跨越边界- Lisp 之美.html.c.gif" /><p class="origImg">http://www.ibm.com/i/c.gif</p></td> 
       <td> 
        <table width="100%" cellspacing="0" cellpadding="5" border="1"> 
         <tbody> 
          <tr> 
           <td bgcolor="#eeeeee"><a name="N10069"><strong>关于本系列</strong></a><br /> <p>在 <a href="http://www.ibm.com/developerworks/cn/java/j-cb/"><font color="#5c81a7">跨越边界系列</font></a> 文章中，作者 Bruce Tate 提出这样一个观点：如今的 Java 程序员可通过学习其他方法和语言得到很好的其他思路。自从 Java 技术明显成为所有开发项目的最佳选择以来，编程前景已经变化。其他的框架影响着构建 Java 框架的方式，从其他语言学到的概念可以影响您的 Java 编程。您编写的 Python（或 Ruby、Smalltalk……）代码可以改变您处理 Java 编码的方式。</p> <p>本系列为您介绍与 Java 开发根本不同，但也可以直接应用于 Java 开发的编程概念和技术。在一些示例中，需要对技术进行集成来利用它。在另外一些示例中，您将能够直接应用这些概念。单独的工具不及其他语言和框架能够影响 Java 社区中的开发人员、框架甚至基本方法的思想那么重要。</p> </td> 
          </tr> 
         </tbody> 
        </table> </td> 
      </tr> 
     </tbody> 
    </table> <p>本期的<em>跨越边界</em> 将重拾这份遗失的财富。我会带您简单地领略一下 Lisp 的基本构造，然后快速的扩展开来。您将学到 Lambda 表达式、递归和宏。这份简单的向导会让您对 Lisp 的高效性和灵活性有所理解。</p> <p><a name="N10080"><span class="atitle">入门</span></a></p> <p>本文使用 GNU 的 GCL，它针对许多操作系统都有免费下载。但稍作修改，就能使用任何版本的 Common Lisp。请参见 <a href="http://www.ibm.com/developerworks/cn/java/j-cb02067.html#resources"><font color="#996699">参考资料</font></a> 获取可用 Lisp 版本的详细说明。</p> <p>和学习大多数其他语言一样，学习 Lisp 最好的方法就是实践。打开您的解释程序，和我一起编码。Lisp 基本上是一门编译好的语言，通过直接键入命令，就可以轻松地用它进行编程。</p> <p><a name="N10091"><span class="atitle">列表语言</span></a></p> <p>基本上，Lisp 是一门关于列表的语言。Lisp 中的一切内容（从数据到组成应用程序的代码）都是列表。每个列表都由一些<em>原子</em> 和列表组成。数字就是原子。键入一个数字仅仅会返回该数字作为结果：</p> <br /> <a name="N100A1"><strong>清单 1. 简单原子</strong></a><br /> 
    <table width="100%" cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
     <tbody> 
      <tr> 
       <td class="code-outline"> <pre class="displaycode">&gt;1<br />1<br />&gt;a<br />Error: The variable A is unbound.</pre> </td> 
      </tr> 
     </tbody> 
    </table> <br /> <p>如果键入一个字母，解释程序会报错，如清单 1 所示。字母是变量，所以使用之前必须先为其赋值。如果想要引用一个字母或词语而不是变量，请使用引号将其括起来。在变量前加单引号告诉 Lisp 延迟对后续列表或原子进行求值，如清单 2 所示：</p> <br /> <a name="N100AE"><strong>清单 2. 延迟求值和引用</strong></a><br /> 
    <table width="100%" cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
     <tbody> 
      <tr> 
       <td class="code-outline"> <pre class="displaycode">&gt;&quot;a&quot;<br />&quot;a&quot;<br />&gt;'a<br />A</pre> </td> 
      </tr> 
     </tbody> 
    </table> <br /> <p>请注意 Lisp 把 a 大写为 A。lisp 假设您希望使用 A 作为符号，因为它没有加括号。后面会讨论赋值，但先要让列表来完成这一任务。简单地讲，Lisp 列表是加了括号并使用空格隔开的原子序列。尝试如清单 3 所示键入一个列表。这个列表是无效的，除非在列表前面加上 '。</p> <br /> <a name="N100BB"><strong>清单 3. 键入一个简单列表</strong></a><br /> 
    <table width="100%" cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
     <tbody> 
      <tr> 
       <td class="code-outline"> <pre class="displaycode">&gt;(1 2 3)<br />Error: 1 is invalid as a function.<br />&gt;'(1 2 3)<br />(1 2 3)</pre> </td> 
      </tr> 
     </tbody> 
    </table> <br /> <p>除非在列表前加上 '，否则 Lisp 会像对函数求值那样对每个列表求值。第一个原子是运算符，列表中其余的原子是参数。Lisp 有数目众多的原语函数，正如您预料的那样，其中包括许多数学函数，例如，+、* 和 <code><font face="新宋体">sqrt</font></code>。<code><font face="新宋体">(+ 1 2 3)</font></code> 返回 <code><font face="新宋体">6</font></code>，<code><font face="新宋体">(* 1 2 3 4)</font></code> 返回 <code><font face="新宋体">24</font></code>。</p> <p>操纵列表的有两类函数：<em>构造函数</em> 和<em>选择函数</em>。构造函数构建列表，选择函数分解列表。<code><font face="新宋体">first</font></code> 和 <code><font face="新宋体">rest</font></code> 是核心选择函数。<code><font face="新宋体">first</font></code> 选择函数返回列表的第一个原子，<code><font face="新宋体">rest</font></code> 选择函数返回除第一个原子外的整个列表。清单 4 显示了这两个选择函数：</p> <br /> <a name="N100F5"><strong>清单 4. 基本 Lisp 函数</strong></a><br /> 
    <table width="100%" cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
     <tbody> 
      <tr> 
       <td class="code-outline"> <pre class="displaycode">&gt; (first '(lions tigers bears))<br />LIONS<br /><br />&gt; (rest '(lions tigers bears))<br />(TIGERS BEARS)</pre> </td> 
      </tr> 
     </tbody> 
    </table> <br /> <p>这两个选择函数都获取整个列表，返回列表的主要片断。稍后，您将了解递归如何利用这些选择函数。</p> <p>如果希望构建列表而不是将其分开，就需要构造函数。与在 Java 语言中一样，构造函数构建新元素：在 Java 语言中为对象，在 Lisp 中即为列表。<code><font face="新宋体">cons</font></code>、<code><font face="新宋体">list</font></code> 和 <code><font face="新宋体">append</font></code> 是构造函数示例。核心构造函数 <code><font face="新宋体">cons</font></code> 带有两个参数：一个原子和一个列表。<code><font face="新宋体">cons</font></code> 将该原子作为第一个元素添加到该列表。如果对 <code><font face="新宋体">nil</font></code> 调用 <code><font face="新宋体">cons</font></code>，Lisp 将 <code><font face="新宋体">nil</font></code> 作为空列表对待，并构建一个含一个元素的列表。<code><font face="新宋体">append</font></code> 连接两个列表。<code><font face="新宋体">list</font></code> 包含一个由所有参数组成的列表。清单 5 显示了这些构造函数的实际应用：</p> <br /> <a name="N1012D"><strong>清单 5. 使用构造函数</strong></a><br /> 
    <table width="100%" cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
     <tbody> 
      <tr> 
       <td class="code-outline"> <pre class="displaycode">&gt; (cons 'lions '(tigers bears))<br />(LIONS TIGERS BEARS)<br /><br />&gt; (list 'lions 'tigers 'bears)<br />(LIONS TIGERS BEARS)<br /><br />&gt; (append '(lions) '(tigers bears))<br />(LIONS TIGERS BEARS)</pre> </td> 
      </tr> 
     </tbody> 
    </table> <br /> <p>将 <code><font face="新宋体">cons</font></code> 与 <code><font face="新宋体">first</font></code>、<code><font face="新宋体">rest</font></code> 一起用时可以构建任何列表。<code><font face="新宋体">list</font></code> 和 <code><font face="新宋体">append</font></code> 运算符只是为了方便，但经常会用到它们。事实上，可以使用 <code><font face="新宋体">cons</font></code>、<code><font face="新宋体">first</font></code> 和 <code><font face="新宋体">rest</font></code> 来构建任何列表，或返回任何列表片段。例如，要获取列表的第二或第三个元素，应该获取 <code><font face="新宋体">rest</font></code> 中的 <code><font face="新宋体">first</font></code>，或 <code><font face="新宋体">rest</font></code> 中的 <code><font face="新宋体">rest</font></code> 中的 <code><font face="新宋体">first</font></code>，如清单 6 所示。或者，若要构建包含两个或三个元素的列表，可以将 <code><font face="新宋体">cons</font></code> 和 <code><font face="新宋体">first</font></code>、<code><font face="新宋体">rest</font></code> 一起使用，来模拟 <code><font face="新宋体">list</font></code> 和 <code><font face="新宋体">append</font></code>。</p> <br /> <a name="N10182"><strong>清单 6. 构建第二个元素、第三个元素，然后模拟 list 和 append</strong></a><br /> 
    <table width="100%" cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
     <tbody> 
      <tr> 
       <td class="code-outline"> <pre class="displaycode">&gt;(first (rest '(1 2 3)))<br />2<br /><br />&gt;(first (rest (rest '(1 2 3))))<br />3<br /><br />&gt;(cons '1 (cons '2 nil))<br />(1 2)<br /><br />&gt;(cons '1 (cons '2 (cons '3 nil)))<br />(1 2 3)<br /><br />&gt;(cons (first '(1)) '(2 3))<br />(1 2 3)</pre> </td> 
      </tr> 
     </tbody> 
    </table> <br /> <p>这些示例也许无法引起您的兴趣，但在如此简单的原语之上构建一门简洁优美的语言，其中的原理让一些程序员激动不已。这些由列表构建的简单指令构成了递归、高阶函数，甚至是闭包和 continuation 之类高级抽象的基础。因此下面将研究高级抽象。</p> <br /> 
    <table width="100%" cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
     <tbody> 
      <tr> 
       <td><img width="100%" height="1" src="image/跨越边界- Lisp 之美.html.blue_rule.gif" /><p class="origImg">http://www.ibm.com/i/v14/rules/blue_rule.gif</p><br /> <img width="8" height="6" border="0" src="image/跨越边界- Lisp 之美.html.c.gif" /><p class="origImg">http://www.ibm.com/i/c.gif</p></td> 
      </tr> 
     </tbody> 
    </table> 
    <table cellspacing="0" cellpadding="0" align="right" class="no-print FCK__ShowTableBorders"> 
     <tbody> 
      <tr align="right"> 
       <td><img width="100%" height="4" src="image/跨越边界- Lisp 之美.html.c.gif" /><p class="origImg">http://www.ibm.com/i/c.gif</p><br /> 
        <table width="42" height="19" cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
         <tbody> 
          <tr> 
           <td valign="middle"> </td> 
           <td valign="top" align="right"> </td> 
          </tr> 
         </tbody> 
        </table> </td> 
      </tr> 
     </tbody> 
    </table> <br /> <p><a name="N1018B"><span class="atitle">构建函数</span></a></p> <p>可以猜到，Lisp 函数声明为列表。清单 7 构建了一个返回列表第二个元素的函数，展示了函数声明的形式：</p> <br /> <a name="N10198"><strong>清单 7. 构建第二个函数</strong></a><br /> 
    <table width="100%" cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
     <tbody> 
      <tr> 
       <td class="code-outline"> <pre class="displaycode">(defun my_second (lst)<br />  (first (rest lst))<br />)</pre> </td> 
      </tr> 
     </tbody> 
    </table> <br /> <p><code><font face="新宋体">defun</font></code> 是用于定义自定义函数的函数。第一个参数是函数名，第二个参数是参数列表，第三个参数是希望执行的代码。可以看出，所有 Lisp 代码都表述为列表。借助这项灵活和强大的功能，就可以像操纵其他任何数据一样操纵应用程序。稍后将看到一些示例使代码和数据之间的区别变得模糊。</p> <p>Lisp 也处理条件结构，如 <code><font face="新宋体">if</font></code> 语句。格式为 <code><font face="新宋体">(if <em>condition_statement</em> <em>then_statement</em> <em>else_statement</em>)</font></code>。清单 8 是一个简单的 <code><font face="新宋体">my_max</font></code> 函数，用于计算两个输入变量中的最大值：</p> <br /> <a name="N101C1"><strong>清单 8. 计算两个整数中的最大值</strong></a><br /> 
    <table width="100%" cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
     <tbody> 
      <tr> 
       <td class="code-outline"> <pre class="displaycode">(defun my_max (x y)<br />  (if (&gt; x y) x y)<br />)<br /><br />MY_MAX<br />(my_max 2 5)<br /><br />5<br />(my_max 6 1)<br /><br />6</pre> </td> 
      </tr> 
     </tbody> 
    </table> <br /> <p>下面回顾一下到目前为止看到的内容：</p> 
    <ul> 
     <li>Lisp 使用列表和原子来表示数据和程序。</li> 
     <li>对列表求值时将第一个元素看作列表函数，将其他元素看作函数参数。</li> 
     <li>Lisp 条件语句将 true/false 表达式和代码一起使用。</li> 
    </ul> <br /> 
    <table width="100%" cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
     <tbody> 
      <tr> 
       <td><img width="100%" height="1" src="image/跨越边界- Lisp 之美.html.blue_rule.gif" /><p class="origImg">http://www.ibm.com/i/v14/rules/blue_rule.gif</p><br /> <img width="8" height="6" border="0" src="image/跨越边界- Lisp 之美.html.c.gif" /><p class="origImg">http://www.ibm.com/i/c.gif</p></td> 
      </tr> 
     </tbody> 
    </table> 
    <table cellspacing="0" cellpadding="0" align="right" class="no-print FCK__ShowTableBorders"> 
     <tbody> 
      <tr align="right"> 
       <td><img width="100%" height="4" src="image/跨越边界- Lisp 之美.html.c.gif" /><p class="origImg">http://www.ibm.com/i/c.gif</p><br /> 
        <table cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
         <tbody> 
          <tr> 
           <td valign="middle"> </td> 
           <td valign="top" align="right"> </td> 
          </tr> 
         </tbody> 
        </table> </td> 
      </tr> 
     </tbody> 
    </table> <br /> <br /> <p><a name="N101D6"><span class="atitle">递归</span></a></p> <p>Lisp 提供用于迭代的编码结构，但递归是更受欢迎的列表遍历方式。使用 <code><font face="新宋体">first</font></code> 和 <code><font face="新宋体">rest</font></code> 组合实现递归效果很好。清单 9 中的 <code><font face="新宋体">total</font></code> 函数显示了其运行原理：</p> <br /> <a name="N101EF"><strong>清单 9. 使用递归计算列表的总和</strong></a><br /> 
    <table width="100%" cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
     <tbody> 
      <tr> 
       <td class="code-outline"> <pre class="displaycode">&gt;(defun total (x)<br />  (if (null x)<br />    0<br />    (+ (first x) (total (rest x)))<br />  )<br />)<br /><br />TOTAL<br />&gt;(total '(1 5 1))<br /><br />7</pre> </td> 
      </tr> 
     </tbody> 
    </table> <br /> <p>清单 9 中的 <code><font face="新宋体">total</font></code> 函数将列表当作单个的参数。第一个 <code><font face="新宋体">if</font></code> 语句在列表为空的情况下中断递归，返回零值。否则，该函数将第一个元素添加到列表其余部分的总和。现在应该明白如此构建 <code><font face="新宋体">first</font></code> 和 <code><font face="新宋体">rest</font></code> 的原因。<code><font face="新宋体">first</font></code> 能够去除列表的第一个元素，<code><font face="新宋体">rest</font></code> 简化了将<em>尾部递归</em> （清单 9 中的递归类型）应用于列表其余部分的过程。</p> <p>由于性能的原因，Java 语言中的递归是有限的。Lisp 提供一项称作<em>尾部递归优化</em> 的性能优化技术。Lisp 编译器或解释器能够将特定形式的递归翻译为迭代，从而允许以一种更为简单明快的方式来使用递归数据结构（如树结构）。</p> <br /> 
    <table width="100%" cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
     <tbody> 
      <tr> 
       <td><img width="100%" height="1" src="image/跨越边界- Lisp 之美.html.blue_rule.gif" /><p class="origImg">http://www.ibm.com/i/v14/rules/blue_rule.gif</p><br /> <img width="8" height="6" border="0" src="image/跨越边界- Lisp 之美.html.c.gif" /><p class="origImg">http://www.ibm.com/i/c.gif</p></td> 
      </tr> 
     </tbody> 
    </table> 
    <table cellspacing="0" cellpadding="0" align="right" class="no-print FCK__ShowTableBorders"> 
     <tbody> 
      <tr align="right"> 
       <td><img width="100%" height="4" src="image/跨越边界- Lisp 之美.html.c.gif" /><p class="origImg">http://www.ibm.com/i/c.gif</p><br /> 
        <table cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
         <tbody> 
          <tr> 
           <td valign="middle"> </td> 
           <td valign="top" align="right"> </td> 
          </tr> 
         </tbody> 
        </table> </td> 
      </tr> 
     </tbody> 
    </table> <br /> <p><a name="N10219"><span class="atitle">高阶函数</span></a></p> <p>如果模糊了数据和代码之间的区别，Lisp 会更有意思。在本系列的前两篇文章中，介绍了 <a href="http://www.ibm.com/developerworks/cn/java/j-cb12196/index.html"><font color="#5c81a7">JavaScript 中的高阶函数</font></a> 和 <a href="http://www.ibm.com/developerworks/cn/java/j-cb01097.html"><font color="#5c81a7">Ruby 中的闭包</font></a>。这两项功能都将函数作为参数进行传递。在 Lisp 中，由于函数和列表没有任何区别，高阶函数也就非常简单。</p> <p>高阶函数的最常见用法或许是 <em>lambda 表达式</em>，这是闭包的 Lisp 版。lambda 函数是用于将高阶函数传入 Lisp 函数的函数定义。例如，清单 10 中的 lambda 表达式计算了两个整数的和：</p> <br /> <a name="N10235"><strong>清单 10. Lambda 表达式</strong></a><br /> 
    <table width="100%" cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
     <tbody> 
      <tr> 
       <td class="code-outline"> <pre class="displaycode">&gt;(setf total '(lambda (a b) (+ a b)))<br />(LAMBDA (A B) (+ A B))<br /><br />&gt;total<br />(LAMBDA (A B) (+ A B))<br /><br />&gt;(apply total '(101 102))<br />203</pre> </td> 
      </tr> 
     </tbody> 
    </table> <br /> <p>如果使用过高阶函数或闭包，那么可能更容易理解清单 10 中的代码。第一行代码定义了一个 lambda 表达式并将其和 <code><font face="新宋体">total</font></code> 符号绑定到一起。第二行代码仅显示了这个和 <code><font face="新宋体">total</font></code> 绑定到一起的 lambda 表达式。最终，最后一个表达式对包含 <code><font face="新宋体">(101 102)</font></code> 的列表应用这个 lambda 表达式。</p> <p>高阶函数提供比面向对象概念更高层次的抽象。可以用它们来更简洁清晰地表达想法。编程的至高境界就是在不牺牲可读性或性能的前提下，用更少的代码提供更强大更灵活的功能。高阶函数能实现所有这些要求。</p> <p>Lisp 还有两种类型的高阶函数。其中功能最强大的可能是<em>宏</em>。宏为后面的执行定义 Lisp 对象。可以将宏看作代码模板。请参考清单 11 中的示例：</p> <br /> <a name="N10257"><strong>清单 11. 宏</strong></a><br /> 
    <table width="100%" cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
     <tbody> 
      <tr> 
       <td class="code-outline"> <pre class="displaycode">&gt;(defmacro times_two (x) (* 2 x))<br />TIMES_TWO<br /><br />&gt;(setf a 4)<br />4<br /><br />&gt;(times_two a)<br />8</pre> </td> 
      </tr> 
     </tbody> 
    </table> <br /> <p>这个示例应该分为两个阶段进行阅读。第一次赋值定义了宏 <code><font face="新宋体">times_two</font></code>。在第二个阶段（称为<em>宏扩展</em>）中，在对 <code><font face="新宋体">a</font></code> 求值之前，将 <code><font face="新宋体">a</font></code> 扩展为 <code><font face="新宋体">(* 2 a)</font></code>。该模板中这项延迟求值方式使宏的功能非常强大。Lisp 语言本身的许多功能都是基于宏的。</p> <p><a name="N10273"><span class="atitle">结束语</span></a></p> <p>从年份上讲，Lisp 也许很陈旧，甚至语法也很陈旧。但如果稍作研究，就会发现该语言有着难以置信的强大功能，它的高阶抽象一如既往地有效，并且生产力很高。许多更为现代的语言从 Lisp 中得到借鉴，但是其中大多数语言的功能无法与 Lisp 媲美。如果 Lisp 拥有 Java 或 .NET 的一部分市场，并且大学中具备 lisp 知识的人也占有一定的比例，我们可能就会立即用它进行编码。</p> <br /> <br /> <p><a name="resources"><span class="atitle">参考资料 </span></a></p> <strong>学习</strong><br /> 
    <ul> 
     <li>您可以参阅本文在 developerWorks 全球站点上的 <a target="_blank" href="http://www.ibm.com/developerworks/java/library/j-cb02067.html?S_TACT=105AGX52&amp;S_CMP=cn-a-j"><font color="#5c81a7">英文原文</font></a> 。</li> 
     <li><a href="http://www.oreilly.com/catalog/beyondjava/index.html"><font color="#5c81a7"><em>Beyond Java</em> </font></a>（O'Reilly，2005 年）：本文作者编写的一本书，讲述 Java 语言优缺点以及在某些方面可能对 Java 平台带来挑战的技术。</li> 
     <li><a href="http://www.gnu.org/software/gcl/"><font color="#5c81a7">GNU Common Lisp</font></a>：一个更为流行的 Lisp 实现，也是本文中使用的 Lisp 解释器。</li> 
     <li><a href="http://www.paulgraham.com/carl.html"><font color="#5c81a7">Carl de Marcken: Inside Orbitz</font></a>：这个关于 Lisp 实际功能的讨论展示了 Lisp 在现实世界中能完成的工作。</li> 
     <li><a href="http://philebus.tamu.edu/~colin/lp/lp.html"><font color="#5c81a7">Learning Lisp</font></a>：一本关于 Lisp 的优秀初级读物，构成了本文中一些示例的基础。</li> 
     <li><a href="http://mitpress.mit.edu/sicp/full-text/book/book.html"><font color="#5c81a7"><em>Structure and Interpretation of Computer Programs</em>,</font></a>第 2 版（Harold Abelson et al.，McGraw-Hill，1996 年）：一本以 Lisp 哲学为基础的经典读物。</li> 
     <li><a href="http://www.lisp.org/alu/home"><font color="#5c81a7">Association of Lisp Users</font></a>：支持 Lisp 社区的国际组织。</li> 
     <li><a href="http://www.ibm.com/developerworks/cn/java/"><font color="#5c81a7">Java 技术专区</font></a>：这里可以找到数百篇关于 Java 编程各方面的文章。</li> 
    </ul> <br /> <strong>获得产品和技术</strong><br /> 
    <ul> 
     <li><a href="http://www.lisp.org/table/systems.htm"><font color="#5c81a7">Common Lisp Implementations</font></a>：商业和免费的 Common Lisp 实现。</li> 
    </ul> <br /> <strong>讨论</strong><br /> 
    <ul> 
     <li>通过参与 <a href="http://www.ibm.com/developerworks/blogs/?S_TACT=105AGX52&amp;S_CMP=cn-a-j"><font color="#5c81a7">developerWorks blog</font></a> 加入 <a href="http://www.ibm.com/developerworks/community?S_TACT=105AGX52&amp;S_CMP=cn-a-j"><font color="#5c81a7">developerWorks 社区</font></a>。</li> 
    </ul> <br /> <br /> <p><a name="author"><span class="atitle">关于作者</span></a></p> 
    <table width="100%" cellspacing="0" cellpadding="0" border="0" class="FCK__ShowTableBorders"> 
     <tbody> 
      <tr> 
       <td colspan="3"> </td> 
      </tr> 
      <tr valign="top" align="left"> 
       <td> <p> </p> </td> 
       <td><img width="4" height="5" src="image/跨越边界- Lisp 之美.html.c.gif" /><p class="origImg">http://www.ibm.com/i/c.gif</p></td> 
       <td width="100%"> <p>Bruce Tate 居住在德克萨斯州的奥斯汀，他是一位父亲，同时也是山地车手和皮艇手。他是 3 本 Java 畅销书籍的作者，其中包括荣获 Jolt 大奖的 <em>Better, Faster, Lighter Java</em> 一书。他最近又出版了 <em>From Java to Ruby</em> 和 <em>Rails: Up and Running</em>。他在 IBM 工作了 13 年，随后创建了 RapidRed 顾问公司，在那里他潜心研究基于 Ruby 和 Ruby on Rails 框架的轻量级开发策略和架构。如今，他是 WellGood LLC 公司的 CTO，该公司专为非营利组织和慈善机构谋求市场中的一席之地。</p> </td> 
      </tr> 
     </tbody> 
    </table> </td> 
  </tr> 
 </tbody> 
</table> 
<a href="http://www.ibm.com/developerworks/cn/java/j-cb02067.html"><br /> </a></div></body></html>