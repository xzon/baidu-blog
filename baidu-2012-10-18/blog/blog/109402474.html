<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>精通AspectJ 详细目录 -hxzon爱读书</title></head><body><h1>精通AspectJ 详细目录 -hxzon爱读书</h1><div>精通AspectJ 详细目录 -hxzon爱读书<br>
<br>
出版社　： 清华大学出版社 <br>
作者　　： Joseph D. Gradecki/ Nicholas Lesiecki/ <br>
<br>
译者　　： 王欣轩/ 吴东升 等/ <br>
出版日期：2005年1月 <br>
版别版次：2005年1月第1版第1次印刷 <br>
=====================<br>
目录 <br>
&nbsp;&nbsp;&nbsp;  第1章 AOP简介<br>
1.1 00P把我们带到了何处<br>
1.2 AOP如何解决OOP问题<br>
1.2.1什么是AOP<br>
1.2.2 AOP的开发过程<br>
1.3 结束语<br>
第2章 实现AOP<br>
2.1 AOP语言剖析<br>
2.1.1 AOP语言规范<br>
2.1.2 AOP语言的实现<br>
2.2 AspectJ<br>
2.3 结束语<br>
第3章 AspectJ的获取和安装<br>
3.1 AspectJ的要求<br>
3.2 下载AspectJ<br>
3.3 安装AspectJP<br>
3.3.1 设置PATH<br>
3.3.2 设置CLASSPATH<br>
3.4 安装测试<br>
3.5 结束语<br>
第4章 实现AspmJ<br>
4.1 我们的首个AspectJ程序<br>
4.1.1 首先编写组件<br>
4.1.2 aspect代码<br>
4.1.3 识别连接点<br>
4.1.4 确定poincut<br>
4.1.5 提供advice<br>
4.1.6 增加一个aspect<br>
4.1.7 编译和执行这个例子<br>
4.2 添加一个新的关注点<br>
4.2.1 返回文本的方法<br>
4.2.2 把返回方法记入日志<br>
4.2.3 一个新的首要关注点<br>
4.3 暴露的上下文<br>
4.4 类型间声明<br>
4.5 aspect粒度<br>
4.6 AspectJ编译器功能<br>
4.6.1 指定源目录<br>
4.6.2 用JAR进行织人<br>
4.6.3 指定输出到一个JAR文件<br>
4.6.4 创建和使用aspect库<br>
4.6.5 阻止织人<br>
4.6.6 使用渐进式编译<br>
4.7 结束语<br>
第5章 AspectJ连接点<br>
5.1 动态连接点模型<br>
5.2 AspectJ连接点<br>
5.3 连接点签名<br>
5.4 模式<br>
5.4.1类型名称模式<br>
5.4.2 子类型模式<br>
5.4.3 抛出模式<br>
5.4.4 类型模式<br>
5.5 反射<br>
5.5.1 thisJoinPoint方法<br>
5.5.2 thisJoinPointStaticPart方法<br>
5.6 连接点示例<br>
5.6.1 方法调用接收和执行<br>
5.6.2 构造函数的调用接收／执行以及对象初始化<br>
5.6.3 字段获取／设置<br>
5.6.4 异常处理程序执行<br>
5.6.5 类初始化<br>
5.7 结束语<br>
第6章 AspectJ pointcut<br>
6.1 三个类的介绍<br>
6.2 建立oointeut<br>
6.3 使用指示符<br>
6.3.1 指示符快速参考<br>
6.3.2 使用逻辑运算符来创建指示符组合<br>
6.4 组合pointcut<br>
6.4.1 方法相关的pointeut<br>
6.4.2 异常处理指示符<br>
6.4.3 与域有关的指示符<br>
6.4.4 基于状态的指示符<br>
6.4.5 基于控制流的指示符<br>
6.4.6 类初始化指示符<br>
6.4.7 基于程序文本的指示符<br>
6.4.8 基于动态属性的指示符<br>
6.4.9 adviceexecution<br>
6.4.10 preinitialization<br>
6.4.11 处理接口<br>
6.4.12 匿名pointcut<br>
6.4.13 在类中使用aspect<br>
6.4.14 创建Factory对象<br>
6.4.15 捕获Java库调用<br>
6.4.16 访问final属性<br>
6.4.17 异常模式<br>
6.5 结束语<br>
第7章 advice<br>
7.1 advice的定义<br>
7.1.1 将信息添加到Stem.out.println()中<br>
7.1.2 advice<br>
7.1.3 形式定义.<br>
7.2 所有类型advice中普遍存在的问题<br>
7.2.1 将上下文导人advice中<br>
7.2.2 advice与异常<br>
7.3 advice的类型：概述<br>
7.4 before advice<br>
7.5 after advice&rdquo;<br>
7.5.1 after advice(无限制型)<br>
7.5.2 after抛出<br>
7.5.3 after returning<br>
7.6 around advice<br>
7.6.1 对getProperty()调用进行替换<br>
7.6.2 proceed()<br>
7.7 advice的优先级<br>
7.7.1 优先级的重要性<br>
7.7.2 优先级的决定方法<br>
7.7.3 运行期执行<br>
7.7.4 伪优先级<br>
7.8 结束语<br>
第8章 类型间声明<br>
8.1 类型间声明的简单例子<br>
8.1.1 向类中添加方法<br>
8.1.2 引入和advice<br>
8.2 类型间成员：机制<br>
8.2.1 类型间成员的类型<br>
8.2.2 类型间声明的目标<br>
8.2.3 访问控制<br>
8.2.4 成员间的冲突<br>
8.3 declare parents<br>
8.3.1 添加一个简单的接口<br>
8.3.2 declare parents：机制<br>
8.4 带有具体成员的接口<br>
8.4.1 重构Persistence解决方案<br>
8.4.2 带有具体成员的接El：机制<br>
8.4.3 带有具体成员的接口的可能性<br>
8.5 声明优先级<br>
8.5.1 一个优先级的例子<br>
8.5.2 声明优先级：机制<br>
8.5.3 迂回问题<br>
8.5.4 优先级的效果<br>
8.6 其他静态横切<br>
8.6.1 静态可确定的pointcut<br>
8.6.2 自定义编译消息<br>
8.6.3 软化异常<br>
8.7 结束语<br>
第9章 aspec<br>
9.1 aspect结构<br>
9.2 aspect扩展<br>
9.2.1 构建抽象aspect<br>
9.2.2 从类和接口中继承<br>
9.3 aspect实例化和联合<br>
9.3.1 单独的aspect<br>
9.3.2 基于每对象的aspect<br>
9.3.3 基于每控制流的aspect<br>
9.4 aspect支配和优先级<br>
9.5 访问aspect对象<br>
9.6 aspect特权<br>
9.7 结束语<br>
第10章 AspecO的开发应用<br>
10.1 采用AspectJ<br>
lO.1.1 采用AspectJ的缘由<br>
10.1.2 如何将AspectJ应用到过程中<br>
10.1.3 前期开发工作<br>
10.1.4 取消AspectJ<br>
10.2 开发使用<br>
10.2.1 跟踪<br>
10.2.2 条件检查<br>
10.3 生产aspect<br>
10.3.1 日志和计时<br>
10.3.2 授权<br>
10.4 结束语<br>
第11章 使用AspectJ工具<br>
11.1 AspectJ编译器选项<br>
11.2 aspect结构浏览器<br>
11.3 使用AspectJ IDE扩展<br>
11.3.1 JBuilder&rdquo;<br>
11.3.2 Forte与NetBeans<br>
11.3.3 Emacs <br>
11.3.4 Eclipse<br>
11.4 Ant <br>
11.5 调试AspectJ<br>
11.5.1 aidb命令行指南<br>
11.5.2 aidb GUI指南<br>
11.6 使用ajdoc <br>
11.7 结束语<br>
第12章 错误处理和一般问题<br>
12.1 编译错误<br>
12.1.1 错误的编译器<br>
12.1.2 无法找到aspectjtools.jar文件<br>
12.1.3 内存溢出错误<br>
12.1.4 错误的JSDK<br>
12.1.5 没有Java编译器<br>
12.2 扩展运行时错误处理<br>
12.2.1 堆栈溢出<br>
12.2.2 连接点不匹配<br>
12.3 异常抛出与捕获<br>
12.4 使用TraceJoinPoints.java<br>
12.5 call指示符与execution指示符的区别<br>
12.5.1 this()和target()的使用<br>
12.5.2 within和withincode的效果<br>
12.6 结束语<br>
第13章 面向aspect例子：模式与重用<br>
13.1 可重用持久性<br>
13.1.1 PersistencePmtocol aspect<br>
13.1.2 通过subaspect应用PersistenceProtocol<br>
13.2 方法缓存<br>
13.3 将模式标记为aspect<br>
13.3.1 往aspect的API中添加无效特性<br>
13.3.2 Observer模式<br>
13.3.3在 AspecU中重用Observer<br>
13.4 面向方面的设计<br>
13.5 结束语<br>
第14章 AspeeO在现实中的应用<br>
14.1 添加特性<br>
14.1.1 初始应用程序<br>
14.1.2 待添加的特性<br>
14.1.3 当前设计<br>
14.1.4 软件的可继承性<br>
14.1.5 编写aspect和源代码<br>
14.1.6 测试<br>
14.1.7 文档<br>
14.1.8 结论<br>
14.2 重构网络结构<br>
14.2.1 logging<br>
14.2.2 计时<br>
14.2.3 检查点<br>
14.3 结束语<br>
附录A AspectJ API<br>
A.1 接口层次关系<br>
A.2 类层次关系<br>
A.3 AspectJ API说明<br>
A.3.1 接口：J0inPoint<br>
A.3.2 接口：J0inPoint.StaticPart<br>
A.3.3 接口：Signature<br>
A.3.4 接口：CatchClauseSignature<br>
A.3.5 接12I：MemberSignature<br>
A.3.6 接口：CodeSignature <br>
A.3.7 接口：AdviceSignature<br>
A.3.8 接口：InitializerSignature<br>
A.3.9 接口：MethodSignature<br>
A.3.10 接口：FieldSignature<br>
A.3.11 接口：SourceLocation<br>
A.3.12 类：SoftException<br>
A.3.13 类：NOAspectBoundException<br>
附录B 有帮助的Web站点<br>
B.1 概述性站点<br>
B.2 人物<br>
B.3 自然教程<br>
B.4 论文<br>
B.5 其他范例<br>
B.6 软件开发和系统<br>
B.7 事件<br>
B.8大学<br>
附录C 其他AoP语言绑定 <br>
C.1 AspectR<br>
C.1.1 说明<br>
C.1.2 要求<br>
C.1.3 例子代码<br>
C.2 AspectS<br>
C.2.1 说明<br>
C.2.2 要求<br>
C.3 Apostle<br>
C.3.1 说明<br>
C.3.2 要求<br>
C.4 AspectC<br>
C.4.1 说明<br>
C.4.2 要求<br>
C.4.3 例子代码<br>
C.5 AspectC++<br>
C.5.1 说明<br>
C.5.2 要求<br>
C.5.3 例子代码<br>
C.6 Pythius<br>
C.6.1 说明<br>
C.6.2 要求<br>
C.6.3 例子代码 <br></div></body></html>