<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>javascript面向对象编程的学习</title></head><body><h1>javascript面向对象编程的学习</h1><div><strong><font size="5">javascript面向对象编程的学习<br>
<br>
</font></strong>&nbsp;&nbsp;&nbsp;  事先说明:<br>
&nbsp;&nbsp;&nbsp;  对面向对象编程,自己不曾系统学习过,之前只是肤浅地了解了一下java,php以及asp的一些类的用法,几乎没有实践过.所以对后面介绍的 javascript面向对象编程文章中,不可避免地出现错误,甚至是低级的错误.希望大家不吝赐教,这也正是个人发布这几篇文章的目的.当然,如果这几 篇文章可以帮助到你,那也是快人心的事情.<br>
<br>
---------------------------------------------------------------------------------<br>
&nbsp;&nbsp;&nbsp;  版权说明:<br>
&nbsp;&nbsp;&nbsp;  这几篇文章是利用&lt;&lt;JavaScript高级程序设计&gt;&gt;(Nicholas C.Zakas著,曹力 张欣 等译)学习过程中总结出来的.<br>
&nbsp;&nbsp;&nbsp;  如果你认为这几篇文章还算有点价值转贴的话.请标名版权说明这段话.<br>
<br>
&nbsp;&nbsp;&nbsp;  作者:草履虫<br>
&nbsp;&nbsp;&nbsp;  email:caolvchong@gmail.com<br>
&nbsp;&nbsp;&nbsp;  原文出自:<a href="http://cceer.xmu.edu.cn/blog/"><font color="#8bb90d">cceer.xmu.edu.cn/blog/</font></a><br>
<br>
&nbsp;&nbsp;&nbsp;  如果你对文章有您的建议或者看法,您的姓名和建议将会出现在版权说明里面<br>
---------------------------------------------------------------------------------<br>
<br>
<font color="#0000ff"><strong>----&gt;什么是类和对象</strong></font><br>
&nbsp;&nbsp;&nbsp;  这是所有面向对象编程之前必须弄明白的.<br>
&nbsp;&nbsp;&nbsp;  所谓类:简单地说就是模板,说的专业一些,是一类具有某种性质的物的集合.比如:人就是一个类,车也是一个类,等等.<br>
&nbsp;&nbsp;&nbsp;  所谓对象:就是类的具体实现.如上面所说,人是一个类,一个具体的人就是一个对象,比如张三.<br>
&nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  对象是类的实例化后的结果.javascript中使用new关键字来实例化一个类,生成一个对象.<br>
&nbsp;&nbsp;&nbsp;  例子:<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function people(){&nbsp;&nbsp;&nbsp;  //javascript中一个function也是一个类,这里我们建立一个空的类people<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var zhangsan=new people;&nbsp;&nbsp;&nbsp;  //实例化生成一个对象张三<br>
<br>
<strong><font color="#0000ff">----&gt;一个具体形象的例子</font></strong><br>
&nbsp;&nbsp;&nbsp;  /*--&gt;最简单的类:<br>
&nbsp;&nbsp;&nbsp;  *people类<br>
&nbsp;&nbsp;&nbsp;  *&nbsp;&nbsp;&nbsp;  属性:性别,年龄,姓名<br>
&nbsp;&nbsp;&nbsp;  *&nbsp;&nbsp;&nbsp;  方法:说话<br>
&nbsp;&nbsp;&nbsp;  */<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function people(name,sex,age){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.name=name;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.sex=sex;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.age=age;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.say=function(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  return &quot;我叫&quot;+this.name;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  使用时:<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var zhangsan=new people;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  alert(zhangsan.say());<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var lisi=new people;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  alert(lizi.say());<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  说明:<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  上面使用了this关键字,this总是指向当前的对象,在上面例子中,zhangsan.say中具有this.name,这里的this是当前的对象zhangsan.后面lisi.say则是指向当前对象lisi<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  对象具有属性,上面的name,sex和age就是对象的属性.我们这样可以访问,如lisi.name,zhangsan.age<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  对象还具有方法,比如上面的say.方法是通过构造函数实现的.使用时,如上面,用lisi.say(),zhangsan.say()<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  当然我们还可以在实例化对象后为对象添加新的属性和方法.比如:<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  zhangsan.girlfriend=&quot;小丽&quot;;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  zhangsan.doing=function(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  return &quot;I am eating&quot;;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
<br>
<font color="#0000ff"><strong>----&gt;javascript类/对象和其他面向对象语言的异同</strong></font><br>
&nbsp;&nbsp;&nbsp;  相同点:面向对象编程的思想都是一样的,世界上所有的具体事物都可以看成对象,而这些事物从属的集合都可以看成类.我们要做的是构造我们需要的类,在实例化成我们需要的对象为我们工作.<br>
&nbsp;&nbsp;&nbsp;  不同点:其他面向对象编程的语言对于类/对象关心下面的事情:<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  1.作用域:公用,私用,受保护,静态.而javascript只有一种作用域:公用作用域.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  2.特性:继承,多态.javascript不支持多态,继承方面的内容将在&quot;javascript对象的继承&quot;一文中介绍<br>
<br>
<font color="#0000ff"><strong>----&gt;构建javascript类/对象的方式</strong></font><br>
&nbsp;&nbsp;&nbsp;  首先,可以大致定义出下面几种类型:<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  1.工厂方式<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  2.构造函数方式<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  3.原型方式<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  4.混合的构造函数/原型方式<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  5.动态原型方法<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  6.混合工厂方式<br>
&nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  具体说明:<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;<strong><font color="#ff0000"> A.工厂方式:</font></strong><br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  所谓工厂方式,是指先建立对象,然后再往对象里面添加属性和方法.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  eg.1<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var zhangsan=new Object;&nbsp;&nbsp;&nbsp;  //创建对象<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  zhangsan.name=&quot;张三&quot;;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  //给对象添加属性<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  zhangsan.say=function(){&nbsp;&nbsp;&nbsp;  //给对象增加方法<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  alert(&quot;我叫张三&quot;);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  eg.2 上面的例子没有封装性,我们可以使用函数封装,实现多重利用<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function people(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var p_object=new Object;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  p_object.name=&quot;张三&quot;;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  p_object.say=function(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  alert(&quot;我叫张三&quot;);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  return p_object;&nbsp;&nbsp;&nbsp;  //返回对象<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var zhangsan=people;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var lisi=people;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  上面zhangsan和lisi两个对象具有完全相同的属性和方法,都叫&quot;张三&quot;(name属性),都会说&quot;我叫张三&quot;(say()方法)<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  eg.3 通过传递参数改进eg.2<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function people(name){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var p_object=new Object;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  p_object.name=name;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  p_object.say=function(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  alert(&quot;我叫&quot;+this.name);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  return p_object;&nbsp;&nbsp;&nbsp;  //返回对象<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var zhangsan=people(&quot;张三&quot;);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var lisi=people(&quot;李四&quot;);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  总结:<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  工厂方式,总是先创建一个对象,再往对象中添加你需要的属性和方法.但这种做法对于封装性和多种利用性不是很有利,这导致了这种对象的构造方法不被提倡.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  使用工厂方式总是为每个对象创建独立的函数版本.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  这类方式使用封装然后调用新对象的时候不使用new创建对象.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <font color="#ff0000"><strong>B.构造函数方式:</strong></font><br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  所谓构造函数方式,就像我给出的例子&quot;一个具体形象的例子&quot;,就是采用构造函数的方式.它和工厂方式的区别是不再在函数内部创建一个对象.而是通过this关键字指向当前对象.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  构造函数的例子不再给出.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  构造函数和工厂方式一样,会重复生成函数,为每个版本的对象创建独立的函数版本.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <font color="#ff0000"><strong>C.原型方式</strong></font><br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  所谓原型方式,就是利用prototype属性来实现属性和方法的继承<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  eg.1<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function people(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  people.prototype.name=&quot;张三&quot;;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  people.prototype.say=function(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  alert(&quot;我叫&quot;+this.name);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  };<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var zhangsan=new people();<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var lisi=new people();<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  原型方式不能通过构造函数传递参数初始化属性的值,因为所有的属性和方法都是通过prototype添加的<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <font color="#ff0000"><strong>D.混合的构造函数/原型方式</strong></font><br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  对于对象的属性,使用构造函数的方式<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  对于对象的方法,使用原型方式<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  eg.1<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function people(name){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.name=name;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  people.prototype.say=function(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  return &quot;我的名字叫&quot;+this.name;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  };<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var zhangsan=new people(&quot;张三&quot;);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  document.write(zhangsan.say());<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  eg.2 我们也可以把prototype写入类,实现视觉上的封装.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function people(name){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.name=name;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  people.prototype.say=function(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  return &quot;我的名字叫&quot;+this.name;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  };<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var zhangsan=new people(&quot;张三&quot;);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  document.write(zhangsan.say());<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  总结:这种构造类/对象的方法是推荐使用的<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;<strong><font color="#ff0000"> E.动态原型方式</font></strong><br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  这是在混合的构造函数/原型方式上改进的一种方式(提供更友好的编码风格),他们功能是等价的<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  eg.1<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function people(name){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.name=name;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  if(typeof people._initialized==&quot;undefined&quot;){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  people.prototype.say=function(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  return &quot;我的名字叫&quot;+this.name;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  };<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  people._initialized=true;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var zhangsan=new people(&quot;张三&quot;);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  document.write(zhangsan.say());<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var lisi=new people(&quot;李四&quot;);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  document.write(lisi.say());<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  这样处理的目的是创建对象的方法后下一次使用时不要再创建.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  由于上面的原因,动态原型方式也是javascript中常用的一种创建类/对象的一种方式<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;<font color="#ff0000"><strong> F.混合工厂方式</strong></font><br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  混合工厂方式几乎和工厂方式是一样的.它同样是先构造对象,然后再往对象中添加属性和方法.不同的是,混合工厂方式生成对象时依旧使用new关键字.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  eg.1<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function people(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var p_object=new Object;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  p_object.name=&quot;张三&quot;;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  p_object.say=function(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  alert(&quot;我叫张三&quot;);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  return p_object;&nbsp;&nbsp;&nbsp;  //返回对象<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var zhangsan=new people;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var lisi=new people;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  zhangsan.say();<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  lisi.say();<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  混合工厂方式和工厂方式以及经典方式(构造函数,原型方式)一样会产生问题,不推荐使用<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  对各种构建类/对象方式的总结:<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  通常地,我们使用混合的构造函数/原型方式,即属性使用构造函数方式,方法采用原型方式.当然,加强地,我们可以使用动态原型方式.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  上面两种方式是推荐使用的.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
<font color="#0000ff"><strong>----&gt;关于prototype的其他功能</strong></font><br>
&nbsp;&nbsp;&nbsp;  1.给对象(包括本地对象)添加新的方法<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  比如Array对象,你可能需要添加一个方法toHexString,你可以这样做:<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  Array.prototype.toHexString=function(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  //code here<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  2.重定义方法<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  实质是让方法指向一个新的函数<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  Array.prototype.toHexString=function(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  //other code href<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
---------------------------------------------------------------------------------<br>
<br>
&nbsp;&nbsp;&nbsp;  继承,通俗地说,之前你写过一些类,这些类中有一些是而你现在要写的类的功能的子集或者基本相同,那么你不用完全重新写一个新的类,你可以把之前写的类拿过来使用.这样的一种代码重用过程就叫做继承.<br>
&nbsp;&nbsp;&nbsp;  深入学习javascript继承之前,先了解下面的几个概念:<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  父类:被继承的类<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  子类:由继承得来的类<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  超类:也就是父类<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  抽象类:一般不用来实例化的类,它的用途是用来给其他类继承.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  基类:提供给其他类可以继承的类<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  派生类:由基类继承而来的类<br>
<br>
&nbsp;&nbsp;&nbsp;  javascript对象继承通常有下面的5种方式:<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  1.对象冒充<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  2.call()方式<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  3.apply()方式<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  4.原型链<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  5.混合方式<br>
&nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;<font color="#ff0000"><strong> A.对象冒充</strong></font><br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  所谓对象冒充,就是新的类冒充旧的类(旧的类必须采用构造函数方式),从而达到继承目的.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  eg.1<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function people(name,sex,age){&nbsp;&nbsp;&nbsp;  //使用构造函数方式<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.name=name;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.sex=sex;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.age=age;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.say=function(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  alert(&quot;My name is &quot;+this.name);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  };<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.doing=function(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  alert(&quot;I am speaking&quot;);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  };<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var Marry=new people(&quot;Marry&quot;,&quot;Woman&quot;,&quot;23&quot;);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  Marry.say();<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  Marry.doing();<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function white_people(name,sex,age){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.inherit=people;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.inherit(name,sex,age);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  delete this.inherit;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.area=function(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  alert(&quot;I am in Europe&quot;);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var Tom=new white_people(&quot;Tom&quot;,&quot;man&quot;,&quot;21&quot;);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  Tom.say();<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  Tom.area();<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  alert(Tom.age);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  上面的例子中,people是用来做white_people的基类,记住这个格式是用来对象冒充达到继承目的的<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.inherit=people;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  //冒充<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.inherit(name,sex,age);&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  //继承<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  delete this.inherit;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  //删除继承<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  所有新属性和新方法都必须再删除了继承后定义,这样是为了避免覆盖父类的相关属性和方法.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  另外,对象冒充支持多继承.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  eg.2<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function worker(pay,work){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.pay=pay;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.work=work;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function city_worker(name,sex,age,pay,work){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.inherit=people;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.inherit(name,sex,age);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  delete this.inherit;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.inherit=worker;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.inherit(pay,work);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  delete this.inherit;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var Jerry=new city_worker(&quot;Jerry&quot;,&quot;man&quot;,&quot;21&quot;,&quot;$1000&quot;,&quot;coder&quot;);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  Jerry.say();<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  alert(Jerry.work);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  对象冒充有一个不足的地方:多继承机制实现时,如果基类存在相同的属性或者方法,将从后面的类继承.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  <font color="#ff0000"><strong>B.call()方式</strong></font><br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  只是封装的对象冒充的一个函数.这样,我们不再需要写&quot;经典&quot;的三句话,而是用下面这句话代替:<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  基类.call(对象,参数列表)<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  eg.1<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function farmer(name,sex,age,pay,work){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  people.call(this,name,sex,age);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  worker.call(this,pay,work);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var Nicholas=new farmer(&quot;Nicholas&quot;,&quot;man&quot;,&quot;27&quot;,&quot;$3000&quot;,&quot;irrigator&quot;);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  Nicholas.say();<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  alert(Nicholas.pay);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  同样,call()存在同名属性和方法的小问题.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  <font color="#ff0000"><strong>C.apply()方式</strong></font><br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  和call()一样.apply()也是对象冒充的一个封装函数.其格式为:<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  基类.apply(对象,参数数组);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  eg.1<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function white_collar(name,sex,age,pay,work){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  people.apply(this,new Array(name,sex,age));<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  worker.apply(this,[pay,work]);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var Jiessie=new white_collar(&quot;Jiessie&quot;,&quot;woman&quot;,&quot;26&quot;,&quot;$2500&quot;,&quot;editor&quot;);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  Jiessie.say();<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  alert(Jiessie.work);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  同样,apply()存在同名属性和方法的小问题.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  <font color="#ff0000"><strong>D.原型链</strong></font><br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  上面三种方式都是采用构造函数方式的继承,对应地,也具有原型函数方式的继承:原型链.<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  eg.1<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function blue_collar(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  blue_collar.prototype.name=&quot;Jean&quot;;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  blue_collar.prototype.age=&quot;33&quot;;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  blue_collar.prototype.say=function(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  alert(&quot;my name is &quot;+ this.name);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  };<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function city_blue_collar(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  city_blue_collar.prototype=new blue_collar();<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var jj=new city_blue_collar;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  jj.say();<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  原型链也具有了原型链的缺点:不能传递参数.另外,原型链不支持多继承,因为<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  <font color="#ff0000"><strong>E.混合方式</strong></font><br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  使用构造函数方式来写类的属性,对属性的继承采用call()或者apply()<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  使用原型方式来写的方法,对方法的继承采用原型链<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  eg.1<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function beauty(name,age){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.name=name;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.age=age;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  beauty.prototype.say=function(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  alert(&quot;小女叫&quot;+this.name);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  };<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  function china_beauty(name,age,area){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  beauty.call(this,name,age);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  this.area=area;<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  china_beauty.prototype=new beauty();<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  china_beauty.prototype.from=function(){<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  alert(&quot;我来自&quot;+this.area);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  };<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  var diaochan=new china_beauty(&quot;貂禅&quot;,&quot;16&quot;,&quot;临洮&quot;);<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  diaochan.say();<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  diaochan.from();<br>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  alert(diaochan.age);<br>
-----------------------------------------------------------<br>
&nbsp;&nbsp;&nbsp;  1.如何创建类/对象<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  使用&quot;混合构造函数/原型方式&quot;<br>
&nbsp;&nbsp;&nbsp;  2.怎么继承<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对应创建,采用&quot;混合方式&quot;进行继承<br>
&nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  采用之前写的一个例子.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  function beauty(name,age){&nbsp;&nbsp;&nbsp;  //基类:美女,这里采用构造函数方式,接收参数,设置类的属性<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  this.name=name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  //美女的名字<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  this.age=age;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  //美女的年龄<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  beauty.prototype.say=function(){&nbsp;&nbsp;&nbsp;  //基类:为美女添加方法,采用原型方式<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  alert(&quot;小女叫&quot;+this.name);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  };<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  function china_beauty(name,age,area){&nbsp;&nbsp;&nbsp;  //派生类:中国美女<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  beauty.call(this,name,age);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  //继承美女的属性<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  this.area=area;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  //添加自己的属性:来源地<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  china_beauty.prototype=new beauty();&nbsp;&nbsp;&nbsp;  //继承美女的方法<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  china_beauty.prototype.from=function(){&nbsp;&nbsp;&nbsp;  //添加自己的方法:介绍来源地<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  alert(&quot;我来自&quot;+this.area);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  };<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  var diaochan=new china_beauty(&quot;貂禅&quot;,&quot;16&quot;,&quot;临洮&quot;);&nbsp;&nbsp;&nbsp;  //创建中国美女对象&quot;貂禅&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  diaochan.say();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  //使用继承自美女类的方法say<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  diaochan.from();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  //使用自己的方法from<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  alert(diaochan.age);&nbsp;&nbsp;&nbsp;  //使用继承自美女的属性age</div></body></html>