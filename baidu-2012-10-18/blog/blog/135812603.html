<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>3.2.9. 具有多个角色的组件（角色，安全） -seam满江红 -good</title></head><body><h1>3.2.9. 具有多个角色的组件（角色，安全） -seam满江红 -good</h1><div><div>
<p> </p>
<div class="titlepage">
<div>
<div>
<h3 class="title">3.2.9. 具有多个角色的组件（角色，安全） -seam满江红 -good</h3>
<h3 class="title">3.2.9. 具有多个角色的组件（Components with multiple roles）</h3>
</div>
</div>
<div> </div>
</div>
<p>有些Seam组件类可以在系统中具有多个角色。例如，我们经常有一个 <tt class="literal"><font face="新宋体">User</font></tt> 类用作Session-Scoped组件，代表当前用户，同时它又在用户管理界面中被用作Conversation-Scoped组件。<tt class="literal"><font face="新宋体">@Role</font></tt> 注解让我们可以定义组件在另一个范围中的额外角色名 &mdash;&mdash; 这可以让我们把相同的组件类绑定成不同的上下文变量。（任何Seam组件 <span class="emphasis"><em>实例</em></span> 都可以被绑定到多个上下文变量，但@Role使得我们也可以在类的级别做到这一点，从而享受自动实例化的优点。）</p>
<pre class="programlisting">@Name(&quot;user&quot;)
@Entity
@Scope(CONVERSATION)
@Role(name=&quot;currentUser&quot;, scope=SESSION)
public class User {
    ...
}</pre>
<p><tt class="literal"><font face="新宋体">@Roles</font></tt> 注解可以让我们为组件指定任意多的附加角色。</p>
<pre class="programlisting">@Name(&quot;user&quot;)
@Entity
@Scope(CONVERSATION)
@Roles({@Role(name=&quot;currentUser&quot;, scope=SESSION),
        @Role(name=&quot;tempUser&quot;, scope=EVENT)})
public class User {
    ...
}</pre>
<p>=============================================</p>
<h2 style="clear: both" class="title">27.1. 用于定义组件的注解</h2>
<dt><span class="term"><tt class="literal"><font face="新宋体">@Role</font></tt> </span></dt><dd>
<pre class="programlisting">@Role(name=&quot;roleName&quot;, scope=ScopeType.SESSION)</pre>
<p>允许一个Seam组件绑定多个上下文变量。 <tt class="literal"><font face="新宋体">@Name</font></tt>/<tt class="literal"><font face="新宋体">@Scope</font></tt> 注解定义一个&ldquo;默认角色&rdquo;。每一个 <tt class="literal"><font face="新宋体">@Role</font></tt> 注解定一个附加角色。</p>
<div class="itemizedlist">
<ul type="disc">
    <li>
    <p><tt class="literal"><font face="新宋体">name</font></tt> &mdash; 上下文变量的名字。</p>
    </li>
    <li>
    <p><tt class="literal"><font face="新宋体">scope</font></tt> &mdash; 上下文变量的作用域。当没有显式定义作用域时，和上面一样默认取决于组件类型。</p>
    </li>
</ul>
</div>
</dd><dt><a name="roles-annotation"></a><span class="term"><tt class="literal"><font face="新宋体">@Roles</font></tt> </span></dt><dd>
<pre class="programlisting">@Roles({
        @Role(name=&quot;user&quot;, scope=ScopeType.CONVERSATION),
        @Role(name=&quot;currentUser&quot;, scope=ScopeType.SESSION)
    })</pre>
<p>允许指定多个额外角色。</p>
<p>==============================</p>
<div class="titlepage">
<div>
<div>
<h2 style="clear: both" class="title">28.6. 与安全相关的组件</h2>
</div>
</div>
<div> </div>
</div>
<p>这些组件都与Web层安全有关。</p>
<div class="variablelist"><dl><dt><span class="term"><tt class="literal"><font face="新宋体">org.jboss.seam.web.userPrincipal</font></tt> </span></dt><dd>
<p>当前用户(本人)<tt class="literal"><font face="新宋体">Principal</font></tt>的管理组件。</p>
</dd><dt><span class="term"><tt class="literal"><font face="新宋体">org.jboss.seam.web.isUserInRole</font></tt> </span></dt><dd>
<p>使JSF页面可以根据当前用户拥有的角色来选择渲染某一控制。 <tt class="literal"><font face="新宋体">&lt;h:commandButton value=&quot;edit&quot; rendered=&quot;#{isUserInRole['admin']}&quot;/&gt;</font></tt>。</p>
</dd></dl></div>
<p>=====================================</p>
<p><a target="_blank" href="http://hi.baidu.com/hxzon/blog/item/4a613fdb4847446ed1164e09.html"><font size="3">Chapter 13. 安全 -<font color="#c60a00">seam满江红</font></font></a><a href="http://hi.baidu.com/hxzon/blog/item/4a613fdb4847446ed1164e09.html">http://hi.baidu.com/hxzon/blog/item/4a613fdb4847446ed1164e09.html</a></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<div class="sect1">
<div class="titlepage">
<div>
<div>
<h2 style="clear: both" class="title">13.4. 验证</h2>
</div>
</div>
<div> </div>
</div>
<p>Seam Security提供的验证特性建立在JAAS（Java Authentication和Authorization Service）之上，给处理用户验证提供稳健的、非常容易配置的API。 然而，对于并不复杂的验证需求，Seam提供了一种更加简化的验证方法，隐藏了JAAS的复杂性。</p>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="d0e7183"></a>13.4.1. 配置</h3>
</div>
</div>
<div> </div>
</div>
<p>简化的验证方法使用一种内置的JAAS登录模块：<tt class="literal"><font face="新宋体">SeamLoginModule</font></tt>，把验证委托给你项目中的一个Seam组件。 这个登录模块已经在Seam内部配置为默认的应用策略的一部分，因此不需要任何额外的配置文件。它允许你利用你自己的应用程序提供的实体类编写验证方法。 配置这个简化的验证形式需要在 <tt class="literal"><font face="新宋体">components.xml</font></tt> 中配置 <tt class="literal"><font face="新宋体">identity</font></tt> 组件。</p>
<pre class="programlisting">&lt;components xmlns=&quot;http://jboss.com/products/seam/components&quot;
            xmlns:core=&quot;http://jboss.com/products/seam/core&quot;
            xmlns:security=&quot;http://jboss.com/products/seam/security&quot;
            xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            xsi:schemaLocation=
                &quot;http://jboss.com/products/seam/components http://jboss.com/products/seam/components-2.0.xsd
                 http://jboss.com/products/seam/security http://jboss.com/products/seam/security-2.0.xsd&quot;&gt;

    &lt;security:identity authenticate-method=&quot;#{authenticator.authenticate}&quot;/&gt;

&lt;/components&gt;</pre>
<p>如果你希望使用高级的安全性特性，如基于规则的许可检查，你所要做的就是把Drools（JBoss Rules）jars包含在你的classpath中，并添加一些额外的配置，后面会讲到。</p>
<p>EL表达式 <tt class="literal"><font face="新宋体">#{authenticator.authenticate}</font></tt> 是一种方法绑定，表示 <tt class="literal"><font face="新宋体">authenticator</font></tt> 组件的 <tt class="literal"><font face="新宋体">authenticate</font></tt> 方法将用来验证该用户。</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="d0e7212"></a>13.4.2. 编写验证方法</h3>
</div>
</div>
<div> </div>
</div>
<p>在 <tt class="literal"><font face="新宋体">components.xml</font></tt> 中给 <tt class="literal"><font face="新宋体">identity</font></tt> 指定的 <tt class="literal"><font face="新宋体">authenticate-method</font></tt> 属性，规定了哪种方法将被SeamLoginModule用来验证用户。 这个方法没有参数，并将要返回一个布尔值，表示验证是否成功。用户的用户名和密码可以分别地通过 <tt class="literal"><font face="新宋体">Identity.instance().getUsername()</font></tt> 和 <tt class="literal"><font face="新宋体">Identity.instance().getPassword()</font></tt> 获取，用户所属的任何角色都应该利用 <tt class="literal"><font face="新宋体">Identity.instance().addRole()</font></tt> 分配。 下面是JavaBean组件内部一个验证方法的完整实例：</p>
<pre class="programlisting">@Name(&quot;authenticator&quot;)
public class Authenticator {
   @In EntityManager entityManager;

   public boolean authenticate() {
      try
      {
         User user = (User) entityManager.createQuery(
            &quot;from User where username = :username and password = :password&quot;)
            .setParameter(&quot;username&quot;, Identity.instance().getUsername())
            .setParameter(&quot;password&quot;, Identity.instance().getPassword())
            .getSingleResult();

         if (user.getRoles() != null)
         {
            for (UserRole mr : user.getRoles())
               Identity.instance().addRole(mr.getName());
         }

         return true;
      }
      catch (NoResultException ex)
      {
         return false;
      }

   }

}</pre>
<p>在上面的例子中，<tt class="literal"><font face="新宋体">User</font></tt> 和 <tt class="literal"><font face="新宋体">UserRole</font></tt> 都是应用程序指定的实体Bean。 <tt class="literal"><font face="新宋体">roles</font></tt> 参数以用户所属的角色填充，它应该添加到 <tt class="literal"><font face="新宋体">Set</font></tt> 作为文字型字符串值，如&ldquo;admin&rdquo;、&ldquo;user&rdquo;。 在这个例子中，如果没有找到用户记录，并抛出一个 <tt class="literal"><font face="新宋体">NoResultException</font></tt>，验证方法就返回false，表示验证失败。</p>
<div class="sect3">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="d0e7254"></a>13.4.2.1. Identity.addRole()</h4>
</div>
</div>
<div> </div>
</div>
<p><tt class="literal"><font face="新宋体">Identity.addRole()</font></tt> 方法表现的不同取决于当前会话是否已经验证过了。 如果会话没有验证过，那么 <tt class="literal"><font face="新宋体">addRole()</font></tt> 就 <span class="emphasis"><em>只能</em></span> 在验证的过程中被调用。 当被调用到这里时，角色名称被放进一个预验证角色的临时列表中。 一当验证成功，预验证角色就变成&ldquo;真实的&rdquo;角色了，并且调用 <tt class="literal"><font face="新宋体">Identity.hasRole()</font></tt> 就可以返回true了。 下面的序列图展示了预验证角色列表作为第一类对象，以更清楚地表明它如何适应在整个验证过程。</p>
<div class="mediaobject" align="center"><img align="middle" src="http://www.redsaga.com/opendoc/Seam2.0/html/images/security-addrole.png"></div>
</div>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="d0e7276"></a>13.4.3. 编写登录表单</h3>
</div>
</div>
<div> </div>
</div>
<p><tt class="literal"><font face="新宋体">Identity</font></tt> 组件提供 <tt class="literal"><font face="新宋体">username</font></tt> 和 <tt class="literal"><font face="新宋体">password</font></tt> 属性，适合最常见的验证场景。 这些属性可以直接绑定到登录表单上的用户名和密码字段。一旦设置了这些属性，调用 <tt class="literal"><font face="新宋体">identity.login()</font></tt> 方法就可以验证使用所提供的证书的用户。 下面是一个简单的登录表单的例子：</p>
<pre class="programlisting">&lt;div&gt;
    &lt;h:outputLabel for=&quot;name&quot; value=&quot;Username&quot;/&gt;
    &lt;h:inputText id=&quot;name&quot; value=&quot;#{identity.username}&quot;/&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;h:outputLabel for=&quot;password&quot; value=&quot;Password&quot;/&gt;
    &lt;h:inputSecret id=&quot;password&quot; value=&quot;#{identity.password}&quot;/&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;h:commandButton value=&quot;Login&quot; action=&quot;#{identity.login}&quot;/&gt;
&lt;/div&gt;</pre>
<p>类似地，注销用户通过调用 <tt class="literal"><font face="新宋体">#{identity.logout}</font></tt> 来完成。调用这个动作将清除当前被验证用户的安全性状态。</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="d0e7300"></a>13.4.4. 简化配置 - 概述</h3>
</div>
</div>
<div> </div>
</div>
<p>因此归结起来，配置验证有三个简单的步骤：</p>
<div class="itemizedlist">
<ul type="disc">
    <li>
    <p>在 <tt class="literal"><font face="新宋体">components.xml</font></tt> 中配置一种验证方法。</p>
    </li>
    <li>
    <p>编写一种验证方法。</p>
    </li>
    <li>
    <p>编写一个登录表单，以便用户可以验证。</p>
    </li>
</ul>
</div>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="d0e7318"></a>13.4.5. 处理安全异常</h3>
</div>
</div>
<div> </div>
</div>
<p>为了防止用户随安全错误而收到默认的错误页面，建议 <tt class="literal"><font face="新宋体">pages.xml</font></tt> 配置为把安全错误重定向到一个更&ldquo;漂亮&rdquo;的页面。由Security API抛出的两种主要的异常类型是：</p>
<div class="itemizedlist">
<ul type="disc">
    <li>
    <p><tt class="literal"><font face="新宋体">NotLoggedInException</font></tt> - 如果用户试图在没有登录的情况下访问一个受限的动作或者页面，就会抛出这个异常。</p>
    </li>
    <li>
    <p><tt class="literal"><font face="新宋体">AuthorizationException</font></tt> - 只有当用户已经登录，并且试图访问他们没有必要权限的受限动作或者页面时，才会抛出这个异常。</p>
    </li>
</ul>
</div>
<p>在 <tt class="literal"><font face="新宋体">NotLoggedInException</font></tt> 抛出的情况下，建议把用户限制到一个登录页面或者注册页面，以便登录。 对于 <tt class="literal"><font face="新宋体">AuthorizationException</font></tt>，把用户重定向到一个错误页面可能更合适。 以下是 <tt class="literal"><font face="新宋体">pages.xml</font></tt> 文件的一个例子，它把这两种安全异常都处理了：</p>
<pre class="programlisting">&lt;pages&gt;

    ...

    &lt;exception class=&quot;org.jboss.seam.security.NotLoggedInException&quot;&gt;
        &lt;redirect view-id=&quot;/login.xhtml&quot;&gt;
            &lt;message&gt;You must be logged in to perform this action 你必须登录执行这个动作&lt;/message&gt;
        &lt;/redirect&gt;
    &lt;/exception&gt;

    &lt;exception class=&quot;org.jboss.seam.security.AuthorizationException&quot;&gt;
        &lt;end-conversation/&gt;
        &lt;redirect view-id=&quot;/security_error.xhtml&quot;&gt;
            &lt;message&gt;You do not have the necessary security privileges to perform this action.你没有执行这个动作的必要权限。&lt;/message&gt;
        &lt;/redirect&gt;
    &lt;/exception&gt;

&lt;/pages&gt;</pre>
<p>大多数Web应用程序需要更复杂的登录重定向处理，因此Seam包含了处理这个问题的一些特殊功能。</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="d0e7354"></a>13.4.6. 登录重定向</h3>
</div>
</div>
<div> </div>
</div>
<p>当未被验证的用户试图访问某个特定的视图（或者通配符id）时，可以让Seam把用户重定向到一个登录页面：</p>
<pre class="programlisting">&lt;pages login-view-id=&quot;/login.xhtml&quot;&gt;

    &lt;page view-id=&quot;/members/*&quot; login-required=&quot;true&quot;/&gt;

    ...

&lt;/pages&gt;</pre>
<p>（这个不像上述的异常处理器那么简洁，但是可能要结合起来使用。）</p>
<p>用户登录以后，我们要自动返回到原来的地方（网址），以便可以重试要求登录之后才能进行的操作。 如果把下列事件监听器添加到 <tt class="literal"><font face="新宋体">components.xml</font></tt>，如果用户在没有登录的情况下去访问受限的页面，那么页面信息就会被记录下来。 用户登录之后，就会被重定向到刚才的受限页面，并且把原来的请求参数也一起传过去。</p>
<pre class="programlisting">&lt;event type=&quot;org.jboss.seam.notLoggedIn&quot;&gt;
    &lt;action execute=&quot;#{redirect.captureCurrentView}&quot;/&gt;
&lt;/event&gt;

&lt;event type=&quot;org.jboss.seam.postAuthenticate&quot;&gt;
    &lt;action execute=&quot;#{redirect.returnToCapturedView}&quot;/&gt;
&lt;/event&gt;</pre>
<p>注意登录重定向被实现为一种对话范围的机制，因此不要在 <tt class="literal"><font face="新宋体">authenticate()</font></tt> 方法中终止对话。</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="d0e7375"></a>13.4.7. HTTP验证</h3>
</div>
</div>
<div> </div>
</div>
<p>虽然不建议使用，除非绝对必要，Seam提供HTTP Basic或HTTP Digest（RFC 2617 ）方法的验证。 为使用表单的验证方式，<tt class="literal"><font face="新宋体">authentication-filter</font></tt> 组件必须能够在components.xml中激活：</p>
<pre class="programlisting">&lt;web:authentication-filter url-pattern=&quot;*.seam&quot; auth-type=&quot;basic&quot;/&gt;</pre>
<p>为了激活Basic验证的过滤器，设置 <tt class="literal"><font face="新宋体">auth-type</font></tt> 为 <tt class="literal"><font face="新宋体">basic</font></tt> 或者对于Digest验证 ，设置 <tt class="literal"><font face="新宋体">auth-type</font></tt> 为 <tt class="literal"><font face="新宋体">digest</font></tt>。 如果是使用Digest验证，<tt class="literal"><font face="新宋体">key</font></tt> 和 <tt class="literal"><font face="新宋体">realm</font></tt> 也必须进行设置：</p>
<pre class="programlisting">&lt;web:authentication-filter url-pattern=&quot;*.seam&quot; auth-type=&quot;digest&quot; key=&quot;AA3JK34aSDlkj&quot; realm=&quot;My App&quot;/&gt;</pre>
<p><tt class="literal"><font face="新宋体">key</font></tt> 可以是任何字符串值。 <tt class="literal"><font face="新宋体">realm</font></tt> 就是进行用户验证时所用的验证Realm的名称。</p>
<div class="sect3">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="d0e7415"></a>13.4.7.1. 编写Digest验证者</h4>
</div>
</div>
<div> </div>
</div>
<p>如果是使用Digest认证，你的鉴定者类需要继承抽象类 <tt class="literal"><font face="新宋体">org.jboss.seam.security.digest.digestauthenticator </font></tt>，并使用 <tt class="literal"><font face="新宋体">validatePassword()</font></tt> 方法，以根据Digest的要求来验证用户的纯文本密码。下面是一个例子：</p>
<pre class="programlisting">public boolean authenticate()
   {
      try
      {
         User user = (User) entityManager.createQuery(
            &quot;from User where username = :username&quot;)
            .setParameter(&quot;username&quot;, identity.getUsername())
            .getSingleResult();

         return validatePassword(user.getPassword());
      }
      catch (NoResultException ex)
      {
         return false;
      }
   }</pre>
</div>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="d0e7428"></a>13.4.8. 高级验证特性</h3>
</div>
</div>
<div> </div>
</div>
<p>本节探讨Security API提供的部分高级特性，用来满足更复杂的安全需求。</p>
<div class="sect3">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="d0e7433"></a>13.4.8.1. 使用容器的JAAS配置</h4>
</div>
</div>
<div> </div>
</div>
<p>如果你宁可不用Seam Security API提供的简化的JAAS配置，可以委托给默认的系统JAAS配置，该配置是在 <tt class="literal"><font face="新宋体">components.xml</font></tt> 中提供的一个 <tt class="literal"><font face="新宋体">jaasConfigName</font></tt>。 例如，如果你正在使用JBoss AS，并希望使用 <tt class="literal"><font face="新宋体">其它</font></tt> 策略（使用JBoss AS提供的 <tt class="literal"><font face="新宋体">UsersRolesLoginModule</font></tt> 登录模块），那么 <tt class="literal"><font face="新宋体">components.xml</font></tt> 中的项看起来就像这样：</p>
<pre class="programlisting">&lt;security:identity authenticate-method=&quot;#{authenticator.authenticate}&quot;
                      jaas-config-name=&quot;other&quot;/&gt;</pre>
</div>
</div>
</div>
<div class="sect1">
<div class="titlepage">
<div>
<div>
<h2 style="clear: both" class="title"><a name="d0e7455"></a>13.5. 错误消息</h2>
</div>
</div>
<div> </div>
</div>
<p>Security API给各种安全相关的事件生成许多默认的展现消息。下表列出了可以用来覆盖这些消息的Key，它们在 <tt class="literal"><font face="新宋体">message.properties</font></tt> 资源文件中指定。为了禁止消息，只要在资源文件里给相应的Key赋予空值就行了。</p>
<div class="table"><a name="d0e7463"></a>
<p class="title"><strong>Table 13.1. 安全消息Key</strong></p>
<table border="1" summary="安全消息Key">
    <colgroup><col></col><col></col></colgroup>
    <tbody>
        <tr>
            <td>
            <p><tt class="literal"><font face="新宋体">org.jboss.seam.loginSuccessful</font></tt></p>
            </td>
            <td>
            <p>这个消息在用户通过Security API成功登录时生成。</p>
            </td>
        </tr>
        <tr>
            <td>
            <p><tt class="literal"><font face="新宋体">org.jboss.seam.loginFailed</font></tt></p>
            </td>
            <td>
            <p>这个消息在登录过程失败时生成。失败是由于用户提供了错误的用户名或者密码，或者由于其他问题造成的。</p>
            </td>
        </tr>
        <tr>
            <td>
            <p><tt class="literal"><font face="新宋体">org.jboss.seam.NotLoggedIn</font></tt></p>
            </td>
            <td>
            <p>这个消息在用户试图执行一个动作，或者访问一个需要安全检查的页面，并且用户目前未被验证时生成。</p>
            </td>
        </tr>
    </tbody>
</table>
</div>
</div>
<div class="sect1">
<div class="titlepage">
<div>
<div>
<h2 style="clear: both" class="title"><a name="d0e7500"></a>13.6. 授权</h2>
</div>
</div>
</div>
</div>
</dd></div></div></body></html>