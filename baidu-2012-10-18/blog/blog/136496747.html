<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>seam对话( conversation )概述</title></head><body><h1>seam对话( conversation )概述</h1><div><div class="blog_title">
<h3 class="type_original" title="原创"><a href="http://yourenyouyu2008.javaeye.com/blog/248531"><font size="3">seam对话( conversation )概述</font></a></h3>
</div>
<div class="blog_content">
<p><font size="3">对seam的研究使用已经有很长一段时间了，整体感觉是相当的不错，虽说中间也碰到了各种各样、大大小小的问题，但最终也都能一一解决了，逐渐对它的信心越来越坚定了。</font></p>
<p><font size="3">对话是seam的一个亮点，seam很多内置组件也是利用了对话的特性，比如message,持久化，重定向等等很多都是利用对话来实现的。下面来说说我们项目中使用对话的一些概况。</font></p>
<p><font size="3">1）列表翻页后编辑后再返回当前页</font></p>
<p><font size="3">2）类似多窗口的工作区切换，和1）相似就是任何时候进入指定页面都能保留最后一次在该页面操作的条件（描述的不太好）</font></p>
<p><font size="3">这些功能不用seam对话也可是做的，想必大家也为此做过不少工作，应该说是相当麻烦的，并且每个查询条件都要特定来写。而使用了对话那就是非常的简单了，跟具体的列表没有关系。</font></p>
<p> </p>
<p><font size="3">大家也都知道对话是seam的一大特色，但对它强大的功能表示怀疑，对它的第一怀疑就是性能问题，而性能是web系统的最大忌讳，所以就将信将疑地浮云掠过。主要还是对对话这种方式不太习惯，因为这是seam特有的机制，基于session和request之间，还要就是对话的原理还是比较复杂的，需要慢慢的来理解深入。</font></p>
<p> </p>
<p><font size="3">对话的基本原理：对话范围的对象按照&ldquo;对话id+变量名称&rdquo;来存储在session中，每个jsf请求的第一阶段都会去恢复当前对话及它的父对话，这样中间的阶段就可以使用前一个request中的对话范围的对象，在请求的第6阶段回去保存当前长久对话，并且结束所有超时的长对话。</font></p>
<p><font size="3"><strong>对话最关键的就是要明确的开始和结束</strong>，如果不明确的开始对话，那就与普通的request没有什么区别；还要明确的来结束对话，当然你也可以不结束对话而是让他自然超时，但是这样明显会带来性能问题。</font></p>
<p><font size="3">seam提供了多种开始结束（嵌套算是子对话的开始）的方式</font></p>
<p><font size="3">1）第一阶段，通过s:link s:button标签来开始、嵌套、结束对话,他们的本质就是通过在url中传递cid或对话传播类型来使用、结束、开始对话等</font></p>
<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><font size="3"><strong><span>没有</span></strong><strong><span>propagation</span></strong><strong><span>：当前</span></strong><strong><span>cid</span></strong></font></p>
<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><font size="3"><strong><span>propagation=&quot;none&quot; </span></strong><strong><span>传播类型和</span></strong><strong><span>cid</span></strong><strong><span>都没有</span></strong></font></p>
<p style="margin: 0cm 0cm 0pt" class="MsoNormal"> </p>
<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><strong><font size="3"><strong><span>propagation=&quot;end&quot;</span></strong><strong><span>：</span></strong><strong><em><span style="color: rgb(0,0,0)"><span style="font-size: small"><span>Propagation=end&amp;amp;cid=25</span></span></span></em></strong></font></strong></p>
<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><strong><font size="3"><strong><span>propagation=&quot;begin&quot;</span></strong><strong><span>：</span></strong><strong><em><span style="color: rgb(255,0,0)"><span style="font-size: small"><span>pagation=begin'</span></span></span></em></strong></font></strong></p>
<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><strong><font size="3"><strong><span>propagation=&quot;nest&quot;</span></strong><strong><span>：</span></strong><strong><span>conversationPropagation=nest&amp;amp;cid=25</span></strong></font></strong></p>
<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><strong><font size="3"><strong><span>propagation=&quot;join&quot;</span></strong><strong><span>：</span></strong><strong><span>Propagation=join&amp;amp;cid=29</span></strong></font></strong></p>
<p style="margin: 0cm 0cm 0pt" class="MsoNormal"><strong><font size="3"><strong><span>propagation=&quot;join22&quot;:</span></strong><strong><span>错误的传播类型，传播类型和</span></strong><strong><span>cid</span></strong><strong><span>都没有</span></strong></font></strong></p>
<p><strong><strong><font size="3">由于s:link s:button最终也是生成html，通过url传递cid或对话传播类型的，所以我们也可以在普通的链接上添加<strong><em><span style="color: rgb(0,0,0); font-size: small">pagation=begin'参数来启动长对话，这对帧结构的菜单非常有用，这样我们就可以在帧中方便地使用对话了</span></em></strong></font></strong></strong></p>
<p><span style="font-size: small"><strong><strong>2）在第5阶段，通过action来开始结束对话，可以直接调用对话方法<em><span><span> </span></span><tt><span style="font-size: 12pt"><span><font face="新宋体">#{conversation.begin}，也可以调用普通方法，只是该方法需要@Begin注释而已.</font></span></span></tt></em></strong></strong></span></p>
<p><span><strong><strong><em><tt><span style="font-size: 12pt"><font face="新宋体">3)在第6阶段，通过page.xml配置文件来开始结束对话&lt;<span>begin-conversation/&gt; <span>&lt;end-conversation/&gt;注意，同一页面配置<span>begin-和end-只能配置一个。</span></span></span></font></span></tt></em></strong></strong></span></p>
<p><span><strong><strong><em><tt><span style="font-size: 12pt"><span><span><span><font face="新宋体">我的感觉最方便的应该是第1种方式，毕竟直接在页面上写要直接的多，第3种可能会导致对话的多长执行，因为进入该页面时需要执行一次对话，而faces提交时还要执行对话，而我们可能faces提交时并不想执行对话。</font></span></span></span></span></tt></em></strong></strong></span></p>
<p> </p>
<p> </p>
<p><strong><strong><tt><em><tt><span style="font-size: 12pt"><span><span><span><font face="新宋体">一个对话是由多个request组成的，我们大部分的概念是一连串的request，比如用户注册分成了多个步骤，还有就是复杂的页面流，很多朋友一提到对话就与页面流联系上，说我们没有那么复杂的页面流程用不上对话，其实页面流只是使用对话机制来实现的，而不是对话只能用在页面流上，我们项目中使用对话来解决的问题都跟页面流无关。其实一个对话也可以不连续，一个对话的中间也可以执行其他的对话。就比如用户注册的例子，用户注册需要3步来完成，而如果操作者执行到第2步却去执行其他的操作了，这是我们无法控制的，由于web访问的随意性,我们没办法来强制用户的操作。当操作者做完其他事情了，又想继续刚才的注册（这里只是打个比方，想说明的是一个中断的任务如何继续而已），这时如何恢复还没有结束的对话就显得非常的必要了。 seam给出的解决方案就是工作区管理，我们可以在页面上列出所有未结束的长久对话，想继续那个对话就直接点击对话链接就行了，这样就进入了该对话最后一次操作时保留的状态。具体内容请参考满江红文档，里面的工作区管理写的还是比较详细的。 </font></span></span></span></span></tt></em></tt></strong></strong></p>
<p><strong><strong><tt><em><tt><span style="font-size: 12pt"><span><span><span><font face="新宋体">并不是每个没有结束的长久对话我们都需要恢复的，要做到能恢复我们还必须给对话设置个描述（参见seam文档），不设置对话描述的对话我们是没法再使用的，这样就会产生个问题，那些对话没法来显示关闭了，只能等待对话超时，不知不觉就会积累出性能问题，因为这些操作可能会非常频繁，只开始对话而不结束对话，相当与把很多request的内容都保存到了session，这是相当可怕的。所以在我们没有很好的掌握对话的前提下要避免使用对话。还有就是上步提到的工作区管理也存在同样的问题，由于用户操作的习惯性（或者误操作），用户更习惯于点击注册菜单来注册，而不会去工作区里去恢复中断的注册对话，这样也会产生很多我们不再使用的长对话 。</font></span></span></span></span></tt></em></tt></strong></strong></p>
<p> </p>
<p><strong><strong><tt><em><tt><span style="font-size: 12pt"><span><span><span><font face="新宋体">通过深入研究seam对话，我们通过jsf事件机制来解决了上面两种问题，保证了对话的及时关闭</font></span></span></span></span></tt></em></tt></strong></strong></p>
<p><strong><strong><tt><em><tt><span style="font-size: 12pt"><span>不需要操作者通过关闭操作来关闭对话（一般操作者也不会听你的话去点关闭操作，对他来说这个步骤是多余的）</span></span></tt></em></tt></strong></strong></p>
<p><strong><strong><tt><em><tt><span style="font-size: 12pt"><span><span><span><font face="新宋体">public class SeamConversationPhaseListener implements PhaseListener{<br>
/**<br>
* <br>
*/<br>
private static final long serialVersionUID = 1L;</font></span></span></span></span></tt></em></tt></strong></strong></p>
<p><strong><strong><tt><em><tt><span style="font-size: 12pt"><span><span><span><font face="新宋体">public void afterPhase(PhaseEvent event) {<br>
<br>
&nbsp;&nbsp;  System.out.println(&quot;--Conversation.size:&quot;+ConversationEntries.getInstance().size());<br>
}</font></span></span></span></span></tt></em></tt></strong></strong></p>
<p><strong><strong><tt><em><tt><span style="font-size: 12pt"><span><span><span><font face="新宋体">public void beforePhase(PhaseEvent event) {<br>
&nbsp;&nbsp;  if(event.getPhaseId()==PhaseId.RENDER_RESPONSE){<br>
&nbsp;&nbsp;&nbsp;  endLongConversationEntryList();<br>
&nbsp;&nbsp;&nbsp;  isInLongConversation(Pages.getCurrentViewId());<br>
&nbsp;&nbsp;  }<br>
}</font></span></span></span></span></tt></em></tt></strong></strong></p>
<p><strong><strong><tt><em><tt><span style="font-size: 12pt"><span><span><span><font face="新宋体">public PhaseId getPhaseId() {<br>
&nbsp;&nbsp;  return PhaseId.ANY_PHASE;<br>
}<br>
</font></span></span></span></span></tt></em></tt></strong></strong></p>
<p> </p>
<p><strong><strong><tt><font size="3" face="新宋体">//将不需要恢复的长对话结束</font></tt></strong></strong></p>
<p><span><strong><strong><tt><em><tt><span style="font-size: 12pt"><span><span><span><font face="新宋体">public void endLongConversationEntryList()<br>
&nbsp;&nbsp;&nbsp;  {<br>
&nbsp;&nbsp;  String currentConversationId=org.jboss.seam.core.Conversation.instance().getId();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ConversationEntries conversationEntries = ConversationEntries.getInstance();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if (conversationEntries==null)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return ;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Set&lt;ConversationEntry&gt; orderedEntries = new TreeSet&lt;ConversationEntry&gt;();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  orderedEntries.addAll( conversationEntries.getConversationEntries() );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  for ( ConversationEntry entry: orderedEntries )<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if ( !entry.getId().equals(currentConversationId)&amp;&amp;!entry.isDisplayable() &amp;&amp; !Session.instance().isInvalid() )<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ConversationEntries.instance().removeConversationEntry(entry.getId());<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }</font></span></span></span></span></tt></em></tt></strong></strong></span></p>
<p><span><strong><strong><tt><em><tt><span style="font-size: 12pt"><span><span><span><font face="新宋体">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  }</font></span></span></span></span></tt></em></tt></strong></strong></span></p>
<p><span><strong><strong><tt><em><tt><span style="font-size: 12pt"><span><span><span><font face="新宋体">//点击需要恢复的长对话菜单会转到已经存在的长对话，与直接在工作区里点击对话的效果一样<br>
public boolean isInLongConversation(String viewid){<br>
&nbsp;&nbsp;  ConversationEntries conversationEntries = ConversationEntries.getInstance();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if (conversationEntries==null)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Set&lt;ConversationEntry&gt; orderedEntries = new TreeSet&lt;ConversationEntry&gt;();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  orderedEntries.addAll( conversationEntries.getConversationEntries() );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  int count=0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ConversationEntry firstEntry=null;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  for ( ConversationEntry entry: orderedEntries )<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if ( entry.isDisplayable() &amp;&amp;entry.getViewId().equals(viewid)&amp;&amp; !Session.instance().isInvalid() )<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  count++;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if(count==1){<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;  firstEntry=entry;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }else{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;  ConversationEntries.instance().removeConversationEntry(firstEntry.getId());<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  entry.select();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }</font></span></span></span></span></tt></em></tt></strong></strong></span></p>
<p> </p>
<p><strong><strong><tt><em><tt><span style="font-size: 12pt"><span><span><span><font face="新宋体">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;  return false;<br>
} </font></span></span></span></span></tt></em></tt></strong></strong></p>
<p><strong><strong><tt><em><tt><br>
<font size="3" face="新宋体">}</font></tt></em></tt></strong></strong></p>
<strong><strong><tt><em><tt>
<p> </p>
<p><font size="3">如果同一功能需要不同的对话，比如同样的列表查询我们要保留不同的查询条件，这样就要根据具体需求来修改 isInLongConversation方法。</font></p>
<p><font size="3">最后我们还剩下一些长对话没有关闭，这必须要操作者的参与才能完成的，就像操作者打开来多个窗口，他必须手工来关闭，我们可以在工作区中的对话列表上增加关闭对话的操作，就像操作者要关闭窗口一样。</font></p>
<p><font size="3"><a href="http://yourenyouyu2008.javaeye.com/blog/248531">http://yourenyouyu2008.javaeye.com/blog/248531</a></font></p>
</tt></em></tt></strong></strong></div></div></body></html>