<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>拖拽网格线 -hxzon -Javacode</title></head><body><h1>拖拽网格线 -hxzon -Javacode</h1><div><p> </p>
<p>拖拽网格线 -hxzon -Javacode</p>
<p>package hxzon.ui;</p>
<p>import java.awt.BorderLayout;<br>
import java.awt.Color;<br>
import java.awt.Cursor;<br>
import java.awt.Dimension;<br>
import java.awt.Graphics;<br>
import java.awt.HeadlessException;<br>
import java.awt.Point;<br>
import java.awt.event.MouseEvent;<br>
import java.awt.event.MouseListener;<br>
import java.awt.event.MouseMotionListener;</p>
<p>import javax.swing.JFrame;<br>
import javax.swing.JPanel;<br>
import javax.swing.UIManager;</p>
<p>public class DragingFrame2 extends JFrame {</p>
<p>public DragingFrame2() throws HeadlessException {<br>
&nbsp;&nbsp;  this.setDefaultCloseOperation(EXIT_ON_CLOSE);<br>
&nbsp;&nbsp;  getContentPane().setLayout(new BorderLayout());<br>
&nbsp;&nbsp;  getContentPane().add(new ImagePanel(), BorderLayout.CENTER);<br>
}</p>
<p>// 程序入口<br>
public static void main(String[] args) throws Exception {<br>
&nbsp;&nbsp;  UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());<br>
&nbsp;&nbsp;  DragingFrame2 frame = new DragingFrame2();<br>
&nbsp;&nbsp;  frame.setSize(1000, 800);<br>
&nbsp;&nbsp;  frame.setLocation(300, 300);<br>
&nbsp;&nbsp;  // frame.setResizable(false);<br>
&nbsp;&nbsp;  frame.setTitle(&quot;拖拽网格线&quot;);<br>
&nbsp;&nbsp;  frame.setVisible(true);<br>
}<br>
}</p>
<p>class ImagePanel extends JPanel {<br>
Point AXIS_START = new Point(30, 20);// 坐标原点的当前位置<br>
int GRID_WIDTH = 100;<br>
int GRID_HEIGHT = 20;<br>
Dimension size = new Dimension(1000, 800);<br>
int K_1 = 1024;<br>
int axisMaxRate = 10 * K_1;// 默认最大10K<br>
int M_1 = 1000 * K_1;<br>
int gridRate = 1024;// 单位刻度的流量,单位字节</p>
<p>private DragStatus status = DragStatus.Ready; // 拖拽状态</p>
<p>private Point imageStartposition = new Point(AXIS_START); // 每次拖拽开始时图片的位置（也就是上次拖拽后的位置）</p>
<p>private Point mouseStartposition; // 每次拖拽开始时鼠标的位置</p>
<p>ImagePanel() {</p>
<p>&nbsp;&nbsp;  addMouseListener(new MouseListener() {</p>
<p>&nbsp;&nbsp;&nbsp;  // 双击鼠标时打开图片<br>
&nbsp;&nbsp;&nbsp;  public void mouseClicked(MouseEvent e) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;  if (e.getClickCount() == 2) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  // openImage();<br>
&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  }</p>
<p>&nbsp;&nbsp;&nbsp;  // 按下鼠标时，更改状态，并且记录拖拽起始位置。<br>
&nbsp;&nbsp;&nbsp;  public void mousePressed(MouseEvent e) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;  if (status == DragStatus.Ready) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  status = DragStatus.Dragging;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  setCursor(new Cursor(Cursor.HAND_CURSOR));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  mouseStartposition = e.getPoint();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  imageStartposition.setLocation(AXIS_START.getLocation());<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  // System.out.println(&quot;pressed<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  // mouseStartposition:&quot;+imageStartposition);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  // System.out.println(&quot;AXIS_START.x:&quot;+AXIS_START.x);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  // System.out.println(&quot;AXIS_START.y:&quot;+AXIS_START.y);<br>
&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  }</p>
<p>&nbsp;&nbsp;&nbsp;  // 松开鼠标时更改状态<br>
&nbsp;&nbsp;&nbsp;  public void mouseReleased(MouseEvent e) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;  if (status == DragStatus.Dragging) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  status = DragStatus.Ready;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  setCursor(new Cursor(Cursor.DEFAULT_CURSOR));<br>
&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  }</p>
<p>&nbsp;&nbsp;&nbsp;  public void mouseEntered(MouseEvent e) {<br>
&nbsp;&nbsp;&nbsp;  }</p>
<p>&nbsp;&nbsp;&nbsp;  public void mouseExited(MouseEvent e) {<br>
&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;  });</p>
<p>&nbsp;&nbsp;  addMouseMotionListener(new MouseMotionListener() {</p>
<p>&nbsp;&nbsp;&nbsp;  // Java 有拖拽事件，在这个事件中移动图片位置<br>
&nbsp;&nbsp;&nbsp;  public void mouseDragged(MouseEvent e) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;  if (status == DragStatus.Dragging) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  moveImage(e.getPoint());<br>
&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  }</p>
<p>&nbsp;&nbsp;&nbsp;  public void mouseMoved(MouseEvent e) {<br>
&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;  });<br>
}</p>
<p>/**<br>
* 移动图片。实际上画图工作在 paintComponent() 中进行，这里只是计算图片位置，然后调用该方法。<br>
* <br>
* @param point<br>
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  当前的鼠标位置<br>
*/<br>
private void moveImage(Point point) {</p>
<p>&nbsp;&nbsp;  AXIS_START.x = imageStartposition.x + (point.x - mouseStartposition.x);<br>
&nbsp;&nbsp;  AXIS_START.y = imageStartposition.y - (point.y - mouseStartposition.y);// y轴方向相反<br>
&nbsp;&nbsp;  // System.out.println(&quot;drag mouseStartposition:&quot;+point);<br>
&nbsp;&nbsp;  // System.out.println(&quot;AXIS_START.x:&quot;+AXIS_START.x);<br>
&nbsp;&nbsp;  // System.out.println(&quot;AXIS_START.y:&quot;+AXIS_START.y);<br>
&nbsp;&nbsp;  if (AXIS_START.x &gt; 800) {<br>
&nbsp;&nbsp;&nbsp;  AXIS_START.x = 800;<br>
&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;  if (AXIS_START.y &gt; 600) {<br>
&nbsp;&nbsp;&nbsp;  AXIS_START.y = 600;<br>
&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;  repaint();<br>
}</p>
<p>@Override<br>
protected void paintComponent(Graphics g) {<br>
&nbsp;&nbsp;  super.paintComponent(g);<br>
&nbsp;&nbsp;  // System.out.println(&quot;paint component&quot;);<br>
&nbsp;&nbsp;  Color gridColor = new Color(0, 128, 64);<br>
&nbsp;&nbsp;  int count = 0;<br>
&nbsp;&nbsp;  for (int i = AXIS_START.x + GRID_WIDTH; i &lt; size.width; i += GRID_WIDTH) {<br>
&nbsp;&nbsp;&nbsp;  g.setColor(gridColor);<br>
&nbsp;&nbsp;&nbsp;  g.drawLine(i, 0, i, size.height - AXIS_START.y);<br>
&nbsp;&nbsp;&nbsp;  count++;<br>
&nbsp;&nbsp;&nbsp;  g.drawString(&quot;t&quot; + count, i, 30);<br>
&nbsp;&nbsp;  }</p>
<p>&nbsp;&nbsp;  int unitK = axisMaxRate / 10;// 一个格子多少字节,单位用rateUnit表示//hxzon 10个有效格子<br>
&nbsp;&nbsp;  int totalB = 0;<br>
&nbsp;&nbsp;  count = 0;</p>
<p>&nbsp;&nbsp;  GRID_HEIGHT = size.height / 11;// hxzon 单元格高度，11个格子<br>
&nbsp;&nbsp;  if (GRID_HEIGHT &lt;= 0) {<br>
&nbsp;&nbsp;&nbsp;  GRID_HEIGHT = 1;<br>
&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;  // 画水平网格线<br>
&nbsp;&nbsp;  for (int i = size.height - GRID_HEIGHT - AXIS_START.y; i &gt; 0; i -= GRID_HEIGHT) {<br>
&nbsp;&nbsp;&nbsp;  g.setColor(gridColor);<br>
&nbsp;&nbsp;&nbsp;  g.drawLine(AXIS_START.x, i, size.width, i);<br>
&nbsp;&nbsp;&nbsp;  totalB += gridRate;<br>
&nbsp;&nbsp;&nbsp;  // 本水平线所代表的字节流量，每条水平线依次递增一个gridRate。ok<br>
&nbsp;&nbsp;&nbsp;  count++;<br>
&nbsp;&nbsp;&nbsp;  if (count % 2 == 0) {// 隔一个格子写刻度<br>
&nbsp;&nbsp;&nbsp;&nbsp;  String mark;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  int totalK = totalB / K_1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  int totalM = totalB / M_1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  if (totalK &lt; 10) {// hxzon right align<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  mark = &quot; &quot; + totalK + &quot;K&quot;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  } else if (totalK &lt; 100) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  mark = &quot; &quot; + totalK + &quot;K&quot;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  } else if (totalK &lt; 1000) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  mark = totalK + &quot;K&quot;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  } else if (totalK &lt; 10000) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  mark = &quot; &quot; + totalM + &quot;M&quot;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  } else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  mark = &quot; &quot; + totalM + &quot;M&quot;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;  g.setColor(Color.BLACK);<br>
&nbsp;&nbsp;&nbsp;&nbsp;  g.drawString(mark, 0, i + 4);<br>
&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;  }// end for<br>
}</p>
<p>private enum DragStatus {</p>
<p>&nbsp;&nbsp;  Ready, Dragging<br>
}<br>
}</p></div></body></html>