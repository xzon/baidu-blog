<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>C#之父Anders Hejlsberg演讲解读：编程语言大趋势</title></head><body><h1>C#之父Anders Hejlsberg演讲解读：编程语言大趋势</h1><div><p>C#之父Anders Hejlsberg演讲解读：编程语言大趋势</p>
<p>——基于对C#之父Anders Hejlsberg演讲的总结<br>
文 / 赵劼</p>
<br>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span > </span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >程 序设计离不开编程语言，但是编程语言在国内的大环境中似乎一直是个二等公民。国内的计算机教育和工程培训，似乎一直在宣传“语言不重要，重要的是思想”、 “语言一通百通”等观点，甚至在许多人眼中，语言的讨论完全是不入流的，但其实编程语言与工具、框架或开发方法等一样，都对生产力有着重要的影响。事实 上，语言的发展历史比其他方面更为悠久，并且在过去十几年，甚至最近几年中都依然在不断的碰撞和演变。期间一些新的语言诞生了，而另一些在当时看来阳春白 雪的语言和编程范式也重新获得了重视。</span><span > </span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >Anders&#160;Hejlsberg 是微软的Technical&#160;Fellow，担任C#编程语言的首席架构师，也参与了.NET&#160;Framework、VB.NET和F#等语言的设计与开 发。几个月前，Anders在比利时TechDays&#160;2010及荷兰DevDays&#160;2010分别作了一场演讲，阐述了他眼中的编程语言的发展趋势及未 来方向，本文便对他的观点进行了总结。</span><span > </span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >大约25</span><span >~</span><span >30 年前，Anders开发了著名的Turbo&#160;Pascal，这是一套集语言、编译器及开发工具于一体的产品，也是Anders进入编程语言领域的起点。 Anders谈到，当年Turbo&#160;Pascal所用的Z-80和如今的计算机已经不可同日而语。与那时相比，如今的机器已经有大约10万倍的外部存储容 量，1万倍的内存大小，CPU速度也有大约1000倍的提高。但是，如果我们比较如今的Java代码及当年的Pascal代码，会发现它们的差别其实并不 大。Anders认为编程语言的发展非常缓慢，期间当然出现了一些东西，例如面向对象等，但是远没有好上1000倍。事实上，近几十年来的努力主要体现在 框架及工具等方面（如图1）。例如.NET&#160;Framework里有超过一万个类和十万个方法，与Turbo&#160;Pascal相比的确有了超过1000倍的 增长。类似的，现在的IDE包含了无数强大的功能，例如语法提示、重构、调试器等。与此相比，编程语言的改进的确很不明显。</span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span > </span></p>
<div style="width: 310px;" class="wp-caption aligncenter" ><a><img width="300" height="225" alt="图1  近几十年来语言,框架及工具的发展" src="http://www.programmer.com.cn/wp-content/uploads/2010/07/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%801-300x225.gif" title="编程语言1" class="size-medium wp-image-3746"></a>
<p class="wp-caption-text">图1  近几十年来语言、框架及工具的发展</p>
</div>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >在 过去50~60年的编程历史中，编程语言的抽象级别不断提高，人们都在努力让编程语言更有表现力，这样就可以用更少的代码完成更多的工作。我们一开始使用 汇编，然后使用面向过程的语言（如Pascal和C），然后是面向对象语言（如C++），随后便进入了托管时代，语言运行于受托管的执行环境上（如C#和 Java），它们的主要特性有自动垃圾收集、类型安全等。Anders认为这样的趋势还会继续下去，还会有抽象级别越来越高的语言。另一方面，编程语言往 往都倾向于构建于现有的工具上，而不会从头写起。现在出现的编程语言，例如F#、Scala和Clojure等，都是基于现有框架构建的，每次从头开始的 代价实在太高。</span><span > </span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >在 Anders眼中，如今影响力较大的趋势主要有三个（如图2），分别是声明式的编程风格（包括领域特定语言、函数式编程）、动态语言（最重要的方面是元编 程能力）以及多核环境下的并发编程。此外随着语言的发展，原本常用的面向对象语言、动态语言或是函数式等边界也变得越来越模糊，例如各种主要的编程语言都 受到函数式语言的影响。因此，多范式程序设计语言也是一个愈发明显的趋势。</span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span > </span></p>
<div style="width: 310px;" class="wp-caption aligncenter" ><a><img width="300" height="225" alt="图2  影响力较大的三个趋势" src="http://www.programmer.com.cn/wp-content/uploads/2010/07/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%802-300x225.gif" title="编程语言2" class="size-medium wp-image-3747"></a>
<p class="wp-caption-text">图2  影响力较大的三个趋势</p>
</div>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span > </span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >声明式编程与DSL</span><span > </span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >目 前常见的编程语言大都是命令式（Imperative）的，例如C#、Java或C++等。这些语言的特征在于，代码里不仅表现了“做什么 （What）”，而更多表现出“如何（How）完成工作”这样的实现细节，例如for循环、i&#160;+=&#160;1等，甚至这部分细节会掩盖我们的最终目标。在 Anders看来，命令式编程通常会让代码变得十分冗余，更重要的是由于它提供了过于具体的指令，这样执行代码的基础设施（如CLR或JVM）没有太多发 挥空间，只能老老实实地根据指令一步步地向目标前进。例如，并行执行程序会变得十分困难，因为像“执行目的”这样更高层次的信息已经丢失了。因此，编程语 言的趋势之一，便是能让代码包含更多的“What”，而不是“How”，这样执行环境便可以更加聪明地去适应当前的执行要求。</span><span > </span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >关 于声明式的编程风格，Anders主要提出了两个方面，第一个方面是DSL（Domain&#160;Specific&#160;Language，领域特定语言）。DSL 不是什么新鲜的玩意儿，我们平时经常接触的SQL、CSS、正则表达式等都属于DSL。有的DSL可能更加专注于一个方面，例如Mathematica、 LOGO等。这些语言的目标都是特定的领域，与之相对的则是GPPL（General&#160;Purpose&#160;Programming&#160;Language，通用 目的编程语言）。Martin&#160;Fowler将DSL分为外部DSL和内部DSL两种。外部DSL有自己的特定语法、解析器和词法分析器等，它们往往是一 种小型的编程语言，甚至不会像GPPL那样需要源文件。与之相对的则是内部DSL。内部DSL其实更像是种别称，它代表一类特别API及使用模式。</span><span > </span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >XSLT、 SQL等都可以算作是外部DSL。外部DSL一般会直接针对特定的领域设计，而不考虑其他方面。James&#160;Gosling曾经说过：每个配置文件最终都 会变成一门编程语言。一开始你可能只会用它表示一点点东西，慢慢地你便会想要一些规则，而这些规则则变成了表达式，后来你可能还会定义变量，进行条件判断 等，而最终它就变成了一种奇怪的编程语言。这样的情况屡见不鲜。现在有一些公司也在关注DSL的开发。例如以前在微软工作的 Charles&#160;Simonyi提出了Intentional&#160;Programming的概念，还有JetBrains公司提供了叫做 MPS（Meta&#160;Programming&#160;System）的产品。最近微软也提出了自己的Oslo项目，而在Eclipse世界里也有Xtext，所以 如今在这方面已经有不少尝试。由于外部DSL的独立性，在某些情况下也会出现特定的工具，辅助领域专家或是开发人员编写DSL代码。还有一些DSL会以 XML方言的形式提出，利用XML方言的好处在于有不少现成的工具可用，这样可以更快地定义自己的语法。</span><span > </span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >内 部DSL往往只代表一系列特别的API及使用模式，例如LINQ查询语句及Ruby&#160;on&#160;Rails中的Active&#160;Record声明代码等。内部 DSL可以使用一系列API来“伪装”成一种DSL，利用一些流畅化的技巧，例如像jQuery那样把一些方法通过“点”连接起来，而另一些也会利用元编 程的方式。内部DSL还有一些优势，例如可以访问语言中的代码或变量，以及利用代码补全、重构等母语言的所有特性。</span><span > </span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >DSL的可读性往往很高。例如，要筛选出单价大于20的产品，并对所属种类进行分组，降序列出每组的分类名称及产品数量。如果是用命令式的编程方式，可能是这样的：</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span >var&#160;groups&#160;=&#160;new&#160;Dictionary&lt;string,&#160;Grouping&gt;();</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span >foreach&#160;(Product&#160;p&#160;in&#160;products)</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span >{</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > if&#160;(p.UnitPrice&#160;&gt;=&#160;20)</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > {</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > if&#160;(!groups.ContainsKey(p.CategoryName))</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > {</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > Grouping&#160;g&#160;=&#160;new&#160;Grouping();</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > g.Name&#160;=&#160;p.CategoryName;</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > g.Count&#160;=&#160;0;</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > groups[p.CategoryName]&#160;=&#160;g;</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > }</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > groups[p.CategoryName].ProductCount++;</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > }</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span >}</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"> </p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span >var&#160;result&#160;=&#160;new&#160;List&lt;Grouping&gt;(groups.Values);</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span >result.Sort(delegate(Grouping&#160;x,&#160;Grouping&#160;y)</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span >{</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > return</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > x.Count&#160;&gt;&#160;y.Count&#160;?&#160;-1&#160;:</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > x.Count&#160;&lt;&#160;y.Count&#160;?&#160;1&#160;:</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > 0;</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span >});</span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >显然这些代码编写起来需要一点时间，且很难直接看出它的真实目的，换言之，“What”几乎完全被“How”所代替了。这样，一个新的程序员必须花费一定时间才能理解这段代码的目的。但如果使用LINQ，代码便可以改写成：</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span >var&#160;result&#160;=&#160;products</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > .Where(p&#160;=&gt;&#160;p.UnitPrice&#160;&gt;=&#160;20)</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > .GroupBy(p&#160;=&gt;&#160;p.CategoryName)</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > .OrderByDescending(g&#160;=&gt;&#160;g.Count())</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > .Select(g&#160;=&gt;&#160;new&#160;{&#160;Name&#160;=&#160;g.Key,&#160;Count&#160;=&#160;g.Count()&#160;});</span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >这段代码更加关注的是“How”而不是“What”，它不会明确地给出过滤的操作方式，也没有涉及到创建字典这样的细节。这段代码还可以利用C#&#160;3.0中内置的DSL，即LINQ查询语句来改写：</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span >var&#160;result&#160;=</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > from&#160;p&#160;in&#160;products</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > where&#160;p.UnitPrice&#160;&gt;=&#160;20</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > group&#160;p&#160;by&#160;p.CategoryName&#160;into&#160;g</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > orderby&#160;g.Count()&#160;descending</span></p>
<p style="text-indent: 18pt; margin-bottom: 0pt; margin-top: 0pt;"><span > select&#160;new&#160;{&#160;Name&#160;=&#160;g.Key,&#160;Count&#160;=&#160;g.Count()&#160;};</span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >编译器会简单地将LINQ差距语句转化为前一种形式。这段代码只是表现出最终的目的，而不是明确指定做事的方式，这样便可以很容易地并行执行这段代码，如使用PINQ则几乎不需要做出任何修改。</span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span ><br>
</span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"> </p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >函数式编程</span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >Anders 提出的另一个重要的声明式编程方式便是函数式编程。函数式编程历史悠久，如当年的LISP便是函数式编程语言。除了LISP以外还有其他许多函数式编程语 言，如APL、Haskell、ML等。函数式编程在学术界已经有过许多研究，大约在5~10年前许多人开始吸收和整理这些研究内容，想要把它们融入更为 通用的编程语言。现在的编程语言，如C#、Python、Ruby、Scala等，都受到了函数式编程语言的影响。</span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >使 用命令式编程语言写程序时，我们经常会编写如x&#160;=&#160;x&#160;+&#160;1这样的语句，此时我们大量依赖的是可变状态，或者说是变量，它们的值可以随程序运行而改 变，可变状态非常强大，但随之而来的便是“副作用”问题，例如一个无需参数的void方法，它会根据调用次数或是在哪个线程上进行调用对程序产生影响，它 会改变程序内部的状态，从而影响之后的运行效果。而在函数式编程中则不会出现这个情况，因为所有的状态都是不可变的。事实上对函数式编程的讨论更像是数 学、公式，而不是程序语句，如x&#160;=&#160;x&#160;+&#160;1对于数学家来说，似乎只是个永不为真的表达式而已。</span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt; text-align: justify;"><span >函 数式编程十分容易并行，因为它在运行时不会修改任何状态，因此无论多少线程在运行时都可以观察到正确的结果。假如两个函数完全无关，那么它们是并行还是顺 序执行便没有什么区别。当然，现实中的程序一定是有副作用的，例如向屏幕输出内容，向Socket传输数据等，因此真实世界中的函数式编程往往都会考虑如 何将有副作用的代码分离出来。函数式编程默认是不可变的，开发人员必须做些额外的事情才能使用可变状态或是危险的副作用，与之相反，C#或Java必须使 用readonly或final来做到这一点。此时，使用函数式编程语言时的思维观念便会有所不同。</span><span >……</span><span >（完整文章请关注0</span><span >8</span><span >期杂志）</span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt; text-align: justify;"><span ><br>
</span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"> </p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >未完的部分还有这些内容：</span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >动态语言与元编程</span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >并发</span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span >总结</span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"><span ><br>
</span></p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;"> </p>
<p style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt; text-align: justify;"><span >（本文来自《程序员》杂志10年0</span><span >8</span><span >期，更多精彩内容敬请关注0</span><span >8</span><span >期杂志）</span></p>
<p> </p></div></body></html>