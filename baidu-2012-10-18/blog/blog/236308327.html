<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>ActiveObjects: An Easier Java ORM</title></head><body><h1>ActiveObjects: An Easier Java ORM</h1><div><h1>ActiveObjects: An Easier Java ORM</h1>
<p>https://activeobjects.dev.java.net/</p>
<p>Java is absolutely full of Object Relational Mapping frameworks.  Obviously Hibernate is the first which    comes to mind, but also high on the list would be the likes of iBatis, Beankeeper, etc.  In short, there    is no shortage of ORMs.  However, they all seem to suffer from one of a number of fundamental flaws:</p>
<ul>
    <li>They're complicated and hard to use</li>
    <li>They're slow and unsuitable for high-load deployment</li>
    <li>They're only compatible with a small handful of databases</li>
</ul>
<p>Most ORMs actually match the first problem: they're just too darn complicated.  Think about it, when's    the last time you tried to configure a Hibernate project from scratch?  You have to write more XML than    code!  iBatis makes things a bit easier at times, but you still have to run through a ton of manual    configuration and headache.  It would be nice if the framework could just automate most of this annoyance    away.  However, it seems very few frameworks these days put the proper emphasis on &quot;ease of use&quot; and low    learning curve.</p>
<h2>The Example to Follow</h2>
<p>One major exception to this &quot;ease of use drought&quot; is the ActiveRecord framework.  For those of you    who don't know, ActiveRecord is the ORM upon which Ruby on Rails is based.  In fact, without ActiveRecord,    Rails really wouldn't be anywhere near as powerful a framework.  AR provides an extremely intuitive way to    work with databases.  For example, let's assume you have the following (fairly simple) schema:</p>
<img src="http://www.javalobby.org/articles/activeobjects/tables-diagram.png">
<p>This is a fairly common scenario.  We have a simple table which has a one-to-many relationship with    another table.  Each table has a few values and a primary key (id).  Now in Hibernate, we would map to this    schema using a pair of Java beans and mountains of mapping XML.  With ActiveRecord, all we need to do is    write the following Ruby code:</p>
<pre>class Person &lt; ActiveRecord::Base<br> belongs_to :company<br>end<br><br>class Company &lt; ActiveRecord::Base<br> has_many :people<br>end<br><br>p = Person.find(1)<br>p.age = 27<br>p.save<br><br>c = Company.find(1)<br>c.people.each do |person|<br> puts &quot;#{person.first_name} #{person.last_name}&quot;<br>end</pre>
<p>As you can see, ActiveRecord puts a very high emphasis on minimalism and simplicity.  In fact, thanks to    Ruby's dynamic meta-programming underpinnings, we don't even need to write methods to access the data.    All we need to do is define the empty classes, add a little mapping DSL goodness, and ActiveRecord figures    out the rest (including pluralization of the table names).  ActiveRecord will dynamically generate and execute    all the SQL required to run the driver code at the bottom of the example.  In fact, the only logic missing from    this example is the code required to make the actual connection to the database.</p>
<p>ActiveRecord is an example of &quot;convention over configuration&quot;.  Notice all the assumptions it's making.     To start with, it assumes that your table names are pluralized.  When we get to the mapping logic, it makes    the additional assumption that the <em>people</em> table contains a <em>company_id</em> field with the appropriate foreign key    configuration.  In short, ActiveRecord is assuming that your needs are equivalent to 90% of developers in this    situation, and that you have configured your environment accordingly.  As such, it can do some pretty    amazing things with little-to-no intervention on your part.</p>
<h2>Lessons Learned, Applied to Java</h2>
<p>So, ActiveRecord is interesting, how does this help us?  Well, for one thing, we can infer the following    axioms:</p>
<ul>
    <li>Conventions can be assumed, and conclusions can be drawn from these conventions</li>
    <li>Simplicity, simplicity, simplicity, simplicity</li>
    <li>Less code is more</li>
    <li>It's ok if the API is mildly atypical and DSL-like, as long as it makes sense and remains internally consistent</li>
</ul>
<p>So, in theory we could design a brand new ORM, based on these principles, entirely in Java.  We may    not be able to take advantage of cool Ruby features like <em>method_missing</em>, but Java has its own mechanisms    for code reductions which, while not as powerful as Ruby's, still allow for some interesting stuff.  The first bit    we can focus on is the &quot;Less code is more&quot;.</p>
<p>Almost every Java ORM currently available is POJO based.  This means that you write Java beans, with    fields, accessors and mutators, then pass around instances of these beans.  The ORM then reflectively    interrogates these beans, extracting values and using mapping logic (usually defined in XML) to persist (or    retrieve) these values in the database.  This requires a lot of excess boiler-plate code.  Think about it, to    define a simple bean for our companies table would require something like this:</p>
<pre>public class Company {<br> private int id;<br> private String name;<br> private String tickerSymbol;<br> <br> public Company() {}<br> <br> public void getId() {<br>  return id;<br> }<br> <br> public void setId(int id) {<br>  this.id = id;<br> }<br> <br> public void getName() {<br>  return name;<br> }<br> <br> public void setName(String name) {<br>  this.name = name;<br> }<br> <br> public void getTickerSymbol() {<br>  return tickerSymbol;<br> }<br> <br> public void setTickerSymbol(String tickerSymbol) {<br>  this.tickerSymbol = tickerSymbol;<br> }<br>}</pre>
<p>While this is nice and readable, it's rather long.  Compare this to the three lines required for the    ActiveRecord <em>Company</em> class, and we haven't even dealt with relations yet!</p>
<p>At some minimal level, the Java compiler still needs to be satisfied.  So even in a theoretically    least-possible-code situation, we still need to provide something like the following:</p>
<pre>public class Company {<br> public int getID();<br> public void setID(int id);<br> <br> public String getName();<br> public void setName(String name);<br> <br> public String getTickerSymbol();<br> public void setTickerSymbol(String tickerSymbol);<br>}</pre>
<p>All the same methods are still there, but we haven't actually implemented anything.  In fact, looking    closely at this, we seem to have written an interface definition.  In fact, by changing &quot;class&quot; to &quot;interface&quot; in    the above code sample, we can make it compile.  Of course, it doesn't do anything yet, but we can handle    that later.  The important part is we've established the minimum and most intuitive code required to map the    <em>companies</em> table.</p>
<p>Java has a little-known reflective backwater called &quot;dynamic proxies&quot;.  Basically, this mechanism allows    developers to implement interfaces dynamically, without having to actually write every method explicitly.  All    the developer has to do is provide an implementation of <em>InvocationHandler</em>.  This implementation has a single    method, <em>invoke</em>, which handles all method invocations called against the dynamic interface instance.  It's    about the closest thing Java has to Ruby's <em>method_missing</em>.  Fortunately, it's good enough for our    purposes.</p>
<p>If we define an <em>InvocationHandler</em> which handles the method invocations for our sample interface above,    we could conceivably manage the entire entity state within our framework, eliminating the need for the    end-developer to write this boilerplate themselves.  We could even write a super-interface which defines the    <em>getID()</em> and <em>setID(int)</em> methods.  Extending this idea even further, we could also define a <em>save()</em> method, to    allow API-users to call a method on the entity instance itself to persist values, rather than relying on a    persistence manager.</p>
<h2>Fleshing Out the Implementation</h2>
<p>A few random interfaces does not an ORM make.  There are far more things to database access than just    getters and setters.  But as before, we can write concept code to guide our efforts in implementing the API.     Given what we know about the framework so far (based on interfaces and dynamic proxies), we should be    able to envision some plausible code:</p>
<pre>public interface Company extends Entity {<br> public String getName();<br> public void setName(String name);<br> <br> public String getTickerSymbol();<br> public void setTickerSymbol(String tickerSymbol);<br> <br> @OneToMany<br> public Person[] getPeople();<br>}<br>// assume Person is defined similarly<br><br>EntityManager manager = new EntityManager(&quot;jdbc:mysql://localhost/test&quot;, &quot;user&quot;, &quot;password&quot;);<br><br>Company[] companies = manager.find(Company.class);<br>for (Company c : companies) {<br> System.out.println(c.getName());<br> <br> for (Person p : c.getPeople()) {<br>  p.setFirstName(&quot;Joe&quot;);<br>  p.setAge(8);<br>  p.save();<br> }<br>}<br><br>Company dzone = manager.find(Company.class, &quot;name = DeveloperZone&quot;)[0];<br><br>Person me = manager.create(Person.class);<br>me.setFirstName(&quot;Daniel&quot;);<br>me.setLastName(&quot;Spiewak&quot;);<br>me.setCompany(dzone);<br>me.save();</pre>
<p>You'll notice that we have added to the Company interface slightly: we're now handling relations.     However, the bulk of the interesting prototyping is being done farther along in the sample.  We've now    introduced the <em>EntityManager</em> class.</p>
<p><em>EntityManager</em> is the focal point for all of the interesting activity in our new ORM.  This is where the    database connection is established, it's where the dynamic proxy is created and wrapped into dynamic    instance of the relevant interfaces.  Here also, we have the handling of interesting query operations like    <em>find()</em>.  Unlike ActiveRecord, we can't put <em>find()</em> and friends as part of the <em>Entity</em> super-interface since    interfaces in Java cannot contain class methods.  However, if we keep the <em>EntityManager#find(&#226;&#8364;&#166;)</em> syntax    simple enough, it shouldn't make too much of a difference.</p>
<h2>Complex Queries</h2>
<p>Of course an ORM is more than just database encapsulation and simple CRUD operations.  We need some    way to execute more complex queries against the database and receive entities as a result.  It turns out that    this is a surprisingly tough nut to crack.</p>
<p>Most ORMs (most notably JPA) utilize their own query language to solve the problem.  So, to get all of    the <em>Person</em>(s) who are older than 18 would be something like this: &quot;from Person where age &gt; 18&quot;.  As close    as this may be to actual SQL, it really isn't.  This means that not only do you have to learn a whole new query    language, but the framework itself needs to worry about string parsing and query execution, which brings    with it a whole new set of issues.  In short, it was an interesting, but in practice it turns into a bit of a    mess.</p>
<p>Going back once again to our &quot;hero ORM&quot; implementation, ActiveRecord, we can see that it already    solves the problem in a somewhat unique manner:</p>
<pre>people = Person.find(:where =&gt; 'age &gt; 18', :limit =&gt; 10)</pre>
<p>If you ask me, this is pretty darn intuitive.  It's fairly obvious what's going on, we don't need to worry    about selecting the right fields for the ORM to construct the Person instance, and on top of that it evaluates    very naturally into SQL.  ActiveRecord might execute the following SQL in the above case:    &quot;SELECT * FROM people WHERE age &gt; 18 LIMIT 10&quot;.  No obscure query-lang parsing; no new language to    learn.</p>
<p>Unfortunately, taking example from this is a bit challenging.  ActiveRecord is making use of a Ruby feature    which allows the easy creation of Hash instances as part of a method invocation.  But even if Ruby didn't    have this syntax, named parameters could have been used to achieve the same effect.  Java on the other    hand, has no such constructs.  There is no &quot;simple&quot; way to construct a Map instance on the fly, nor does    Java support named parameters.  In short, we're a bit stuck.</p>
<p>We could define a <em>find</em> method which takes a hundred parameters, varying its behavior accordingly based    on which are non-null.  This can be streamlined by overloading the <em>find</em> method to allow for different    permutations of parameters.  But this is problematic since a) we may have parameter type conflict, breaking    the overloading, and b) it's verbose and ugly.  In fact, our only recourse is to use a rather odd Java pattern    which not-so-neatly gets around the lack of named parameters: method chaining.</p>
<p>If we define a <em>Query</em> class which has several methods used in defining query parameters, each returning    <em>this</em>, we should be able to pass these to <em>find</em> and give it all the information it needs in a (comparatively)    syntactically simple manner:</p>
<pre>Person[] people = manager.find(Person.class, Query.select().where(&quot;age &gt; 18&quot;).limit(10));</pre>
<p>By chaining the method calls on the <em>Query</em> class, we can simulate the use of named parameters and limit    the excess code required to run a complex query.  In fact, this method even allows us to make use of    prepared statement parameterization while still avoiding query parsing:</p>
<pre>Person[] drinkers = manager.find(Person.class, Query.select().where(&quot;age &gt; ?&quot;, 21).limit(10));<br>Person[] adults = manager.find(Person.class, Query.select().where(&quot;age &gt; ?&quot;, 18).limit(10));<br>Person[] drivers = manager.find(Person.class, Query.select().where(&quot;age &gt; ?&quot;, 16).limit(10));</pre>
<p>Here all we're doing is taking advantage of the Java varargs feature and passing extra parameters to the    <em>where(String, Object&#226;&#8364;&#166;)</em> method.  Most databases will take the above queries, which all resolve to the    parameterized &quot;SELECT id FROM people WHERE age &gt; ? LIMIT 10&quot;, and compile them all down to a single    prepared statement.  Whenever this statement is re-invoked (such as in the &quot;adults&quot; and &quot;children&quot; queries),    the database will merely pass different parameters to the already compiled statement, streamlining execution.     In fact, on most databases, the second two queries will execute anywhere from 2-5 times <em>faster</em> than the first    (based on my own micro-benchmarking).</p>
<p>Incidentally, this is an area where we can gain a significant performance advantage over ActiveRecord,    which doesn't utilize prepared statements at all.  Given the fact that we want our ORM to be as performant    as possible, this is good news.  :-)</p>
<h2>Implementing the Active Record Pattern</h2>
<p><a src="http://martinfowler.com">Martin Fowler</a> defines the Active Record pattern as:</p>
<blockquote>An object that wraps a row in a database table or view, encapsulates the database access,    and adds domain logic on that data.</blockquote>
<p>Even though Fowler wasn't the first to posit this pattern, his definition is considered to be among the    best.  In fact, it was this definition which directly led to the creation of the ActiveRecord framework within    Ruby on Rails.  Active Record is considered to be a fairly solid design pattern to use in ORM construction.     Granted, it does have issues, but for most scenarios it's pretty useful.  Since our goal is to create a useful    and simple ORM for 90% of use-cases, Active Record is probably a good design pattern to follow.  But at the   moment, our informal spec only handles the first part of the definition: database access encapsulation.  We    need to have some way of adding domain logic to our entities.</p>
<p>This actually poses a bigger problem than it would seem at first glance.  In our ORM, entities are    represented by interfaces.  Thus, they cannot contain any method definitions; hence no domain logic.  We    could go back to the idea of classes, but Java doesn't support dynamic proxies for classes, only interfaces.     Of course, there are always hacks like CGLIB, but I've always considered bytecode modification to be a    dubious pursuit at best.  So, we can't change our entities to classes, and we can't put domain logic in our    interface-entities.  In short, we're stuck.</p>
<p>The solution is to factor the domain logic out into a separate class from the entity.  This probably makes    sense already to most OOD purists since it separates the model logic from the database access itself.     Unfortunately, to the Active Record purists, this is probably going to look like heresy.  To continue with our    tradition of &quot;designing in code&quot;, we can add domain logic to the Company entity to auto-generate the ticker    symbol from the company name:</p>
<pre>@Implementation(CompanyImpl.class)<br>public interface Company extends Entity {<br> // ...<br>}<br><br>public class CompanyImpl {<br> private Company company;<br> <br> public CompanyImpl(Company company) {<br>  this.company = company;<br> }<br> <br> public void setName(String name) {<br>  company.setName(name);<br>  <br>  name = name.trim();<br>  if (name.length() &gt; 4) {<br>   company.setTickerSymbol(name.substring(0, 4).toUpperCase());<br>  } else {<br>   company.setTickerSymbol(name.toUpperCase());<br>  }<br> }<br>}</pre>
<p>As you see, we can use an annotation to specify an &quot;implementation class&quot; which can contain all of the    domain logic for our entity.  In that class, we will of course need some way of calling back to the original    entity to set data and so on.  Thus, in the implementation class constructor, we'll accept the corresponding    instance and save it as part of the implementor state.  We don't really need the implementation classes to    extend any particular superclass, since they aren't actually inheriting any functionality.</p>
<p>Once we have the defined implementation instance, we can reflectively interrogate it for matching    method signatures and redirect method calls to the corresponding method implementations at will.  If there    is no matching signature, we'll just execute the database operation as per normal and move on.</p>
<p>In the case of <em>Company</em>, the only method with any implementation is the <em>setName(String)</em> method.     This is because we only need to set the ticker symbol when the name changes.  In the implementation    above, we just set the ticker symbol to the first four characters of the name, converted to upper-case.</p>
<p>Astute observers will see an immediate problem with the provided example: it's recursive.  If we're    redirecting method calls on the entity with matching method signatures to the defined implementation, then    our control flow as defined above will look something like this:</p>
<ol>
    <li>Consumer code calls <em>Company#setName(String)</em></li>
    <li>Invocation handler sees <em>setName(String)</em> method signature within <em>CompanyImpl</em> and passes it the     method call, skipping the database-peered implementation</li>
    <li>Defined implementation calls <em>company.setName(name)</em></li>
    <li>Invocation handler sees <em>setName(String)</em> method signature within <em>CompanyImpl</em> and passes it the     method call, skipping the database-peered implementation</li>
    <li>...</li>
</ol>
<p>Minor issues we hath.</p>
<p>The obvious way to avoid this issue is to make sure that any method invocations coming from the    defined implementation are never fed back to the implementation itself.  This breaks the infinite recursion    and still allows the defined implementations to actually access the entity safely.  The trick is in actually    detecting the source of the method call.</p>
<p>Fortunately, Java does provide a mechanism - albeit obfuscated and little-known - which allows    developers to get access to the call stack dynamically.  Actually, it defines two mechanisms for such access,    but one would require starting the application in debug mode, which is something we can't mandate of a    framework's users.  The preferred mechanism is to take advantage of the way Java constructs    exceptions.</p>
<p>In creating a generic <em>RuntimeException</em>, Java actually copies out the meta for the current stack trace    and sticks it in the exception.  This is so that <em>printStackTrace()</em> has something to print.  Java even provides    an API (<em>Throwable#getStackTrace():StackTraceElement[]</em>) to access this stack trace within the exception    dynamically (and without string parsing).  We can use this to check for the defined implementation one step    up on the stack.  If we find that it initiated the method call, we'll skip the re-invocation of the defined    implementation and actually execute the method call normally.  Thus, <em>any</em> calls to an entity from its defined    implementation will skip any implementation logic, avoiding recursion.</p>
<h2>It Lives!</h2>
<p>The product of all of this brainstorming and prototyping has already been created.  What I've been    describing in the code samples provided was not just some theoretical, prototype code but actually working    code which can be run against the <a src="https://activeobjects.dev.java.net">ActiveObjects ORM</a>.</p>
<p>ActiveObjects is designed from the ground up to be as absolutely simple as possible.  Just about all that    is required of you (the API user) is to create the interface mappings and place the appropriate JDBC driver in    the classpath.  All of the details of the database access layer are completely handled by ActiveObjects.  You    can even enable connection pooling simply by placing a pooling library in the classpath (DBCP, C3P0 and    Proxool are currently supported).  ActiveObjects allows you to work with the database as naturally as you    would work with a standard object-oriented class hierarchy, avoiding all of the complications associated with    multi-database deployment and SQL.</p>
<p>ActiveObjects can even generate the database schema for you, just based on your entity interface    definitions.  Alternatively (and a more common scenario), if the schema already exists in some form, but    you've added (or removed) a field, ActiveObjects will generate the appropriate DDL to migrate the existing    schema to the new version.  This means that, as an object-oriented developer, you can think about the    objects themselves, and never give consideration to the underlying database or how they are stored.</p>
<p>Currently, ActiveObjects fully supports the following databases:</p>
<ul>
    <li>MySQL</li>
    <li>Derby</li>
    <li>HSQLDB</li>
    <li>PostgreSQL</li>
    <li>Oracle (migrations don't work due to a bug in the JDBC driver, raw schema generation is available     however)</li>
    <li>MS SQL Server (JTDS and Microsoft drivers)</li>
</ul>
<p>Running your code against any one of these databases is as simple as placing the driver JAR in your    classpath and changing the JDBC URI passed to the EntityManager constructor.  There's no XML, no    properties files to deal with, no configuration cruft whatsoever.</p>
<p>ActiveObjects even supports table name pluralization (if you really want it).  All you have to do is specify    a different <em>TableNameConverter</em>:</p>
<pre>EntityManager manager = new EntityManager(&quot;jdbc:mysql://localhost/test&quot;, &quot;user&quot;, &quot;password&quot;);<br>manager.setTableNameConverter(new PluralizedNameConverter());<br>// ...</pre>
<h2>Conclusion</h2>
<p>ActiveObjects is a powerful, efficient and highly-intuitive Java ORM.  Its syntax is flexible and easy to use,    and its lack of extensive configuration requirements means it can cut out dozens of XML files and hundreds of    lines of code.  By utilizing certain syntax-streamlining features in the Java language, ActiveObjects is able to    easily accommodate almost any schema requirements without bulking up your code or introducing    complexity.</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p></div></body></html>