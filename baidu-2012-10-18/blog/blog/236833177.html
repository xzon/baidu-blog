<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Hibernate vs. Rails: The Persistence Showdown</title></head><body><h1>Hibernate vs. Rails: The Persistence Showdown</h1><div><h1>Hibernate vs. Rails: The Persistence Showdown</h1>
<p> </p>
<p>http://www.theserverside.com/news/1364757/Hibernate-vs-Rails-The-Persistence-Showdown</p>
<p><em>And the wires were all a buzz about Rails...</em> <br>
Much like a few other java folks, such as <a target="_blank" href="http://today.java.net/pub/au/186">Bruce Tate</a> and <a target="_blank" href="http://www.jroller.com/page/dgeary">David Geary</a>, I have been taking a look at a new web framework <a target="_blank" href="http://www.rubyonrails.com/">Rails</a>. Of particular interest to me is its ORM (Object Relational Mapping) tool, <u>ActiveRecord</u>.  Since choosing a technology always involves opportunity costs of some  kind, I have written this article to compare and contrast with another  popular ORM tool, <a target="_blank" href="http://www.hibernate.org/">Hibernate</a>. It summarizes what I've learned about Rails, mainly by stacking it up against Hibernate,  a technology I'm very familiar with.</p>
<h2>The Back Story</h2>
<p>One of the hotter topics on the minds of developers of late has been the rise in discussion about a new framework, <a target="_blank" href="http://www.rubyonrails.com/">Ruby on Rails</a>. Rails is a MVC web framework, conceptually similar to <a href="http://struts.apache.org/">Struts</a> or <a target="_blank" href="http://www.opensymphony.com/webwork/">Webwork</a>, but written in the scripting language <a target="_blank" href="http://www.ruby-lang.org/en/">Ruby</a>, instead of <a target="_blank" href="http://java.sun.com/">Java</a>.  Beyond just a web framework, it offers a number of integrated  technologies, like built in code generation and its own ORM (Object  Relational Mapping) tool, the ActiveRecord. By combining a number of  tools into an single elegant integrated framework, it has led to <a href="http://www.onlamp.com/pub/a/onlamp/2005/01/20/rails.html">claims</a> that Rails development is &quot;at least ten times faster with Rails than you could with a typical Java framework&quot;.</p>
<p>Now the claims and counterclaims might lead one to believe that Rails  either the reincarnated Savior itself or alternatively a foul creature  from the 66th layer of the Abyss. Which one you believe probably depends  on your favorite programming language starts with J or an R.</p>
<strong>What this isn't...</strong>
<p>This is not a Hibernate is <strong>l33t</strong>, Rails <strong>suxxor</strong> article.  Rails appears to have some interesting concepts, but I'm very suspicious  when people start throwing around 10x productivity figures.  After a  first pass, the framework appears to be very fast out of the gate  especially if you are building a pure CRUD <a target="_blank" href="http://www.bookpool.com/sm/0764526413">implementation model</a> web database. However, its hard to see if the development velocity remains that high though.</p>
<h2>Overview</h2>
<p>Based on the research I've done so far, Rails seems very grounded in a  single table/single object mind set. This makes it very well suited for  simple models, with a few associations. The assumptions it make about  database are reasonable and simple to deal with for a <a target="_blank" href="http://en.wikipedia.org/wiki/Greenfield_land">green field</a>  project. Hibernate shines as the object model gets more complicated, or  against existing databases.  Having been around a while longer, it is  more mature and has a lot more features. But lets get into the weeds and  look at some of the differences. Here is a list of concepts and  questions I hope to answer in this article.</p>
<ul>
    <li>Basic Architecture Patterns - Hibernate and Rails each use each use completely different patterns of ORMs. What does that imply?</li>
    <li>Explicitness - Hibernate and Rails define mappings differently,  Hibernate explicitly and Rails implicitly. What does that mean, and how  important is it?</li>
    <li>Associations - Each supports associations, what do they look like for each of them?</li>
    <li>Transitive Persistence Models - How does each tool deal with persisting objects?</li>
    <li>Query Languages - How do you find objects?</li>
    <li>Performance Tuning - What options do I have to tune them?</li>
</ul>
With our road map to understanding laid out, lets dive right in.
<h2>Basic Architecture Differences</h2>
<p>The core difference between Rails ActiveRecord and Hibernate is the  architectural patterns the two are based off of. Rails, obviously, is  using the ActiveRecord pattern, where as Hibernate uses the Data  Mapper/Identity Map/Unit of Work patterns. Just knowing these two facts  gives us some insight into potential differences.</p>
<strong>Active Record Pattern</strong>
<p><strong>ActiveRecord </strong>is &quot;an object that wraps a row in a database table or view, encapsulates database access and adds domain logic on that data&quot;[<a target="_blank" href="http://www.martinfowler.com/books.html">Fowler, 2003</a>].  This means the ActiveRecord has &quot;class&quot; methods for finding instances,  and each instance is responsible for saving, updating and deleting  itself in the database. It's pretty well suited for simpler domain  models, those where the tables closely resemble the domain model. It is  also generally simpler then the more powerful, but complex <strong>Data Mapper</strong> pattern.</p>
<strong>Data Mapper Pattern</strong>
<p>The <strong>Data Mapper</strong> is &quot;a layer of mappers that moves data between  objects and a database while keeping them independent of each other and  the mapper itself&quot;[<a target="_blank" href="http://www.martinfowler.com/books.html">Fowler, 2003</a>]. It moves the responsibility of persistence out of the domain object, and generally uses an <strong>identity map</strong>  to maintain the relationship between the domain objects and the  database. In addition, it often (and Hibernate does) use a Unit of Work  (Session) to keep track of objects which are changed and make sure they  persist correctly.</p>
<strong>General Pattern Implications</strong>
<p>So that covers the basic differences, the general implication of  which should be fairly obvious. The ActiveRecord (Rails) will likely be  easier to understand and work with, but past a certain point more  advanced/complex usages will likely be difficult or just not possible.  The question is is of course, when or if many projects will cross this  line. Let's look at some specifics of the two frameworks. To illustrate  these differences, we will be using code from my &quot;Project <a href="http://www.hbo.com/deadwood/">Deadwood</a>&quot; sample app. (Guess what I've been watching lately.) :)</p>
<h2>The Value of Explicitness</h2>
<p>So what is <a target="_blank" href="http://www.martinfowler.com/ieeeSoftware/explicit.pdf">explicitness</a>  worth?  One of the key &quot;features&quot; of Ruby's ActiveRecord is that you  don't need to specify the fields on class, but rather it dynamically  determines its fields based off the columns in the database. So if you  had a table &quot;miners&quot; that looked like this.</p>
<pre>create table miners (<br>   id BIGINT NOT NULL AUTO_INCREMENT,<br>   first_name VARCHAR(255),<br>   last_name VARCHAR(255),<br>   primary key (id)<br>)</pre>
Your corresponding ruby class (miner.rb) and sample usage looks like this.
<pre>class Miner &lt; ActiveRecord::Base<br>end<br><br>miner.first_name = &quot;Brom&quot;</pre>
<p>On the other hand, your Hibernate class (Miner.java) specifies the fields, getters/setters and xdoclet tags looks like so.</p>
<pre>package deadwood;<br>/**<br> * @hibernate.class table=&quot;miners&quot;<br> */<br>public class Miner {<br>    private Long id;<br>    private String firstName;<br>    private String lastName;<br>    /**<br>     * @hibernate.id generator-class=&quot;native&quot;<br>     */<br>    public Long getId() { return id; }<br>    public void setId(Long id) { this.id = id; }<br><br>    /**<br>     * @hibernate.property column=&quot;first_name&quot;<br>     */<br>    public String getFirstName() { return firstName; }<br>    public void setFirstName(String firstName) { this.firstName = firstName; }<br><br>    /**<br>     * @hibernate.property column=&quot;last_name&quot;<br>     */<br>    public String getLastName() { return lastName; }<br>    public void setLastName(String lastName) { this.lastName = lastName; }<br>}<br><br>miner.setFirstName(&quot;Brom&quot;);</pre>
<p>Now, as I have mentioned before <a target="_blank" href="http://www.patrickpeak.com/page/patrick/20050228#java_vs_ruby_persistence_the">here</a>,  both Rails and Hibernate really only need to specify the field name  once. Hibernate details are in the code, ActiveRecord details are in the  database. So when you are browsing through your ruby code and you see  this...</p>
<pre>class GoldClaim &lt; ActiveRecord::Base<br>end</pre>
<p>The question is, what fields does this object have? You have to fire  up MySQL Front (or whatever) and look at the database schema. When the  number of domain models is small, this isn't a big deal. But when your  project has 40+ tables/50ish domain objects (like a Hibernate project  I'm currently working on), this would seem pretty painful. Ultimately,  this might come down to preference, but having the details in the code  makes it easier to understand and alter.</p>
<h2>Associations</h2>
<p>In the last section, the <u>Miner</u> class we looked at was single table oriented, mapping to a single <u>miners</u>  table. ORM solutions support ways to map associated tables to in memory  objects, Hibernate and Rails are no different. Both handle the most of  the basic mapping strategies. Here's a non-exhaustive list of  association supported by both of them, including the corresponding  Hibernate - Rails naming conventions where appropriate.</p>
<ul>
    <li>Many to One/One to one - belongs_to/has_one</li>
    <li>One to Many (set) - has_many</li>
    <li>Many to Many (set) - has_and_belongs_to_many</li>
    <li>Single Table Inheritance</li>
    <li>Components (mapping &gt; 1 object per table)</li>
</ul>
<p>As a comparative example, lets look at the many to one relationship.  We are going to expand our Deadwood example from part I. We add to the <u>Miner</u> a many to one association with a <u>GoldClaim</u> object. This means there is a foreign key, gold_claim_id in the miners table, which links it to a row in the gold_claims table.</p>
<pre>(Java)<br>public class Miner {<br>   // Other fields/methods omitted<br><br>    private GoldClaim goldClaim;<br>    /**<br>     * @hibernate.many-to-one column=&quot;gold_claim_id&quot;<br>     *         cascade=&quot;save&quot;<br>     */<br>    public GoldClaim getGoldClaim() { return goldClaim; }<br>    public void setGoldClaim(GoldClaim goldClaim) {<br>        this.goldClaim = goldClaim;<br>    }<br>}<br><br>(Rails)<br>class Miner &lt; ActiveRecord::Base<br>    belongs_to :gold_claim<br>end</pre>
<p>Not much real difference here, both do functionally the same thing.  Hibernate uses explicit mapping to specify the foreign key column, as  well as the cascade behavior, which we will talk about next. Saving a <u>Miner</u> will save its associated <u>GoldClaim</u>, but updates and deletes to it won't affect the associated object.</p>
<strong>Transitive Persistence</strong>
<p>Non-demo applications tend to work with big graphs of connected  objects. Its important for an ORM solution to provide a way to detect  and cascade changes from in memory objects to the database, without the  need to manually <u>save()</u> each one. Hibernate features a flexible  and powerful version of this via declarative cascading persistence.  Rails seems to offer a limited version of this, based on the type of  association. For example, Rails seems to emulates Hibernate's <u>cascade=&quot;save&quot;</u> behavior for the <u>belongs_to</u> association by default, as the following Rails listing demonstrates...</p>
<pre>miner = Miner.new(&quot;name&quot; =&gt; &quot;Brom Garrott&quot;)<br>miner.gold_claim = GoldClaim.new( &quot;name&quot; =&gt; &quot;Western Slope&quot;)<br>miner.save # This saves both the Miner and GoldClaim objects<br>miner.destroy # Deletes only the miner row from the database</pre>
<strong>Deleting</strong> Hibernate offers a number of different cascading behaviors for all  associations types, giving it a high degree of flexibility. For example,  setting <u>cascade=&quot;all&quot;</u> will make <u>GoldClaim</u> save, update and delete along with its parent <u>Miner</u>, like so...
<pre>Miner miner = new Miner();<br>miner.setGoldClaim(new GoldClaim());<br>session.save(miner); // Saves Miner and GoldClaim objects.<br>session.delete(miner); // Deletes both of them.</pre>
To be fair, you can make Rails do this, but you have to custom code the behavior as part of the <u>Miner</u> object's life cycle using a callback. <strong>Updating</strong> One difference relates to updating. In Rails, if you want cascading it  only works from the 'has_one' end. So if you want to change the name of  the <u>GoldClaim</u>, this doesn't work.
<pre>miner = Miner.find(@params['id'])<br>miner.gold_claim.name = &quot;Eastern Slope&quot;<br>miner.save</pre>
<p>This does not update the gold_claim.name. From the opposite direction (<u>has_one</u>), this does work...</p>
<pre>class GoldClaim &lt; ActiveRecord::Base<br>    has_one :miner<br>end<br><br>claim = GoldClaim.find(@params['id'])<br>claim.miner.name = &quot;Seth Bullock&quot;<br>claim.save # Saves the miner's name</pre>
<p>By using the cascade=&quot;save-update&quot;, you could get this behavior on  any association, regardless of which table the foreign key lives in.  Hibernate doesn't base the transistive persistence behavior off the  relationship type, but rather the cascade style, which is much more fine  grained and powerful. Next, lets look at how each framework finds the  objects we have persisted.</p>
<h2>Query Languages</h2>
<p>While there have been a number of similarities to this point between  the two frameworks, when the topic comes to query languages,  capabilities and usage starts to differ rapidly. Rails essentially uses  SQL, the well known standard for getting data in and out of databases.  In addition, via the use of dynamic finder methods, it has what I think  of as its own 'mini' language which lets developers write simplified  queries by basically inventing methods. But ultimately everything is  expressed in terms of tables and columns.</p>
<p>On the other hand, Hibernate has its own object oriented query  language (Hibernate Query Language - HQL), which is deliberately very  similar to SQL. How it differs is that it lets developers express their  queries in terms of objects and fields instead of tables and columns.  Hibernate translates the query into SQL optimized for your particular  database. Obviously, inventing a new query language is very substantial  task, but the expressiveness and power of it is one of Hibernate's  selling points. Now let's a take a look at some samples of each of them.</p>
<strong>Rails Insta-Finders</strong>
<p>For simple queries, like 'find by property x and y', Rails lets you  add dynamic finder methods which it will translate into SQL for you.  Suppose for example, we want to find <u>Miner</u>s based on first name and last name, you would write something like this.</p>
<pre>@miners = Miner.find_by_first_name_and_last_name(&quot;Elma&quot;, &quot;Garrott&quot;)</pre>
In addition, the ActiveRecord object provides common methods finder methods that let you pass in the <u>where clause</u>, like these...
<pre># Returns only the first record<br>@miner = Miner.find_first(&quot;first_name = ?&quot;, &quot;Elma&quot;)<br><br># Finds up to 10 miners older than 30, ordered by age.<br>@miners = Miner.find_all [&quot;age &gt; ?&quot;, 30], &quot;age ASC&quot;, 10<br><br># Like find all, but need complete SQL<br>@minersWithSqA = Miner.find_by_sql [<br>        &quot;SELECT m.*, g.square_area FROM gold_claims g, miners m &quot; +<br>        &quot; WHERE g.square_area = ? and m.gold_claim_id = g.id&quot;,  1000]</pre>
<p>The big thing to realize is that since Rails classes have dynamic  fields, all columns returned by the result set are smashed on the <u>Miner</u> object. In the last query, the <u>Miner</u> gets a square_area field that it doesn't normally get. This means the view might have to change, like so...</p>
<pre># Normal association traversing<br>&lt;%= miner.gold_claim.square_area<br><br># Altered query for @minersWithSqA<br>&lt;%= miner.square_area %&gt;</pre>
<strong>Querying for Objects with HQL</strong>
<p>As mentioned before, being able to express in terms of objects and  columns really powerful. While simple queries are definitely easier with  Rails, when you have to start navigating across objects with SQL, HQL  can be very convenient alternative. Let's take a look at our sample  queries for HQL.</p>
<pre>// Find first Miner by name<br>Query q = session.createQuery(&quot;from Miner m where m.firstName = :name&quot;);<br>q.setParameter(&quot;name&quot;, &quot;Elma&quot;);<br>Miner m = (Miner) q.setMaxResults(1).uniqueResult();<br><br>// Finds up to 10 miners older than 30, ordered by age.<br>Integer age = new Integer(30);<br>Query q = session.createQuery(<br>    &quot;from Miner m where m.age &gt; :age order by age asc&quot;);<br>List miners = q.setParameter(&quot;age&quot;, age).setMaxResults(10).list();<br><br>// Similar to join query above, but no need to manually join<br>Query q = session.createQuery(<br>   &quot;from Miner m where m.goldClaim.squareArea = :area&quot;);<br>List minersWithSqA = q.setParameter(&quot;area&quot;, new Integer(1000)).list();</pre>
For the last query, <u>Miner</u> objects always have the same fields,  regardless of how you find them. So unlike the Rails query, in the JSP  view, you still access traverse the association normally, like so.
<pre>${miner.goldClaim.squareArea} &lt;%-- Traverse fields normally --%&gt;</pre>
<p>Having covered some of the basics of fetching objects, let's turn  your attention to how we can make fetching objects fast. The next  section covers the means by which we can tune the performance.</p>
<h2>Performance Tuning</h2>
<p>Beyond just mapping objects to tables, robust ORM solutions need to  provide ways to tune the performance of the queries. One of the risks of  working with ORM's is that you often pull back too much data from the  database. This tends to happen because it its very easy to pull back  several thousand rows, with multiple SQL queries, with a simple  statement like <u>&quot;from Miner&quot;</u>. Common ORM strategies for dealing with this include Lazy fetching, outer join fetching and caching.</p>
<strong>Rails is very very Lazy</strong>
<p>What I mean by lazy is that when you fetch an object, the ORM tool  doesn't fetch data from other tables, until you request the association.  This prevents loading to much unneeded data. Both Rails and Hibernate  support lazy loading associations, but Hibernate allows you to choose  which associations are lazy. For example, here's how it works with  Rails...</p>
<pre>@miner = Miner.find(1) # select * from miners where id = 1<br>@claim = @miner.gold_claim # select * from gold_claim where id = 1</pre>
<p>This leads us to one of the great fallacies of ORM, that Lazy loading is always good. In reality, <strong>lazy loading is only good if you didn't need the data</strong>.  Otherwise, you are doing with 2-1000+ queries what you could have done  with one. This is dreaded N+1 select problem, where to get all the  objects require N selects + 1 original selects. This problem gets much  worse when you deal with collections..</p>
<strong>Outer Joins and Explicit Fetching</strong>
<p>Generally, one of the best way to improve performance is to limit the  number of trips to the database. Better 1 big query than a few small  ones. Hibernate has a number ways its handles the N+1 issue.  Associations can be explicitly flagged for outer join fetching (via <u>outer-join=&quot;true&quot;</u>), and you can add outer join fetching to HQL statements. For example...</p>
<pre>/**<br>* @hibernate.many-to-one column=&quot;gold_claim_id&quot;<br>*           cascade=&quot;save-update&quot; outer-join=&quot;true&quot;<br>*/<br>public GoldClaim getGoldClaim() { return goldClaim;  }<br><br>// This does one select and fetches both the Miner and GoldClaim<br>// and maps them correctly.<br>Miner m = (Miner) session.load(Miner.class, new Long(1));</pre>
<p>In addition, when selecting lists or dealing with collection associations, you can use an explicit outer join fetch, like so...</p>
<pre>// Issues a single select, instead of 1 + N (where N is the # miners)<br>List list = session.find(&quot;from Miner m left join fetch m.goldClaim&quot;);</pre>
<p>The performance savings from this can very significant. On the other  hand, Rails suffers badly from N+1 issues, and has limited means to  solve this problem, other than writing explicit SQL joins, referred to  as <strong>Piggy-back</strong> queries. The trouble is because Rails maps all the fields to the <u>Miner</u>  object, you lose the association objects, meaning you need to alter  your views and how you work with the domain model. Also, the query is  fairly complicated, particularly if there are more than one association  to be fetched. The @minersWithSqA query we did above is an example of a  Piggy back query. In addition, all the additional fields are strings,  losing their original type value. Queries get progressively worse as you  add more associations.</p>
<strong>Caching</strong>
<p>While object caching isn't always going to be helpful or a  performance silver bullet, Hibernate has a huge potential advantage  here. It provides several levels of caching, including a session  (UnitOfWork) level as well as an optional second level cache. You always  use the '1st level' cache, as it prevents circular references and  multiple trips to the database for the same object. Using a second level  cache can allow much of the database state to stay resident in memory.  This is especially useful for frequently read and reference data. Rails  essentially has no options for caching at the database level. (Though it  does support caching for the web tier).</p>
<h2>Conclusion</h2>
<p>While this is by no means a complete coverage, we have looked at some  of the high level differences between the two frameworks. Hopefully you  should have a basic understanding of what the opportunity costs of  either framework are. I have covered the basic architectural patterns  which underly both Rails and Hibernate, as well as a how explicitness  applies to both framework's basic persistent classes. For associations,  there are quite a few more mappings that are possible with an ORM, but  that covers the basics that most developers use.</p>
<p>Beyond the basics, Hibernate adds quite a few more mapping types (I  documented a complete catalog of examples with over 20 mappings in  Hibernate Quickly), including different inheritance strategies, custom  user types, and maps of entity or simple types. While it's simpler to  specify and use simple associations in Rails than in is in Hibernate,  but there is less you can do with them. If you stick to the simple cases  like single tables with a few associations, and you name your tables  and columns right, Rails will likely do just fine, but for more  complicated object models, Hibernate will be a better choice.</p>
<p>Rails and Hibernate are very different when it comes to query  languages. While its not possible to do an exhaustive comparison of  their query languages, generally selects for single objects/tables will  be quicker and easier for Rails, and anything join related is better  suited for Hibernate. Rails use SQL, which is familiar to most  developers, while Hibernate offers HQL a OO query language that  developers will need to learn. In addition, Hibernate offers quite a few  more tuning opportunities, providing the necessary ORM mechanisms, like  outer join fetching, configurable lazy fetching and second level  caching. This further supports the theory that Rails is likely suitable  for smaller projects, but its ORM layer lacks a number of the essential  features that will allow it to scale up to larger projects.</p>
<h2>References</h2>
<ul>
    <li><a target="_blank" href="http://www.patrickpeak.com/">The Art of .war</a> - Patrick's Weblog</li>
    <li><a target="_blank" href="http://www.hibernate.org/">Hibernate</a> - Project Homepage</li>
    <li><a target="_blank" href="http://www.rubyonrails.com/">Ruby on Rails</a> - Project Homepage</li>
    <li><a target="_blank" href="http://www.martinfowler.com/books.html">Patterns of Enterprise Application Architecture</a> - By Martin Fowler</li>
    <li><a target="_blank" href="http://www.onlamp.com/pub/a/onlamp/2005/01/20/rails.html">Getting Rolling with Rails</a> - By Curt Hibbs</li>
</ul>
<h2>About the Author</h2>
<p>Patrick Peak is co-author of <a target="_blank" href="http://www.manning.com/peak">Hibernate Quickly</a></p>
<p class="paragraph">Though he feels very weird about referring to himself in the   third person, Patrick Peak is currently the Chief Technology Officer of Browsermedia,   a Web DevelopmentDesign firm in Bethesda, MD. His focus is on using open-source   as building block for rapid web software development.</p>
He has used most of the leading/popular open source frameworks on numerous projects, including Struts, WebWork, Hibernate and Spring. Current side projects include wrapping up Hibernate Quickly which is being published by Manning Publishing in May 2005. His spare time is generally filled with soccer, mountain biking and kickball.
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p></div></body></html>