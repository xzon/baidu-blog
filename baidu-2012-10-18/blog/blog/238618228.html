<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Scala as the long term replacement for java/javac?</title></head><body><h1>Scala as the long term replacement for java/javac?</h1><div><h3 class="post-title entry-title"><a href="http://macstrac.blogspot.com/2009/04/scala-as-long-term-replacement-for.html">Scala as the long term replacement for java/javac?</a></h3>
<p>http://macstrac.blogspot.com/2009/04/scala-as-long-term-replacement-for.html</p>
<p>Don't get me wrong - I've written tons of Java over the last decade or  so &amp; think its been a great evolutionary step from C++ and Smalltalk   (lots of other languages have helped too like JavaScript, Ruby,  Groovy, Python etc). However I've long wanted a long term replacement to  javac. I even created a <a href="http://groovy.codehaus.org/">language</a> to scratch this itch.<br>
<br>
Java  is a surprisingly complex language (the spec is 600 pages and does  anyone really grok generics in Java?), with its autoboxing (and lovely  NPE's hiding in there), primitive types, icky arrays which are not  collections &amp; general lack of polymorphism across  strings/text/buffers/collections/arrays along with extremely verbose  syntax for working with any kind of data structure &amp; bean properties  and still no closures (even in JDK7) which leads to tons of icky  try/catch/finally crapola unless you use frameworks with new custom APIs  &amp; yet more complexity. Java even has <a href="http://james-iry.blogspot.com/2009/04/java-has-type-inference-and-refinement.html">type inference, it just refuses to use it</a> to let us save any typing/reading.<br>
<br>
This issue becomes even more pressing with there being <a href="http://www.jroller.com/scolebourne/entry/no_more_java_7">no Java7</a>  (which is even more relevant after Snorcle - I wonder if javac is gonna  be replaced with jdkc? :). So I guess javac has kinda reached its  pinacle; closures look unlikely as does any kind of simplification or  progression.<br>
<br>
So whats gonna be the long term replacement for  javac? Certainly the dynamic languages like Ruby, Groovy, Python,  JavaScript have been getting very popular the last few years - lots of  folks like them.<br>
<br>
Though my tip though for the long term replacement of javac is <a href="http://www.scala-lang.org/">Scala</a>. I'm very impressed with it! I can honestly say if someone had shown me the <a href="http://www.amazon.com/Programming-Scala-Comprehensive-Step-step/dp/0981531601/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1240563267&amp;sr=8-1">Programming in Scala</a> book by by Martin Odersky, Lex Spoon &amp; Bill Venners back in 2003 I'd probably have never created Groovy.<br>
<br>
So  why Scala? Scala is statically typed and compiles down to the same fast  bytecode as Java so its usually about as fast as Java (sometimes a  little faster sometimes a little slower). e.g. compare how well <a href="http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&amp;lang=scala&amp;lang2=java&amp;box=1">Scala does</a> in some benchmarks with <a href="http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&amp;lang=groovy&amp;lang2=java&amp;box=1">groovy</a> or <a href="http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&amp;lang=jruby&amp;lang2=java&amp;box=1">jruby</a>. Or <a href="http://stronglytypedblog.blogspot.com/2009/07/java-vs-scala-vs-groovy-performance.html">this</a>.  Note speed isn't everything - there are times when you might want to  trade code thats 10x slower for more productivity and conciseness; but  for a long term replacement for javac speed is important.<br>
<br>
Yet  Scala has type inference - so its typically as concise as Ruby/Groovy  but that everything has static types. This is a good thing; it makes  code comprehension, navigation &amp; documentation much simpler. Any  token/method/symbol you can click on to navigate to the actual  implementation code &amp; documentation. No wacky monkey patching  involved, or doubting of who added a method, when and how - which is  great for large projects with lots of folks working on the same code  over long periods of time. Scala seems to hit the perfect sweet spot  between the consise feel of a dynamic language, while actually being  completely statically typed. So I never have to remember the magic  methods that are available - or run a script in a shell then inspect the  object to see what it really looks like - the IDE/compiler just knows  while you edit.<br>
<br>
Scala has high order functions and closure support along with <a href="http://www.scala-lang.org/node/111">sequence comprehensions</a>  so you can write beautifully concise code. Scala also unifies  functional and OO paradigms beautifully together into a language thats  considerably simpler than Java (though the type system is of a similar  order to truly understand than generics - but then thats usually an  issue for framework creators rather than application code developers).  It also lets folks gradually migrate from a traiditional OO/Java way of  coding to a more functional way - which is particularly relevant for  folks writing concurrent or asynchronous code (which due to the GHz of  chips no longer going up but instead we're getting more cores is  becoming more necessary). You can start the OO way and migrate to using  immutable state if/when you need its benefits. Increasingly functional  programming is becoming more and more important as we try and make  things more concise and higher level (e.g. closures, higher order  functions, pattern matching, monads etc) as well as dealing with  concurrency and asynchrony via immutable state etc.<br>
<br>
Scala also  has proper mixins (traits) so you don't have to muck about with AOP  wackiness to get nice modular code. There's even structural types in  case you really do need some duck typing.<br>
<br>
The thing which most  impresses me is the core language syntax is pretty small and simple (the  spec is about a quarter the size of Java's); but its way more powerful  and flexible and is very easy to extend in <span style="font-weight: bold;">libraries</span> to add new semantics and features. For example see the <a href="http://www.scala-lang.org/node/242">Scala Actors</a>.  So its ideal for creating either embedded DSLs or external DSLs.  There's really no need to have Java , XPath, XSLT, XQuery, JSP, JSTL, EL  and SQL - you can just use Scala with some DSLs here and there  (examples of this later...).<br>
<br>
Scala does take a little bit of  getting used to - I confess the first few times I looked at Scala it  wasn't that pleasing on the eye - with Java you're kinda used to dumb  verbose code which doesn't do very much - it can be quite a shock to see  quite a few symbols at first. (It took me a while to get over the use  of _ in scala which is the 'wildcard' symbol since * is an  identifier/method).<br>
<br>
If you've been doing lots of Java then Scala  does feel quite different at first - (e.g. the order of types &amp;  identifiers in method/variable/parameter declarations - though the  reason for that is to make it easy to miss out redundant type  information).<br>
<br>
e.g. in Java</p>
<blockquote>List&lt;String&gt;<string><string> list = new ArrayList</string></string>&lt;String&gt;<string><string><string><string>()<br>
</string></string></string></string></blockquote> in Scala<br>
<blockquote>val list = new List[String]</blockquote> or if you want to specify exact typing<br>
<blockquote>val list : List[String] = new List[String]<br>
</blockquote> However  if you keep at it, the beauty of Scala soon becomes apparent; its  simplified so many of the gremlins in the Java language, allows you to  write very concise code describing the intent behind the code rather  than the implementation cruft - together with providing a nice migration  path to elegant functional programming which is awesome for building  concurrent or distributed software.<br>
<br>
I highly recommend you take a  look at Scala - with an open mind - and see if (once you're brain  adjusts) you can see its beauty too.<br>
<br>
<span style="font-weight: bold; font-size: 130%;">Some scala links and online presentations</span><br>
<ul>
    <li>I can highly recommend the <a href="http://www.amazon.com/Programming-Scala-Comprehensive-Step-step/dp/0981531601/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1240563267&amp;sr=8-1">Programming in Scala</a>  book by by Martin Odersky, Lex Spoon &amp; Bill Venners - its a great  read and describes the features of Scala and design choices very well.  Its a <span style="font-style: italic;">big</span> book - but you can skip chunks and come back to it later.</li>
    <li>I've only skim read it a little so far but the  <a href="http://programming-scala.labs.oreilly.com/">O'Reilly Scala book</a> looks great too</li>
    <li>the <a href="http://www.scala-lang.org/node/104">Tour of Scala</a>  is a good read if you're short on time and want a quick look at its  syntax; though it can take a little while to truly appreciate why things  are different to Java</li>
    <li>Martin Odersky's <a href="http://developers.sun.com/learning/javaoneonline/2008/pdf/TS-5165.pdf">Scala talk at JavaOne 2008</a></li>
    <li><a href="http://jonasboner.com/">Jonas Bonér</a>'s presentation on <a href="http://www.slideshare.net/jboner/pragmatic-real-world-scala-45-min-presentation">Real-World Scala</a></li>
    <li>Gert's <a href="http://www.anova.be/files/camel-scala.pdf">presentation</a> on how he created the <a href="http://camel.apache.org/">Apache Camel</a> <a href="http://camel.apache.org/scala-dsl.html">DSL for Scala</a></li>
    <li>speaking of internal cool DSLs try this blog post on <a href="http://pragmaticdesign.blogspot.com/2009/04/scala-program-like-you-mean-it.html">program like you mean it</a> with links to some other great internal DSLs for Scala</li>
    <li>a scala version of LINQ for <a href="http://szeiger.de/blog/2008/12/21/a-type-safe-database-query-dsl-for-scala/">type safe querying of JDBC</a> also check out <a href="http://scala.sygneca.com/libs/dbc">dbc</a></li>
    <li>a great presentation on using <a href="http://osgilook.com/2009/05/08/osgi-on-scala/">Scala and OSGi</a> with DSLs</li>
    <li>how to work with <a href="http://www.ibm.com/developerworks/library/x-scalaxml/">Scala and XML</a> (kinda embedded XML, XPath, XSLT, XQuery in neat syntax in the language :) more <a href="http://www.scala-lang.org/node/131">here</a></li>
    <li><a href="http://www.scala-lang.org/docu/files/ScalaByExample.pdf">Scala by example</a></li>
    <li><a href="http://www.geekontheloose.com/images/stories/programming/Scala_Cheatsheet.pdf">Scala cheat sheet</a></li>
    <li>an example showing how to <a href="http://www.scala-lang.org/node/29">create bean style properties</a> (or C# style getters)</li>
    <li>creating a <a href="http://liftweb.blip.tv/">chat demo using Lift</a> or more on the <a href="http://liftweb.net/">Lift site</a></li>
</ul>
If you have a spare hour or so these video talks are great to watch<br>
<ul>
    <li><a href="http://www.parleys.com/display/PARLEYS/Home#talk=27131945;slide=1;title=The%20Feel%20Of%20Scala">The Feel of Scala</a> by Bill Venners</li>
    <li><a href="http://www.infoq.com/presentations/jaoo-spoon-scala">Scala: Bringing Future Languages</a> to the JVM by Lex Spoon</li>
</ul>
Handy Scala frameworks and libraries<br>
<ul>
    <li><a href="http://liftweb.net/">liftweb</a> the rails of scala</li>
    <li><a href="http://code.google.com/p/specs/">specs</a> and <a href="http://www.artima.com/scalatest/">ScalaTest</a>  for BDD and more literate testing showing how a typesafe DSL can help  you write more consise and expressive code that is very IDE friendly</li>
    <li><a href="http://code.google.com/p/scalaz/">scalaz</a> a handy library of utilities</li>
    <li><a href="http://databinder.net/dispatch/Guide">dispatch</a> for working with HTTP/JSON services</li>
</ul>
BTW for those like me who <a href="http://macstrac.blogspot.com/2009/01/jax-rs-as-one-web-framework-to-rule.html">love JAXRS</a> you can now use <a href="http://liftweb.net/">lift</a> templates with <a href="https://jersey.dev.java.net/">Jersey</a> via the new <a href="http://n2.nabble.com/Lift-support-for-Jersey-checked-into-trunk-td3007414.html#a3007414">jersey-lift</a> module.<br>
<br>
As an example of this in action you can check out <a href="http://restmq.fusesource.org/">RestMQ</a>  which is an open source project I've been working on lately to provide a  RESTful API and web console to message orientated middleware which is  built on JAXRS (Jersey), Scala and Lift.<br>
<br>
From a tooling  perspective there's Ant/Maven plugins, an interactive Scala console  (REPL) and IDE plugins for IDEA, Eclipse, NetBeans along with the usual  editors (TextMate/Emacs etc). The IDE plugins are not yet up to the Java  grade, but they are very useful with good code navigation &amp;  completion.<br>
<br>
I've tried the plugins for NetBeans, Eclipse and IDEA  they all have strengths and weaknesses; it seems Scala folks are split  between them all. For code navigation and completion along with maven  support I've found IDEA to be quite good. When you open a Maven pom.xml  it seems to grok the code nicely, finding the scala source so you can  navigate through any type/method to see its documentation/source etc.  (You do typically have to manually add the Scala facet to run/debug  stuff). Though IDEA is not always the best at highlighting syntax errors  as you type. They could all use some work to bring them up to line with  their Java counterparts though - try them out and see which you prefer.<br>
<br>
<span style="font-weight: bold; font-size: 130%;">Scala nits<br>
</span>With  any language there's gonna be bits you love and bits you're not so keen  on. Early impressions of Scala do seem like there's a bit of an attempt  to use a few too many symbols :-; but you don't have to use them all -  you can stick to the Java-ish OO side of the fence if you like. But then  I guess longer term its probably better to use symbols for the 'special  stuff' to avoid clashing with identifiers etc.<br>
<br>
I'm not a massive  fan of the nested import statement, using _root_.java.util.List to  differentiate a 'global' import from a relative import. I'd have  preferred a child prefix. e.g. if you have imported  com.acme.cheese.model.Foo then to import model.impl.FooImpl i'd prefer  an explicit relative prefix, say: import _.impl.FooImpl which would  simplify things a little and more in keeping with Scala's attempt at  simplifying things and removing cruft (being polymorphic to import  java.util._).<br>
<br>
However compared to all the massive hairy warts in  Java, these downsides of Scala are tiny compared to the beauty,  simplicity and power of Scala.<br>
<br>
<span style="font-weight: bold; font-size: 130%;">Conclusion<br>
</span>Given that <a href="http://www.adam-bien.com/roller/abien/entry/java_net_javaone_which_programming">MrJava</a>, <a href="http://blog.headius.com/2009/04/future-part-one.html">MrJRuby</a> and <a href="http://macstrac.blogspot.com/">MrGroovy</a> are all tipping Scala as javac's long term replacement, there might be something in it. So what are you waiting for; get the <a href="http://www.amazon.com/Programming-Scala-Comprehensive-Step-step/dp/0981531601/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1240563267&amp;sr=8-1">Programming in Scala</a> book or the <a href="http://programming-scala.labs.oreilly.com/">O'Reilly Scala book</a> and start having fun :)
<h1>Groovy创始人：Java面临终结 Scala将取而代之</h1>
<p><a href="http://developer.51cto.com/art/200907/134785.htm">http://developer.51cto.com/art/200907/134785.htm</a></p>
<p>Groovy创始人James Strachan前日在其<a href="http://macstrac.blogspot.com/2009/04/scala-as-long-term-replacement-for.html">博客</a>（地址在Blogspot，未架好梯子前请勿随便点击）上发表了一篇文章，题目为《<a href="http://macstrac.blogspot.com/2009/04/scala-as-long-term-replacement-for.html">Scala as the long term replacement for java/javac?</a> 》。以下是正文部分的翻译：</p>
<p>不要误解我的意思——我在过去的这十来年里写了无数的Java代码，并且坚信它相对C++和Smalltalk来说是一个巨大的进步（当然，很多其 它语言也很有帮助，像JavaScript，Ruby，Groovy，Python等）。但是我还是一直期待着能有javac的替代者出现。我甚至还自创 了一门<a href="http://groovy.codehaus.org/">语言</a>（编者注：此处指Groovy）好让我暂时满足一下这种期望。</p>
<p>Java是一种令人惊叹的复杂语言（它的语法规范长达600页，我怀疑到底有没有人能真正理解它），它有自动装箱(Autoboxing)，空指针 异常(NPE)往往就是这时抛出的。其中的基本类型(primitive  type)，字符串/文字/缓冲器/集合类(collections)以及数组缺乏多态性，以至于处理任何数据结构都需要冗长的语法；而且，由于Bean 属性和对闭包支持的缺失（甚至在JDK 7里也仍然还不支持），这会让你的代码里充满了 try/catch/finally  这些语句（除非你使用框架和新的自定义API）。除了这些还有好多数不清的麻烦问题。Java倒是有类型推断（type  inference）功能但却不用，使得我们要多输/读如此大量的代码。</p>
<p>这个问题在没有Java7后变得更加紧迫 （在Snorcle之后它变得更加重要：我不知道javac是不是要被jdkc 取而代之了？）。所以我猜javac可能已经走到了尽头，它看起来根本就没有什么进展或简化了。</p>
<p>那么，从长久来看，谁能取代javac 呢？当然，像Ruby，Groovy，Python，还有JavaScript这些动态语言在过去几年里很受欢迎——很多人喜欢他们。</p>
<p><strong>我认为将来可能替代javac的就是Scala 。</strong>它实在太让我印象深刻了。我甚至可以诚实地说，如果有人在2003年把Martin Odersky，Lex Spoon以及Bill Venners写的那本《Programming in Scala》拿给我看了的话，那我根本就不会再去发明Groovy了。</p>
<p>那么，为什么我会看好Scala呢？Scala是静态类型的，它可以被编译成与Java同样快速的字节码，所以它的速度与Java不分上下（有时快 一点，有时慢一点）。你可以看看 Scala 在与 groovy  或jruby一起进行测试时表现有多好。注意：速度并不是我们追求的唯一目标——有时候我们可能宁肯让代码慢上十倍，也要写得简洁一点；但是如果要取代 javac，速度当然还是很重要的。</p>
<p>Scala已有类型推理(type  inference)功能，因此它和Ruby/Groovy一样简洁，但是它完全是静态类型的。这是很有好处的，它使得理解代码、阅读代码以及编写文档都 简单多了。在任何片段(token)/方法/符号上点击，你都可以跳转到相应的代码或文档中去浏览。不需要打那些怪异的补丁，也不用操心谁什么时候新增了 一个方法——这对于那些需要一个团队一起长期开发的大项目是很有好处的。Scala似乎已经实现了动态语言(dynamic  language)的那种简洁，而实际上它是完全静态类型的。所以，我根本不需要去记哪些魔术方法可用——或是在shell里运行脚本来查看这些对象—— IDE/编译器在你编辑代码时就已经知道这些了。</p>
<p>Scala已经提供了对高阶函数和闭包的支持，另外还支持序列解析（sequence comprehensions)  ，这样你就可以很容易用Scala写出漂亮简洁的代码。Scala还把函数式和面向对象的编程思想很好地统一到了一种语言里，它比Java要明显简单一些 （虽然它的类型体系(type  system)和泛型(generics)需要花费差不同一个数量级的时间去理解，但是，它通常是框架开发者才需要考虑的问题，应用程序开发人员并不需要 涉及）。它也使得从传统的面向对象/Java编程模式向函数式编程的转变变得更加容易——这对于编写并行或异步程序的开发人员尤其意义重大（这是因为现在 芯片的主频已经达到了数个GHz，很难再有提升了；而芯片集成的核心数则在快速增长。51CTO之前曾发布过哪种语言将统治多核时代  再看函数式语言特性一文，对于函数式语言在多核时代的潜力做了相当深入的分析）。你可以在最开始用面向对象的方法编程，然后当你需要它的好处时，就可以迁 移到用不变状态(immutable  state)函数式编程正变得越来越重要，因为我们总是希望能把问题变简单，并且在一个更高的层次上解决它（如闭包，高阶函数，模式匹配，单子 (monad)等），同时我们还需要通过不变状态(immutable state)实现并发和异步。</p>
<p>Scala也有适当的混入(mixin)（特性(trait)） ，所以你不必去摆弄面向对象编程的缺陷来获得模块化的代码。如果你确实需要一些鸭子类型(duck typing)，Scala甚至能为你提供构造类型(structural type)。</p>
<p>最让我印象深刻的一点就是它的核心语法极其精练简洁（它的语法手册只有大概Java的四分之一），但是其方式却更加强大和灵活，而且非常容易通过库 来扩展，添加新的语义和功能。可以看看这个例子：Scala Actors。因此它非常适合用于创建嵌入式DSL或外部DSL  。有了它以后就真没必要再用Java，XPath  ，XSLT，XQuery，JSP，JSTL，EL和SQL这些东西了——你可以在各种各样的场合使用DSL。</p>
<p>Scala确实需要花点时间去习惯——我承认第一次我看Scala时并不觉得顺眼——用了Java之后你就会习惯用一堆冗长的代码来做一点点事，刚 开始时我们也都不会一看到几个符号就觉得有多惊讶。（我花了好长一段时间才习惯Scala里用_作“通配符”，因为在Scala里是用作标识符/方法）。</p>
<p>如果你一直在写Java，那么最开始确实会觉得Scala很不一样（如在声明方法/变量/参数时在类型或标识符上加上阶，虽然那样做的原因是为了能更方便地略去一多余的类型信息）。</p>
<p>例如，在Java中的写法：</p>
<p>List&lt; String&gt; list = new ArrayList&lt; String&gt;()</p>
<p>在Scala中的写法：</p>
<p>val list = new List[String]</p>
<p>或者，如果你要指定确切的类型的话：</p>
<p>val list : List[String] = new List[String]</p>
<p>但是如果你坚持用上一段时间，Scala优美的一在很快就显现出来。它对Java里的许多地方进行了简化，让你可以用非常简洁的代码就描述出意图， 而不用花上大段代码去实现细节——同时还为你提供了一条迁移到函数式编程的不错途径，这对于编写并发和分布式程序是非常有利的。</p>
<p>我强烈建议你学习一下Scala：以开放的心态看看（当你的思维转过来后）你是否能发现它的美丽之处。</p>
<p><strong>一些Scala资料的链接和在线演示文档</strong></p>
<p>&gt; 我强烈推荐由 Martin Odersky，Lex Spoon 和 Bill Venners编写的《<a href="http://www.amazon.com/Programming-Scala-Comprehensive-Step-step/dp/0981531601/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1240563267&amp;sr=8-1">Programming in Scala</a>》 一书。它非常好地介绍了Scala的特点以及设计时的选择。这本书相当厚，但是你可以先跳着读，必要时再深入细节。</p>
<p>&gt; 《<a href="http://programming-scala.labs.oreilly.com/">O'Reilly Scala book</a>》这本书我只跳着读了一点，但是看起来也非常不错。</p>
<p>&gt; 如果你想在短时间内就知道个大概语法，那么可以看看《<a href="http://www.scala-lang.org/node/104">Tour of Scala</a>》。不过看了之后你也还得花上一些时间来真正理解为什么它跟Java会有这样那样的不同。</p>
<p>&gt; Martin Odersky 的JavaOne 2008上<a href="http://developers.sun.com/learning/javaoneonline/2008/pdf/TS-5165.pdf">关于Scala的演说</a></p>
<p>&gt;<a href="http://jonasboner.com/">Jonas Bonér</a>在<a href="http://www.slideshare.net/jboner/pragmatic-real-world-scala-45-min-presentation">Real-World Scala</a>上作的报告</p>
<p>&gt; Gert's的关于他如何创建 <a href="http://camel.apache.org/">Apache Camel</a> <a href="http://camel.apache.org/scala-dsl.html">DSL for Scala</a> 的介绍</p>
<p>&gt; 用于<a href="http://szeiger.de/blog/2008/12/21/a-type-safe-database-query-dsl-for-scala/">JDBC类型安全查询</a>的一个Scala版LINQ，顺便再了解下<a href="http://scala.sygneca.com/libs/dbc">DBC</a>。</p>
<p>&gt; 一份非常不错的报告，介绍了把<a href="http://osgilook.com/2009/05/08/osgi-on-scala/">Scala 和OSGi </a>与DSL结合使用</p>
<p>&gt; 如何使用<a href="http://www.ibm.com/developerworks/library/x-scalaxml/">Scala和XML</a> （ 语言里已经自带了处理XML，XPath ， XSLT， XQuery的简洁语法）</p>
<p>&gt; <a href="http://www.scala-lang.org/docu/files/ScalaByExample.pdf">Scala的例子</a></p>
<p>&gt; <a href="http://www.geekontheloose.com/images/stories/programming/Scala_Cheatsheet.pdf">Scala快速参考表</a></p>
<p>&gt; 这个例子显示了如何创建的<a href="http://www.scala-lang.org/node/29">bean风格的属性</a>（或C ＃风格的getter函数）</p>
<p>&gt; 创建一个<a href="http://liftweb.blip.tv/">用Lift实现的聊天演示程序</a>或查看<a href="http://liftweb.net/">Lift网站</a>上的更详细介绍</p>
<p>如果你还有一些空余时间的话，这些视频资料也非常不错</p>
<p>&gt; Bill Venners所发表的<a href="http://www.parleys.com/display/PARLEYS/Home#talk=27131945;slide=1;title=The%20Feel%20Of%20Scala">The Feel of Scala</a></p>
<p>&gt; Lex Spoon所作的<a href="http://www.infoq.com/presentations/jaoo-spoon-scala">Scala： 把未来的语言带到JVM里来</a></p>
<p><strong>好用的Scala框架和库</strong></p>
<p>&gt; <a href="http://liftweb.net/">liftweb</a> ：Scala的rails</p>
<p>&gt; <a href="http://code.google.com/p/specs/">语言规范</a>和<a href="http://www.artima.com/scalatest/">ScalaTest for BDD </a>以及其它一些入门测试(literate testing)能让你体会到类型安全的DSL对于编写IDE友好 的简洁代码有多大帮助。</p>
<p>&gt; <a href="http://code.google.com/p/scalaz/">scalaz</a> 是一个很有用的例程库。</p>
<p>&gt; 用<a href="http://databinder.net/dispatch/Guide">HTTP /JSON服务进行调度</a></p>
<p>另外，顺便说一下，对于那些像我一样一喜欢JAXRS的，现在可以通过jersey-lift模块使用lift模板和Jersey了。</p>
<p>作为这的实例，你可以看看RestMQ，这是一个我最近也参与了的开源项目，它旨在为面向消息的中间件提供REST风格的API和Web控制台，它也是基于JAXRS（Jersey），Scala，Lift构建的。</p>
<p>至于开发工具方面，有Ant/Maven插件，它带有一个交互式Scala控制台（REPL）和一个用于IDEA的IDE插件，还有 Eclipse，NetBeans，以及TextMate，Emacs这些通用编辑器，都可以供你选择。在IDE插件的丰富程度上与Java还是有差距 的，但是这些工具所提供的代码导航和自动补全功能还是很有用的。</p>
<p>我试用过NetBeans，Eclipse和IDEA这几个IDE上的插件，它们都各有优劣。看起来，Scala的追随者也因为这些工具分裂成了几 派。如果要代码导航和自动补全，那我发现IDEA非常不错。当你打开一个Maven  pom.xml，它好像就能非常好地自动解析代码，找出Scala源，那样你就能很方便地在任意的类型/方法以及它们对应的文档/源代码中跳转浏览。（通 常你必须在运行/调试任务里手动添加Scala）。不过IDEA在错误代码高亮上并不是最好的。在作上一些弥补后，它们都能变得与对应的Java工具一样 好用。试试这几个工具吧，找出你最习惯的那个。</p>
<p><strong>Scala Nit</strong></p>
<p>任何一种语言都有你喜欢的一面，也有你不是那么热衷的一面。Scala给你的最初印象可能确实是符号太多了点，但是你并不需要使用所有的这些符号 ——如果你喜欢的话，你可以继续沿用很多Java里的东西。但我想到了那个时候最好还是用符号来实现“特殊任务”以避免标识符冲突。</p>
<p>我对嵌套的引入声明不太感冒，使用_root_.java.util..List来把一个”全局“引入和相对引入区别开来。我还更愿意使用子引入。 例如，如果你引入了com.acme.cheese.model.Foo，然后，为了引入model.impl.FooImpl，我就更喜欢用一个明确的 相对前缀，就像：import _.impl.FooImpl。这对简化任务有一些好处，对于保持和Scala的简洁性就更有帮助了。</p>
<p>然而，和Java里大把的毛病相比，再考虑到Scala的优美，简洁和强大，Scala的这一些负面因素和根本不算什么了。</p>
<p><strong>结语：  </strong></p>
<p>既然  MrJava（<a href="http://www.adam-bien.com/roller/abien/entry/java_net_javaone_which_programming">Adam Bien</a>），MrJRuby（<a href="http://blog.headius.com/2009/04/future-part-one.html">Charles Nutter</a>） 和 MrGroovy（作者本人） 都认为Scala将会是javac的的替代者，那肯定是有些原因的。那你还在等什么呢？赶快去买《Programming in Scala》 或 《O'Reilly Scala book》一探究竟吧！</p>
<hr>
<p>这篇博文发布后，立刻有很多Scala，Groovy和Java开发者进行了回复。Scala的创始人Martin Odersky也对这篇文章发表了自己的赞赏之词。以下是Martin的留言：</p>
<p>James，感谢你的认可！这对我来说意义重大。我相信，如果我们一起努力向Java开发者们展示现在在JVM上更加美好的语言选择，我们大家都会因此而得到好处。感谢你在这方面带了个好头。</p>
<p>根据我对Groovy的了解（很可惜的，我的了解没有你了解Scala那样多），它看起来并非是意图填补同一块领域的。Groovy的吸引力在于它是一个语法接近Java的动态脚本语言。Scala的吸引力在于它是一个强类型的，静态的，结合函数式和面向对象的语言。</p>
<p>此外还有很多精彩的评论，51CTO译者对这些评论进行了一些筛选，挑出部分翻译如下：</p>
<p><strong>Scala的体验</strong></p>
<p>去年，我在做一些调查项目时把Scala引进到了我的小Java车间里。</p>
<p>如今Scala成为了我们最主要的编程语言。</p>
<p>通过使用Scala，我们现在可以构建类型系统(type  system)，跟踪总结以前所做项目的经验教训，并用它来替代我们过去以模型为导向(model-driven)的开发方式。然后，我们利用函数分发 (pass around functions)的特性来改进组件的参数化。</p>
<p>总之，对于建立可重用的组件，Scala提供了一套比Java更好的机制。</p>
<p><strong>C#和Java？</strong></p>
<p>我觉得你可以去看看C#。它解决了你在Java中遇到的许多问题。如果你不喜欢微软的话，就可以试试.NET的开源替代版本Mono。</p>
<p><strong>有关Scala和F#</strong></p>
<p>其实，在.NET平台里与Scala对应的语言并不是C#，而是F#。不管什么时候，我都更倾向于使用Scala，而不是F#，原因如下：</p>
<p>1  ）在F#文化里，面向对象看起来并不重要。在所有讲F#的书里，都必定有一章介绍类，然后，剩余部分就是专门讲解函数式。相比之下，Odersky在发明 Scala时，并没有照搬Java的这一套机制，而是通过对象类型、特性(trait）、增强的可见性规则(visibility  rule)等概念扩展并超过了Java的这一套机制。Scala使得像我这样有根深蒂固面向对象思想的开发人员觉得很舒适，它提供的函数式语法特性让我可 以用来把代码变得非常简洁。</p>
<p>2 ）F#比Scala看起来更接近人类语言，初看起来这似乎是好事。不幸的是，由于开发者很少需要写类型说明(type  annotation)，大部分代码里也都没写，这就使得代码变得更加难于理解。在Scala里，至少要声明参数类型，而且最好也声明一个方法的返回类 型，除了那些一目了然的情况。</p>
<p>3  ）F#一直力求尽量往OCAML的语法靠拢，所以它在语法也真是没有什么创新之处。而Scala则是博取众长，吸纳了各种语言的优点。此外，它还让人感觉 有些机制并不是必须的，而是为了让开发者更好地表达意图而加入的。通过加入隐式转换(implicit  conversion)，析取器(extractor)这些功能，Martin从我这里得到了很大的帮助。</p>
<p>4  ）在我看来，Java程序员学会Scala比从C#到F#的过渡要容易得多。大体上来说，原因是Java程序员不需要花很大的代价入门，Scala可以直 接被当作一门少了些模板(boilerplate)的Java使用。当程序员渐渐熟练后，他就可以开始发掘函数式编程的威力了。在其它任何的面向对象/函 数式编程语言里我都找不出可以这样过渡学习的。</p>
<p><strong>Groovy盖棺定论了？</strong></p>
<p>James，我一直在留意你的博客，这篇文章写得棒极了，堪称高超。你发过一份声明说不会再继续把Groovy开发得更强大了（51CTO编者 注：James  Strachan在写这篇博文之前很久已经离开了Groovy开发团队），这份声明影响力很大，而且几乎可以说是给Groovy盖棺定论了。</p>
<p>我们有一个面向最终用户的数据处理软件，然后我们选择的是Groovy （而没用Jython和JRuby  ）来作为实现各种功能扩展（从对变量编写公式到编写脚本）的途径。你们在开发Groovy所写的代码很多都是粘合代码(glue  code)(对核心语言起补充作用）。我们充分利用Groovy所支持的这些特性与MS  Office产品和Web服务进行整合。我真的希望，如果你们的开发团队更中意Scala的话，也请尽量让我们到时候在Scala里也能用上这些有用的 库。</p>
<p><strong>James Strachan对上文的回复</strong></p>
<p>我不认为任何一种主要的JVM语言会消失，肯定会一直有一大帮人继续维护Groovy, Jruby, Cojure, Jython, Rhino等。</p>
<p>JVM中最大的一点好处就是这些语言很容易共存，重用另一种语言的代码也非常容易。因此，只要相信大众的选择，就不用担心会选错开发语言。</p>
<p>而且我也并不认为Scala会是Ruby/Groovy/Fan这些动态语言的替代者；大多数情况下性能还是很重要的。对于一个快速、静态类型的编 译器来说，过去Java显然是第一选择——但是现在，Scala才是首选——这是因为Java已经显出老态了。（它可能永远也不会支持闭包，永远也不会考 虑支持类型推断等新特性）。</p>
<p>自从发现了类型推断的威力之后，我实际上越来越觉得动态类型(就是很简洁的代码实现功能）的动机变得越来越难以琢磨了。比如说，你可以用Scala 写一些脚本，它就会像Ruby/Groovy一样进入”读取-执行-打印 循环“(Read-Evaluate-Print Loop, REPL)。</p>
<p>但是我发这篇文章的目的并不是要挑起Scala拥护者和Ruby/Grovy/Clojure/JavaScript这些动态语言支持者之间的战争 ——我只是想让被Java一叶障目的开发者们意识到，这个世上已经有了比Java更好的静态类型语言：这门语言有他们所想要的全部功能（还附带有Java 最需要增强的功能）。所有这一切，都能在这门语言里用简洁、优美的代码表示出来（尽管这门语言和Java确定有些不太一样，并且需要你经历一个学习曲 线）。</p>
<p><strong>附录：有关Scala编程语言的其他言论</strong></p>
<p>&gt; Java的不足可以比作大量的毛疣，那么同样在Scala中，这些地方正是表现了Scala的美、简化和强大。——James Strachan</p>
<p>&gt; 在一个社区（java.net booth）举办的和James  Gosling对话会议上，一个与会者问了一个非常有意思的问题：“除了Java，现在你会把哪种语言运行于JVM之上？”。答案是惊人地快速简 洁：Scala。——Java之父James Gosling</p>
<p>&gt;  我必须说Scala看起来是是现在Java王座的继承人。其他在JVM的语言看起来不可能有Scala那样的能力来取代Java，Scala背后的推动力 是无可置疑的。Scala还不是一个动态语言，但是它有许多流行动态语言的特性，例如它的灵活富类型系统，稀疏和简洁的语法，函数式语言和面向对象范式的 完美结合。Scala的缺点：“太复杂”或者“太丰富”，但这些可以通过编码规范很好避免，从而构建更健壮的编辑器和工具，以及指导多语言开发者明白如何 更好地使用Scala。Scala是JVM上静态语言的重生，它也像JRuby那样延伸平台的性能，这些都是Java做不到的。——JRuby核心开发者 Charles Nutter</p></div></body></html>