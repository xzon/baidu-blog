<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Lift web framework (scala)</title></head><body><h1>Lift web framework (scala)</h1><div><p>Lift web framework (scala)</p>
<p>http://liftweb.net/docs/getting_started.html</p>
<h5>&quot;Lift is the kind of web framework that enables you as a developer to concentrate on the big picture. Strong, expressive typing and higher-level features like the built-in Comet support allow you to focus on innovating instead of the plumbing. Building a rich, real-time web application like Novell Pulse requires a framework with the power of Lift under the covers.&quot;</h5>
<h2>It's Chat App Time</h2>
<p><strong>Author</strong>: Mads Hartmann Jensen <br>
<strong>Code co-author</strong>: David Pollak</p>
<p>I have the honor to represent the demo that David Pollak gives all the time, it's the ubiquitous Lift chat app.</p>
<p>In this article I'll show how you can create a comet-enabled chat application using Lift. I will show all the code you need to get it working and walk through the lines step by step to give you an understanding of what's happening. In the end I'll show how to enhance the application with some extra functionality and a few effects.</p>
<p>Before we begin I want to say a quick word about comet in case it's the first you've heard of it. Comet describes a model where the client sends a request to the server. The request is hanging till the server has something interesting to response. As soon as the server responses another request is made. The idea is to give the impression that the server is notifying the client of changes on the server.</p>
<p>To get started install the <a href="http://code.google.com/p/simple-build-tool/">Simple Build Tool</a> (aka sbt) and download the <a href="http://github.com/lift/lift_sbt_prototype/tarball/Lift_20">TAR</a> or <a href="http://github.com/lift/lift_sbt_prototype/zipball/Lift_20">Zip</a> of the default Lift project and un-tar or un-zip the file.</p>
<p>Now <em>cd</em> into the new folder and type <code>sbt update</code> to grab the dependencies.</p>
<p>Next, spark up your editor of choice and create the <em>src/main/scala/code/comet/Chat.scala</em> file. Put the following code into Chat.scala (before you get all cranky-like that we're mixing mark-up and logic, the step after this one will show how to separate the two):</p>
<pre><code>package code.comet<br> <br>import net.liftweb._<br>import http._<br>import actor._<br> <br>object ChatServer extends LiftActor with ListenerManager {<br> <br> private var messages = List(&quot;Welcome&quot;)<br> <br> def createUpdate = messages<br> <br> override def lowPriority = {<br> case s: String =&gt; messages ::= s ; updateListeners()<br> }<br>}<br> <br>class Chat extends CometActor with CometListener { <br> <br> private var msgs: List[String] = Nil <br> <br> def registerWith = ChatServer <br> <br> override def lowPriority = {<br> case m: List[String] =&gt; msgs = m; reRender(false) <br> } <br> <br> def render = { <br> &lt;div&gt;<br> &lt;ul&gt;<br> {<br> msgs.reverse.map(m =&gt; &lt;li&gt;{m}&lt;/li&gt;)<br> }<br> &lt;/ul&gt;<br> &lt;lift:form&gt;<br> {<br> SHtml.text(&quot;&quot;, s =&gt; ChatServer ! s)<br> }<br> &lt;input type=&quot;submit&quot; value=&quot;Chat&quot;/&gt;<br> &lt;/lift:form&gt;<br> &lt;/div&gt;<br> }<br>}</code></pre>
<p>In your <em>src/main/webapp/index.html</em> file, put the tag: <code>&lt;lift:comet type=&quot;Chat&quot;/&gt;</code> and run the app by typing the following in your console:</p>
<pre><code>sbt ~jetty-run</code></pre>
Now browse to <em>http://localhost:8080</em> with multiple browsers and you have your chat app. Pretty cool huh? Lets walk through the code to figure out how it all fits together.
<pre><code>object ChatServer extends LiftActor with ListenerManager {<br> <br> private var messages = List(&quot;Welcome&quot;)<br> <br> def createUpdate = messages<br> <br> override def lowPriority = {<br> case s: String =&gt; messages ::= s ; updateListeners()<br> }<br>}</code></pre>
<p>We're doing a couple of things here. In the first line we're defining a chat server as an object (singleton) that's a <a target="_blank" href="http://main.scala-tools.org/mvnsites/liftweb-2.0/framework/scaladocs/net/liftweb/actor/LiftActor.html">LiftActor</a> and that can manage listeners by mixing in the <a target="_blank" href="http://main.scala-tools.org/mvnsites/liftweb-2.0/framework/scaladocs/net/liftweb/http/ListenerManager.html">ListenerManager</a> trait.</p>
<p>In the implementation of our ChatServer we're creating a private list of strings that we'll use to store the messages posted by the clients. The createUpdate method is called when the updateListeners method needs a message to send to the subscribed Actors. Here's it's simply returning all the messages posted to the server.</p>
<p>Lastly we're overriding the lowPriority method where we're pattern matching against the messages sent to us. If the message is a string we're simply adding it to the list of messages and telling all the listeners that something happened by invoking the updateListeners method which we got by mixing in the ListenerManager trait.</p>
<p>lowPriority is just one of three methods (lowPriority, mediumPriority, hightPriority) you can override to process the messages. As the names may suggest the three methods lets you prioritize your messages.</p>
<pre><code>class Chat extends CometActor with CometListener {</code></pre>
<p>Here we're defining our chat component that knows how to push updates to the browser and interact with the ChatServer.</p>
<pre><code>private var msgs: List[String] = Nil</code></pre>
<p>This is where we'll store our local state.</p>
<pre><code>def registerWith = ChatServer</code></pre>
<p>Here the component is registrering itself with the ChatSever so it will get notified of any changes.</p>
<pre><code>override def lowPriority = {<br> case m: List[String] =&gt; msgs = m; reRender(false)<br>}</code></pre>
<p>This is where we implement how our component will handle the messages from our ChatServer. We're simply updating our local state (msgs) and invoking reRender(false). false tells Lift that we don't want to rerender the entire page but just the comet component.</p>
<pre><code>def render = {<br> &lt;div&gt;<br> &lt;ul&gt;<br> {<br> msgs.reverse.map(m =&gt; &lt;li&gt;{m}&lt;/li&gt;)<br> }<br> &lt;/ul&gt;<br> &lt;lift:form&gt;<br> {<br> // a &lt;lift:form&gt; is an Ajax form. Define our<br> // input box that sends the message to the chat server<br> SHtml.text(&quot;&quot;, s =&gt; ChatServer ! s)<br> }<br> &lt;input type=&quot;submit&quot; value=&quot;Chat&quot;/&gt;<br> &lt;/lift:form&gt;<br> &lt;/div&gt;<br>}</code></pre>
<p>Here we're telling the component how to render itself. But, <strong>OMG</strong>... we've mixed view logic with our Scala code, gaaakkk... sputter... barf. Yes, Lift allows you to mix view into your business logic, but it's a choice. Here's how we can break the code out to separate the view from the logic. The critical thing to keep in mind is that we did not change our logic at all in order to achieve the separation.</p>
<p>First, let's update our view (<em>src/main/webapp/index.html</em>) to:</p>
<pre><code>&lt;lift:comet type=&quot;Chat&quot;&gt;<br> &lt;ul&gt;<br> &lt;chat:line&gt;<br> &lt;li&gt;&lt;chat:msg/&gt;&lt;/li&gt;<br> &lt;/chat:line&gt;<br> &lt;/ul&gt;<br> &lt;lift:form&gt;<br> &lt;chat:input/&gt;<br> &lt;input type=&quot;submit&quot; value=&quot;chat&quot;/&gt;<br> &lt;/lift:form&gt;<br>&lt;/lift:comet&gt;</code></pre>
<p>The view now contains the definition of the layout with &quot;bind points&quot; where dynamic content will be inserted.</p>
<p>Next, let's update our Chat component's render method. Replace the def render = line through the end of the file (except the closing brace) with:</p>
<pre><code>// import NodeSeq... yes, this can be done inside any scope in Scala<br>import scala.xml.NodeSeq<br><br>def render =<br> bind(&quot;chat&quot;, // the namespace for binding<br> &quot;line&quot; -&gt; lines _, // bind the function lines<br> &quot;input&quot; -&gt; SHtml.text(&quot;&quot;, s =&gt; ChatServer ! s))<br><br>private def lines(xml: NodeSeq): NodeSeq =<br> msgs.reverse.flatMap(m =&gt; bind(&quot;chat&quot;, xml, &quot;msg&quot; -&gt; m))</code></pre>
<p>Instead of using inline xhtml we're using the bind method. You'll find the bind method in the <a target="_blank" href="http://main.scala-tools.org/mvnsites/liftweb-2.0/framework/scaladocs/net/liftweb/util/BindHelpers$object.html">BindHelpers</a> trait and it is used to bind real content to the binding points of your templates.</p>
<p>In this code we're binding content to tags with the namespace <em>chat</em>. The last argument of bind is repeatable and accepts <a target="_blank" href="http://main.scala-tools.org/mvnsites/liftweb-2.0/framework/scaladocs/net/liftweb/util/BindHelpers.BindParam.html">BindParam</a>. So the second and third line of the bind statement are really instances of BindParam and should be read: &quot;replace the tag <code>&lt;chat:line&gt;</code> with the return value of invoking lines&quot; and &quot;replace the tag <code>&lt;chat:input&gt;</code> with the return value of invoking the text method on the SHtml object&quot;. <br>
You might notice that we aren't specifying which xml to bind to in our bind statements like we've done previously. This is because the markup passed to the comet component when it is instantiated (i.e. every child node of <code>&lt;lift:comet type=&quot;Chat&quot;&gt;</code>) is kept around and that's what we're binding against.</p>
<p>The method <span>lines</span> simply takes a NodeSeq and returns a NodeSeq. It reverses the list of messages so the newest message will be at the end of the list and flatMaps the list of messages into the proper xhtml by using the bind method. Note that we have to use flatMap instead of map, because map would result in a Seq[NodeSeq] instead of the expeced NodeSeq (Seq[Node]).</p>
<p>The text method of the <a target="_blank" href="http://main.scala-tools.org/mvnsites/liftweb-2.0/framework/scaladocs/net/liftweb/http/SHtml$object.html">SHtml</a> object returns an input field. The method takes two normal arguments and a repeatable one. The first is the initial value of the input field and the second is a function that takes a string and returns Any (<em>(String) =&gt; Any</em>). This function will be invoked when the form is submitted. Our function takes a string s and sends that string to our ChatServer using the bang (!) method.</p>
<p>I hope this has helped you gain a better understanding of what the code does. Now, it would be quite dull if all I did was recite the demo that David has done numerous times - Lets see if I can't spice the demo application up a bit to provide some extra functionality.</p>
<p>Lets add the following to our application</p>
<ul>
    <li>It should be possible to delete messages</li>
    <li>When a message is deleted/added it should fade out/in</li>
</ul>
<p>To achieve this lets start editing the view (<em>src/main/webapp/index.html</em>) so it looks like this:</p>
<pre><code>&lt;lift:comet type=&quot;Chat&quot;&gt;<br> &lt;ul id=&quot;ul_dude&quot;&gt;<br> &lt;chat:line&gt;<br> &lt;li&gt;&lt;chat:msg/&gt; &lt;chat:btn/&gt;&lt;/li&gt;<br> &lt;/chat:line&gt;<br> &lt;/ul&gt;<br> &lt;lift:form&gt;<br> &lt;chat:input/&gt;<br> &lt;input type=&quot;submit&quot; value=&quot;chat&quot;/&gt;<br> &lt;/lift:form&gt;<br>&lt;/lift:comet&gt;</code></pre>
<p>Not a whole lot change in the view, we simply added a new tag <code>&lt;chat:btn/&gt;</code> and added an id attribute to the <code>&lt;ul&gt;</code> tag. So lets fast forward to the exciting part. Changing the <em>ChatServer</em> and <em>Chat</em>.</p>
<p>Start by adding the following imports to your <em>src/main/scala/code/comet/Chat.scala</em> file:</p>
<pre><code>import js._<br>import JsCmds._<br>import js.jquery.JqJsCmds.{AppendHtml, FadeOut, Hide, FadeIn}<br>import java.util.Date<br>import scala.xml._</code></pre>
<p>Now that we've got the right classes imported lets start looking at the actual code, again in your <em>src/main/scala/code/comet/Chat.scala</em> file add the following:</p>
<pre><code>sealed trait ChatCmd<br><br>object ChatCmd {<br> implicit def strToMsg(msg: String): ChatCmd =<br> new AddMessage(Helpers.nextFuncName, msg, new Date)<br>}<br><br>final case class AddMessage(guid: String, msg: String, date: Date) extends ChatCmd<br>final case class RemoveMessage(guid: String) extends ChatCmd</code></pre>
<p>In the two last lines we're creating two case classes (the final keyword means you can't subclass them). We're going to send instances of these classes between the client and server instead of strings as we did earlier. We're also creating an object named ChatCmd which has an implicit conversion from string to AddMessage as this will simplify the code in Chat as we'll be able to send the string the user entered in the input field and let the implicit conversion do the work of instantiating an instance of AddMessage.</p>
<p>The <code>Helpers.nextFuncName</code> simply creates a unique string based on the current time and a random String generation. We use it here as a unique id for both AddMessage and RemoveMessage.</p>
<p>Now lets take a look how we need to change the ChatServer:</p>
<pre><code>object ChatServer extends LiftActor with ListenerManager {<br> <br> private var messages: List[ChatCmd] = List(&quot;Welcome&quot;)<br> <br> def createUpdate = messages<br> <br> override def lowPriority = {<br> case s: String =&gt; messages ::= s ; updateListeners()<br> case d: RemoveMessage =&gt; messages ::= d ; updateListeners()<br> }<br>}</code></pre>
<p>Instead of using a list of strings to store our messages we're using a list of ChatCmd (both AddMessage and RemoveMessage are subclasses of ChatCmd). The lowPriority message has also changed a bit. We're pattern matching against the message and if it's a string we simply add it to the list of ChatCmd ... but wait ... String isn't a subclass of ChatCmd so surely this doesn't compile. Oh, but it does, this is where our implicit conversion from String to AddMessage comes in handy. The compiler does notice that String isn't a subclass of ChatCmd but before it starts complaining it checks if there is any implicit conversion in scope that might be able to solve the type problem and in this case there is.</p>
<p>Finally lets take a look at the Chat. Replace the following implementation of Chat with the one currently in your file:</p>
<pre><code>class Chat extends CometActor with CometListener { <br> private var msgs: List[ChatCmd] = Nil <br> private var bindLine: NodeSeq = Nil<br><br> def registerWith = ChatServer <br> <br> override def lowPriority = {<br> case m: List[ChatCmd] =&gt; {<br> val delta = m diff msgs<br> msgs = m<br> updateDeltas(delta)<br> }<br> } <br><br> def updateDeltas(what: List[ChatCmd]) {<br> partialUpdate(what.foldRight(Noop) {<br> case (m: AddMessage , x) =&gt;<br> x &amp; AppendHtml(&quot;ul_dude&quot;, doLine(m)) &amp;<br> Hide(m.guid) &amp; FadeIn(m.guid, TimeSpan(0),TimeSpan(500))<br> case (RemoveMessage(guid), x) =&gt;<br> x &amp; FadeOut(guid,TimeSpan(0),TimeSpan(500)) &amp;<br> After(TimeSpan(500),Replace(guid, NodeSeq.Empty))<br> })<br> }<br><br> def render =<br> bind(&quot;chat&quot;, // the namespace for binding<br> &quot;line&quot; -&gt; lines _, // bind the function lines<br> &quot;input&quot; -&gt; SHtml.text(&quot;&quot;, s =&gt; ChatServer ! s)) // the input<br> <br> private def lines(xml: NodeSeq): NodeSeq = {<br> bindLine = xml<br> val deleted = Set((for {<br> RemoveMessage(guid) &lt;- msgs<br> } yield guid) :_*)<br><br> for {<br> m @ AddMessage(guid, msg, date) &lt;- msgs.reverse if !deleted.contains(guid)<br> node &lt;- doLine(m) <br> } yield node<br> }<br><br> private def doLine(m: AddMessage): NodeSeq =<br> bind(&quot;chat&quot;, addId(bindLine, m.guid),<br> &quot;msg&quot; -&gt; m.msg,<br> &quot;btn&quot; -&gt; SHtml.ajaxButton(&quot;delete&quot;, <br> () =&gt; {<br> ChatServer ! <br> RemoveMessage(m.guid)<br> Noop}))<br> <br><br> private def addId(in: NodeSeq, id: String): NodeSeq = in map {<br> case e: Elem =&gt; e % (&quot;id&quot; -&gt; id)<br> case x =&gt; x<br> }<br>}</code></pre>
<p>Bam, If you restart the jetty server and browse to http://localhost:8080 after pasting in the above code you should have a chat application with fancy fading messages and the ability to delete old messages. I hope this is enough to keep your motivated as we walk through the code. Lets take it from the top:</p>
<pre><code>private var msgs: List[ChatCmd] = Nil <br>private var bindLine: NodeSeq = Nil<br><br>def registerWith = ChatServer</code></pre>
<p>We're declaring a list of ChatCmd which we'll use as our local state (ChatCmd instead of String) and a NodeSeq called bindLine which I'll talk about later when we're using it. We're still registering with ChatServer.</p>
<pre><code>override def lowPriority = {<br> case m: List[ChatCmd] =&gt; {<br> val delta = m diff msgs<br> msgs = m<br> updateDeltas(delta)<br> }<br>}</code></pre>
<p>Again, the lowPriority method is the one that deals with the messages sent from the ChatServer. We're pattern matching against the messages and if it's a list of ChatCmd we're calculating the difference between the new list and our local state using the diff method on List and store the result in the variable delta. Then we're replacing our local state with the new list and finally we call updateDeltas with delta. Now lets take a look at what updateDeltas actually does:</p>
<pre><code>def updateDeltas(what: List[ChatCmd]) {<br> partialUpdate(what.foldRight(Noop) {<br> case (m: AddMessage , x) =&gt;<br> x &amp; AppendHtml(&quot;ul_dude&quot;, doLine(m)) &amp;<br> Hide(m.guid) &amp; FadeIn(m.guid, TimeSpan(0),TimeSpan(500))<br> case (RemoveMessage(guid), x) =&gt;<br> x &amp; FadeOut(guid,TimeSpan(0),TimeSpan(500)) &amp;<br> After(TimeSpan(500),Replace(guid, NodeSeq.Empty))<br> })<br>}<br></code></pre>
<p>We're calling partialUpdate which is declared in CometActor and takes a <a target="_blank" href="http://main.scala-tools.org/mvnsites/liftweb-2.0/framework/scaladocs/net/liftweb/http/js/JsCmd.html">JsCmd</a> as it's only argument. As the name may suggest partialUpdate is used to do partial updates of your comet component. The exciting part of updateDeltas is how we convert a List[ChatCmd] into a JsCmd. Lets take a look.</p>
<p>We declared <em>what</em> as an argument of updateDeltas. We're calling foldRight on <em>what</em> which is a method on List that has the following method signature <code>foldRight [B](z : B)(f : (A, B) =&gt; B) : B</code>. Unless you're used to reading Scala code this doesn't help you much, so here's the explanation of foldRight from the Scala Library Documentation: <q>Combines the elements of this list together using the binary function f, from right to left, and starting with the value z</q>.</p>
<p>In our case we're currying it with Noop which extends JsCmd and basically is an empty javascript statement. In the binary function we're pattern matching against the arguments which is the current element from the list starting from the right-most element and the cumulated value of foldRight so far.</p>
<p>If the element is an instance of AddMessage we're doing a couple of things, first off we're chaining javascripts calls using the &amp; method (okay, you can call it an operator, but it's a method with a symbolic name). The left-most argument well be invoked before the right-most one. We're also using the AppendHtml object declared in <a target="_blank" href="http://main.scala-tools.org/mvnsites/liftweb-2.0/framework/scaladocs/net/liftweb/http/js/jquery/JqJsCmds$object.html">JqJsCmds</a> which has an apply method <code>def apply(uid: String, content: NodeSeq): JsCmd</code> that takes the id of the node to append html to, in this case it's our UL tag with the id <em>ul_dude</em>. The second argument is the NodeSeq to append. In this case we're calling the doLine method with our instance of AddMessage. Well go through that method in due time don't worry. For the second argument of the first CmdPair we're chaining together another CmdPair where we're hiding the html we've just created using the <a target="_blank" href="http://main.scala-tools.org/mvnsites/liftweb-2.0/framework/scaladocs/net/liftweb/http/js/jquery/JqJsCmds/Hide.html">Hide</a> class and then we're using the <a target="_blank" href="http://main.scala-tools.org/mvnsites/liftweb-2.0/framework/scaladocs/net/liftweb/http/js/jquery/JqJsCmds/FadeIn.html">FadeIn</a> object to fade in the message. Had this not been a demo I would probably have added a css class to the newly created messages with the display property set to none and then simply fade in the messages ones added.</p>
<p>In the second match statement we're using Scala Extractors to fetch the value guid of RemoveMessage. For more information about extractors read <a target="_blank" href="http://www.scala-lang.org/node/112">this</a>. If the unapply method on RemoveMessage was successful (i.e. returned Some) we're using CmdPair once more. First we're fading out the message using <a target="_blank" href="http://main.scala-tools.org/mvnsites/liftweb-2.0/framework/scaladocs/net/liftweb/http/js/jquery/JqJsCmds/FadeOut.html">FadeOut</a> and then we're creating an instance of <a target="_blank" href="http://main.scala-tools.org/mvnsites/liftweb-2.0/framework/scaladocs/net/liftweb/http/js/JsCmds/After.html">After</a> which allows us to invoke a JsCmd after waiting for the amount of time specified in the instantiation of After. The JsCmd we're handing to After is an instance of <a target="_blank" href="http://main.scala-tools.org/mvnsites/liftweb-2.0/framework/scaladocs/net/liftweb/http/js/JsCmds/Replace.html">Replace</a> which we use to replace the node with id guid with NodeSeq.Empty (i.e. nothing).</p>
<p>In each case we're using the &amp; method to combine the new JsCmd with the cumulated JsCmd which means that the entire foldRight method wil results in a JsCmd that will remove all unwanted messages and add all the new ones on the fly with Javascript. Neat!</p>
<p>The render method hasn't changed so we can skip that. The lines method however has, so lets take a look at it:</p>
<pre><code>private def lines(xml: NodeSeq): NodeSeq = {<br> bindLine = xml<br> val deleted = Set((for {<br> RemoveMessage(guid) &lt;- msgs<br> } yield guid) :_*)<br><br> for {<br> m @ AddMessage(guid, msg, date) &lt;- msgs.reverse if !deleted.contains(guid)<br> node &lt;- doLine(m) <br> } yield node<br>}</code></pre>
<p>The first thing we're doing is storing the xml in the private variable bindLine (the one I mentioned earlier). We're storing it because we need to use it in the doLine method that I'll explain next. Next we're creating a local variable <em>deleted</em> that we'll use to store the guid of all the messages that should be deleted. We find all the deleted messages by using a for comprehension. We're yielding the guild of all the objects in msgs (our local list of messages) by using the RemoveMessage extractor (which I explained earlier) in our for-comprehension. The for-comprehension returns a List so if we pass it to Set(..) we'll get a Set with Lists instead of a Set of String. To avoid this we're using :_* which tells scala to pass each element of the list to Set as a separate argument.</p>
<p>Next we're using yet another for-comprehension. This time we want to do something with all the instances in msgs (reversed) that isn't part of set of deleted messages. In the second line we're storing the result of invoking doLine with the message. Again we're yielding the result of the for-comprehension so the result of the for-comprehension will be NodeSeq.</p>
<p>Finally it's time to take a look at doLine:</p>
<pre><code>private def doLine(m: AddMessage): NodeSeq =<br> bind(&quot;chat&quot;, addId(bindLine, m.guid),<br> &quot;msg&quot; -&gt; m.msg,<br> &quot;btn&quot; -&gt; SHtml.ajaxButton(&quot;delete&quot;, <br> () =&gt; {<br> ChatServer ! <br> RemoveMessage(m.guid)<br> Noop}))</code></pre>
<p>We're using the bind message to bind content to nodes with the prefix chat in the NodeSeq returned by calling addId with bindLine and the guid of the AddMessage passed to doLine. We'll look at addId next. The new thing in this bind statement is the invocation of SHtml.ajaxButton(...). The AjaxButton of the <a target="_blank" href="http://main.scala-tools.org/mvnsites/liftweb-2.0/framework/scaladocs/net/liftweb/http/SHtml$object.html">SHtml object</a> takes two arguments, the text of the button and a function that takes zero arguments and returns a JsCmd that will get invoked when the button is clicked. In this case we're setting the value of the button to delete and the function sends a RemoveMessage with the guid of the current message to the ChatServer followed by Noop.</p>
<p>Now lets take a look at the very last method:</p>
<pre><code>private def addId(in: NodeSeq, id: String): NodeSeq = in map {<br> case e: Elem =&gt; e % (&quot;id&quot; -&gt; id)<br> case x =&gt; x<br>}</code></pre>
<p>It takes a NodeSeq and a String. It simply matches against the NodeSeq: If it's an Elem (scala.xml.Elem) it simply adds the attribute id with the value of the argument id. If it's anything else (well it has to be NodeSeq or a subclass of NodeSeq or else the compiler would have complained) it just returns that.</p>
<p>And thats it! I hope this have given you some taste of what Lift is able to do. If you have any feedback please don't hesitate to communicate it to the <a target="_blank" href="http://groups.google.com/group/liftweb">community</a>.</p>
<p> </p>
<p> </p>
<p> </p></div></body></html>