<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Using Tomcat internal HTTP protocol standalone</title></head><body><h1>Using Tomcat internal HTTP protocol standalone</h1><div><p><span class="title"><font color="#000000">Using Tomcat internal HTTP protocol standalone</font></span></p>
<p>http://www.webweavertech.com/costin/archives/000420.html<br>
http://www.webweavertech.com/costin/archives/000421.html</p>
<p>tomcat源码品读 coyote</p>
<p><font color="#000000"><span class="title">Using Tomcat internal HTTP protocol standalone ( part I )</span> </font></p>
<p>For very special cases, when you want maximum performance, smaler code size, and no flexibility - you can use directly the tomcat coyote connector. Embedding&Acirc; the connector is quite easy, but implementing a request needs a bit of understanding into how tomcat internal optimizations work. Let's start with starting the http protocol:</p>
<pre>/** Start http on the port. It creates an internal thread pool. This method doesn't block, all processing <br>     * will be done in the thread pool.<br>     * <br>     * @param port<br>     * @throws Exception<br>     */ <br>    private static void startHttp(int port) throws Exception {<br>        Http11Protocol proto=new Http11Protocol();<br>        proto.setPort(port);<br><br>        proto.setAdapter(new MyAdapter());<br>       <br>        proto.init();<br>        proto.start();<br><br>    }</pre>
There are a few other params you can set to tune the protocol, including adding support for SSL, tunning the thread pool, etc. <br>
<br>
The dependencies are tomcat-coyote.jar, tomcat-http.jar, tomcat-util.jar, commons-logging.jar and commons-modeler.jar.&Acirc; Modeler and jmx could be refactored out, but&Acirc; since JMX is part of JDK1.5 and&Acirc; so usefull in many other ways, it's probably better to leave it in.<br>
<br>
The important class is the adapter, where the request processing takes place. <br>
<br>
<pre>static class MyAdapter implements Adapter {<br><br>        public void service(Request req, Response res) throws Exception {<br>            System.out.println(&quot;Incoming request &quot; + req.queryString().toString());<br>            res.setStatus(200);<br><br>            // tomcat doesn't use a stream internally - so the object can be recycled and avoids<br>            // buffer to buffer copy.<br><br>            // To write to the stream, tomcat uses 'byte chunk' - a buffer optimized for char-byte conversions<br>            // This is similar with NIO buffers<br>            ByteChunk myChunk=new ByteChunk();<br><br>            // let's just send some bytes - more advanced mechanism later<br>            String hello=&quot;hello&quot;;<br>            byte helloBytes[]=hello.getBytes();<br>            myChunk.setBytes( helloBytes, 0, helloBytes.length);<br><br><br>            res.doWrite(myChunk);<br>        }<br>    }</pre>
You would obviously have to do all the dispatching in the service() method - at this level there is no web.xml or servlets. This would be usefull for very limited use cases - say you have incoming SOAP or XML-RPC requests, or&Acirc; you want to&Acirc; serve very specialized requests. What you gain in performance, by eliminating all layers, is lost in flexibility.<br>
<a name="more"></a><span class="posted">Posted by costin at August 25, 2005 10:41 PM </span>
<p><font color="#000000"><span class="title">Using Tomcat Coyote ( part II )</span> </font></p>
<p>Memory management is the most important thing to keep in mind when working with Coyote. Just like most other servers - and Apache is a great example - we put a lot of effort into minimizing the buffer copy and allocation overhead in the critical path. Apache2 uses memory pools and bucket brigades - the first improves the allocation times, the second reduces the buffer copy.&Acirc; In Coyote, ByteChunk is used to reduce copy, and aggressive recycling of each object is minimizing the GC overhead.<br>
<br>
When working with Coyote, you need to understand few classes:</p>
<ul>
    <li>ByteChunk is the main buffer used in tomcat. At core, it is similar with a java.nio.ByteBuffer, but with many additional methods optimized to work on the bytes. The main thing to keep in mind is that we want to avoid copy - the data from the network should be manipulated in place as much as possible. Eventually higher-level objects like OutputStream will have to be created to support the servlet API, but as long as you're in the low-layer, you should use ByteChunk and its peers as much as possible. There are few sets of methods:
    <ul>
        <li>StringBuffer or ByteBuffer style append,&Acirc; allowing the buffer to grow to an optional limit. When the limit is reached - the buffer can flush itself to a sink.</li>
        <li>Read methods - called strangely 'substract', allowing it's use for implementing input streams and parsing the request.</li>
        <li>few of the String methods, but operating on the byte buffer<small><small>:</small></small>&Acirc; equals, equalsIgnoreCase, startsWith, startsWithIgnoreCase, findChar(s), findNotChars, indexOf(),&Acirc; .</li>
        <li>few conversion methods - getInt, getLong - parsing the bytes directly, without conversion to chars and strings.</li>
    </ul>
    </li>
    <li>MessageBytes is a union of a ByteChunk, a String,&Acirc; a CharChunk, an int and a date. This is mainly used to represent headers. The headers are read as bytes, in the ByteChunk ( pointers to the input ByteChunk are used, no copy is made ). Some of the headers are never used, so no conversion to String is made until the user asks for their string value. Internal header processing can be made in the ByteChunks themself, at least in the common cases. Another function of the MessageBytes is to delay the charset decoding of headers until the right encoding is known. Most of the conversions are optimized to minimize allocations and operate directly on buffers.</li>
    <li>C2BConverter and B2CConverter are used for the byte[] and char[] charset decoding. It provides the a lot&Acirc; of optimization over Writer/Reader as NIO does. In future, when tomcat will use NIO - those classes can be simply substituted with CharsetEncoder and CharsetDecoder. The performance should be similar, but it'll be cleaner.</li>
    <li>MimeHeaders - headers are represented by MessageBytes, with the conversion to String or int performed on demand ( most headers will never be requested by user ). Like all other internal classes, the common case operates without generating garbage.</li>
</ul>
A code example:<br>
<pre>class MyAdapter implements Adapter {<br>        /** Get the C2BConverter, which allows writing strings and chars to the output.<br>  */<br>        protected C2BConverter getOut(final Response res) throws IOException {<br>            // You can fine tune the buffers. In a real app - this should be reused, this is just <br>            // an example to show how the buffers are used.<br>            final ByteChunk myChunk=new ByteChunk( 1024 );<br>            myChunk.setLimit(4096);<br>            C2BConverter out=new C2BConverter( myChunk, &quot;UTF8&quot; );<br><br>            // You can set limit to -1, add to it, and explicitly write when you<br>            // want to, or you can have it write automatically when the buffer is filled.<br>            myChunk.setByteOutputChannel( new ByteChunk.ByteOutputChannel() {<br>                public void realWriteBytes(byte cbuf[], int off, int len) throws IOException {<br>                    res.doWrite(myChunk);<br>                }<br>            });<br>            return out;<br>        }<br><br>        public void service(Request req, final Response res) throws Exception {<br>            System.out.println(&quot;Incoming request: uri=&quot; + req.requestURI() +<br>                    &quot; queryString=&quot; + req.queryString().toString() +<br>                    &quot; protocol=&quot; + req.protocol().toString());<br><br>            res.setStatus(200);<br><br>            res.setHeader( &quot;foo&quot;, &quot;bar&quot;);<br>            res.setContentType(&quot;text/plain&quot;);<br><br>            // We must explicitely flush the headers.<br>            res.sendHeaders();<br><br>            // tomcat doesn't use a stream internally - so the object can be recycled and avoids<br>            // buffer to buffer copy.<br><br>            // To write to the stream, tomcat uses 'byte chunk' - a buffer optimized for char-byte conversions<br>            // This is similar with NIO buffers<br>            C2BConverter out=getOut(res);<br><br><br>            // You can also add bytes<br>            //ByteChunk myChunk=out.getByteChunk();<br>            //String h=&quot;hellow&quot;;<br>            //byte hB[]=h.getBytes();<br>            //myChunk.append( hB, 0, hB.length);<br>            <br>            out.convert(&quot;Hello World&quot;);<br>            // make sure all the chars are sent to the byte[].<br>            // Unlike OutputStream/Writer - you can mix char and bytes, but you must remember to flush when switching.<br>            out.flushBuffer();<br><br>            // Send it to the stream. Output will also be sent when the buffer is full, based on the limit<br>            // Buffer size is set with myChunk.setLimit()<br>            out.getByteChunk().flushBuffer();<br><br>            // final processing<br>            res.finish();<br><br>            // Alternatively, you can use a growing ByteChunk and write it explicitely:<br>            //res.doWrite(myChunk);<br>            req.recycle();<br>            res.recycle();<br>        }<br>      }</pre>
<br>
<br>
<a name="more"></a><span class="posted">Posted by costin at August 28, 2005 04:03 PM </span>
<p>=======================================</p>
<pre>package com.demo;<br><br>import java.io.IOException;<br><br>import org.apache.coyote.Adapter;<br>import org.apache.coyote.Request;<br>import org.apache.coyote.Response;<br>import org.apache.coyote.http11.Http11Protocol;<br>import org.apache.tomcat.util.buf.ByteChunk;<br>import org.apache.tomcat.util.buf.C2BConverter;<br>import org.apache.tomcat.util.net.SocketStatus;<br><br><br>public class Start {<br> /** Start http on the port. It creates an internal thread pool. This method doesn't block, all processing <br>     * will be done in the thread pool.<br>     * <br>     * @param port<br>     * @throws Exception<br>     */ <br>    private static void startHttp(int port) throws Exception {<br>        Http11Protocol proto=new Http11Protocol();<br>        //Http11NioProtocol proto=new Http11NioProtocol();<br><br>        proto.setPort(port);<br><br>        proto.setAdapter(new MyAdapter());<br>       <br>        proto.init();<br>        proto.start();<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      while(true){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      }<br>    }<br><br>    static class MyAdapter implements Adapter {<br><br>//        public void service(Request req, Response res) throws Exception {<br>//            System.out.println(&quot;Incoming request &quot; + req.queryString().toString());<br>//            res.setStatus(200);<br>//<br>//            // tomcat doesn't use a stream internally - so the object can be recycled and avoids<br>//            // buffer to buffer copy.<br>//<br>//            // To write to the stream, tomcat uses 'byte chunk' - a buffer optimized for char-byte conversions<br>//            // This is similar with NIO buffers<br>//            ByteChunk myChunk=new ByteChunk();<br>//<br>//            // let's just send some bytes - more advanced mechanism later<br>//            String hello=&quot;hello&quot;;<br>//            byte helloBytes[]=hello.getBytes();<br>//            myChunk.setBytes( helloBytes, 0, helloBytes.length);<br>//<br>//<br>//            res.doWrite(myChunk);<br>//        }<br>        protected C2BConverter getOut(final Response res) throws IOException {<br>            // You can fine tune the buffers. In a real app - this should be reused, this is just <br>            // an example to show how the buffers are used.<br>            final ByteChunk myChunk=new ByteChunk( 1024 );<br>            myChunk.setLimit(4096);<br>            C2BConverter out=new C2BConverter( myChunk, &quot;UTF8&quot; );<br><br>            // You can set limit to -1, add to it, and explicitly write when you<br>            // want to, or you can have it write automatically when the buffer is filled.<br>            myChunk.setByteOutputChannel( new ByteChunk.ByteOutputChannel() {<br>                public void realWriteBytes(byte cbuf[], int off, int len) throws IOException {<br>                    res.doWrite(myChunk);<br>                }<br>            });<br>            return out;<br>        }<br><br>        public void service(Request req, final Response res) throws Exception {<br>            System.out.println(&quot;Incoming request: uri=&quot; + req.requestURI() +<br>                    &quot; queryString=&quot; + req.queryString().toString() +<br>                    &quot; protocol=&quot; + req.protocol().toString());<br><br>            res.setStatus(200);<br><br>            res.setHeader( &quot;foo&quot;, &quot;bar&quot;);<br>            res.setContentType(&quot;text/plain&quot;);<br><br>            // We must explicitely flush the headers.<br>            res.sendHeaders();<br><br>            // tomcat doesn't use a stream internally - so the object can be recycled and avoids<br>            // buffer to buffer copy.<br><br>            // To write to the stream, tomcat uses 'byte chunk' - a buffer optimized for char-byte conversions<br>            // This is similar with NIO buffers<br>            C2BConverter out=getOut(res);<br><br><br>            // You can also add bytes<br>            //ByteChunk myChunk=out.getByteChunk();<br>            //String h=&quot;hellow&quot;;<br>            //byte hB[]=h.getBytes();<br>            //myChunk.append( hB, 0, hB.length);<br>            <br>            out.convert(&quot;Hello World&quot;);<br>            // make sure all the chars are sent to the byte[].<br>            // Unlike OutputStream/Writer - you can mix char and bytes, but you must remember to flush when switching.<br>            out.flushBuffer();<br><br>            // Send it to the stream. Output will also be sent when the buffer is full, based on the limit<br>            // Buffer size is set with myChunk.setLimit()<br>            out.getByteChunk().flushBuffer();<br><br>            // final processing<br>            res.finish();<br><br>            // Alternatively, you can use a growing ByteChunk and write it explicitely:<br>            //res.doWrite(myChunk);<br>            req.recycle();<br>            res.recycle();<br>        }<br><br><br><br>  @Override<br>  public boolean event(Request req, Response res, SocketStatus status) throws Exception {<br>   System.out.println(status.name());<br>   return false;<br>  }<br>    }<br>    <br>    public static void main(String args[]) throws Exception{<br>     Start.startHttp(8080);<br>    }<br><br><br>}</pre>
<p>hxzon:在网页浏览器中输入网址，如http://localhost:8080/material?p=1&amp;s=2，网页显示</p>
<pre>Hello World</pre>
<p>控制台输出如下：</p>
<p>2010-10-28 9:25:07 org.apache.coyote.http11.Http11Protocol init<br>
信息: Initializing Coyote HTTP/1.1 on http-8080<br>
2010-10-28 9:25:07 org.apache.coyote.http11.Http11Protocol start<br>
信息: Starting Coyote HTTP/1.1 on http-8080<br>
Incoming request: uri=/material queryString=p=1&amp;s=2 protocol=HTTP/1.1<br>
Incoming request: uri=/favicon.ico queryString=null protocol=HTTP/1.1<br>
Incoming request: uri=/favicon.ico queryString=null protocol=HTTP/1.1</p></div></body></html>