<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>编程语言的发展趋势及未来方向（2）：声明式编程与DSL</title></head><body><h1>编程语言的发展趋势及未来方向（2）：声明式编程与DSL</h1><div><p> </p>
<p>编程语言的发展趋势及未来方向（2）：声明式编程与DSL</p>
<p><a href="http://blog.zhaojie.me/2010/04/trends-and-future-directions-in-programming-">http://blog.zhaojie.me/2010/04/trends-and-future-directions-in-programming-languages-by-anders-2-declarative-programming-and-dsl.html</a></p>
<p>这是<a href="http://en.wikipedia.org/wiki/Anders_Hejlsberg">Anders Hejlsberg</a>在<a href="http://channel9.msdn.com/posts/adebruyn/TechDays-2010-Developer-Keynote-by-Anders-Hejlsberg/">比利时TechDays 2010所做的开场演讲</a>。</p>
<p> </p>
<p><a target="_blank" href="http://img.zhaojie.me/blog/prog-lang-trends-anders/9.png"><img src="http://img.zhaojie.me/blog/prog-lang-trends-anders/9-thumbnail.png"></a></p>
<p>这里先从<a href="http://en.wikipedia.org/wiki/Declarative_programming">声明式（Declarative）编程</a>谈起。</p>
<p><a target="_blank" href="http://img.zhaojie.me/blog/prog-lang-trends-anders/10.png"><img src="http://img.zhaojie.me/blog/prog-lang-trends-anders/10-thumbnail.png"></a></p>
<p>目前我们在编写软件时大量使用的是<a href="http://en.wikipedia.org/wiki/Imperative_programming">命令式（Imperative）编程</a>语言，例如C#，Java或是C++等等。这些语言的特征在于，写出的代码除了表现出&ldquo;什么（What）&rdquo;是你想做的事情之外，更多的代码则表现出实现的细节，也就是&ldquo;如何（How）&rdquo;完成工作。这部分代码有时候多到掩盖了我们原来问题的解决方案。比如，你会在代码里写for循环，if语句，a等于b，i加一等等，这体现出机器是如何处理数据。首先，这种做法让代码变得冗余，而且它也很难让执行代码的基础设施更聪明地判断该如何去执行代码。当你写出这样的命令是代码，然后把编译后的中间语言交给虚拟机去执行，此时虚拟机并没有多少空间可以影响代码的执行方式，它只能根据指令一条一条老老实实地去执行。例如，我们现在想要并行地执行程序就很困难了，因为更高层次的一些信息已经丢失了。这样，我们只能在代码里给出&ldquo;How&rdquo;，而不能体现出&ldquo;What&rdquo;的信息。</p>
<p>有多种方式可以将&ldquo;What&rdquo;转化为更为&ldquo;声明式&rdquo;的编程风格，我们只要能够在代码中体现出更多&ldquo;What&rdquo;，而不是&ldquo;How&rdquo;的信息，这样执行环境便可以更加聪明地去适应当前的执行要求。例如，它可以决定投入多少CPU进行计算，你的当前硬件是什么样的，等等。</p>
<p><a target="_blank" href="http://img.zhaojie.me/blog/prog-lang-trends-anders/11.png"><img src="http://img.zhaojie.me/blog/prog-lang-trends-anders/11-thumbnail.png"></a></p>
<p>我之前提到过，现在有两种比较重要的成果，一是<a href="http://en.wikipedia.org/wiki/Domain-specific_">DSL</a>（Domain Specific Language，领域特定语言），另一个则是<a href="http://en.wikipedia.org/wiki/Functional_programming">函数式编程</a>。</p>
<p>其实DSL不是什么新鲜的玩意儿，我们平时一直在用类似的东西，比如，SQL，CSS，正则表达式，有的可能更加专注于一个方面，例如<a href="http://en.wikipedia.org/wiki/Mathematica">Mathematica</a>，<a href="http://en.wikipedia.org/wiki/Logo_%28programming_">LOGO</a>等等。这些语言的目标都是特定的领域，与之相对的则是<a href="http://en.wikipedia.org/wiki/General-purpose_programming_">GPPL</a>（General Purpose Programming Language，通用目的编程语言）。</p>
<p><a target="_blank" href="http://img.zhaojie.me/blog/prog-lang-trends-anders/12.png"><img src="http://img.zhaojie.me/blog/prog-lang-trends-anders/12-thumbnail.png"></a></p>
<p>对于DSL而言其实并没有一个明确的定义，在这里我也不打算为它下个定义，例如<a href="http://en.wikipedia.org/wiki/Unified_Modeling_">UML</a>甚至根本没有特定的语法。不过我这里会谈一些我觉得比较重要的东西。</p>
<p><a target="_blank" href="http://img.zhaojie.me/blog/prog-lang-trends-anders/13.png"><img src="http://img.zhaojie.me/blog/prog-lang-trends-anders/13-thumbnail.png"></a></p>
<p><a href="http://martinfowler.com/">Martin Fowler</a>提出DSL应该分为外部DSL及内部DSL两种，我认为这种划分方式还是比较有意义的。外部DSL是自我包含的语言，它们有自己特定语法、解析器和词法分析器等等，它往往是一种小型的编程语言，甚至不会像GPPL那样需要源文件。与之相对的则是内部DSL。内部DSL其实更像是种别称，它代表一类特别API 及使用模式。这里我会给你们看一些示例。</p>
<p><a target="_blank" href="http://img.zhaojie.me/blog/prog-lang-trends-anders/14.png"><img src="http://img.zhaojie.me/blog/prog-lang-trends-anders/14-thumbnail.png"></a></p>
<p>这些是我们平时会遇到的一些外部DSL，如这张幻灯片上表现的XSLT，SQL或是Unix脚本。外部DSL的特点是，你在构建这种DSL时，其实扮演的是编程语言设计者的角色，这个工作并不会交给普通人去做。外部DSL一般会直接针对特定的领域设计，而不考虑其他东西。<a href="http://en.wikipedia.org/wiki/James_Gosling">James Gosling</a>曾经说过这样的话，每个配置文件最终都会变成一门编程语言。你一开始可能只会用它表示一点点东西，然后慢慢你便会想要一些规则，而这些规则则变成了表达式，可能你还会定义变量，进行条件判断等等。而最终它就变成了一种奇怪的编程语言，这样的情况屡见不鲜。</p>
<p>事实上，现在有一些公司也在关注DSL的开发。例如以前在微软工作的<a href="http://en.wikipedia.org/wiki/Charles_Simonyi">Charles Simonyi</a>提出了<a href="http://en.wikipedia.org/wiki/Intentional_programming">Intentional Programming</a>的概念，还有一个叫做<a href="http://en.wikipedia.org/wiki/JetBrains">JetBrains</a>的公司提供一个叫做<a href="http://en.wikipedia.org/wiki/JetBrains_MPS">MPS（Meta Programming System）</a>的产品。最近微软也提出了自己的<a href="http://en.wikipedia.org/wiki/Oslo_%28Microsoft%29">Oslo</a>项目，而在Eclipse世界里也有个叫做<a href="http://www.eclipse.org/Xtext/">Xtext</a>的东西，所以其实在这方面现在也有不少人在尝试。</p>
<p>我在观察外部DSL时，往往会关注它的语法到底提供了多少空间，例如一种XML的方言，利用XML方言的好处在于有不少现成的工具可用，这样可以更快地定义自己的语法。</p>
<p><a target="_blank" href="http://img.zhaojie.me/blog/prog-lang-trends-anders/15.png"><img src="http://img.zhaojie.me/blog/prog-lang-trends-anders/15-thumbnail.png"></a></p>
<p>而内部DSL，正像我之前说的那样，它其实只是一系列特别的API及使用模式的别称。这里则是一些LINQ查询语句，<a href="http://rubyonrails.org/">Ruby on Rails</a>以及<a href="http://jquery.com/">jQuery</a>代码。内部DSL的特点是，它其实只是一系列API，但是你可以&ldquo;假装&rdquo;它们一种DSL。内部DSL往往会利用一些&ldquo;流畅化&rdquo;的技巧，例如像这里的LINQ 或jQuery那样把一些方法通过&ldquo;点&rdquo;连接起来。有些则利用了元编程的方式，如这里的Ruby on Rails就涉及到了一些元编程。这种DSL可以访问语言中的代码或变量，以及利用如代码补全，重构等母语言的所有特性。</p>
<p><a target="_blank" href="http://img.zhaojie.me/blog/prog-lang-trends-anders/16.png"><img src="http://img.zhaojie.me/blog/prog-lang-trends-anders/16-thumbnail.png"></a></p>
<p>现在我会花几分钟时间演示一下我所创建的DSL，也就是LINQ。我相信你们也已经用过不少LINQ了，不过这里我还是快速的展示一下我所表达的更为&ldquo;声明式&rdquo;的编程方式。</p>
<pre class="code"><span style="color: blue">public class </span><span style="color: rgb(43,145,175)">Product
</span>{
    <span style="color: blue">public int </span>ProductID { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
    <span style="color: blue">public string </span>ProductName { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
    <span style="color: blue">public string </span>CategoryName { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
    <span style="color: blue">public int </span>UnitPrice { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }

    <span style="color: blue">public static </span><span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(43,145,175)">Product</span>&gt; GetProducts() { <span style="color: green">/* ... */ </span>}
}

<span style="color: blue">public partial class </span><span style="color: rgb(43,145,175)">_Default </span>: System.Web.UI.<span style="color: rgb(43,145,175)">Page
</span>{
    <span style="color: blue">protected void </span>Page_Load(<span style="color: blue">object </span>sender, <span style="color: rgb(43,145,175)">EventArgs </span>e)
    {
        <span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(43,145,175)">Product</span>&gt; products = <span style="color: rgb(43,145,175)">Product</span>.GetProducts();

        <span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(43,145,175)">Product</span>&gt; result = <span style="color: blue">new </span><span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(43,145,175)">Product</span>&gt;();
        <span style="color: blue">foreach </span>(<span style="color: rgb(43,145,175)">Product </span>p <span style="color: blue">in </span>products)
        {
            <span style="color: blue">if </span>(p.UnitPrice &gt; 20) result.Add(p);
        }

        GridView1.DataSource = result;
        GridView1.DataBind();
    }
}</pre>
<p>这里有许多Product对象，那么现在我要筛选出所有单价大于20的那些， 再把他们显示在一个GridView中。传统的做法就是这样，我先得到所有的Product对象，然后foreach遍历每个对象，再判断每个对象的单价，最终把数据绑定到GridView里。运行这个程序……（打开页面）这就是就能得到结果。</p>
<p>好，那么现在我要做一些稍微复杂的事情。可能我不是要展示单价超过20的Product对象，而是要查看每个分类中究竟有多少个单价超过20的对象，然后根据数量进行排序。如果不用DSL完成这个工作，那么我可能会先定义一个对象来表示结果：</p>
<pre class="code"><span style="color: blue">class </span><span style="color: rgb(43,145,175)">Grouping
</span>{
    <span style="color: blue">public string </span>CategoryName { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
    <span style="color: blue">public int </span>ProductCount { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
}</pre>
<p>这是个表示分组的对象，用于保存分类的名称和产品数量。然后我们就会写一些十分丑陋的代码：</p>
<pre class="code"><span style="color: rgb(43,145,175)">Dictionary</span>&lt;<span style="color: blue">string</span>, <span style="color: rgb(43,145,175)">Grouping</span>&gt; groups = <span style="color: blue">new </span><span style="color: rgb(43,145,175)">Dictionary</span>&lt;<span style="color: blue">string</span>, <span style="color: rgb(43,145,175)">Grouping</span>&gt;();
<span style="color: blue">foreach </span>(<span style="color: rgb(43,145,175)">Product </span>p <span style="color: blue">in </span>products)
{
    <span style="color: blue">if </span>(p.UnitPrice &gt;= 20)
    {
        <span style="color: blue">if </span>(!groups.ContainsKey(p.CategoryName))
        {
            <span style="color: rgb(43,145,175)">Grouping </span>r = <span style="color: blue">new </span><span style="color: rgb(43,145,175)">Grouping</span>();
            r.CategoryName = p.CategoryName;
            r.ProductCount = 0;
            groups[p.CategoryName] = r;
        }
        groups[p.CategoryName].ProductCount++;
    }
}

<span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(43,145,175)">Grouping</span>&gt; result = <span style="color: blue">new </span><span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(43,145,175)">Grouping</span>&gt;(groups.Values);
result.Sort(<span style="color: blue">delegate</span>(<span style="color: rgb(43,145,175)">Grouping </span>x, <span style="color: rgb(43,145,175)">Grouping </span>y)
{
    <span style="color: blue">return
        </span>x.ProductCount &gt; y.ProductCount ? -1 :
        x.ProductCount &lt; y.ProductCount ? 1 :
        0;
});</pre>
<p>我先创建一个新的字典，用于保存分类名称到分组的对应关系。然后我遍历每个Product对象，对于每个单价大于20的对象，如果字典中还没有保存对应的分组则创建一个，然后将数量加一。然后为了排序，我调用Sort方法，于是我要提供一个委托作为排序方法，然后blablablabla……执行之后……（打开页面）我自然可以得到想要的结果。</p>
<p>但是，首先这些代码写起来需要花费一些时间，很显然。然后仔细观察，你会发现这写代码几乎都是在表示&ldquo;How&rdquo;，而&ldquo;What&rdquo;基本已经丢失了。假设我离开了，现在新来了一个程序员要维护这段代码，他会需要一点时间才能完整理解这段代码，因为他无法直接看清代码的目标。</p>
<p>不过如果这里我们使用DSL，也就是LINQ，就像这样：</p>
<pre class="code"><span style="color: blue">var </span>result = products
    .Where(p =&gt; p.UnitPrice &gt;= 20)
    .GroupBy(p =&gt; p.CategoryName)
    .OrderByDescending(g =&gt; g.Count())
    .Select(g =&gt; <span style="color: blue">new </span>{ CategoryName = g.Key, ProductCount = g.Count() });</pre>
<p>products……先调用Where……blablabla……再GroupBy等等。由于我们这里可以使用DSL来表示高阶的术语，用以体现我们想做的事情。于是这段代码则更加关注于&ldquo;What&rdquo;而不是&ldquo;How&rdquo;。我这里不会明确地指示我想要过滤的方式，我也不会明确地说我要建立字典和分类，这样基础结构就可以聪明地，或者说更加聪明地去确定具体的执行方式。你可能比较容易想到我们可以并行地执行这段代码，因为我没有显式地指定做事方式，我只是表示出我的意图。</p>
<p>我们打开页面……（打开页面）很显然我们得到了相同的结果。</p>
<p>这里比较有趣的是，内部DSL是如何设计进C#语法中的，为此我们为C# 3.0添加了一系列的特性，例如Lambda表达式，扩展方法，类型推断等等。这些特性统一起来之后，我们就可以设计出更为丰富的API，组合之后便成为一种内部DSL，就像这里的LINQ查询语言。</p>
<p>除了使用API的形式之外，我们还可以这样做：</p>
<pre class="code"><span style="color: blue">var </span>result =
    <span style="color: blue">from </span>p <span style="color: blue">in </span>products
    <span style="color: blue">where </span>p.UnitPrice &gt;= 20
    <span style="color: blue">group </span>p <span style="color: blue">by </span>p.CategoryName <span style="color: blue">into </span>g
    <span style="color: blue">orderby </span>g.Count() <span style="color: blue">descending
    select new </span>{ CategoryName = g.Key, ProductCount = g.Count() };</pre>
<p>编译器会简单地将这种形式转化为前一种形式。不过，这里我认为有意思的地方在于，你完全可以创建一门和领域编程语言完全无关的语法，然后等这种语法和API变得流行且丰富起来之后，再来创一种新的表现形式，就如这里的LINQ查询语法。我颇为中意这种语言设计的交流方式。</p>
<p>OK，现在我们回到下面的内容。</p>
<ul>
    <li><a href="http://blog.zhaojie.me/2010/04/trends-and-future-directions-in-programming-">编程语言的发展趋势及未来方向（1）：历史回顾及趋势概述</a></li>
    <li><a href="http://blog.zhaojie.me/2010/04/trends-and-future-directions-in-programming-">编程语言的发展趋势及未来方向（2）：声明式编程与DSL</a></li>
    <li><a target="_blank" href="http://blog.zhaojie.me/2010/04/trends-and-future-directions-in-programming-">编程语言的发展趋势及未来方向（3）：函数式编程</a></li>
    <li><a href="http://blog.zhaojie.me/2010/05/trends-and-future-directions-in-programming-">编程语言的发展趋势及未来方向（4）：动态语言</a></li>
    <li><a href="http://blog.zhaojie.me/2010/05/trends-and-future-directions-in-programming-">编程语言的发展趋势及未来方向（5）：元编程</a></li>
    <li><a href="http://blog.zhaojie.me/2010/05/trends-and-future-directions-in-programming-">编程语言的发展趋势及未来方向（6）：并发</a></li>
    <li><a href="http://blog.zhaojie.me/2010/06/trends-and-future-directions-in-programming-">编程语言的发展趋势及未来方向（7）：总结</a></li>
</ul>
<p> </p>
<p> </p>
<p> </p>
<p> </p></div></body></html>