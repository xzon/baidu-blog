<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Tapestry5.2.4客户端校验代码</title></head><body><h1>Tapestry5.2.4客户端校验代码</h1><div><p>Tapestry5.2.4客户端校验代码</p><p>tapestry源码品读 -hxzon</p><p>校验器</p><pre>/*<br> * Collection of field based functions related to validation. Each function<br> * takes a field, a message and an optional constraint value. Some functions are<br> * related to Translators and work on the format event, other's are from<br> * Validators and work on the validate event.<br> */<br><br>Tapestry.Validator = {<br><br> required : function(field, message) {<br>  $(field).getFieldEventManager().requiredCheck = function(value) {<br>   if ((Object.isString(value) &amp;&amp; value.strip() == '')<br>     || value == null)<br>    $(field).showValidationMessage(message);<br>  };<br> },<br><br> /** Supplies a client-side numeric translator for the field. */<br> numericformat : function(field, message, isInteger) {<br>  $(field).getFieldEventManager().translator = function(input) {<br>   try {<br>    return Tapestry.formatLocalizedNumber(input, isInteger);<br>   } catch (e) {<br>    $(field).showValidationMessage(message);<br>   }<br>  };<br> },<br><br> minlength : function(field, message, length) {<br>  field.addValidator(function(value) {<br>   if (value.length &lt; length)<br>    throw message;<br>  });<br> },<br><br> maxlength : function(field, message, maxlength) {<br>  field.addValidator(function(value) {<br>   if (value.length &gt; maxlength)<br>    throw message;<br>  });<br> },<br><br> min : function(field, message, minValue) {<br>  field.addValidator(function(value) {<br>   if (value &lt; minValue)<br>    throw message;<br>  });<br> },<br><br> max : function(field, message, maxValue) {<br>  field.addValidator(function(value) {<br>   if (value &gt; maxValue)<br>    throw message;<br>  });<br> },<br><br> regexp : function(field, message, pattern) {<br>  var regexp = new RegExp(pattern);<br><br>  field.addValidator(function(value) {<br>   if (!regexp.test(value))<br>    throw message;<br>  });<br> }<br>};
</pre><p>错误弹出框</p><pre>Tapestry.ErrorPopup = Class.create( {<br><br> /*<br>  * If the images associated with the error popup are overridden (by<br>  * overriding Tapestry's default.css stylesheet), then some of these values<br>  * may also need to be adjusted.<br>  */<br> BUBBLE_VERT_OFFSET : -34,<br><br> BUBBLE_HORIZONTAL_OFFSET : -20,<br><br> BUBBLE_WIDTH : "auto",<br><br> BUBBLE_HEIGHT : "39px",<br><br> <span style="color: rgb(255, 0, 0);">initialize</span> : function(field) {<br>  this.field = $(field);<br><br>  this.innerSpan = new Element("span");<br>  this.outerDiv = $(new Element("div", {<br>   'id' : this.field.id + ":errorpopup",<br>   'class' : 't-error-popup'<br>  })).update(this.innerSpan).hide();<br><br>  var body = $(document.body);<br><br>  body.insert( {<br>   bottom : this.outerDiv<br>  });<br><br>  this.outerDiv.absolutize();<br><br>  this.outerDiv.observe("click", function(event) {<br>   this.ignoreNextFocus = true;<br><br>   this.stopAnimation();<br><br>   this.outerDiv.hide();<br><br>   this.field.activate();<br><br>   event.stop();<br>  }.bindAsEventListener(this));<br><br>  this.queue = {<br>   position : 'end',<br>   scope : this.field.id<br>  };<br><br>  Event.observe(window, "resize", this.repositionBubble.bind(this));<br><br>  document.observe(Tapestry.FOCUS_CHANGE_EVENT, function(event) {<br>   if (this.ignoreNextFocus) {<br>    this.ignoreNextFocus = false;<br>    return;<br>   }<br><br>   if (event.memo == this.field) {<br>    this.fadeIn();<br>    return;<br>   }<br><br>   /*<br>    * If this field is not the focus field after a focus change, then<br>    * it's bubble, if visible, should fade out. This covers tabbing<br>    * from one form to another.<br>    */<br>   this.fadeOut();<br><br>  }.bind(this));<br> },<br><br> showMessage : function(message) {<br>  this.stopAnimation();<br><br>  this.innerSpan.update(message);<br><br>  this.hasMessage = true;<br><br>  this.fadeIn();<br> },<br><br> <span style="color: rgb(255, 0, 0);">repositionBubble</span> : function() {<br>  var fieldPos = this.field.cumulativeOffset();<br><br>  this.outerDiv.setStyle( {<br>   top : (fieldPos[1] + this.BUBBLE_VERT_OFFSET) + "px",<br>   left : (fieldPos[0] + this.BUBBLE_HORIZONTAL_OFFSET) + "px",<br>   width : this.BUBBLE_WIDTH,<br>   height : this.BUBBLE_HEIGHT<br>  });<br> },<br><br> fadeIn : function() {<br>  if (!this.hasMessage)<br>   return;<br><br>  this.repositionBubble();<br><br>  if (this.animation)<br>   return;<br><br>  this.animation = new Effect.Appear(this.outerDiv, {<br>   queue : this.queue,<br>   afterFinish : function() {<br>    this.animation = null;<br><br>    if (this.field != Tapestry.currentFocusField)<br>     this.fadeOut();<br>   }.bind(this)<br>  });<br> },<br><br> stopAnimation : function() {<br>  if (this.animation)<br>   this.animation.cancel();<br><br>  this.animation = null;<br> },<br><br> fadeOut : function() {<br>  if (this.animation)<br>   return;<br><br>  this.animation = new Effect.Fade(this.outerDiv, {<br>   queue : this.queue,<br>   afterFinish : function() {<br>    this.animation = null;<br>   }.bind(this)<br>  });<br> },<br><br> hide : function() {<br>  this.hasMessage = false;<br><br>  this.stopAnimation();<br><br>  this.outerDiv.hide();<br> }<br>});
</pre><p>表单域事件管理者</p><pre>Tapestry.FieldEventManager = Class.create( {<br><br> <span style="color: rgb(255, 0, 0);">initialize</span> : function(field) {<br>  this.field = $(field);<br><br>  var id = this.field.id;<br><br>  var selector = "label[for='" + id + "']";<br><br>  this.label = this.field.up("form").down(selector);<br>  this.icon = $(id + '_icon');<br><br>  this.translator = Prototype.K;<br><br>  var fem = $(this.field.form).getFormEventManager();<br><br>  if (fem.validateOnBlur) {<br><br>   document.observe(Tapestry.FOCUS_CHANGE_EVENT, function(event) {<br>    /*<br>     * If changing focus *within the same form* then perform<br>     * validation. Note that Tapestry.currentFocusField does not<br>     * change until after the FOCUS_CHANGE_EVENT notification.<br>     */<br>    if (Tapestry.currentFocusField == this.field<br>      &amp;&amp; this.field.form == event.memo.form)<br>     this.validateInput();<br><br>   }.bindAsEventListener(this));<br>  }<br><br>  if (fem.validateOnSubmit) {<br>   $(this.field.form).observe(Tapestry.FORM_VALIDATE_FIELDS_EVENT,<br>     this.validateInput.bindAsEventListener(this));<br>  }<br> },<br><br> /**<br>  * Removes validation decorations if present. Hides the ErrorPopup, if it<br>  * exists.<br>  */<br> <span style="color: rgb(255, 0, 0);">removeDecorations</span> : function() {<br>  this.field.removeClassName("t-error");<br><br>  if (this.label)<br>   this.label.removeClassName("t-error");<br><br>  if (this.icon)<br>   this.icon.hide();<br><br>  if (this.errorPopup)<br>   this.errorPopup.hide();<br> },<br><br> /**<br>  * Show a validation error message, which will add decorations to the field<br>  * and it label, make the icon visible, and raise the field's<br>  * Tapestry.ErrorPopup to show the message.<br>  * <br>  * @param message<br>  *            validation message to display<br>  */<br> <span style="color: rgb(255, 0, 0);">showValidationMessage</span> : function(message) {<br>  $T(this.field).validationError = true;<br>  $T(this.field.form).validationError = true;<br><br>  this.field.addClassName("t-error");<br><br>  if (this.label)<br>   this.label.addClassName("t-error");<br><br>  if (this.icon) {<br>   if (!this.icon.visible())<br>    new Effect.Appear(this.icon);<br>  }<br><br>  if (this.errorPopup == undefined)<br>   this.errorPopup = new Tapestry.ErrorPopup(this.field);<br><br>  this.errorPopup.showMessage(message);<br> },<br><br> /**<br>  * Invoked when a form is submitted, or when leaving a field, to perform<br>  * field validations. Field validations are skipped for disabled fields. If<br>  * all validations are succesful, any decorations are removed. If any<br>  * validation fails, an error popup is raised for the field, to display the<br>  * validation error message.<br>  * <br>  * @return true if the field has a validation error<br>  */<br> <span style="color: rgb(255, 0, 0);">validateInput</span> : function() {<br>  if (this.field.disabled)<br>   return false;<br><br>  if (!this.field.isDeepVisible())<br>   return false;<br><br>  var t = $T(this.field);<br><br>  var value = $F(this.field);<br><br>  t.validationError = false;<br><br>  if (this.requiredCheck)<br>   this.requiredCheck.call(this, value);<br><br>  /*<br>   * Don't try to validate blank values; if the field is required, that<br>   * error is already noted and presented to the user.<br>   */<br><br>  if (!t.validationError &amp;&amp; !(Object.isString(value) &amp;&amp; value.blank())) {<br>   var translated = this.translator(value);<br><br>   /*<br>    * If Format went ok, perhaps do the other validations.<br>    */<br>   if (!t.validationError) {<br>    this.field.fire(Tapestry.FIELD_VALIDATE_EVENT, {<br>     value : value,<br>     translated : translated<br>    });<br>   }<br>  }<br><br>  /* Lastly, if no validation errors were found, remove the decorations. */<br><br>  if (!t.validationError)<br>   this.field.removeDecorations();<br><br>  return t.validationError;<br> }<br>});
</pre><p>表单事件管理者</p><pre>Tapestry.FormEventManager = Class.create( {<br><br> <span style="color: rgb(255, 0, 0);">initialize</span> : function(spec) {<br>  this.form = $(spec.formId);<br>  this.validateOnBlur = spec.validate.blur;<br>  this.validateOnSubmit = spec.validate.submit;<br><br>  this.form.onsubmit = this.handleSubmit.bindAsEventListener(this);<br> },<br><br> /**<br>  * Identifies in the form what is the cause of the submission. The element's<br>  * id is stored into the t:submit hidden field (created as needed).<br>  * <br>  * @param element<br>  *            id or element that is the cause of the submit (a Submit or<br>  *            LinkSubmit)<br>  */<br> setSubmittingElement : function(element) {<br><br>  if (!this.submitHidden) {<br>   // skip if this is not a tapestry controlled form<br>   if (this.form.getInputs("hidden", "t:formdata").size() == 0)<br>    return;<br><br>   var hiddens = this.form.getInputs("hidden", "t:submit");<br><br>   if (hiddens.size() == 0) {<br><br>    /**<br>     * Create a new hidden field directly after the first hidden<br>     * field in the form.<br>     */<br>    var firstHidden = this.form.getInputs("hidden").first();<br><br>    this.submitHidden = new Element("input", {<br>     type : "hidden",<br>     name : "t:submit"<br>    });<br><br>    firstHidden.insert( {<br>     after : this.submitHidden<br>    });<br>   } else<br>    this.submitHidden = hiddens.first();<br>  }<br><br>  this.submitHidden.value = element == null ? null : $(element).id;<br> },<br><br> handleSubmit : function(domevent) {<br><br>  /*<br>   * Necessary because we set the onsubmit property of the form, rather<br>   * than observing the event. But that's because we want to specfically<br>   * overwrite any other handlers.<br>   */<br>  Event.extend(domevent);<br><br>  var t = $T(this.form);<br><br>  t.validationError = false;<br><br>  if (!t.skipValidation) {<br><br>   t.skipValidation = false;<br><br>   /* Let all the fields do their validations first. */<br><br>   this.form.fire(Tapestry.FORM_VALIDATE_FIELDS_EVENT, this.form);<br><br>   /*<br>    * Allow observers to validate the form as a whole. The FormEvent<br>    * will be visible as event.memo. The Form will not be submitted if<br>    * event.result is set to false (it defaults to true). Still trying<br>    * to figure out what should get focus from this kind of event.<br>    */<br>   if (!t.validationError)<br>    this.form.fire(Tapestry.FORM_VALIDATE_EVENT, this.form);<br><br>   if (t.validationError) {<br>    domevent.stop();<br><br>    /*<br>     * Because the submission failed, the last submit element is<br>     * cleared, since the form may be submitted for some other<br>     * reason later.<br>     */<br>    this.setSubmittingElement(null);<br><br>    return false;<br>   }<br>  }<br><br>  this.form.fire(Tapestry.FORM_PREPARE_FOR_SUBMIT_EVENT, this.form);<br><br>  /*<br>   * This flag can be set to prevent the form from submitting normally.<br>   * This is used for some Ajax cases where the form submission must run<br>   * via Ajax.Request.<br>   */<br><br>  if (this.form.hasClassName(Tapestry.PREVENT_SUBMISSION)) {<br>   domevent.stop();<br><br>   /*<br>    * Instead fire the event (a listener will then trigger the Ajax<br>    * submission). This is really a hook for the ZoneManager.<br>    */<br>   this.form.fire(Tapestry.FORM_PROCESS_SUBMIT_EVENT);<br><br>   return false;<br>  }<br><br>  /* Validation is OK, not doing Ajax, continue as planned. */<br><br>  return true;<br> }<br>});
</pre><p>一些特效</p><pre>/*<br> * Wrappers around Prototype and Scriptaculous effects. All the functions of<br> * this object should have all-lowercase names. The methods all return the<br> * Effect object they create.<br> */<br>Tapestry.ElementEffect = {<br><br> /** Fades in the element. */<br> show : function(element) {<br>  return new Effect.Appear(element);<br> },<br><br> /** The classic yellow background fade. */<br> highlight : function(element, color) {<br>  if (color)<br>   return new Effect.Highlight(element, {<br>    endcolor : color,<br>    restorecolor : color<br>   });<br><br>  return new Effect.Highlight(element);<br> },<br><br> /** Scrolls the content down. */<br> slidedown : function(element) {<br>  return new Effect.SlideDown(element);<br> },<br><br> /** Slids the content back up (opposite of slidedown). */<br> slideup : function(element) {<br>  return new Effect.SlideUp(element);<br> },<br><br> /** Fades the content out (opposite of show). */<br> fade : function(element) {<br>  return new Effect.Fade(element);<br> }<br>};
</pre><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p></div></body></html>