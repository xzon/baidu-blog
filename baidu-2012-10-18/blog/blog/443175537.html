<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>java并发编程中CountDownLatch和CyclicBarrier的使用</title></head><body><h1>java并发编程中CountDownLatch和CyclicBarrier的使用</h1><div><div><p>java并发编程中CountDownLatch和CyclicBarrier的使用<br><p>http://blackgu.blogbus.com/logs/69596661.html</p><p>java并发 java concurrency</p><p><span style="font-size: 16px;">在多线程程序设计中，经常会遇到一个线程等待一个或多个线程的场景，遇到这样的场景应该如何解决？</span></p><p><span style="font-size: 16px;">如果是一个线程等待一个线程，则可以通过await()和notify()来实现；</span></p><p><span style="font-size: 16px;">如果是一个线程等待多个线程，则就可以使用CountDownLatch和CyclicBarrier来实现比较好的控制。</span></p><p><strong><span style="font-size: 16px;">下面来详细描述下CountDownLatch的应用场景：</span></strong></p><p><span style="font-size: 16px;">例如：百米赛跑：8名运动员同时起跑，由于速度的快慢，肯定有会出现先到终点和晚到终点的情况，而终点有个统计成绩的仪器，当所有选手到达终点时，它会统计所有人的成绩并进行排序，然后把结果发送到汇报成绩的系统。</span></p><p><span style="font-size: 16px;">其实这就是一个CountDownLatch的应用场景：一个线程或多个线程等待其他线程运行达到某一目标后进行自己的下一步工作，而被等待的“其他线程”达到这个目标后继续自己下面的任务。</span></p><p><span style="font-size: 16px;">这个场景中：</span></p><p><span style="font-size: 16px;">1. 被等待的“其他线程”------&gt;8名运动员</span></p><p><span style="font-size: 16px;">2. 等待“其他线程”的这个线程------&gt;终点统计成绩的仪器</span></p><p><span style="font-size: 16px;">那么，如何来通过CountDownLatch来实现上述场景的线程控制和调度呢？</span></p><p><span style="font-size: 16px;">jdk中CountDownLatch类有一个常用的构造方法：<span style="font-family: Courier New;">CountDownLatch(int count)；</span></span></p><p><span style="font-family: Courier New;"><span style="font-size: 16px;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>两个常用的方法：await()和countdown()<strong>&nbsp;</strong></span></span></p><p><span style="font-family: Courier New;"><span style="font-size: 16px;">其
 中count是一个计数器中的初始化数字，比如初始化的数字是2，当一个线程里调用了countdown()，则这个计数器就减一，当线程调用了 
await()，则这个线程就等待这个计数器变为0，当这个计数器变为0时，这个线程继续自己下面的工作。下面是上述CountDownLatch场景的
 实现：</span></span></p><p><span style="font-family: Courier New;"><span style="font-size: 16px;">Work类（运动员）：</span></span></p><p>import java.util.concurrent.CountDownLatch;<br><br>public class Work implements Runnable {<br>&nbsp;private int id;<br>&nbsp;private CountDownLatch beginSignal;<br>&nbsp;private CountDownLatch endSignal;<br>&nbsp;<br>&nbsp;public Work(int id, CountDownLatch begin, CountDownLatch end) {<br>&nbsp; this.id = id;<br>&nbsp; this.beginSignal = begin;<br>&nbsp; this.endSignal = end;<br>&nbsp;}<br><br>&nbsp;@Override<br>&nbsp;public void run() {<br>&nbsp; try {<br>&nbsp;&nbsp; beginSignal.await();<br>&nbsp;&nbsp; System.out.println("work" + id + "起跑...");<br>&nbsp;&nbsp; System.out.println("work" + id + "到达终点");<br>&nbsp;&nbsp; endSignal.countDown();<br>&nbsp;&nbsp; System.out.println("work" + id + "继续干其他事情");<br>&nbsp; } catch (InterruptedException e) {<br>&nbsp;&nbsp; // TODO Auto-generated catch block<br>&nbsp;&nbsp; e.printStackTrace();<br>&nbsp; }<br>&nbsp;}<br>}</p><p><span style="font-family: Courier New;"><span style="font-size: 16px;">Main类（终点统计仪器）：</span></span></p><p>import java.util.concurrent.CountDownLatch;<br><br>public class Main {<br>&nbsp;<br>&nbsp;public static void main(String[] args) {<br>&nbsp; CountDownLatch begSignal = new CountDownLatch(1);<br>&nbsp; CountDownLatch endSignal = new CountDownLatch(8);<br>&nbsp;<br>&nbsp; for (int i = 0; i &lt; 8; i++) {<br>&nbsp;&nbsp; new Thread(new Work(i, begSignal, endSignal)).start();<br>&nbsp; }<br>&nbsp;<br>&nbsp; try {<br>&nbsp;&nbsp; begSignal.countDown();&nbsp; //统一起跑<br>&nbsp;&nbsp; endSignal.await();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //等待运动员到达终点<br>&nbsp;&nbsp; System.out.println("结果发送到汇报成绩的系统");<br>&nbsp; } catch (InterruptedException e) {<br>&nbsp;&nbsp; e.printStackTrace();<br>&nbsp; }<br>&nbsp;}<br>}</p><p><span style="font-family: Courier New;"><strong><span style="font-size: 16px;">下面详细描述下CyclicBarrier的应用场景：</span></strong></span></p><p><span style="font-family: Courier New;"><span style="font-size: 16px;">有四个游戏玩家玩游戏，游戏有三个关卡，每个关卡必须要所有玩家都到达后才能允许通关。</span></span></p><p><span style="font-family: Courier New;"><span style="font-size: 16px;">其
 实这个场景里的玩家中如果有玩家A先到了关卡1，他必须等待其他所有玩家都到达关卡1时才能通过，也就是说线程之间需要互相等待，这和 
CountDownLatch的应用场景有区别，CountDownLatch里的线程是到了运行的目标后继续干自己的其他事情，而这里的线程需要等待其
 他线程后才能继续完成下面的工作。</span></span></p><p><span style="font-family: Courier New;"><span style="font-size: 16px;">jdk中CyclicBarrier类有两个常用的构造方法：</span></span></p><p><span style="font-family: Courier New;"><span style="font-size: 16px;">1. CyclicBarrier(int parties)</span></span></p><p><span style="font-family: Courier New;"><span style="font-size: 16px;">这里的parties也是一个计数器，例如，初始化时parties里的计数是3，于是拥有该CyclicBarrier对象的线程当parties的计数为3时就唤醒，<span style="color: #ff0000;">注：这里parties里的计数在运行时当调用CyclicBarrier:await()时,计数就加1，一直加到初始的值</span></span></span></p><p><span style="font-family: Courier New;"><span style="font-size: 16px;">2. CyclicBarrier(int parties, Runnable barrierAction)</span></span></p><p><span style="font-family: Courier New;"><span style="font-size: 16px;">这里的parties与上一个构造方法的解释是一样的，这里需要解释的是第二个入参（Runnable barrierAction）,这个参数是一个实现Runnable接口的类的对象，也就是说当parties加到初始值时就出发barrierAction的内容。</span></span></p><p><span style="font-family: Courier New;"><span style="font-size: 16px;">下面来实现上述的应用场景：</span></span></p><p><span style="font-size: 16px;">&nbsp;Player类（玩家类）</span></p><p>import java.util.concurrent.BrokenBarrierException;<br>import java.util.concurrent.CyclicBarrier;<br><br>public class Player implements Runnable {<br>&nbsp;<br>&nbsp;private CyclicBarrier cyclicBarrier;<br>&nbsp;private int id;<br>&nbsp;<br>&nbsp;public Player(int id, CyclicBarrier cyclicBarrier) {<br>&nbsp; this.cyclicBarrier = cyclicBarrier;<br>&nbsp; this.id = id;<br>&nbsp;}<br><br>&nbsp;@Override<br>&nbsp;public void run() {<br>&nbsp; try {<br>&nbsp;&nbsp; System.out.println("玩家" + id + "正在玩第一关...");<br>&nbsp;&nbsp; System.out.println("玩家" + id + "等待进入第二关...");<br>&nbsp;&nbsp; cyclicBarrier.await();<br>&nbsp;&nbsp; System.out.println("玩家" + id + "进入第二关...");<br>&nbsp; } catch (InterruptedException e) {<br>&nbsp;&nbsp; e.printStackTrace();<br>&nbsp; } catch (BrokenBarrierException e) {<br>&nbsp;&nbsp; e.printStackTrace();<br>&nbsp; }<br>&nbsp;}<br>}</p><p><span style="font-size: 16px;">GameBarrier类（关卡类，这里控制玩家必须全部到达第一关结束的关口才能进入第二关）</span></p><p>import java.util.concurrent.CyclicBarrier;<br><br>
public class GameBarrier {<br>
&nbsp;<br>
&nbsp;public static void main(String[] args) {<br>
&nbsp; CyclicBarrier cyclicBarrier = new CyclicBarrier(4, new Runnable() {<br>
&nbsp; &nbsp;<br>
&nbsp;&nbsp; @Override<br>
&nbsp;&nbsp; public void run() {<br>
&nbsp;&nbsp;&nbsp; System.out.println("所有玩家进入第二关！");<br>
&nbsp;&nbsp; }<br>
&nbsp; });<br>
&nbsp;<br>
&nbsp; for (int i = 0; i &lt; 4; i++) {<br>
&nbsp;&nbsp; new Thread(new Player(i, cyclicBarrier)).start();<br>
&nbsp; }<br>
&nbsp;}<br>
}</p><p>&nbsp;</p><p>&nbsp;</p></p></div></div></body></html>