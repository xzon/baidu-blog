<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>讨论：Java编程风格的改变</title></head><body><h1>讨论：Java编程风格的改变</h1><div><p>讨论：Java编程风格的改变</p><p><a href="http://www.infoq.com/cn/news/2009/08/java-programming-style">http://www.infoq.com/cn/news/2009/08/java-programming-style</a></p><p><a href="http://www.infoq.com/cn/bycategory/newsbycategory.action?idx=6&amp;alias=Scala">http://www.infoq.com/cn/bycategory/newsbycategory.action?idx=6&amp;alias=Scala</a></p><p><a href="http://www.infoq.com/cn/scala">http://www.infoq.com/cn/scala</a></p><p><a href="http://www.infoq.com/scala">http://www.infoq.com/scala</a></p><p>作者&nbsp;<strong>赵劼&nbsp;</strong>发布于 2009年8月17日</p><p></p><p>最近<a href="http://codemonkeyism.com/" style="text-decoration: underline; color: rgb(11, 89, 178); ">Stephan Schmidt</a>在博客中发表了题为《<a href="http://codemonkeyism.com/generation-java-programming-style/" style="text-decoration: underline; color: rgb(11, 89, 178); ">下一代Java编程风格</a>》的文章，阐述了他眼中Java编程风格的改变，以及未来的走向：</p><p>许多公司和开发人员正在从Java转向其他编程语言：Ruby、Python、Grrovy、Erlang或Scala等等。不过你可能做不到这一点。即便如此，你也可以改变你的编程风格，获取这些新语言的优势。事实上，在过去的15年中，Java编程风格也已经有明显变化了。</p><p>Stephan在文章中提出了以下几点：</p><b>尽可能地标注final：</b>让所有东西不可变，把变量标为final可以阻止改变它的值。很多时候，重新为变量赋值会引入bug，你应该使用新的变量。除此之外，final可以提高代码的可读性。我针对这个话题还写过一篇文章：《<a href="http://codemonkeyism.com/all-variables-in-java-must-be-final/" style="text-decoration: underline; color: rgb(11, 89, 178); ">Java中所有变量都应该是final的</a>》<b>没有setter：</b>许多Java程序员会自然而然地为类中所有的字段加上setter。思考一下，真的每个字段都需要修改吗？更好的方法是创建包含改变后状态的新对象。此外，也试着去除getter，我们应该遵循“<a href="http://www.pragprog.com/articles/tell-dont-ask" style="text-decoration: underline; color: rgb(11, 89, 178); ">Tell, don't ask</a>”的思想。<b>避免使用循环来操作List：</b>从函数式编程那里获得的经验，循环并不是进行集合操作最好方法。例如，我们可以使用<a href="http://code.google.com/p/google-collections/" style="text-decoration: underline; color: rgb(11, 89, 178); ">Google Collections</a>提供的<a href="http://google-collections.googlecode.com/svn/trunk/javadoc/com/google/common/collect/Iterables.html#filter(java.lang.Iterable, com.google.common.base.Predicate)" style="text-decoration: underline; color: rgb(11, 89, 178); ">过滤</a>功能。 
Predicate canDrinkBeer = new Predicate() {
     public boolean apply(HasAge hasAge) {
         return hasAge.isOlderThan( 16 );
    }
};
 
List&lt;Person&gt; beerDrinkers = filter(persons, canDrinkBeer);<b>使用单行代码：</b>Java是一门繁杂（noisy）的语言，我们应该编写更精确的代码。尝试将代码写为一行。例如： 
public int add(int a, int b) { return a + b; }<b>使用大量接口：</b>领域驱动设计已经大行其道，一个应该拆分为多种“角色”，即实现多种接口，提高复用程度。方法应该面向“角色”，而不是面向特定的类。我在《<a href="http://codemonkeyism.com/generation-java-programming-style/" style="text-decoration: underline; color: rgb(11, 89, 178); ">不要在Java中使用String</a>》一文中讨论了更多这方面的内容。<b>使用Erlang风格的并发：</b>Java的并发特性（如lock和synchronized）过于低端，难以使用。Erlang风格的并发是一种更好的做法。Java平台上已经有了<a href="http://github.com/jboner/akka/tree/master" style="text-decoration: underline; color: rgb(11, 89, 178); ">Akka</a>和<a href="http://code.google.com/p/actorom/" style="text-decoration: underline; color: rgb(11, 89, 178); ">Actorom</a>。此外，也可以使用java.util.concurrent中的Join/Fork和数据结构进行编程。<b>使用Fluent Interface：</b>Fluent Interface可以使代码更短，更容易编写。Google Collections中的MapMaker是个不错的示例： 
ConcurrentMap graphs = new MapMaker()
    .concurrencyLevel(32)
    .softKeys()
    .weakValues()
    .expiration(30, TimeUnit.MINUTES)
    .makeComputingMap(
        new Function() {
            public Graph apply(Key key) {
                return createExpensiveGraph(key);
            }
        });<b>避免在DTO中创建getter和setter：</b>如果你拥有简单的DTO（Data Transfer Object），不要耗费精力去编写getter和setter，直接使用公开的字段吧。不过在你无法完全控制代码的使用情况时，还是小心为上。<p>这篇文章发表之后，有许多人发表了不同的看法。其中<a href="http://beust.com/weblog/" style="text-decoration: underline; color: rgb(11, 89, 178); ">Cedric Otaku</a>发表了文章《<a href="http://beust.com/weblog/archives/000517.html" style="text-decoration: underline; color: rgb(11, 89, 178); ">下一代Java与现在差不多</a>》予以回应，其中反对了Stephan提出的大部分观点。</p><b>尽可能final：</b>太多final会降低代码的可读性，它无法代码额外的好处。我已经不记得上次因为重新给变量赋值而造成错误是什么时候了。值得一提的是，在字段以外的成员上标记final违反了Google的风格指南。<b>避免setter：</b>看上去不错，不过这不现实。有些时候你不愿把所有的参数都通过构造函数传入。此外，如果使用对象池的时候，可变的对象会让编程更为方便。Stephan不是第一个提出要将访问器（accessor）从OO编程中移除的人，不过这个说法<a href="http://beust.com/weblog/archives/000022.html" style="text-decoration: underline; color: rgb(11, 89, 178); ">很明显不可行</a>。<b>避免循环：</b>Java并不适合函数式编程风格，所以我认为使用Predicate的代码反而难以读懂。我估计大部分的Java程序员会同意我的观点，即使他们已经熟悉了闭包风格。<b>单行代码：</b>这要视情况而定。并引入临时变量把一个表达式拆开可以提高代码可读性，也容易为其设置断点。<b>使用接口：</b>不错的建议，但也不能过火。过去我也争论过类似的话题，不过引入太多接口会导致细小类型的爆炸，使你高端的类型意图变得模糊。<b>Erlang风格并行：</b>重申一点，使用Java设计以外的编程风格是危险的做法。java.util.concurrent中包含了非常有用的功能，我遇到过不少基于这些元素的Java抽象，它们要优于Erlang风格的actor架构。<b>Fluent Interface：</b>这个建议比较有趣，它与Stephan提出的另一个建议“避免setter”相违背。Fluent Interface只是setter的另一种形式，不是吗？<b>使用公有字段：</b>不，千万别这么做。你不会因为加了访问器而后悔，但是我能保证你会因为一时偷懒，使用了公有字段而后悔莫及。<p>在Cedric的文章之后，Stephan又对他的说法进行了补充：</p><p>没有setter并不代表你不能修改这个对象，我只是说纯粹的setter不是面向对象的思维方式。例如，你觉得stop()和setStop(true)哪个更好一些？</p><p>（针对Predicate代码不易读）我认为你的假设有误。循环是“程序化”的代码，而Predicate是经过封装的，可以重用的，易于理解的“对象”。这里并没有函数式编程，这里是纯粹的OO - 我提起FP只是因为我从那里“引入”了这个方式。</p><p>还有许多人对Stephon和Cedric的文章发表了评论，例如有人支持Stephan的观点，认为final的可以更好的表示出代码的意图。甚至有人提出：</p><p>更简单的解决方案是使用Scala :) - 不可变的状态、统一访问原则（字段、属性、方法看上去一样）、单行代码、使用monads或函数来替代循环……这些特性都已经在Scala中优雅地体现出来了。</p><p>您的Java编程风格是什么样的，和过去相比有什么改变吗？</p><p></p><p>&nbsp;</p><p></p></div></body></html>