<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>JDK 7 Adoption Guide</title></head><body><h1>JDK 7 Adoption Guide</h1><div><p>JDK 7 Adoption Guide</p><p>&nbsp;</p><p>http://download.oracle.com/javase/7/docs/webnotes/adoptionGuide/index.html</p><p>&nbsp;</p><p>Java SE 7 and JDK 7 Compatibility</p><p>http://www.oracle.com/technetwork/java/javase/compatibility-417013.html</p><p>&nbsp;</p><p>Java SE 7 Features and Enhancements</p><p>http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html</p><p>--------------------------</p><p>hxzon节选：</p><p>Area: API: AWT</p><p>Synopsis: Invoking Windows.setBackground may result in an UnsupportedOperationException exception</p><p>Description: Part of the new API to support per-pixel translucent windows has been incorporated into the existing Windows.setBackground() method. Setting the background to a non-opaque color results in making the window per-pixel translucent. However, some systems may not support this visual effect, and as such invoking the setBackground() method with a non-opaque color will result in an UnsupportedOperationException exception.</p><p>This does not affect new applications that set a non-opaque color deliberately because the code should first verify that the effect is supported by invoking the GraphicsDevice.isWindowTranslucencySupported method. However, legacy applications that apply a non-opaque background color to their frames may fail when the application is run on a system that doesn't support translucency effects. We hope that this will not affect too many legacy applications because a) there are few (if any) legacy apps that apply a non-opaque background color to their frames, and b) most modern systems support tranclucency effects.</p><p>Nature of Incompatibility: behavioral</p><p>RFE: 6802853</p><p>----------------------</p><p>Area: API: 2D</p><p>Synopsis: The Non-standard com.sun.image.jpeg.codec Package is Retired</p><p>Description: The com.sun.image.codec.jpeg package was added in JDK 1.2 (Dec 1998) as a non-standard way of controlling the loading and saving of JPEG format image files. This package was never part of the platform specification and it has been removed from the Java SE 7 release. The Java Image I/O API was added to the JDK 1.4 release as a standard API and eliminated the need for the com.sun.image.jpeg.codec package.</p><p>Nature of Incompatibility: binary and source</p><p>RFE: 6527962</p><p>--------------------</p><p>Area: Tools</p><p>Synopsis: A Class Cannot Define Two Methods with the Same Erased Signature but Two Different Return Types</p><p>Description: A class cannot define two methods with the same erased signature, regardless of whether the return types are the same or not. This follows from the JLS, Java SE 7 Edition, section 8.4.8.3. The JDK 6 compiler allows methods with the same erased signature but different return types; this behavior is incorrect and has been fixed in JDK 7.</p><p>Example:</p><p>class A {</p><p>&nbsp; &nbsp;int m(List&lt;String&gt; ls) { return 0; }</p><p>&nbsp; &nbsp;long m(List&lt;Integer&gt; ls) { return 1; }</p><p>}</p><p>This code compiles under JDK 5.0 and JDK 6, and is rejected under JDK 7.</p><p>Nature of Incompatibility: behavioral and source</p><p>RFE: 6182950</p><p>-----------------</p><p>Area: Tools</p><p>Synopsis: Compiler Disallows Non-Overriding Methods with the Same Erased Signatures</p><p>Description: In JDK 7, javac has been fixed so that it correctly implements the check described in the JLS, Java SE 7 Edition, section 8.4.8 and 9.4.1. This check states that a class may not contain two methods whose erased signatures are identical, even when those methods are not override-equivalent. This restriction, due to limitations of the type-erasure technique used by javac to translate generics, was not implemented properly in javac. As a result, there were some cases in which javac detected the problem, while there were other cases in which javac did not detect the problem. As a result of this fix, the checks described in 8.4.8 and 9.4.1 are now properly implemented, resulting in a slightly stricter javac behavior.</p><p>For instance, the following code is legal prior to JDK 7:</p><p>class A{</p><p>&nbsp; &nbsp;public int compareTo(Object o){</p><p>&nbsp; &nbsp; &nbsp; return 0;</p><p>&nbsp; &nbsp;}</p><p>}</p><p>&nbsp;</p><p>class B extends A implements Comparable&lt;B&gt; {</p><p>&nbsp; &nbsp;public int compareTo(B b){</p><p>&nbsp; &nbsp; &nbsp; return 0;</p><p>&nbsp; &nbsp;}</p><p>}</p><p>This code is now rejected by javac, on the basis that B contains two methods, compareTo(X) (indirectly overridden by Comparable&lt;B&gt;.compareTo(B)) and compareTo(Object) (from A) that are not override-equivalent, but whose erased signature is identical.</p><p>Nature of Incompatibility: behavioral and source</p><p>RFE: 6476118</p><p>------------------</p><p>Area: Tools</p><p>Synopsis: Changes in Most Specific Varargs Method Selection</p><p>Description: The overload resolution algorithm in the javac compiler has been fixed in how it selects the most specific varargs method when more than one method is applicable to a given call-site (see the JLS, Java SE 7 Edition, section 15.12.2.5). Because of a bug, both JDK 5.0 and JDK 6 compilers reject the following legal code:</p><p>class Test {</p><p>&nbsp; &nbsp; void foo(int... i) {}</p><p>&nbsp; &nbsp; void foo(double... d) {}</p><p>&nbsp;</p><p>&nbsp; &nbsp; void test() {</p><p>&nbsp; &nbsp; &nbsp; &nbsp;foo(1,2,3);</p><p>&nbsp; &nbsp; }</p><p>}</p><p>In the above example, both methods are applicable (because you can pass an int where a double is expected). Since both methods are applicable, the compiler must select the so-called most-specific method, that is, the best candidate among the two. This is done by looking at the signatures of both methods; in this case, since one method (foo(double...)) is accepting an argument that is more general than the other (foo(int...)), the answer is straightforward: the most specific method is foo(int...).</p><p>While the javac compiler accepts more code than it did prior to JDK 7, this fix also results in a slight source incompatibility in the following case:</p><p>class Test {</p><p>&nbsp; &nbsp; void foo(int... i) {}</p><p>&nbsp; &nbsp; void foo(Object... o) {}</p><p>&nbsp;</p><p>&nbsp; &nbsp; void test() {</p><p>&nbsp; &nbsp; &nbsp; &nbsp;foo(1,2,3);</p><p>&nbsp; &nbsp; }</p><p>}</p><p>This code compiles in JDK 6 (the most specific method is foo(int...)). This code does not compile under JDK 7. As per 15.12.2.5, it is not possible to choose between foo(int...) and foo(Object...) as neither int is a subtype of Object, nor Object is a subtype of int. This program should be disallowed (in fact, it should never have been allowed in the first place).</p><p>Nature of Incompatibility: behavioral and source</p><p>RFE: 6199075</p><p>------------------</p><p>Area: Tools</p><p>Synopsis: Compiler No Longer Allows More Than One Occurrence of the Same Parameterized Interface</p><p>Description: Previously, the compiler would allow parameterized interfaces twice. For example:</p><p>public abstract class Test implements Iterable&lt;Class&gt;, Iterable&lt;Class&amp;g</p><p>t; {}</p><p>or</p><p>public interface Test extends Iterable&lt;Class&gt;, Iterable&lt;Class&gt; {}</p><p>or</p><p>public abstract class Test&lt;T extends Iterable&lt;Class&gt; &amp; Iterable&lt;</p><p>Class&gt;&gt; {}</p><p>This bug has been fixed. If source code contains more than one instance of a parameterized interface, it needs to be cleaned up.</p><p>Nature of Incompatibility: behavioral and source</p><p>RFE: 4972073</p><p>------------------</p><p>Area: Tools</p><p>Synopsis: Compiler No Longer Allows Access to Private Members of Type Variables</p><p>Description: In JDK 5.0 and JDK 6, javac erroneously allowed access to private members of type-variables. This is wrong, as the JLS, Java SE 7 Edition, section 4.4, states that the members of a type-variable are the members of an intersection types whose components are the type-variable bounds (intersection types are defined in section 4.9) - and intersection types do not inherit private members from their components. As a result, the following program should get a compilation error:</p><p>class A {</p><p>&nbsp; &nbsp;private int val = 42;</p><p>}</p><p>&nbsp;</p><p>class Test&lt;X extends A&gt; {</p><p>&nbsp; &nbsp; void test(X x) {</p><p><span></span>int i = x.val; //error in JDK 7</p><p>&nbsp; &nbsp; }</p><p>}</p><p>The above program compiles in JDK 6. Note that accepting this program is inherently unsound; there is no guarantee that X will be instantiated to a type that inherits val. For instance, if we called test() on an instance whose type is Test&lt;B&gt;, where B is a subclass of A, val should not be accessible there. Since javac cannot guarantee the well-formedness of this program for all possible instantiations of X this program must be rejected.</p><p>Nature of Incompatibility: behavioral and source</p><p>RFE: 6246814</p><p>---------------------</p><p>Area: Tools</p><p>Synopsis: Compiler Rejects Access to Static Member in Parameterized Type</p><p>Description: It is possible for a generic class to define a non-generic nested class, as in:</p><p>class Outer&lt;X&gt; {</p><p>static class Inner {}</p><p>}</p><p>Since the inner class is static, it has no access to the outer class type-variables. Therefore it doesn't make sense to access the inner class type with a qualified identifier in the following form:</p><p>Outer&lt;String&gt;.Inner</p><p>This is now clarified in the JLS, Java SE 7 Edition, section 6.5.5.2.</p><p>Nature of Incompatibility: behavioral and source</p><p>RFE: 6486430</p><p>-----------------------</p><p>Area: API: Utilities</p><p>Synopsis: Updated sort behavior for Arrays and Collections may throw an IllegalArgumentException</p><p>Description: The sorting algorithm used by java.util.Arrays.sort and (indirectly) by java.util.Collections.sort has been replaced. The new sort implementation may throw an IllegalArgumentException if it detects a Comparable that violates the Comparable contract. The previous implementation silently ignored such a situation.</p><p>If the previous behavior is desired, you can use the new system property, java.util.Arrays.useLegacyMergeSort, to restore previous mergesort behavior.</p><p>Nature of Incompatibility: behavioral</p><p>RFE: 6804124</p><p>-------------------</p><p>Area: API: IO</p><p>Synopsis: java.io.File.setReadOnly and setWriteable Methods Have New Behavior</p><p>Description: As of JDK 7, on Windows, the java.io.File setReadOnly and setWritable methods no longer set the DOS readonly attribute on directories. This means that these methods will fail, by returning false, if the file is a directory. To preserve the relationship with canWrite, the canWrite method returns true if the file is a directory.</p><p>Applications that want to set directories on Windows to be read only must use the new API. In particular, the Files.isWritable method takes into account the effective access (as determined by the file's discretionary access control list) and whether the file is located on a writable volume.</p><p>Nature of Incompatibility: behavioral</p><p>RFE: 6728842</p><p>----------------</p><div><br /></div><p></p></div></body></html>