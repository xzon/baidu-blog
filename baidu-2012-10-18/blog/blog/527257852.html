<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Plastic: Advanced Example</title></head><body><h1>Plastic: Advanced Example</h1><div><h1>Plastic: Advanced Example</h1><p>http://feedproxy.google.com/~r/TapestryCentral/~3/N1cotcbT4ms/plastic-advanced-example.html</p><p>Howard Lewis Ship</p><p></p><p>Plastic is Tapestry's built-in&nbsp;<a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming" target="_blank">Aspect Oriented Programming</a>&nbsp;library, which primarily operates at the byte code level, but shields you from most byte code level thinking: normally, your code is implemented in terms of having method invocations or field reads and writes passed to callback objects that act as delegates or filters.</p><p>Sometimes, though, you need to get a little more low-level and generate the implementation of a method more directly. Plastic includes a&nbsp;<a href="http://en.wikipedia.org/wiki/Fluent_interface#Java" target="_blank">fluent interface</a>&nbsp;for this as well:&nbsp;<a href="http://tapestry.apache.org/current/apidocs/org/apache/tapestry5/plastic/InstructionBuilder.html" target="_blank">InstructionBuilder</a>.</p><p>This is an example from Tapestry's&nbsp;<a href="http://en.wikipedia.org/wiki/Inversion_of_control" target="_blank">Inversion Of Control</a>&nbsp;(IoC) container code; the proxy instance is the what's exposed to other services, and encapsulates two particular concerns: First, the late instantiation of the actual service implementation, and second, the ability to serialize the proxy object (even though the services and other objects are decidedly&nbsp;not&nbsp;serializable).</p><p>In terms of serialization, what actually gets serialized is a ServiceProxyToken object; when a ServiceProxyToken is later de-serialized, it can refer back to the equivalent proxy object in the new JVM and IoC Service Registry. The trick is to use the magicwriteReplace()&nbsp;method so that when the proxy is serialized, the token is written instead. Here's the code:</p><p>To kick things off, we use the&nbsp;<a href="http://tapestry.apache.org/current/apidocs/org/apache/tapestry5/ioc/services/PlasticProxyFactory.html" target="_blank">PlasticProxyFactory</a>&nbsp;service to create a proxy that implements the service's interface.</p><p>The callback passed to&nbsp;createProxy()&nbsp;is passed the&nbsp;<a href="http://tapestry.apache.org/current/apidocs/org/apache/tapestry5/plastic/PlasticClass.html" target="_blank">PlasticClass</a>&nbsp;object. This is initially an implementation of the service interface where each interface method does nothing.</p><p>The basic setup includes making the proxy implement&nbsp;<a href="http://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html" target="_blank">Serializable</a>&nbsp;and creating and injecting values into new fields for the other data that's needed.</p><p>Next, a method called&nbsp;delegate()&nbsp;is created; it is responsible for lazily creating the real service when first needed. This is actually encapsulated inside an instance of&nbsp;<a href="http://tapestry.apache.org/current/apidocs/org/apache/tapestry5/ioc/ObjectCreator.html" target="_blank">ObjectCreator</a>; the&nbsp;delegate()&nbsp;method simply invokes the&nbsp;create()&nbsp;method and casts the result to the service interface.</p><p>The methods on InstructionBuilder have a very close correspondence to JVM byte codes. So, for example, loading an instance field involves ensuring that the object containing the field is on the stack (via&nbsp;loadThis()), then consuming the&nbsp;this&nbsp;value and replacing it with the instance field value on the stack, which requires knowing the class name, field name, and field type of the field to be loaded. Fortunately, the&nbsp;<a href="http://tapestry.apache.org/current/apidocs/org/apache/tapestry5/plastic/PlasticField.html" target="_blank">PlasticField</a>&nbsp;knows all this information, which streamlines the code.</p><p>Once the ObjectCreator is on the stack, a method on it can be invoked; at the byte code level, this requires the class name for the class containing the method, the return type of the method, and the name of the method (and, for methods with parameters, the parameter types). The result of that is the service implementation instance, which is cast to the service interface type and returned.</p><p>Now that the&nbsp;delegate()&nbsp;method is in place, it's time to make each method invocation on the proxy invoke&nbsp;delegate()&nbsp;and then re-invoke the method on the late-instantiated service implementation. Because this kind of delegation is so common, its supported by the&nbsp;delegateTo()&nbsp;method.</p><p>introduceMethod()&nbsp;can access an existing method or create a new one; for the&nbsp;writeReplace()&nbsp;method, the&nbsp;introduceMethod&nbsp;call creates a new, empty method. The call to&nbsp;changeImplementation()&nbsp;is used to replace the default empty method implementation with a new once; again, loading an injected field value, but then simply returning it.</p><p>Finally, because&nbsp;<a href="http://tapestryjava.blogspot.com/2003/08/importance-of-tostring.html" target="_blank">I feel strongly about including a useful&nbsp;toString()&nbsp;method in virtually all objects</a>, this is also made easy in Plastic.</p><p>Once the class has been defined, it's just a matter of invoking the&nbsp;newInstance()&nbsp;method on the&nbsp;<a href="http://tapestry.apache.org/current/apidocs/org/apache/tapestry5/plastic/ClassInstantiator.html" target="_blank">ClassInstantiator</a>&nbsp;object to instantiate a new instance of the proxy class. Behind the scenes, Plastic has created a constructor to set the injected field values, but another of the nice parts of the Plastic API is that you don't have to manage that: ClassInstantiator does the work.</p><p>I'm pretty proud of the Plastic APIs in general; I think they strike a good balance between making common operations simple and concise, but still providing you with an escape-valve to more powerful (or more efficient) mechanisms, such as the InstructionBuilder examples above. Of course, the deeply-nested callback approach can be initially daunting, but that's mostly a matter of syntax, which may be addressed in JDK 8 with the addition of proper closures to the Java language.</p><p>I strongly feel that Plastic is a general purpose tool, that goes beyond inversion of control and the other manipulations that are specific to Tapestry ... and Plastic was designed specifically to be reused outside of Tapestry. It seems like it could be used for anything from implementing simple languages and DSLs, to providing all kinds of middleware code in new domains ... I have a fuzzy idea involving JMS and JSON with a lot of wiring and dispatch that could be handled using Plastic. I'd love to hear other people's ideas!</p></div></body></html>