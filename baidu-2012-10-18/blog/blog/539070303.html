<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>为什么我们要学习Haskell这样的编程语言</title></head><body><h1>为什么我们要学习Haskell这样的编程语言</h1><div><h1>为什么我们要学习Haskell这样的编程语言</h1><div><p>http://www.aqee.net/learn-you-a-haskell-for-great-good/</p><p>最近的几个月，我一直在学习一种叫Haskell的编程语言。由于里面有太多的从未遇到的编程概念，整个过程就像是完全重新学习如何编程。在<a href="http://corp.i.tv/" target="_blank">i.TV</a>网站上，我写了很多JavaScript(<a href="http://nodejs.org/" target="_blank" title="Node.js">node.js</a>和前端代码)。虽然有不少的函数式/haskell式的编程模式不能引用进来，但仍有大量的技术思想让我在使用javascript编程语言时受益不少。</p><p>&nbsp;</p><p>你会发现Haskell库里有能够处理各种事情的各种各样的函数。起初我以为这些只是一种技术上的积累，但随后我认识到，这些函数相比起其它语言里的函数，它们能应用到形式更广泛的问题中。这使得它们更有价值，因为我们都不太喜欢对一些常见的问题还不得不自己去写解决方案。</p><p>这些函数是可以相互组合<a href="http://www.aqee.net/learn-you-a-haskell-for-great-good/#fn:1" rel="footnote" target="_blank">1</a>的：它们能针对性的解决某些问题，而不对你的代码做任何依赖，所以，你可以拼装它们，组合成一个能够解决你的大问题的东西。</p><h3>高阶函数(Higher Order Functions)</h3><p>在Haskell语言中，最多的被反复使用的函数都是<a href="http://en.wikipedia.org/wiki/Higher-order_function" target="_blank" title="Higher Order Function">高阶函数(higher order functions)</a>——能以函数作为参数、能返回函数的函数。这使得它们具有固有的灵活性。下面是一个不太灵活的函数：它计算一个数组里等于某个值的元素的个数。</p><p>// 不灵活<br />function&nbsp;countMatching(array,&nbsp;value)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;counted&nbsp;=&nbsp;0<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;array.length;&nbsp;i++)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(array[i]&nbsp;==&nbsp;value)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counted++<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;counted<br />}</p><p>// == 2<br />countMatching([1,3,3,4,5],&nbsp;3)</p><p>它不灵活，因为它只能用来计算一个数组中精确匹配某个值的元素的个数。</p><p>下面是一个灵活一些的版本，它能接受一个函数，而不是一个值，作为参数。我们可以用它来对任何数据、任何对象进行比较。</p><p>// more&nbsp;flexible<br />function&nbsp;count(array,&nbsp;matching)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;counted&nbsp;=&nbsp;0<br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;array.length;&nbsp;i++)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(matching(array[i]))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counted++<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;counted<br />}</p><p>// == 2, same as first example<br />count([1,3,3,4,5],&nbsp;function(num)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(num&nbsp;==&nbsp;3)<br />})</p><p>// == 2, now we can use our functions for ANY kind of items or match test!<br />count([{name:&quot;bob&quot;},&nbsp;{name:&quot;henry&quot;},&nbsp;{name:&quot;jon&quot;}],&nbsp;function(obj)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(obj.name.length&nbsp;&lt;&nbsp;4)<br />})</p><p>因为高阶函数更具灵活性，你就更少有机会去写它们，因为你一旦你写成一个，你可以它应用到各种不同的情况中。</p><h3>可重复利用的比较函数</h3><p>你可能注意到了，count函数的写法比countMatching更冗长。但是，虽然count函数可复用了，但比较函数<a href="http://www.aqee.net/learn-you-a-haskell-for-great-good/#fn:2" rel="footnote" target="_blank">2</a>却不可复用。如果是一些简单的情况，这就足够了，但经常，我们会需要更复杂的比较方法的函数。这样的函数不仅仅可用于计数，它们可以用于任何事情上，一但你写成或找到了这样的函数，从长期的角度看，它们会节省你大量的时间和调试功夫。</p><p>让我们来定义一个可复用的比较函数，达到我们的目的。==不是一个函数。我们是否可以定义一个eq函数来帮我们完成类似的事情呢？</p><p>function&nbsp;eq(a,&nbsp;b)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(a&nbsp;==&nbsp;b)<br />}</p><p>count([1,3,3,4,5],&nbsp;function(num)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;eq(3,&nbsp;num)<br />})</p><p>我们向前迈进了一步：我们用了一个库函数来完成比较任务，而不是使用我们现写的代码。如果eq函数很复杂，我们可以测试它并可以在其它的地方复用它。</p><p>但这使代码变得冗长，因为count函数的参数是一个只需要一个参数——数组元素——的函数，而eq函数却需要两个参数。我还是要定义我们自己的匿名函数。让我们来简化一下这些代码。</p><p><br />function&nbsp;makeEq(a)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;// countMatchingWith wants a function that takes&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;// only 1 argument, just like the one we're returning<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;function(b)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;eq(a,&nbsp;b)<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}</p><p>// now it's only on one line!<br />count([1,3,3,4,5],&nbsp;makeEq(3))</p><p>我们写了一个兼容count函数的函数(一个参数——数组元素——返回true或false)。看起来就像是count函数调用的是eq(3, item)。这叫做偏函数用法(partial function application)。</p><h3>偏函数用法(Partial Application)</h3><p><a href="http://en.wikipedia.org/wiki/Partial_application" target="_blank" title="Partial Application">偏函数用法(Partial Function Application)</a>是指创建一个调用另外一个部分参数已经预置的函数的函数的用法。这样，它就能被别的地方，比如count函数，以更少的参数形式来调用。我们在makeEq函数里已经实现了这些，但是，我们并不想针对我们各种功能开发出各种版本的makeX(比如makeEqt，makeGt，makeLt等)函数。让我们来找一种方法能通用于各种形式的函数。</p><p>function&nbsp;applyFirst(f,&nbsp;a)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;function(b)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;f.call(null,&nbsp;a,&nbsp;b)<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}</p><p>count([1,3,3,4,5],&nbsp;applyFirst(eq,&nbsp;3))</p><p>现在我们不再需要一个makeEq函数了。任何2个参数的库函数，我们都可以按这种方式调用。通过偏函数用法，使得定义即使是诸如==这样简单功能的各种函数都变得十分有意义，我们可以在高阶函数中更容易的使用它们。</p><p>对那些超过2个参数的函数如何办呢？下面的这一版本<a href="http://www.aqee.net/learn-you-a-haskell-for-great-good/#fn:3" rel="footnote" target="_blank">3</a>能让我们接受任意多的参数，高阶函数可以自己追加参数。</p><p>function&nbsp;apply(f)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;args&nbsp;=&nbsp;Array.prototype.slice.call(arguments,&nbsp;1)<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;function(x)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;f.apply(null,&nbsp;args.concat(x))<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}</p><p>function&nbsp;propertyEquals(propertyName,&nbsp;value,&nbsp;obj)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(obj[propertyName]&nbsp;==&nbsp;value)<br />}</p><p>count([{name:&quot;bob&quot;},{name:&quot;john&quot;}],&nbsp;apply(propertyEquals,&nbsp;&quot;name&quot;,&nbsp;&quot;bob&quot;))&nbsp;// == 1</p><p>我们预置了2个参数，“name” 和 “bob”，count函数补足了最后一个参数来完成整个调用。偏函数用法使我们能接受各样的函数为参数，例如eq，然后把它们用于各样的高阶函数，例如count，以此来解决我们特定的问题。</p><h3>配合ES5的 Map 和 Filter 功能函数的偏函数用法</h3><p><a href="http://kangax.github.com/es5-compat-table/" target="_blank">ES5</a>里有很多非常好的高阶函数，<a href="http://documentcloud.github.com/underscore/" target="_blank">underscore</a>里的数量更多。让我们看看filter函数——一个接收比较函数、过滤数组内容的函数。</p><p>// this equals [1,3,3]<br />[1,3,3,4,5].filter(function(num)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(num&nbsp;&lt;&nbsp;4)<br />})</p><p>让我们把它替换成一个可以复用的比较函数lt&nbsp;(less than)。</p><p>function&nbsp;lt(a,&nbsp;b)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(a&nbsp;&lt;&nbsp;b)<br />}</p><p>[1,3,3,4,5].filter(apply(lt,&nbsp;4))</p><p>看上去添加这个lt函数的做法有点傻，但是，我们可以使用偏函数用法来创造一个很简练的比较函数，当这个比较函数变的很复杂的时候，我们就能从对它的复用过程中获得好处。</p><p>map函数能让你把数组里的一个东西变成另外一个东西。</p><p>var&nbsp;usersById&nbsp;=&nbsp;{&quot;u1&quot;:{name:&quot;bob&quot;},&nbsp;&quot;u2&quot;:{name:&quot;john&quot;}}<br />var&nbsp;user&nbsp;=&nbsp;{name:&quot;sean&quot;,&nbsp;friendIds:&nbsp;[&quot;u1&quot;,&nbsp;&quot;u2&quot;]}</p><p>// == [&quot;bob&quot;, &quot;john&quot;]<br />function&nbsp;friendsNames(usersById,&nbsp;user)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;user.friendIds.map(function(id)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;usersById[id].name<br />&nbsp;&nbsp;&nbsp;&nbsp;})<br />}</p><p>我们写一个可以复用的map变换函数，就像之前我们的可复用比较函数一样。让我们写一个叫做lookup的函数。</p><p>function&nbsp;lookup(obj,&nbsp;key)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;obj[key]<br />}</p><p>// == [{name:&quot;bob&quot;}, {name:&quot;john&quot;}]<br />function&nbsp;friends(usersById,&nbsp;user)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;user.friendIds.map(apply(lookup,&nbsp;usersById))<br />}</p><p>很接近要求，但我们需要的是名称，而不是friend对象本身。如果我们再写一个参数颠倒过来的&nbsp;lookup函数，通过第二次的map可以把它们的名称取出来。</p><p>function&nbsp;lookupFlipped(key,&nbsp;obj)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;lookup(obj,&nbsp;key)<br />}</p><p>// == [&quot;bob&quot;, &quot;john&quot;]<br />function&nbsp;friendsNames(usersById,&nbsp;user)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;friends(usersById,&nbsp;user)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.map(apply(lookupFlipped,&nbsp;&quot;name&quot;))<br />}</p><p>但是我不想定义这个lookupFlipped函数，这样干有点傻。这样，我们来定义一个函数，它接收参数的顺序是从右到左，而不是从左到右，于是我们就能够复用lookup了。</p><p>function&nbsp;applyr(f)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;args&nbsp;=&nbsp;Array.prototype.slice.call(arguments,&nbsp;1)<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;function(x)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;f.apply(null,&nbsp;[x].concat(args))<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}</p><p>// == [&quot;bob&quot;, &quot;john&quot;]<br />function&nbsp;friendsNames(usersById,&nbsp;user)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;friends(usersById,&nbsp;user)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.map(applyr(lookup,&nbsp;&quot;name&quot;))&nbsp;// we can use normal lookup!<br />}</p><p>applyr(lookup, &quot;name&quot;)函数返回的函数只接受一个参数——那个对象——返回对象的名称。我们不再需要反转任何东西：我们可以按任何顺序接受参数。</p><p>偏函数用法需要对一些常见的功能定义各种不同的函数，就像lt函数，但这正是我们的目的。你可以以偏函数用法把lt函数既用于count函数，也可用于Array.filter函数。它们可以复用，可以组合使用。</p><h3><a href="http://en.wikipedia.org/wiki/Function_composition_%28computer_science%29" target="_blank" title="Function Composition">函数组合</a></h3><p>在之前的例子中，我们遍历了数组两次，一次用来获取users，一次为了获取names。如果能在一次map映射操作中同时做这两件事情，效率会高很多。</p><p>function&nbsp;friendsNames(usersById,&nbsp;user)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;user.friendIds.map(function(id)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;friend&nbsp;=&nbsp;lookup(usersById,&nbsp;id)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;lookup(friend,&nbsp;&quot;name&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;})<br />}</p><p>我们得到首次lookup的结果，把它第二次传入lookup。<a href="http://en.wikipedia.org/wiki/Function_composition_%28computer_science%29" target="_blank" title="Function Composition">函数组合</a>意思是串联多个函数，组成一个新的函数，每一次串联都是把前一个函数的输出当作下一个函数的输入。</p><p>让我们来写一个能这样运转的高阶函数，利用它把friendsNames函数重写成一个只需要单次map操作的函数。需要注意的是，函数串联的执行顺序是从右到左的，就跟你写出f(g(x))这样的代码的运行方式一样。</p><p>function&nbsp;compose(f,&nbsp;g)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;function(x)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;f(g(x))<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}</p><p>function&nbsp;friendsNames(usersById,&nbsp;user)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;user.friendIds.map(compose(applyr(lookup,&nbsp;&quot;name&quot;),&nbsp;apply(lookup,&nbsp;usersById)))<br />}</p><p>对数组的遍历只进行了一次，只使用一次map操作，跟我们头一个例子一样。</p><p>我们不能使用我们写出的friends函数，因为它既包含了如何取出一个friend的业务逻辑，也包含了map操作。friends函数是不能复用的，它的职责太多了——它是针对特定事物的。如果你们再写一个friend函数，让它只map一个friend，写一个name函数，让它返回对象的名称呢？</p><p>var&nbsp;friend&nbsp;=&nbsp;lookup&nbsp;// lookup 恰巧能干我们想要的事情。<br />var&nbsp;name&nbsp;=&nbsp;applyr(lookup,&nbsp;&quot;name&quot;)</p><p>function&nbsp;friendsNames(usersById,&nbsp;user)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;// this line is now more semantic.&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;user.friends.map(compose(name,&nbsp;apply(friend,&nbsp;usersById)))<br />}</p><p>相较于定义一个既包含转换操作，又包含遍历操作的friends函数，我们只定义了一个可做转换操作的friend函数，而我们已经有了map函数为我做变换操作。friend函数比friends函数更具复用性，因为它包含更少的特定业务逻辑，能在更多的情形中使用。</p><p>在<a href="http://javascriptweblog.wordpress.com/2010/04/14/compose-functions-as-building-blocks/" target="_blank" title="Compose: functions as building blocks">这里</a>你能找到更多的关于JavaScript里函数组合的信息。</p><h3>函数式和功能单一化让你的代码库更整洁</h3><p>我发现我的很多的JavaScript代码都是从无到有自己写出来的。这不仅仅是说比起使用现成的程序包要效率低，它还会暗藏更多的bug，更难阅读和维护。使用高阶函数和偏函数用法，我们可以写出可复用的程序库，每个函数都精准的对应解决它们能解决的一部分问题。</p><p>随着时间的推移，项目会变得越来越复杂，各部分越来越耦合，如果我们拥有的是一个能够各自独立测试不依赖的程序库，我们的项目会从中受益，变得更健康，更稳定。</p><p>&nbsp;</p><ol><li><p>一种宽泛的组合。并不特指函数或对象组合，只是一种你用小东西组建大东西的思想。<a href="http://www.aqee.net/learn-you-a-haskell-for-great-good/#fnref:1" rev="footnote" target="_blank">?</a></p></li><li><p>“Matching functions”被称作<a href="http://en.wikipedia.org/wiki/Predicate_%28mathematical_logic%29" target="_blank" title="Predicate">predicates</a>，但我这里不想引入新的编程术语。<a href="http://www.aqee.net/learn-you-a-haskell-for-great-good/#fnref:2" rev="footnote" target="_blank">?</a></p></li><li><p><a href="http://msdn.microsoft.com/en-us/scriptjunkie/gg575560" target="_blank" title="Partial Application in Javascript">这里</a>有更通用的apply实现。<a href="http://www.aqee.net/learn-you-a-haskell-for-great-good/#fnref:3" rev="footnote" target="_blank">?</a></p></li></ol><p>[本文英文原文链接：<a href="http://seanhess.github.com/2012/02/20/functional.html" target="_blank">Learn You a Haskell: For Great Good?</a>&nbsp;]</p></div></div></body></html>