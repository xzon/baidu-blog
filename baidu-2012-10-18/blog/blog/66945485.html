<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>关于C#,C++,Java在继承，覆盖和多态,抽象类等几个方面的比较归纳。</title></head><body><h1>关于C#,C++,Java在继承，覆盖和多态,抽象类等几个方面的比较归纳。</h1><div>关于C#,C++,Java在继承，覆盖和多态,抽象类等几个方面的比较归纳。<br><br>关于C#,C++,Java在继承，覆盖和多态,抽象类等几个方面的比较归纳。<br>C#,C++用visual studio2005编译通过；java代码用JDK1.4.2编译通过。<br><br><br>一、继承中的带参数构造函数<br>=============================<br>C#示例：<br>//myClass.cs<br><br>using System;<br>using System.Collections.Generic;<br>using System.Text;<br><br>namespace myClass<br>&nbsp;&nbsp;&nbsp; class myFirst{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value_myFirst;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public myFirst(int f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myFirst = f; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; class mySecond : myFirst{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value_mySecond;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //构造函数传递参数时，采用base关键字，s在base()中不需重新声明类型int<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public mySecond(int s)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : base(s) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; class Program<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static void Main(string[] args)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br><br>============================<br><br>C++示例：<br>＃i nclude "stdafx.h"<br><br>class myFirst{<br>private:<br>&nbsp;&nbsp;&nbsp; int value_myFirst;<br>public:<br>&nbsp;&nbsp;&nbsp; myFirst(int f){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myFirst = f; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>//继承需要声明继承的方式，此处是public<br>class mySecond : public myFirst{<br>private:<br>&nbsp;&nbsp;&nbsp; int value_mySecond;<br>public:<br>&nbsp;&nbsp;&nbsp; //构造函数传递参数时，用基类类名，s基类类名()中不需声明类型int<br>&nbsp;&nbsp;&nbsp; mySecond(int s) : myFirst(s){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>};<br><br>int _tmain(int argc, _TCHAR* argv[])<br>{<br>return 0;<br>}<br><br>=============================<br><br>java示例：<br>package com;<br><br>class myFirst{<br>&nbsp;&nbsp;&nbsp; int value_myFirst;<br>&nbsp;&nbsp;&nbsp; public myFirst(int f){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myFirst = f; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>//继承采用extends关键字<br>class mySecond extends myFirst{<br>&nbsp;&nbsp;&nbsp; int value_mySecond;<br>&nbsp;&nbsp;&nbsp; public mySecond(int s){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //传递给基类构造函数时，采用super关键字，而且必须是第一条语句。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(s);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>public class myCon{<br>&nbsp;&nbsp;&nbsp; public static void main(String[] args){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>注意：<br>1.注释中给出了三者的不同点。<br>2.另外，C++语法中定义的类后面必须加上分号";"<br>3.访问控制权限public等的格式，C#和java比较类似，C++相差很大。<br><br>二、方法覆盖与多态<br><br>C#示例：<br>//myClass.cs<br><br>using System;<br>using System.Collections.Generic;<br>using System.Text;<br><br>namespace myClass<br>{<br>&nbsp;&nbsp;&nbsp; class myFirst<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value_myFirst;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public myFirst(int f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myFirst = f;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void f1()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine("myFirst.f1()!");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public virtual void f2() //virtual也可以提到最前面<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine("myFirst.f2()!");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; class mySecond : myFirst<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value_mySecond;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public mySecond(int s)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : base(s)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //使用关键字new覆盖基类中的同名方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public new void f1()&nbsp;&nbsp;&nbsp;&nbsp; //new也可以提到最前面<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine("mySeconde.f1()!");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //error当基类函数myFirst.f1()没有声明为virtual,abstract时不能override！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //public override void f1()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; System.Console.WriteLine("mySeconde.f1()!");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //基类函数中虽然声明是virtual，但是仍然可以用new覆盖。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //public new void f2()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; System.Console.WriteLine("mySeconde.f2()!");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ////基类函数中虽然声明是virtual，用override覆盖。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public override void f2()&nbsp;&nbsp; //override也可以提到最前面<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine("mySeconde.f2()!");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; class Program<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static void Main(string[] args)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myFirst mf = new myFirst(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mySecond ms = new mySecond(2);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf.f1(); //myFirst.f1()!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf.f2(); //myFirst.f2()!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.f1(); //mySeconde.f1()!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.f2(); //mySeconde.f2()!<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf = ms; //向上转型之后<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf.f1(); //myFirst.f1()!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //mySeconde.f2()! 这是用override的运行结果；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果是new那么，结果是myFirst.f2()!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf.f2();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>=============================<br><br>C++示例<br><br>＃i nclude "stdafx.h"<br>＃i nclude &lt;iostream&gt;<br>using namespace std;<br><br>class myFirst{<br>private:<br>&nbsp;&nbsp;&nbsp; int value_myFirst;<br>public:<br>&nbsp;&nbsp;&nbsp; myFirst(int f){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myFirst = f; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br><br>void f1(){<br>cout&lt;&lt;"myFirst.f1()!"&lt;&lt;endl;<br>}<br>vitual void f2(){ //声明为虚函数<br>cout&lt;&lt;"myFirst.f2()!"&lt;&lt;endl;<br>}<br>};<br><br>class mySecond : public myFirst{<br>private:<br>&nbsp;&nbsp;&nbsp; int value_mySecond;<br>public:<br>&nbsp;&nbsp;&nbsp; mySecond(int s) : myFirst(s){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; //直接覆盖基类函数，无需C#中的new<br>void f1(){<br>cout&lt;&lt;"mySecond.f1()!"&lt;&lt;endl;<br>}<br>&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; //覆盖基类需函数<br>void f2(){<br>cout&lt;&lt;"mySecond.f2()!"&lt;&lt;endl;<br>}<br>};<br><br>int _tmain(int argc, _TCHAR* argv[])<br>{<br>myFirst *mf = new myFirst(1);<br>mySecond *ms = new mySecond(1);<br>mf-&gt;f1(); //myFirst.f1()!<br>mf-&gt;f2(); //myFirst.f2()!<br><br>ms-&gt;f1(); //mySecond.f1()!<br>ms-&gt;f2(); //mySecond.f2()!<br><br>mf = ms; //向上转型<br>mf-&gt;f1(); //myFirst.f1()!<br>mf-&gt;f2(); //mySecond.f2()!<br><br>myFirst mf1(1); //也可以<br>mf1.f1();<br><br>return 0;<br>}<br><br>=============================<br><br>java示例<br>//myCon.java<br><br>package com;<br><br>class myFirst{<br>&nbsp;&nbsp;&nbsp; int value_myFirst;<br>&nbsp;&nbsp;&nbsp; public myFirst(int f){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myFirst = f; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; public void f1(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("myFirst.f1()!");&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>}<br><br><br>class mySecond extends myFirst{<br>&nbsp;&nbsp;&nbsp; int value_mySecond;<br>&nbsp;&nbsp;&nbsp; public mySecond(int s){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(s);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; public void f1(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("mySecond.f1()!");&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }&nbsp; &nbsp;<br>}<br><br>class myThird extends myFirst{<br>&nbsp;&nbsp;&nbsp; int value_myThird;<br>&nbsp;&nbsp;&nbsp; public myThird(int t){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(t);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myThird = t;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; public void f1(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("myThird.f1()!");&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp; &nbsp;<br>}<br><br>public class myCon{<br>&nbsp;&nbsp;&nbsp; public static void main(String[] args){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myFirst mf = new myFirst(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mySecond ms = new mySecond(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myThird mt = new myThird(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf.f1(); //myFirst.f1()!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.f1(); //mySecond.f1()!&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mt.f1(); //myThird.f1()!&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //向上转型，由于java的动态绑定机制，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //使得java能够调用派生类mySecond的f1()&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf = ms;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf.f1(); //mySecond.f1()!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf = mt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf.f1(); //myThird.f1()!&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>为了实现多态：<br>1.C#基类方法要声明为virtual，派生类覆盖时要用override；<br>2.C++基类方法要声明为virtual，派生类方法直接覆盖；<br>3.java直接覆盖就可以实现多态。<br><br>三、抽象类<br><br>C#示例<br>上面已经说明，虽然基类方法声明为virtual，以便派生类用override覆盖，但是派生类仍然可以用<br>new关键字覆盖(不具有多态性)。<br>可以强制让派生类覆盖基类的方法，将基类方法声明为抽象的，采用abstract关键字。<br>抽象方法没有方法体，由派生类来提供。<br><br>如果派生类不实现基类的抽象方法，则派生类也需要声明为abstract类<br><br>//myClass.cs<br><br>using System;<br>using System.Collections.Generic;<br>using System.Text;<br><br>namespace myClass{<br>&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; //类中只要存在抽象方法，就必须声明为抽象类<br>&nbsp;&nbsp;&nbsp; abstract class myFirst<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value_myFirst;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public myFirst(int f)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myFirst = f;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //抽象方法没有方法体，以分号结尾。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public abstract void f1();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void f2()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine("myFirst.f2()!");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public virtual void f3()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine("myFirst.f3()!");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; class mySecond : myFirst<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int value_mySecond;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public mySecond(int s)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : base(s)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //覆盖基类抽象方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public override void f1() &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine("mySeconde.f1()!");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //覆盖基类一般方法&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public new void f2()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine("mySeconde.f2()!");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //覆盖基类虚拟方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public override void f3()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Console.WriteLine("mySecond.f3()!");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; class Program<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static void Main(string[] args)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //抽象类和接口不能声明对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //myFirst mf = new myFirst(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mySecond ms = new mySecond(2);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.f1(); //mySeconde.f1()!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.f2(); //mySeconde.f2()!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.f3(); //mySecond.f3()!<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //这里向上转型采用强类型转换的方式<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((myFirst)ms).f1();&nbsp;&nbsp; //mySeconde.f1()!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((myFirst)ms).f2();&nbsp;&nbsp; //myFirst.f2()!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((myFirst)ms).f3();&nbsp;&nbsp; //mySecond.f3()!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>=============================<br><br>C++示例<br><br>纯虚函数是在基类中只宣布某个虚函数的原型，并且为了明确通知编译系统，<br>该虚函数在基类中不再定义具体操作代码，而在函数原型结束分号的左侧写<br>"=0"标识。这个不包含任何代码的虚函数被成为纯虚函数。<br><br>抽象类是含有纯虚函数的类，这种类不能声明任何对象，其作用就是为它的<br>派生类提供一种规定输入数据和返回类型接口的模板。<br><br>从抽象类派生的派生类，必须对基类的纯虚函数进行覆盖；否则编译系统将<br>报错。<br><br>基类中虚函数被派生类覆盖，则派生类对象调用的是派生类中重新定义的函<br>数代码。<br>基类中虚函数没有被派生类覆盖，则派生类对象调用的是基类中定义的函数<br>代码。<br>基类的纯虚函数在其派生类中必须被覆盖。<br><br>＃i nclude "stdafx.h"<br>＃i nclude &lt;iostream&gt;<br>using namespace std;<br><br>class myFirst{&nbsp;&nbsp; //抽象类<br>private:<br>&nbsp;&nbsp;&nbsp; int value_myFirst;<br>public:<br>&nbsp;&nbsp;&nbsp; myFirst(int f){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myFirst = f; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br><br>void f1(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //一般函数<br>cout&lt;&lt;"myFirst.f1()!"&lt;&lt;endl;<br>}<br>virtual void f2(){&nbsp;&nbsp; //虚函数<br>cout&lt;&lt;"myFirst.f2()!"&lt;&lt;endl;<br>}<br><br>virtual void f3()=0; //纯虚函数<br>};<br><br>class mySecond : public myFirst{<br>private:<br>&nbsp;&nbsp;&nbsp; int value_mySecond;<br>public:<br>&nbsp;&nbsp;&nbsp; mySecond(int s) : myFirst(s){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br><br>void f1(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //覆盖基类一般函数<br>cout&lt;&lt;"mySecond.f1()!"&lt;&lt;endl;<br>}<br><br>void f2(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //覆盖基类虚函数<br>cout&lt;&lt;"mySecond.f2()!"&lt;&lt;endl;<br>}<br>void f3(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //覆盖基类纯虚函数<br>cout&lt;&lt;"mySecond.f3()!"&lt;&lt;endl;<br>}<br>};<br><br>int _tmain(int argc, _TCHAR* argv[])<br>{<br>//myFirst *mf = new myFirst(1); //抽象类不能创建对象<br>mySecond *ms = new mySecond(1);<br><br>ms-&gt;f1(); //mySecond.f1()!<br>ms-&gt;f2(); //mySecond.f2()!<br>ms-&gt;f3(); //mySecond.f3()!<br><br>&nbsp;&nbsp;&nbsp; //向上转型采用强类型转换<br>((myFirst *)ms)-&gt;f1(); //myFirst.f1()!<br>((myFirst *)ms)-&gt;f2(); //mySecond.f2()!<br>((myFirst *)ms)-&gt;f3(); //mySecond.f3()!<br><br>return 0;<br>}<br><br>=============================<br><br>java示例<br><br>java提供了抽象方法的机制abstract method，这种方法不完整，仅有声明<br>没有方法体<br>abstract void f();<br>包含抽象方法的类叫抽象类，如果类中包含一个或多个抽象方法，则该类必<br>须被声明为抽象类，用abstract来修饰抽象类。<br>如果从一个抽象类继承，并创建这个新类的对象，必须给抽象基类中所有抽<br>象方法提供方法定义，否则，派生类也是抽象类，也用abstract修饰。<br><br>package com;<br><br>abstract class myFirst{<br>&nbsp;&nbsp;&nbsp; int value_myFirst;<br>&nbsp;&nbsp;&nbsp; public myFirst(int f){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myFirst = f; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; public void f1(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("myFirst.f1()!");&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; public abstract void f2();&nbsp;&nbsp;&nbsp; //抽象方法 &nbsp;<br>}<br><br>//继承采用extends关键字<br>class mySecond extends myFirst{<br>&nbsp;&nbsp;&nbsp; int value_mySecond;<br>&nbsp;&nbsp;&nbsp; public mySecond(int s){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //传递给基类构造函数时，采用super关键字，而且必须是第一条语句。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(s);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; public void f1(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("mySecond.f1()!");&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; public void f2(){ //覆盖基类抽象方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("mySecond.f2()!");&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; } &nbsp;<br>}<br><br>//如果不实现基类抽象方法，那么此派生类也必须用abstract修饰<br>abstract class myThird extends myFirst{<br>&nbsp;&nbsp;&nbsp; int value_myThird;<br>&nbsp;&nbsp;&nbsp; public myThird(int t){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(t);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_myThird = t;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; public void f1(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("myThird.f1()!");&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp; &nbsp;<br>}<br><br>public class myCon{<br>&nbsp;&nbsp;&nbsp; public static void main(String[] args){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //myFirst mf = new myFirst(1); //抽象函数不能创建对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mySecond ms = new mySecond(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //myThird mt = new myThird(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.f1(); //mySecond.f1()!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.f2(); //mySecond.f2()!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((myFirst)ms).f1(); //mySecond.f1()!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((myFirst)ms).f2(); //mySecond.f2()!<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br><br>关于抽象方法和抽象类java和C#比较类似；<br>而C++叫纯虚函数和抽象类。<br><br><br>四、接口<br>C++中的没有接口的概念，它本身就可以多继承。<br><br>java中接口interface比抽象类abstract更进了一步，可看做"纯粹的抽象类"。<br>它允许创建者为一个类建立其形式，方法名，参数列表，返回类型，但没有<br>任何方法体。接口中也可以包含成员函数，但是他们都是隐含的public和<br>final。<br><br>创建接口时用interface来代替class，前面可以有public，如果不加访问权<br>限，那么它就是默认的包访问权限。<br>接口中的方法默认为public。<br><br>类实现接口要用implements关键字。<br><br>接口便于实现多重继承的效果,此处不作具体讨论。<br><br>package com;<br><br>interface myFirst{<br>&nbsp;&nbsp;&nbsp; int value_myFirst=1;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; public void f1();<br>}<br><br>class mySecond implements myFirst{<br>&nbsp;&nbsp;&nbsp; int value_mySecond;<br>&nbsp;&nbsp;&nbsp; public mySecond(int s){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_mySecond = s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; public void f1(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("mySecond.f1()!");&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>public class myCon{<br>&nbsp;&nbsp;&nbsp; static void play(myFirst mf){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mf.f1(); &nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; public static void main(String[] args){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //myFirst mf = new myFirst(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mySecond ms = new mySecond(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.f1();&nbsp;&nbsp; //mySecond.f1()!&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; play(ms); //向上转型 mySecond.f1()!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((myFirst)ms).f1(); ////向上转型 mySecond.f1()!<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>http://hi.baidu.com/knowtohow</div></body></html>