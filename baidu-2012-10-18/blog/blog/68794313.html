<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>实现构造哈夫曼树的哈夫曼算法</title></head><body><h1>实现构造哈夫曼树的哈夫曼算法</h1><div>//设计程序以实现构造哈夫曼树的哈夫曼算法。<br>
//要求：使用实验工具的有关功能；要能有演示过程；求解出所构造的哈夫曼<br>
//树的带权路径长度。<br>
<br>
<br>
#include&quot;btreint.h&quot;<br>
<br>
int count=0;<br>
//数据的个数；<br>
bitre data[50];//存储数组<br>
<br>
void delete_min()//获得最小元素、<br>
{<br>
for(int i=1;i&lt;=count-2;i++)<br>
data[i]=data[i+2];<br>
}<br>
<br>
int tree_insert(bitre t)//插入新的节点; <br>
{ if(t-&gt;data&gt;=data[count]-&gt;data){data[++count]=t;return 0;}<br>
else{int m;<br>
for(int j=1;j&lt;=count;j++)<br>
if(data[j]-&gt;data&gt;=t-&gt;data){m=j;break;}<br>
for(int k=count;k&gt;=m;k--)<br>
data[k+1]=data[k];<br>
data[m]=t;<br>
count++;}<br>
<br>
}<br>
<br>
int num=0;<br>
get_long(bitre t)//求解huffman树的带权路径长度; <br>
{<br>
if(t!=NULL)<br>
{<br>
if(t-&gt;rchild!=NULL&amp;&amp;t-&gt;lchild!=NULL)<br>
{<br>
visite_bnode(t,1);<br>
num=num+t-&gt;data;<br>
get_long(t-&gt;lchild);<br>
get_long(t-&gt;rchild);<br>
}<br>
}<br>
}<br>
void main()<br>
{ <br>
cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl;<br>
cout&lt;&lt;&quot; ***************************************&quot;&lt;&lt;endl;<br>
cout&lt;&lt;&quot; * Construct Huffman Tree *&quot;&lt;&lt;endl;<br>
cout&lt;&lt;&quot; * Name: XuHua *&quot;&lt;&lt;endl;<br>
cout&lt;&lt;&quot; * Number: 20042297 *&quot;&lt;&lt;endl;<br>
cout&lt;&lt;&quot; ***************************************&quot;&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl; <br>
<br>
bitre a,b,t; //定义变量; <br>
cout&lt;&lt;&quot;please put in the data and in increased way and -9999 over &quot;&lt;&lt;endl;<br>
for(int i=1;i&lt;=50;i++)//输入数据;<br>
{<br>
int adj;<br>
data[i]=(bitre)malloc(sizeof(struct bnode));//数据存储; <br>
if(i==1){data[0]-&gt;data=0;}<br>
cin&gt;&gt;adj;<br>
if(adj==-9999){cout&lt;&lt;&quot;put in over &quot;&lt;&lt;endl;break;}//结束标志; <br>
<br>
data[i]-&gt;data=adj;count++;<br>
<br>
<br>
<br>
}<br>
//数据元素，<br>
<br>
//数据的存储;<br>
<br>
for(int y=1;y&lt;=count;y++)//整理存储的数据; <br>
for(int x=count;x&gt;y;x--)<br>
if(data[x]-&gt;data&lt;data[x-1]-&gt;data)<br>
{<br>
int shu=data[x]-&gt;data;<br>
data[x]-&gt;data=data[x-1]-&gt;data;<br>
data[x-1]-&gt;data=shu;<br>
} <br>
for(int j=1;j&lt;=count;j++)<br>
{data[j]-&gt;lchild=NULL;data[j]-&gt;rchild=NULL;}//huffman树构造过程; <br>
while(count&gt;1)<br>
{<br>
<br>
a=data[1];b=data[2];//得到最小的两个节点; <br>
t=(bitre)malloc(sizeof(struct bnode));<br>
t-&gt;lchild=a;<br>
t-&gt;rchild=b;<br>
t-&gt;data=a-&gt;data+b-&gt;data;<br>
delete_min();<br>
count=count-2;<br>
tree_insert(t);<br>
display_bitre(&quot;tree&quot;,t);//显示此时的huffman树; <br>
Wait();<br>
<br>
}<br>
get_long(t);<br>
cout&lt;&lt;&quot;WL=&quot;&lt;&lt;num&lt;&lt;endl;//输出带权路径长度; <br>
Wait();<br>
}<br></div></body></html>