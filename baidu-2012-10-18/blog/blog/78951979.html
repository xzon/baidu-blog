<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>框架设计（第2版）：CLR Via C#-hxzon爱读书</title></head><body><h1>框架设计（第2版）：CLR Via C#-hxzon爱读书</h1><div><div>框架设计（第2版）：CLR Via C#-hxzon爱读书</div>
<div> </div>
<div>&#8226;目录</div>
<div> </div>
<div><br>
目 录 <br>
<br>
<br>
第Ⅰ部分 CLR基础 <br>
<br>
<br>
第1章 CLR的执行模型 3 <br>
1.1 将源代码编译成托管模块 3 <br>
1.2 将托管模块合并成程序集 6 <br>
1.3 加载公共语言运行库 7 <br>
1.4 执行程序集的代码 9 <br>
1.4.1 IL和验证 14 <br>
1.4.2 不安全的代码 15 <br>
1.5 本地代码生成器：NGen.exe 16 <br>
1.6 Framework类库入门 18 <br>
1.7 通用类型系统 20 <br>
1.8 公共语言规范(CLS) 22 <br>
1.9 与非托管代码的互操作性 26 <br>
第2章 生成. 打包. 部署和管理 <br>
应用程序及类型 28 <br>
2.1 .NET Framework部署目标 28 <br>
2.2 将类型集成到模块中 29 <br>
2.3 元数据概述 32 <br>
2.4 合并模块以构成一个程序集 38 <br>
2.4.1 使用Visual Studio IDE在项目 <br>
中添加程序集 43 <br>
<br>
2.4.2 使用程序集链接器 44 <br>
2.4.3 在程序集中包含 <br>
资源文件 45 <br>
2.5 程序集版本资源信息 46 <br>
2.6 语言文化 49 <br>
2.7 简单应用程序部署 <br>
(私有部署的程序集) 50 <br>
2.8 简单管理控制(配置) 51 <br>
第3章 共享程序集和 <br>
强命名程序集 54 <br>
3.1 两种程序集, 两种部署 55 <br>
3.2 为程序集指派强名称 56 <br>
3.3 全局程序集缓存 61 <br>
3.4 在生成的程序集中引用 <br>
一个强命名程序集 66 <br>
3.5 强命名程序集能防范篡改 67 <br>
3.6 延迟签名 68 <br>
3.7 私有部署强命名程序集 70 <br>
3.8 运行库如何解析类型引用 71 <br>
3.9 高级管理控制(配置) 73 <br>
<br>
<br>
第Ⅱ部分 类型的使用 <br>
<br>
<br>
第4章 类型基础 81 <br>
4.1 所有类型都是从 <br>
System.Object派生的 81 <br>
4.2 强制类型转换 83 <br>
4.3 命名空间和程序集 86 <br>
4.4 运行时的相互关系 90 <br>
第5章 基元. 引用和值类型 98 <br>
5.1 编程语言的基元类型 98 <br>
5.2 引用类型和值类型 103 <br>
5.3 值类型的装箱和拆箱 108 <br>
5.4 使用接口更改已装箱值类型中的字段 <br>
(以及为什么不应该这样做) 118 <br>
5.5 对象相等性和身份标识 120 <br>
<br>
5.6 对象哈希码 123 <br>
<br>
<br>
第Ⅲ部分 类型的设计 <br>
<br>
<br>
第6章 类型和成员基础 127 <br>
6.1 类型成员的种类 127 <br>
6.2 类型的可见性 130 <br>
6.3 成员的可访问性 131 <br>
6.4 静态类 133 <br>
6.5 部分类. 结构和接口 134 <br>
6.6 组件. 多态和版本控制 135 <br>
6.6.1 CLR如何调用虚方法. <br>
属性和事件 137 <br>
6.6.2 巧妙使用类型的可见性和 <br>
成员的可访问性 140 <br>
6.6.3 类型版本控制过程中虚 <br>
方法的处理 143 <br>
第7章 常量和字段 147 <br>
7.1 常量 147 <br>
7.2 字段 148 <br>
第8章 方法：构造器. 操作符. <br>
转换操作符 和参数 151 <br>
8.1 实例构造器和类(引用类型) 151 <br>
8.2 实例构造器和结构(值类型) 154 <br>
8.3 类型构造器 156 <br>
8.4 操作符重载 161 <br>
8.5 转换操作符方法 164 <br>
8.6 通过引用向方法传递参数 167 <br>
8.7 向方法传递可变数量的参数 172 <br>
8.8 声明方法的参数类型 174 <br>
<br>
8.9 常量方法和参数 175 <br>
第9章 属性 176 <br>
9.1 无参属性 176 <br>
9.2 有参属性 180 <br>
9.3 调用属性访问器方法的性能 184 <br>
9.4 属性访问器的可访问性 185 <br>
9.5 泛型属性访问器方法 185 <br>
第10章 事件 186 <br>
10.1 设计一个对外提供事件的类型 187 <br>
10.1.1 第一步：定义一个类型 <br>
用于存放所有需要发送 <br>
给事件通知接收者的 <br>
附加信息 187 <br>
10.1.2 第二步：定义事件成员 188 <br>
10.1.3 第三步：定义一个负责 <br>
引发事件的方法来通知已 <br>
订阅事件的对象事件 <br>
已经发生 189 <br>
10.1.4 第四步：定义一个方法, <br>
将输入转化为期望事件 190 <br>
10.2 如何实现事件 190 <br>
10.3 设计一个监听事件的类型 192 <br>
10.4 事件与线程安全 193 <br>
10.5 显式控制事件的订阅与注销 194 <br>
10.6 设计一个定义多个事件的类型 196 <br>
<br>
<br>
第Ⅳ部分 基本类型 <br>
<br>
<br>
第11章 字符. 字符串和文本 201 <br>
11.1 字符 201 <br>
11.2 System.String类型 204 <br>
11.2.1 构造字符串 204 <br>
11.2.2 字符串是不可变的 206 <br>
11.2.3 比较字符串 206 <br>
11.2.4 字符串留用 212 <br>
11.2.5 字符串池 214 <br>
11.2.6 检查字符串的字符 <br>
和文本元素 214 <br>
11.2.7 其他字符串操作 216 <br>
11.3 高效率地动态构造一个字符串 217 <br>
11.3.1 构造一个 <br>
StringBuilder对象 217 <br>
11.3.2 StringBuilder的成员 218 <br>
11.4 获取对象的字符串表示 220 <br>
11.4.1 特定的格式和语言 220 <br>
11.4.2 将多个对象格式化 <br>
成单个字符串 224 <br>
11.4.3 提供定制格式化器 225 <br>
11.5 解析字符串来获取一个对象 227 <br>
11.6 编码：在字符和字节之间转换 229 <br>
11.6.1 字符和字节流的 <br>
编码/解码 234 <br>
11.6.2 Base-64字符串编码 <br>
和解码 235 <br>
11.7 安全字符串 236 <br>
第12章 枚举类型和位标志 239 <br>
12.1 枚举类型 239 <br>
12.2 位标志 244 <br>
第13章 数组 247 <br>
13.1 数组的类型转换 249 <br>
13.2 所有数组都隐式继承自 <br>
System.Array 251 <br>
13.3 所有数组都隐式实现IEnumerable, <br>
ICollection和Ilist 252 <br>
13.4 数组的传递与返回 253 <br>
13.5 创建下界非0的数组 253 <br>
13.6 数组访问性能 254 <br>
13.7 非安全数组访问和 <br>
固定长度数组 258 <br>
第14章 接口 261 <br>
14.1 类和接口的继承 261 <br>
14.2 定义接口 262 <br>
14.3 接口的继承 263 <br>
14.4 调用接口方法详解 265 <br>
14.5 接口方法的隐式和显式实现 <br>
(幕后细节) 266 <br>
14.6 泛型接口 267 <br>
14.7 泛型接口和接口约束 269 <br>
14.8 实现具有相同方法名和签名的 <br>
多个接口 270 <br>
14.9 用显式接口方法实现改进编译时 <br>
类型安全 271 <br>
14.10 谨慎使用显式接口方法实现 272 <br>
14.11 设计：基类还是接口 275 <br>
第15章 委托 277 <br>
15.1 初识委托 277 <br>
15.2 使用委托来回调静态方法 279 <br>
15.3 使用委托回调实例方法 280 <br>
15.4 委托揭秘 281 <br>
15.5 使用委托回调多个方法(链式) 285 <br>
15.6 C#对委托链的支持 288 <br>
15.7 对委托链调用进行更多控制 289 <br>
15.8 C#为委托提供的语法便利 291 <br>
15.8.1 语法快捷方式1： <br>
不需要构造委托对象 291 <br>
15.8.2 语法快捷方式2： <br>
不需要定义回调方法 292 <br>
15.8.3 语法快捷方式3： <br>
不需要指定回调方法 <br>
的参数 293 <br>
15.8.4 语法快捷方式4： <br>
不需要将局部变量人工封装 <br>
到类中, 即可将它们 <br>
传给一个回调方法 294 <br>
15.9 委托和反射 296 <br>
第16章 泛型 300 <br>
16.1 FCL中的泛型 304 <br>
16.2 Wintellect的Power Collections库 305 <br>
16.3 泛型基础结构 306 <br>
16.3.1 开放和封闭式类型 307 <br>
16.3.2 泛型类型和继承 308 <br>
16.3.3 泛型类型同一性 310 <br>
16.3.4 代码爆炸 311 <br>
16.4 泛型接口 311 <br>
16.5 泛型委托 312 <br>
16.6 泛型方法 313 <br>
16.7 泛型和其他成员 315 <br>
16.8 可验证性和限制 315 <br>
16.8.1 主要约束 317 <br>
16.8.2 次要约束 318 <br>
16.8.3 构造器约束 319 <br>
16.8.4 其他可验证性问题 320 <br>
第17章 自定义属性 323 <br>
17.1 使用自定义属性 324 <br>
17.2 定义自己的属性 327 <br>
17.3 属性构造器和Field/Property <br>
数据类型 330 <br>
17.4 检测自定义属性的使用 331 <br>
<br>
17.5 两个属性实例的相互匹配 334 <br>
17.6 检测自定义属性的使用, 同时 <br>
不创建Attribute派生对象 337 <br>
17.7 条件属性类 339 <br>
第18章 可空值类型 341 <br>
18.1 C#对可空值类型的支持 342 <br>
18.2 C#的空接合操作符 344 <br>
18.3 CLR对可空值类型的特殊支持 344 <br>
18.3.1 对可空值类型进行装箱 344 <br>
18.3.2 对可空值类型进行拆箱 345 <br>
18.3.3 通过可空值类型来 <br>
调用GetType 346 <br>
18.3.4 通过可空值类型 <br>
调用接口方法 346 <br>
<br>
<br>
第Ⅴ部分 CLR实用特性 <br>
<br>
<br>
第19章 异常 349 <br>
19.1 异常处理的演变 350 <br>
19.2 异常处理机制 351 <br>
19.2.1 try块 352 <br>
19.2.2 catch块 352 <br>
19.2.3 finally块 354 <br>
19.3 符合公共语言规范(CLS)的异常与 <br>
不符合CLS的异常 354 <br>
19.4 异常的准确定义 356 <br>
19.5 System.Exception类 358 <br>
19.6 FCL中预定义的异常类 359 <br>
19.7 抛出异常 361 <br>
19.8 定义自己的异常类 361 <br>
19.9 如何正确地使用异常 364 <br>
19.9.1 验证方法的参数 364 <br>
19.9.2 合理使用finally块 367 <br>
19.9.3 避免捕获所有的异常 368 <br>
19.9.4 从异常中顺利恢复 369 <br>
19.9.5 当异常无法修复时, <br>
回滚局部完成的操作 369 <br>
19.9.6 隐藏实现细节, <br>
维持&ldquo;约定&rdquo; 370 <br>
19.10 性能考虑 372 <br>
19.11 未处理异常 374 <br>
19.12 异常堆栈跟踪 376 <br>
19.13 调试异常 378 <br>
第20章 自动内存管理(垃圾收集) 380 <br>
20.1 理解垃圾收集平台的 <br>
基本工作原理 380 <br>
20.2 垃圾收集算法 383 <br>
20.3 垃圾收集与调试 387 <br>
20.4 使用终结操作来释放本地资源 389 <br>
20.4.1 确保终结操作使用 <br>
CriticalFinalizerObject <br>
类型 390 <br>
20.4.2 SafeHandle类型及其 <br>
派生类型 391 <br>
20.4.3 使用SafeHandle类型实现 <br>
非托管代码之间的 <br>
互操作 393 <br>
20.5 对托管资源使用终结操作 395 <br>
20.6 哪些事件会导致Finalize <br>
方法的调用 397 <br>
20.7 终结操作内部揭秘 398 <br>
20.8 释放模式：强制对象清理资源 401 <br>
20.9 使用实现了释放模式的类型 404 <br>
20.10 C#的using语句 407 <br>
20.11 一个有趣的依赖问题 409 <br>
20.12 人工监视和控制对象的生存期 410 <br>
20.13 对象复苏 417 <br>
20.14 对象的代 418 <br>
20.15 使用本地资源的其他 <br>
垃圾收集特性 423 <br>
20.16 预测需求较多内存的操作 <br>
能否成功 426 <br>
20.17 编程控制垃圾收集器 427 <br>
20.18 与垃圾收集器性能相关的 <br>
其他一些话题 430 <br>
20.18.1 免同步的多线程分配 431 <br>
20.18.2 可扩展并行收集 431 <br>
20.18.3 并发收集 431 <br>
20.18.4 大尺寸对象 432 <br>
20.19 监视垃圾收集 433 <br>
第21章 CLR寄宿和应用程序域 435 <br>
21.1 CLR寄宿 435 <br>
21.2 应用程序域 438 <br>
21.3 应用程序域的卸载 450 <br>
21.4 宿主如何使用应用程序域 451 <br>
21.4.1 控制台和Windows窗体 <br>
应用程序 451 <br>
21.4.2 Microsoft Internet <br>
Explorer 452 <br>
21.4.3 Microsoft ASP.NET Web <br>
窗体和XML Web服务 <br>
应用程序 452 <br>
21.4.4 Microsoft SQL Server <br>
2005 453 <br>
21.4.5 预测与展望 453 <br>
21.5 高级宿主控制 453 <br>
21.5.1 使用托管代码管理CLR 453 <br>
21.5.2 编写健壮的宿主 <br>
应用程序 454 <br>
21.5.3 宿主如何恢复线程 455 <br>
第22章 程序集的加载与反射 459 <br>
22.1 程序集的加载 459 <br>
22.2 使用反射构建动态可扩展 <br>
应用程序 463 <br>
22.3 反射的性能 463 <br>
22.3.1 发现程序集中定义 <br>
的类型 464 <br>
22.3.2 类型对象的准确含义 465 <br>
22.3.3 构建派生自Exception <br>
的类型的层次结构 467 <br>
22.3.4 构建类型的实例 468 <br>
22.4 设计支持插件的应用程序 470 <br>
22.5 使用反射发现类型的成员 473 <br>
22.5.1 发现类型成员 473 <br>
22.5.2 BindingFlags：筛选返回 <br>
成员的类型 477 <br>
22.5.3 发现类型的接口 478 <br>
22.5.4 调用类型的成员 480 <br>
22.5.5 一次绑定. 多次调用 483 <br>
22.5.6 使用绑定句柄来 <br>
减小工作集 487 <br>
第23章 执行异步操作 490 <br>
23.1 CLR如何使用Windows线程 490 <br>
23.2 高效线程使用圣典 491 <br>
23.3 CLR线程池简介 493 <br>
23.4 限制线程池中线程的数量 494 <br>
23.5 使用线程池执行受计算限制 <br>
的异步操作 495 <br>
23.6 使用专用线程执行受计算限制 <br>
的异步操作 497 <br>
23.7 定期执行受计算限制的异步操作 499 <br>
三个定时器的史话 500 <br>
23.8 异步编程模型简介 501 <br>
23.9 使用APM执行受I/O限制 <br>
的异步操作 502 <br>
23.10 APM的三个聚集技巧 504 <br>
23.10.1 APM的等待直至 <br>
完成聚集技巧 504 <br>
23.10.2 APM的轮询聚集技巧 506 <br>
23.10.3 APM的方法回调聚 <br>
集技巧 508 <br>
23.11 使用APM执行受计算限制 <br>
的异步操作 512 <br>
23.12 APM与异常 514 <br>
23.13 对APM的重要说明 514 <br>
23.14 执行上下文 516 <br>
第24章 线程同步 519 <br>
24.1 内存一致性. 易失内存访问 <br>
与易失字段 520 <br>
24.1.1 易失读取和写入 522 <br>
24.1.2 C#对易失字段的支持 524 <br>
24.2 互锁方法 526 <br>
24.3 Monitor类与同步块 527 <br>
<br>
24.3.1 &ldquo;伟大想法&rdquo; 527 <br>
24.3.2 &ldquo;伟大想法&rdquo;的实现 528 <br>
24.3.3 使用Monitor类管理 <br>
同步块 529 <br>
24.3.4 Microsoft最初计划 <br>
的同步方式 530 <br>
24.3.5 使用C#的lock语句 <br>
简化代码 531 <br>
24.3.6 Microsoft最初计划 <br>
同步静态成员的方式 532 <br>
24.3.7 为什么&ldquo;伟大想法&rdquo; <br>
思想毫无伟大之处 533 <br>
24.3.8 著名的双检锁技巧 535 <br>
24.4 ReaderWriterLock类 537 <br>
24.5 使用托管代码中的Windows <br>
内核对象 538</div>
<div> </div>
<div>框架设计(第2版)--CLR Via C＃/微软技术丛书</div>
<div> </div>
<div>【内容介绍】 <br>
<br>
<br>
作为深受编程人员爱戴和尊敬的编程专家，微软.NET开发团队的顾问， <br>
本书作者Jeffrey Richter针对开发各种应用程序(如Web Form、Windows <br>
Form和Web服务、Microsoft SQL Server解决方案、控制台应用程序、NT <br>
Service)的开发人员，深入揭示了公共语言运行库(CLR)和.NET Framework <br>
，演示了如何将这些知识应用到实际开发。全书分5部分，共24章。第1部分 <br>
讲述CLR基础，第II部分介绍类型的使用，第III部分说明类型的设计，第Ⅳ <br>
部分介绍基本类型，第V部分讲述CLR实用特性。 <br>
通过本书的阅读，读者可以掌握CLR精髓，轻松、高效地创建高性能应 <br>
用程序。 <br>
<br>
<br>
&nbsp;&nbsp;  <br>
<br>
【本书目录】 <br>
<br>
<br>
第I部分 CLR基础 <br>
第1章 CLR的执行模型 <br>
第2章 生成、打包、部署和管理应用程序及类型 <br>
第3章 共享程序集和强命名程序集 <br>
第Ⅱ部分 类型的使用 <br>
第4章 类型基础 <br>
第5章 基元、引用和值类型 <br>
第Ⅲ部分 类型的设计 <br>
第6章 类型和成员基础 <br>
第7章 常量和宇段 <br>
第8章 方法：构造器、操作符、转换操作符和参数 <br>
第9章 属性 <br>
第10章 事件 <br>
第Ⅳ部分 基本类型 <br>
第11章 字符、字符串和文本 <br>
第12章 枚举类型和位标志 <br>
第13章 数组 <br>
第14章 接口 <br>
第15章 委托 <br>
第16章 泛型 <br>
第17章 自定义属性 <br>
第18章 可空值类型 <br>
第V部分 CLR实用特性 <br>
第19章 异常 <br>
第20章 自动内存管理(垃圾收集) <br>
第21章 CLR寄宿和应用程序域 <br>
第22章 程序集的加载与反射 <br>
第23章 执行异步操作 <br>
第24章 线程同步 <br>
<br>
<br>
&nbsp;&nbsp;  <br>
<br>
【作者介绍】 <br>
<br>
Jeffrey Richter是全球享有盛誉的技术作家，Wintellect公司的创办人之一。该公司专门从事培训、调试和咨询，帮助客户构建更好、更快的软件。他在Wirldows／NET领域有着杰出的贡献。他的经典著作《Witldows高级编程指南》和《Windows核心编程》是Wirdows程序设计领域的颠峰之作，培育了几代软件开发设计人员。Jeffrey从1 999年10月以来，一直为Microsoft NET Framework团队担任顾问，与他们一起经历着.NET的孕育、诞生和发展，对.NET细节的了解程度，是其他任何作家无法望其项背的。他还担任MSDN杂志.NET专栏的撰稿人。 <br>
<br>
&nbsp;&nbsp;</div></div></body></html>