<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>马踏棋盘问题-算法设计-C++code</title></head><body><h1>马踏棋盘问题-算法设计-C++code</h1><div>马踏棋盘问题-算法设计-C++code<br>
<br>
#include &lt;stdio.h&gt; <br>
#define N 5 <br>
void main(){ <br>
int x,y; <br>
void horse(int i,int j); <br>
printf("Please input start position:"); <br>
scanf("%d%d",&amp;x,&amp;y); <br>
horse(x-1,y-1); <br>
} <br>
void horse(int i,int j){ <br>
int a[N][N]={0},start=0, <br>
h[]={1,2,2,1,-1,-2,-2,-1}, <br>
v[]={2,1,-1,-2,2,1,-1,-2}, <br>
save[N*N]={0},posnum=0,ti,tj,count=0; <br>
int jump(int i,int j,int a[N][N]); <br>
void outplan(int a[N][N]); <br>
a[i][j]=posnum+1; <br>
while(posnum&gt;=0){ <br>
ti=i;tj=j; <br>
for(start=save[posnum];start&lt;8;++start){ <br>
ti+=h[start];tj+=v[start]; <br>
if(jump(ti,tj,a)) <br>
break; <br>
ti-=h[start];tj-=v[start]; <br>
} <br>
if(start&lt;8){ <br>
save[posnum]=start; <br>
a[ti][tj]=++posnum+1; <br>
i=ti;j=tj;save[posnum]=0; <br>
if(posnum==N*N-1){ <br>
//outplan(a); <br>
count++; <br>
} <br>
} <br>
else{ <br>
a[i][j]=0; <br>
posnum--; <br>
i-=h[save[posnum&gt;;j-=v[save[posnum&gt;; <br>
save[posnum]++; <br>
} <br>
} <br>
printf("%5d",count); <br>
} <br>
int jump(int i,int j,int a[N][N]){ <br>
if(i&lt;N&amp;&amp;i&gt;=0&amp;&amp;j&lt;N&amp;&amp;j&gt;=0&amp;&amp;a[i][j]==0) <br>
return 1; <br>
return 0; <br>
} <br>
void outplan(int a[N][N]){ <br>
int i,j; <br>
for(i=0;i&lt;N;i++){ <br>
for(j=0;j&lt;N;j++) <br>
printf("%3d",a[i][j]); <br>
printf("\n"); <br>
} <br>
printf("\n"); <br>
//getchar(); <br>
} <br>
用回溯法得到所有的解，但效率较低，只能算出5行5列的。 <br>
<img style="display: none; position: relative" src="http://imgcache.qq.com/qzone_v4/b.gif"></div></body></html>