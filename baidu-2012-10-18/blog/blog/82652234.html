<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>在JTable中实现单元格鼠标悬停效果</title></head><body><h1>在JTable中实现单元格鼠标悬停效果</h1><div><p>在JTable中实现单元格鼠标悬停效果</p>
<p>在Google上搜索实现这种效果的方法，只搜到一个网页，是国外的，一看，还得要给钱注册！<br>俗话说，自力更生，艰苦奋斗，就自己想了法子，拿来分享。衷心请各位大虾指点指点不足</p>
<p><clk></clk>我写了个程序，里面用到一个JTable，本着MVC<clk></clk>的精神，而且考虑到单元格可能不是简简单单一个Label能表现的，就写了个表格渲染器的类，叫NoteLabelRenderer</p>
<p>代码如下：</p>
<p><span style="FONT-FAMILY: Courier New">//NoteLabelRenderer.<span style="COLOR: #3366cc">Java</span><br><br>package com.component;</span></p>
<p><span style="FONT-FAMILY: Courier New">import javax.<span style="COLOR: #3366cc">Swing</span>.*;<br>import javax.swing.table.*;</span></p>
<p><span style="FONT-FAMILY: Courier New">import java.awt.*;</span></p>
<p><span style="FONT-FAMILY: Courier New">import com.data.Note;</span></p>
<p><span style="FONT-FAMILY: Courier New">/**<br>* To render the cells showing the note<br>* @author Allen Chue<br>*<br>*/<br>public class NoteLabelRenderer extends JPanel implements TableCellRenderer {</span></p>
<p><span style="FONT-FAMILY: Courier New">public static ImageIcon ATTACH_ICON=new ImageIcon("res/attach.gif");<br>public static ImageIcon BLANK_ICON=new ImageIcon("res/blank.gif");<br><br>private JLabel icon=new JLabel();<br>private JLabel content=new JLabel();<br>private JLabel attach=new JLabel();<br><br>private String contentText,title;<br><br>public NoteLabelRenderer() {<br>&nbsp;&nbsp; super();<br>&nbsp;&nbsp; setLayout(new BorderLayout());<br>&nbsp;&nbsp;<br>&nbsp;&nbsp; icon.setOpaque(true);<br>&nbsp;&nbsp; content.setOpaque(true);<br>&nbsp;&nbsp; attach.setOpaque(true);<br>&nbsp;&nbsp;<br>&nbsp;&nbsp; icon.setHorizontalAlignment(SwingConstants.CENTER);<br>&nbsp;&nbsp; icon.setVerticalAlignment(SwingConstants.CENTER);<br>&nbsp;&nbsp; content.setVerticalAlignment(SwingConstants.NORTH);<br>&nbsp;&nbsp; attach.setHorizontalAlignment(SwingConstants.CENTER);<br>&nbsp;&nbsp; attach.setVerticalAlignment(SwingConstants.CENTER);<br>&nbsp;&nbsp;<br>&nbsp;&nbsp; add(icon,BorderLayout.WEST);<br>&nbsp;&nbsp; add(content,BorderLayout.CENTER);<br>&nbsp;&nbsp; add(attach,BorderLayout.EAST);<br>&nbsp;&nbsp; setSize(getPreferredSize());<br>}<br><br>/**<br>&nbsp;&nbsp;&nbsp;&nbsp; * Returns the component used for drawing the cell. This method is<br>&nbsp;&nbsp;&nbsp;&nbsp; * used to configure the renderer appropriately before drawing.<br>&nbsp;&nbsp;&nbsp;&nbsp; *<br>&nbsp;&nbsp;&nbsp;&nbsp; * @param table&nbsp;&nbsp; the &lt;code&gt;JTable&lt;/code&gt; that is asking the <br>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; renderer to draw; can be &lt;code&gt;null&lt;/code&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp; * @param value&nbsp;&nbsp; the value of the cell to be rendered. It is<br>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; up to the specific renderer to int<span style="COLOR: #3366cc">ERP</span>ret<br>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; and draw the value. For example, if<br>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; &lt;code&gt;value&lt;/code&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; is the string "true", it could be rendered as a<br>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; string or it could be rendered as a check<br>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; box that is checked. &lt;code&gt;null&lt;/code&gt; is a<br>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; valid value<br>&nbsp;&nbsp;&nbsp;&nbsp; * @param isSelected true if the cell is to be rendered with the<br>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; selection highlighted; otherwise false<br>&nbsp;&nbsp;&nbsp;&nbsp; * @param hasFocus if true, render cell appropriately. For<br>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; example, put a special border on the cell, if<br>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; the cell can be edited, render in the color used<br>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; to indicate editing<br>&nbsp;&nbsp;&nbsp;&nbsp; * @param row&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the row index of the cell being drawn. When<br>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; drawing the header, the value of<br>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; &lt;code&gt;row&lt;/code&gt; is -1<br>&nbsp;&nbsp;&nbsp;&nbsp; * @param column&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the column index of the cell being drawn<br>&nbsp;&nbsp;&nbsp;&nbsp; */<br>public Component getTableCellRendererComponent(JTable table, Object value,<br>&nbsp;&nbsp;&nbsp; boolean isSelected, boolean hasFocus, int row, int column) {<br>&nbsp;&nbsp; changeBackground(isSelected);<br>&nbsp;&nbsp; setNoteText((Note)value,isSelected);<br>&nbsp;&nbsp; return this;<br>}<br><br>private void changeBackground(boolean isSelected) {<br>&nbsp;&nbsp; Color selectedColor=new Color(160,231,160);<br>&nbsp;&nbsp; if (isSelected) {<br>&nbsp;&nbsp;&nbsp; icon.setBackground(selectedColor);<br>&nbsp;&nbsp;&nbsp; content.setBackground(selectedColor);<br>&nbsp;&nbsp;&nbsp; attach.setBackground(selectedColor);<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp; icon.setBackground(null);<br>&nbsp;&nbsp;&nbsp; content.setBackground(null);<br>&nbsp;&nbsp;&nbsp; attach.setBackground(null);<br>&nbsp;&nbsp; }<br>}<br><br>/**<br>* Show the note according to a note<br>* @param n The &lt;code&gt;Note&lt;/code&gt;<br>* @param flag A flag variable. True for emphasizing the the <br>* contents, while false for showing it normally<br>*/<br>private void setNoteText(Note n, boolean flag) {<br>&nbsp;&nbsp; String color=flag?"#ffffff":"#000000";<br>&nbsp;&nbsp; /*<br>&nbsp;&nbsp; ************************<br>&nbsp;&nbsp; *****Set Icon Area******<br>&nbsp;&nbsp; ************************<br>&nbsp;&nbsp; */<br>&nbsp;&nbsp; icon.setIcon(n.getIcon());<br>&nbsp;&nbsp; /*<br>&nbsp;&nbsp; ************************<br>&nbsp;&nbsp; ****Set Content Area****<br>&nbsp;&nbsp; ************************<br>&nbsp;&nbsp; */<br>&nbsp;&nbsp; title=n.getTitle();<br>&nbsp;&nbsp; contentText=n.getContent();<br>&nbsp;&nbsp; if (contentText.length()&gt;120) {<br>&nbsp;&nbsp;&nbsp; contentText=contentText.substring(0,115)+"...";<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; content.setText("&lt;html&gt;&lt;font" +<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " color=#116677&gt;"+title+"&lt;/font&gt;&lt;br&gt;" +<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&lt;font color="+color+"&gt;"+contentText+"&lt;/font&gt;&lt;/html&gt;");<br>&nbsp;&nbsp; /*<br>&nbsp;&nbsp; ***********************<br>&nbsp;&nbsp; ***Set Attach Area*****<br>&nbsp;&nbsp; ***********************<br>&nbsp;&nbsp; */<br>&nbsp;&nbsp; if (n.getAttach() != null) {<br>&nbsp;&nbsp;&nbsp; attach.setIcon(ATTACH_ICON);<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp; attach.setIcon(BLANK_ICON);<br>&nbsp;&nbsp; }<br>}<br>public String getContent() {<br>&nbsp;&nbsp; return this.contentText;<br>}<br>public String getTitle() {<br>&nbsp;&nbsp; return this.title;<br>}<br>}</span></p>
<p>这是个备忘的程序，一些有Note字眼的不用关心。</p>
<p>这个NoteLableRenderer继承了JPanel，是为了更好地对其中一些组件进行布局的控制（在这里，每个单元格里有三个JLabel），TableCellRender接口是必须要实现的<br>可以看到，实现鼠标点击单元格改变文字颜色和单元格（也就是一个JPanel）背景色并不难，只需要在<span style="FONT-FAMILY: Courier New">getTableCellRendererComponent方法中判断传入的参数isSelected是否为true，然后对组件属性重新设置，返回修改过的Component即可。JTable在鼠标点击单元格时会重画表格，于是改变后的单元格即可显示出来。</span></p>
<p><span style="FONT-FAMILY: Courier New"><clk></clk>我还想要实现单元格的悬停效果，也就是说，当鼠标移动至某个单元格上方时，该单元格可以变化颜色或者加个边框来突出显示，就想JButton可以设置RollOverIcon一样。我想当然地在这个渲染器里添加了鼠标监听，然而测试确发现不行...<br>&nbsp;&nbsp; 经过一番查阅、思考，我终于将解决的方法从单元格渲染器上转至JTable本身来，因为我发现JTable里竟然有个rowAtPoint(Point point)方法（高手可不要笑我啊）！于是，我就在表格上监听鼠标动作事件，在mouseMoved(MouseEvent e)方法中用int row=this.rowAt(e.getPoint())得到鼠标移动时当前鼠标在哪一行。这样的话，至少是迈了一大步，接下来的问题就是如何对鼠标下面的单元格进行属性的修改。</span></p>
<p><span style="FONT-FAMILY: Courier New">经过查看JTable的源码，发现里面有个public Component prepareRenderer方法调用了单元格渲染器里的getTableCellRenderer方法，用于在绘制表格时准备好单元格内放置的组件。既然它是public的，我就重载了这个方法，并使用了个自己感觉有点笨的方法，表格中加了个Vector，存储每个单元格是否在鼠标下面的信息（用Boolean），也就是说，每一时刻这个Vector中只有一个为true（同一时刻，只能有一个单元格在鼠标下面）,其余为false，同时保持Vector的size与单元格行数相同。<br>重载的prepareRenderer方法体如下：</span></p>
<p><span style="FONT-FAMILY: Courier New">/**<br>* This method overides the super one, in order to <br>* add rollover effects to the &lt;code&gt;JTable&lt;/code&gt;<br>* A &lt;code&gt;Vector&lt;/code&gt; stores information about <br>* whether the cell is beneath the mouse. If the value<br>* corresponding to the cell is true, this method will<br>* return a &lt;code&gt;Component&lt;/code&gt; with the border modified;<br>* while false, the &lt;code&gt;Renderer&lt;/code&gt; will be returned <br>* unchanged after calling the super method <br>*/<br>public Component prepareRenderer(TableCellRenderer renderer, int row,<br>&nbsp;&nbsp;&nbsp; int column) {<br>&nbsp;&nbsp; Component comp = super.prepareRenderer(renderer, row, column);<br>&nbsp;&nbsp; if (((Boolean)<strong>flagMouseOver</strong>.get(row)).booleanValue()) {<br>&nbsp;&nbsp;&nbsp; ((JComponent)comp).setBorder(BorderFactory.createLineBorder(Color.GRAY,1));<br>&nbsp;&nbsp;&nbsp; return comp;<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp; ((JComponent)comp).setBorder(null);<br>&nbsp;&nbsp;&nbsp; return comp;<br>&nbsp;&nbsp; }<br>}</span></p>
<p><span style="FONT-FAMILY: Courier New">flagMouseOver即为保存单元格状态的Vector。而mouseMoved方法如下</span></p>
<p><span style="FONT-FAMILY: Courier New">public void mouseMoved(MouseEvent e) {//Add rollover effects<br>&nbsp;&nbsp; int row=this.rowAtPoint(e.getPoint());<br>&nbsp;&nbsp; if (mouseAtRow == -1) {<br>&nbsp;&nbsp;&nbsp; //Init variable mouseAtRow<br>&nbsp;&nbsp;&nbsp; mouseAtRow=row;<br>&nbsp;&nbsp;&nbsp;<strong>flagMouseOver.set(mouseAtRow,new Boolean(true));<br></strong>&nbsp;&nbsp;&nbsp; //System.out.println("Mouse first moves to row "+(row+1));<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; repaint();<br>&nbsp;&nbsp; revalidate();</span><span style="FONT-FAMILY: Courier New"><br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; else if (row != mouseAtRow) {//The mouse has moved to a new row<br>&nbsp;&nbsp;&nbsp; //Clear the border<br>&nbsp;&nbsp;&nbsp;<strong>flagMouseOver.set(mouseAtRow,new Boolean(false));<br></strong>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; //Set new row's border<br>&nbsp;&nbsp;&nbsp;<strong>flagMouseOver.set(row,new Boolean(true));</strong><br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; //System.out.println("Mouse moves from row "+(mouseAtRow+1)+" to row "+(row+1));<br>&nbsp;&nbsp;&nbsp; repaint();<br>&nbsp;&nbsp; revalidate();<br></span><span style="FONT-FAMILY: Courier New">&nbsp;&nbsp;&nbsp; mouseAtRow=row;<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp; }&nbsp;&nbsp;<br>}</span></p>
<p><span style="FONT-FAMILY: Courier New">mouseAtRow为一个int类型的变量，存储鼠标移动前在哪一行。当鼠标移动时，获得当前鼠标在哪一行（表格仅有一列），然后与mouseAtRow比较，若变化了，说明鼠标到了新的一行，同时更新flagMouseOver内的数据，紧接着用repaint和revalidate方法更新表格，实现了表格GUI的变化。这里悬停效果是添加边框，当然也可以改背景等等。</span></p>
<p></p>
<p><span style="FONT-FAMILY: Courier New">这是我的经历，希望有人提出意见，我非常欢迎！</span></p>
<p><span style="FONT-FAMILY: Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Allen Chue</span></p></div></body></html>