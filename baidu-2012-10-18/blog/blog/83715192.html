<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>最佳的&amp;#34;addEvent&amp;#34;是怎样诞生的</title></head><body><h1>最佳的&amp;#34;addEvent&amp;#34;是怎样诞生的</h1><div><p>最佳的&quot;addEvent&quot;是怎样诞生的</p>
<p>IE的 JScript 存在内存泄露的bug 想必大家都清楚或者有耳闻了。这是由于IE的内存回收管理器的一个设计错误导致的。当我们编写脚本的时候创建了交叉引用，例如如下代码： window.onload = function () {&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  var x = document.getElementsByTagName(&rsquo;H3&rsquo;);&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  for (var i=0;i&lt;x.length;i++)&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  {&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  x[i].onclick = openClose;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  x[i].relatedElement = x[i].nextSibling; // simplified situation&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  x[i].relatedElement.relatedElement = x[i];&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  }&nbsp;&nbsp;<br>
}或者在函数中使用脚本语言最常见的闭句Closures的时候，IE都无法回收内存。而闭句在给DOM对象注册事件处理器(event handler)的时候最为常用。Novemberborn提供了一些example可以让你运行并切实感受到这个bug。&nbsp;&nbsp;<br>
我最喜爱的QuirkMode 去年初意识到这个bug存在巨大隐患，觉得有必要呼吁广大web开发者关注并竭力避免这个问题，于是举办了一个慈善邀请赛，鼓励大家提交各自addEvent/removeEvent 方案。并终于在去年10月下旬宣布了他们认为的胜利者：John Resig，让John赢得胜利的代码如下：&nbsp;&nbsp;&nbsp;<br>
<br>
function addEvent( obj, type, fn ) {&nbsp;&nbsp;<br>
&nbsp;&nbsp;  if ( obj.attachEvent ) {&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  obj[&rsquo;e&rsquo;+type+fn] = fn;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  obj[type+fn] = function(){obj[&rsquo;e&rsquo;+type+fn]( window.event );}&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  obj.attachEvent( &rsquo;on&rsquo;+type, obj[type+fn] );&nbsp;&nbsp;<br>
&nbsp;&nbsp;  } else&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  obj.addEventListener( type, fn, false );&nbsp;&nbsp;<br>
}&nbsp;&nbsp;<br>
function removeEvent( obj, type, fn ) {&nbsp;&nbsp;<br>
&nbsp;&nbsp;  if ( obj.detachEvent ) {&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  obj.detachEvent( &rsquo;on&rsquo;+type, obj[type+fn] );&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  obj[type+fn] = null;&nbsp;&nbsp;<br>
&nbsp;&nbsp;  } else&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  obj.removeEventListener( type, fn, false );&nbsp;&nbsp;<br>
}&nbsp;&nbsp;<br>
QuirkMode 对选择John为胜利者的解释概括来说就是以上代码最简洁有效，在避免内存问题的同时还巧妙的保证了this关键字在ie的attachEvent中能正常工作。缺点当然还是存在：&nbsp;&nbsp;&nbsp;<br>
<br>
不支持 Netscape 4 和 Explorer 5 Mac。(有可能国内的程序员会嗤之以鼻，但国外很强调广泛的兼容性)&nbsp;&nbsp;&nbsp;<br>
在 removeEvent 中遗漏了remove obj[&quot;e&quot;+type+fn]。&nbsp;&nbsp;&nbsp;<br>
总之不管怎么说，简单取胜。&nbsp;&nbsp;<br>
结果一出，众多参赛与评论者不服气，很快又挑出了John的代码的几处毛病：&nbsp;&nbsp;&nbsp;<br>
<br>
addEvent中本身就使用了闭句，所以没有根本解决IE内存泄露的问题。&nbsp;&nbsp;&nbsp;<br>
没有解决同类型的事件可能被重复注册而被IE重复执行的问题。&nbsp;&nbsp;&nbsp;<br>
几个高手于是提出了改进性的方案： /*&nbsp;&nbsp;<br>
Original idea by John Resig&nbsp;&nbsp;<br>
Tweaked by Scott Andrew LePera, Dean Edwards and Peter-Paul Koch&nbsp;&nbsp;<br>
Fixed for IE by Tino Zijdel (crisp)&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  Note that in IE this will cause memory leaks and still doesn&rsquo;t quite function the same as in browsers that do support the W3C event model:&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  - event execution order is not the same (LIFO in IE against FIFO)&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  - functions attached to the same event on the same element multiple times will also get executed multiple times in IE&nbsp;&nbsp;<br>
*/&nbsp;&nbsp;<br>
function addEvent( obj, type, fn ) {&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  if (obj.addEventListener)&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  obj.addEventListener( type, fn, false );&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  else if (obj.attachEvent) {&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  obj[&quot;e&quot;+type+fn] = fn;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  obj.attachEvent( &quot;on&quot;+type, function() { obj[&quot;e&quot;+type+fn](); } );&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  }&nbsp;&nbsp;<br>
}&nbsp;&nbsp;<br>
function removeEvent( obj, type, fn ) {&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  if (obj.removeEventListener)&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  obj.removeEventListener( type, fn, false );&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  else if (obj.detachEvent) {&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  obj.detachEvent( &quot;on&quot;+type, obj[&quot;e&quot;+type+fn] );&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  obj[&quot;e&quot;+type+fn] = null;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  }&nbsp;&nbsp;<br>
}&nbsp;&nbsp;<br>
很明显，虽然修正了John代码的一些不足。但内存泄露依然存在，部分浏览器依然不支持，还是无法避免ie重复注册。另外根据注释:当在同一个对象上注册多个事件处理器的时候，IE与其他浏览器的执行顺序是不同的，这又是一个隐患。&nbsp;&nbsp;<br>
<br>
几天之后，一个被认为最严谨的方案由Dean Edwards 提出。Dean他的方案与众不同：&nbsp;&nbsp;&nbsp;<br>
<br>
不执行对象检测(Object detection)&nbsp;&nbsp;&nbsp;<br>
没有调用 addeventListener/attachEvent 方法&nbsp;&nbsp;&nbsp;<br>
保持this关键字的运行于正确的上下文环境&nbsp;&nbsp;&nbsp;<br>
正确传递 event 对象参数&nbsp;&nbsp;&nbsp;<br>
完全跨浏览器至此(包括IE4和NS4)&nbsp;&nbsp;&nbsp;<br>
不存在内存泄露&nbsp;&nbsp;&nbsp;<br>
Dean的代码如下： // written by Dean Edwards, 2005&nbsp;&nbsp;<br>
// <a target="_blank" href="http://dean.edwards.name/function&nbsp;">http://dean.edwards.name/function </a>;addEvent(element, type, handler) {&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  // assign each event handler a unique ID&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  // 为事件处理函数设定一个唯一值&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  if (!handler.$$guid) handler.$$guid = addEvent.guid++;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  // create a hash table of event types for the element&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  if (!element.events) element.events = {};&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  // create a hash table of event handlers for each element/event pair&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  var handlers = element.events[type];&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  if (!handlers) {&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  handlers = element.events[type] = {};&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  // store the existing event handler (if there is one)&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  // 如果对象已经注册有事件处理，那么要保留下来,并保存为第一个&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if (element[&quot;on&quot; + type]) {&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  handlers[0] = element[&quot;on&quot; + type];&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  }&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  // store the event handler in the hash table&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  handlers[handler.$$guid] = handler;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  // assign a global event handler to do all the work&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  // 指派一个全局函数做统一的事件处理，同时避免了反复注册&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  element[&quot;on&quot; + type] = handleEvent;&nbsp;&nbsp;<br>
};&nbsp;&nbsp;<br>
// a counter used to create unique IDs&nbsp;&nbsp;<br>
addEvent.guid = 1;function removeEvent(element, type, handler) {&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  // delete the event handler from the hash table&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  if (element.events &amp;&amp; element.events[type]) {&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  delete element.events[type][handler.$$guid];&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  }&nbsp;&nbsp;<br>
};function handleEvent(event) {&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  // grab the event object (IE uses a global event object)&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  event = event || window.event;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  // get a reference to the hash table of event handlers&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  // 这里的 this 随 handlerEvent function 被触发的source element 变化而变化&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  var handlers = this.events[event.type];&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  // execute each event handler&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  for (var i in handlers) {&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  //这样写才能保证注册的事件处理函数中的 this 得到正确的引用，直接handlers[i]()是不行的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  this.$$handleEvent = handlers[i];&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  this.$$handleEvent(event);&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  }&nbsp;&nbsp;<br>
};&nbsp;&nbsp;<br>
这段代码相比之前就大了不少了，不过确实很精妙。可是这段代码却引入了其他的问题，比如无法处理事件处理函数的返回值，for..in循环可能因为(Object.prototype)的错误应用而中断等等...很快Dean推出一个&quot;updated version&quot;。&nbsp;&nbsp;<br>
<br>
要做到最好真的好辛苦。&nbsp;&nbsp;<br>
<br>
目前似乎Dean的最终版本是最全面的解决方案。不过就我个人意见，感觉有些吹毛求疵了。尽量使用浏览器本身的实现和保持简单是我一贯坚持的主张。但洋人这种严谨的态度，还是让我深深敬佩。&nbsp;&nbsp;</p>
<p><a href="http://hi.baidu.com/aidfan/blog">http://hi.baidu.com/aidfan/blog</a></p></div></body></html>