<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>JDK1.6.0新特性详解与代码示例 -Javacode</title></head><body><h1>JDK1.6.0新特性详解与代码示例 -Javacode</h1><div><p>JDK1.6.0新特性详解与代码示例 -Javacode</p>
<p>JDK6.0发布有段时间了，新的JDK也有不少新的特性，我去网上搜集了一下，列在下面和大家一起学习．<br>
１．Desktop和SystemTray. 在JDK6中 ,AWT新增加了两个类:Desktop和SystemTray,前者可以用来打开系统默认浏览器浏览指定的URL,打开系统默认邮件客户端给指定的邮箱发邮件,用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件),用系统默认的打印机打印文档;后者可以用来在系统托盘区创建一个托盘程序。</p>
<p>我随便找了几张图，在Tray里面都是空的，没有图,可能是图太大，有xdjm知道希望告诉我．</p>
<p><br>
import java.awt.AWTException;<br>
import java.awt.Desktop;<br>
import java.awt.Image;<br>
import java.awt.MenuItem;<br>
import java.awt.PopupMenu;<br>
import java.awt.SystemTray;<br>
import java.awt.Toolkit;<br>
import java.awt.TrayIcon;<br>
import java.awt.event.ActionEvent;<br>
import java.awt.event.ActionListener;<br>
import java.io.File;<br>
import java.io.IOException;<br>
import java.net.URI;<br>
import java.net.URISyntaxException;</p>
<p>public class DesktopTrayTest ...{<br>
&nbsp;&nbsp;&nbsp;  private static Desktop desktop;<br>
&nbsp;&nbsp;&nbsp;  private static SystemTray st;<br>
&nbsp;&nbsp;&nbsp;  private static PopupMenu pm;<br>
&nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  public static void main( String[] args ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if( Desktop.isDesktopSupported() ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  desktop = Desktop.getDesktop();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if( SystemTray.isSupported() ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  st = SystemTray.getSystemTray();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Image image = Toolkit.getDefaultToolkit().createImage( &quot;<a href="http://www.51ppt.com.cn/Article/Uploadphotos/200604/20064147333288.png">http://www.51ppt.com.cn/Article/Uploadphotos/200604/20064147333288.png</a>&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  createPopupMenu();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  TrayIcon ti = new TrayIcon( image, &quot;Demo&quot;, pm );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  try...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  st.add( ti );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } catch( AWTException awte ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  awte.printStackTrace();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  public static void sendMail( String mail ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if( desktop != null &amp;&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  desktop.isSupported( Desktop.Action.MAIL ) ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  try ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  desktop.mail( new URI( mail ) );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } catch (IOException e) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  e.printStackTrace();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } catch (URISyntaxException e) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  e.printStackTrace();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  public static void openBrowser( String url ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if( desktop != null &amp;&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  desktop.isSupported( Desktop.Action.BROWSE )) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  try ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  desktop.browse( new URI( url ) );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } catch (IOException e) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  e.printStackTrace();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } catch (URISyntaxException e) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  e.printStackTrace();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  public static void edit() ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if( desktop != null &amp;&amp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  desktop.isSupported( Desktop.Action.EDIT ) ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  File file = new File( &quot;test.txt&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  try ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if( file.exists() == false ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  file.createNewFile();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  desktop.edit( file );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } catch( IOException ioe ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ioe.printStackTrace();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  public static void createPopupMenu() ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  pm = new PopupMenu();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  MenuItem ob = new MenuItem( &quot;Open url&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ob.addActionListener( new ActionListener() ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  public void actionPerformed( ActionEvent ae ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  openBrowser( &quot;<a href="http://blog.csdn.net/xumingming64398966">http://blog.csdn.net/xumingming64398966</a>&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  });<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  MenuItem sm = new MenuItem( &quot;Send Mail&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  sm.addActionListener( new ActionListener() ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  public void actionPerformed( ActionEvent ae ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  sendMail( &quot;<a href="mailto:64398966@qq.com">64398966@qq.com</a>&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  });<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  MenuItem ed = new MenuItem( &quot;Edit&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ed.addActionListener( new ActionListener() ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  public void actionPerformed( ActionEvent ae ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  edit();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  });<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  MenuItem ex = new MenuItem( &quot;Exit&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ex.addActionListener( new ActionListener() ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  public void actionPerformed( ActionEvent ae ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  System.exit( 0 );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  });<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  pm.add( ob );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  pm.add( sm );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  pm.add( ed );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  pm.addSeparator();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  pm.add( ex );<br>
&nbsp;&nbsp;&nbsp;  }<br>
}</p>
<p> </p>
<p>２．Console. JDK6中提供了java.io.Console类专用来访问基于字符的控制台设备. 你的程序如果要与Windows下的cmd或者Linux下的Terminal交互,就可以用Console类代劳. 但我们不总是能得到可用的Console, 一个JVM是否有可用的Console依赖于底层平台和JVM如何被调用. 如果JVM是在交互式命令行(比如Windows的cmd)中启动的,并且输入输出没有重定向到另外的地方,那么就可以得到一个可用的Console实例. 下面代码演示了Console类的用法:</p>
<p><br>
import java.io.Console;</p>
<p>public class ConsoleTest ...{<br>
&nbsp;&nbsp;&nbsp;  public static void main( String[] args ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Console console = System.console();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if( console != null ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  String user = new String( console.readLine( &quot;Enter User:&quot;, new Object[ 0 ] ) );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  String pwd = new String( console.readPassword( &quot;Enter Password:&quot;, new Object[ 0 ] ));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  console.printf( &quot;User name is:%s&quot;, new Object[]...{user} );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  console.printf( &quot;Password is:%s&quot;, new Object[]...{pwd} );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } else ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  System.out.println( &quot;No Console!&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  }<br>
}</p>
<p><br>
你如果是在一个IDE中如eclipse, netbeans中运行你将得到：<br>
No Console!<br>
因为只有在命令行中才能得到Console对象。</p>
<p>３．Compiler API. 现在我们可以用JDK6 的Compiler API(JSR 199)去动态编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。这个特性对于某些需要用到动态编译的应用程序相当有用，比如JSP Web Server，当我们手动修改JSP后，是不希望需要重启Web Server才可以看到效果的，这时候我们就可以用Compiler API来实现动态编译JSP文件，当然，现在的JSP Web Server也是支持JSP热部署的，现在的JSP Web Server通过在运行期间通过Runtime.exec或ProcessBuilder来调用javac来编译代码，这种方式需要我们产生另一个进程去做编译工作，不够优雅而且容易使代码依赖与特定的操作系统；Compiler API通过一套易用的标准的API提供了更加丰富的方式去做动态编译,而且是跨平台的。 下面代码演示了Compiler API的使用：</p>
<p><br>
import java.io.BufferedWriter;<br>
import java.io.FileWriter;<br>
import java.io.IOException;<br>
import java.util.Iterator;</p>
<p>import javax.tools.JavaCompiler;<br>
import javax.tools.JavaFileObject;<br>
import javax.tools.StandardJavaFileManager;<br>
import javax.tools.ToolProvider;</p>
<p>public class CompilerAPITest ...{<br>
&nbsp;&nbsp;&nbsp;  private final static String srcFileName = &quot;Test.java&quot;;<br>
&nbsp;&nbsp;&nbsp;  private final static String classFileName = &quot;Test.class&quot;;<br>
&nbsp;&nbsp;&nbsp;  private final static String className = &quot;Test&quot;;<br>
&nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  public static void main( String[] args ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if( compiler == null ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  System.err.println( &quot;Compiler is null!&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  StandardJavaFileManager fileManager = compiler.getStandardFileManager( null, null, null );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  generateJavaClass();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Iterable &lt; ? extends JavaFileObject&gt; sourceFiles = fileManager.getJavaFileObjects( new String[]...{ srcFileName } );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  compiler.getTask( null, fileManager, null, null, null, sourceFiles ).call();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  try ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  fileManager.close();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Class.forName( className ).newInstance();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } catch (IOException e) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  e.printStackTrace();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } catch (InstantiationException e) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  e.printStackTrace();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } catch (IllegalAccessException e) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  e.printStackTrace();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } catch (ClassNotFoundException e) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  e.printStackTrace();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  public static void generateJavaClass() ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  try ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  FileWriter rw = new FileWriter( srcFileName );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  BufferedWriter bw = new BufferedWriter( rw );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  bw.write( &quot;public class &quot; + className + &quot; {&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  bw.newLine();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  bw.write( &quot;public &quot; + className + &quot;() {&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  bw.newLine();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  bw.write( &quot;System.out.println( 'you are in the constructor of Class Test' );&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  bw.write( &quot;}&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  bw.newLine();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  bw.write( &quot;}&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  bw.flush();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  bw.close();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } catch (IOException e) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  e.printStackTrace();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  }<br>
}</p>
<p>我在运行这个例子的时候发现ToolProvider.getSystemJavaCompiler得到的是NULL,后来上网一查，原来是一个Bug!链接如下：<br>
<a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6477844">http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6477844</a></p>
<p>Closed, not reproducible<br>
那为什么我一直在reproduce阿？</p>
<p>4.Http Server API. JDK6提供了一个简单的Http Server API,据此我们可以构建自己的嵌入式Http Server,它支持Http和Https协议,提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现,程序员必须自己实现HttpHandler接口,HttpServer会调用HttpHandler实现类的回调方法来处理客户端请求,在这里,我们把一个Http请求和它的响应称为一个交换,包装成HttpExchange类,HttpServer负责将HttpExchange传给 HttpHandler实现类的回调方法.下面代码演示了怎样创建自己的Http Server .</p>
<p> </p>
<p>import java.io.IOException;<br>
import java.io.InputStream;<br>
import java.io.OutputStream;<br>
import java.net.InetSocketAddress;</p>
<p>import com.sun.net.httpserver.HttpExchange;<br>
import com.sun.net.httpserver.HttpHandler;<br>
import com.sun.net.httpserver.HttpServer;</p>
<p>public class HttpServerAPITest ...{<br>
&nbsp;&nbsp;&nbsp;  private static int count = 0;<br>
&nbsp;&nbsp;&nbsp;  public static void main( String[] args ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  try ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  HttpServer hs = HttpServer.create( new InetSocketAddress( 8888 ), 0 );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  hs.createContext( &quot;/&quot;, new MyHandler() );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  hs.createContext( &quot;/java&quot;, new MyHandler() );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  hs.setExecutor( null );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  hs.start();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  System.out.println( &quot;---begin---&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  System.out.println( &quot;Listening on &quot; + hs.getAddress() );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } catch( IOException ioe ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ioe.printStackTrace();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  static class MyHandler implements HttpHandler ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  public void handle( HttpExchange he ) throws IOException ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  System.out.println( &quot;Request &quot; + count++ );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  System.out.println( he.getHttpContext().getPath() );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  InputStream is = he.getRequestBody();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  String response = &quot;&lt;font color='blue'&gt;Happy Spring Festerval&lt;/font&gt;&quot;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  he.sendResponseHeaders( 200, response.length() );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  OutputStream os = he.getResponseBody();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  os.write( response.getBytes() );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  os.close();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  }<br>
}</p>
<p> </p>
<p>效果如图:</p>
<p> </p>
<p>5.对脚本语言的支持如: ruby, groovy, javascript.</p>
<p>代码如下:</p>
<p>import java.io.FileReader;</p>
<p>import javax.script.Invocable;<br>
import javax.script.ScriptEngine;<br>
import javax.script.ScriptEngineManager;</p>
<p>public class ScriptTest ...{<br>
&nbsp;&nbsp;&nbsp;  public static void main( String[] args ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ScriptEngineManager manager = new ScriptEngineManager();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ScriptEngine engine = manager.getEngineByName( &quot;ECMAScript&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  try ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  engine.eval( new FileReader( &quot;C:\test.js&quot; ) );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Invocable invocableEngine = (Invocable)engine;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Object ret = invocableEngine.invokeFunction( &quot;test&quot;, null );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  System.out.println( &quot;The result is :&quot; + (Double)ret );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } catch( Exception e ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  e.printStackTrace();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  }<br>
}</p>
<p>test.js如下:</p>
<p>function test()...{<br>
&nbsp;&nbsp;&nbsp;  return Math.round( 11.2 );<br>
}<br>
6.插入式注解处理API(Pluggable Annotation Processing API)，插入式注解处理API(JSR 269)提供一套标准API来处理Annotations.JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation, Annotation Processor相当于编译器的一个插件,所以称为插入式注解处理.如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码,编译器会再调用一次Annotation Processor,如果第二次处理还有新代码产生,就会接着调用Annotation Processor,直到没有新代码产生为止.每执行一次process()方法被称为一个&quot;round&quot;,这样整个Annotation processing过程可以看作是一个round的序列. <br>
举个例子：们想建立一套基于Annotation的单元测试框架(如TestNG),在测试类里面用Annotation来标识测试期间需要执行的测试方法,如下所示:</p>
<p><br>
@TestMethod<br>
public void testCheckName()...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  //do something here<br>
}</p>
<p>这时我们就可以用JSR 269提供的API来处理测试类,根据Annotation提取出需要执行的测试方法.</p>
<p><br>
再举个例子: 下面我用代码演示如何来用JSR 269提供的API来处理Annotations和读取Java源文件的元数据(metadata)</p>
<p><br>
import java.util.List;<br>
import java.util.Map;<br>
import java.util.Set;</p>
<p>import javax.annotation.processing.AbstractProcessor;<br>
import javax.annotation.processing.RoundEnvironment;<br>
import javax.annotation.processing.SupportedAnnotationTypes;<br>
import javax.annotation.processing.SupportedSourceVersion;<br>
import javax.lang.model.SourceVersion;<br>
import javax.lang.model.element.AnnotationMirror;<br>
import javax.lang.model.element.AnnotationValue;<br>
import javax.lang.model.element.Element;<br>
import javax.lang.model.element.ExecutableElement;<br>
import javax.lang.model.element.TypeElement;<br>
import javax.lang.model.util.ElementFilter;<br>
import javax.tools.Diagnostic.Kind;</p>
<p>@SupportedAnnotationTypes( &quot;ToBeTested&quot; )<br>
@SupportedSourceVersion( SourceVersion.RELEASE_6 )<br>
public class MyAnnotationProcessor extends AbstractProcessor ...{<br>
&nbsp;&nbsp;&nbsp;  private void note( String msg ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  processingEnv.getMessager().printMessage( Kind.NOTE, msg );<br>
&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  public boolean process( Set&lt; ? extends TypeElement &gt; annotations, RoundEnvironment roundEnv ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  for( TypeElement te : annotations ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  note( &quot;annotation: &quot; + te.toString() );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Set&lt; ? extends Element &gt; elements = roundEnv.getRootElements();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  for( Element e : elements ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  List&lt; ? extends Element &gt; enclosedElems = e.getEnclosedElements();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  List&lt; ? extends ExecutableElement &gt; ees = ElementFilter.methodsIn( enclosedElems );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  for( ExecutableElement ee : ees ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  note( &quot;Executable Element Name: &quot; + ee.getSimpleName() );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  List&lt; ? extends AnnotationMirror &gt; as = ee.getAnnotationMirrors();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  note( &quot; as: &quot; + as ); <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  for( AnnotationMirror am : as )...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Map&lt; ? extends ExecutableElement, ? extends AnnotationValue &gt; map = am.getElementValues();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Set&lt; ? extends ExecutableElement &gt; ks = map.keySet();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  for( ExecutableElement k : ks ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  AnnotationValue av = map.get( k );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  note(&quot;----&quot;+ee.getSimpleName()+&quot;.&quot;+k.getSimpleName()+&quot;=&quot;+av.getValue());<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return false;<br>
&nbsp;&nbsp;&nbsp;  }<br>
}</p>
<p> </p>
<p><br>
public class Testing ...{<br>
&nbsp;&nbsp;&nbsp;  @ToBeTested(group=&quot;A&quot;)<br>
&nbsp;&nbsp;&nbsp;  public void m1()...{<br>
&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  @ToBeTested(group=&quot;B&quot;,owner=&quot;QQ&quot;)<br>
&nbsp;&nbsp;&nbsp;  public void m2()...{<br>
&nbsp;&nbsp;&nbsp;  }&nbsp;&nbsp;&nbsp;  <br>
}</p>
<p> </p>
<p>import java.lang.annotation.ElementType;<br>
import java.lang.annotation.Retention;<br>
import java.lang.annotation.RetentionPolicy;<br>
import java.lang.annotation.Target;</p>
<p>@Retention( RetentionPolicy.RUNTIME )<br>
@Target( ElementType.METHOD )<br>
public @interface ToBeTested ...{<br>
&nbsp;&nbsp;&nbsp;  String owner() default &quot;Chinajash&quot;;<br>
&nbsp;&nbsp;&nbsp;  String group();<br>
}</p>
<p>效果如下：</p>
<p><br>
7.StAX. StAX是The Streaming API for XML的缩写，是继DOM(Document Object Model)和SAX(Simple API for XML)之后的又一种处理xml的api,一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符；SAX也是基于事件处理xml文档，但却是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。</p>
<p>下面是个例子：</p>
<p> </p>
<p>import java.io.FileNotFoundException;<br>
import java.io.FileOutputStream;</p>
<p>import javax.xml.namespace.QName;<br>
import javax.xml.stream.XMLEventReader;<br>
import javax.xml.stream.XMLInputFactory;<br>
import javax.xml.stream.XMLOutputFactory;<br>
import javax.xml.stream.XMLStreamException;<br>
import javax.xml.stream.XMLStreamWriter;<br>
import javax.xml.stream.events.StartElement;<br>
import javax.xml.stream.events.XMLEvent;</p>
<p>public class StaxTest ...{<br>
&nbsp;&nbsp;&nbsp;  public static void main( String[] arg ) throws XMLStreamException, FileNotFoundException ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  readXMLByStAX();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  writeXMLByStAX();<br>
&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  public static void readXMLByStAX() throws XMLStreamException, FileNotFoundException ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  XMLInputFactory factory = XMLInputFactory.newInstance();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  XMLEventReader reader = factory.createXMLEventReader( StaxTest.class.getResourceAsStream( &quot;test.xml&quot; ) );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  XMLEvent event;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  StringBuffer parsingResult = new StringBuffer();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  while( reader.hasNext() ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  event = reader.nextEvent();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if( event.isStartElement() ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  StartElement se = event.asStartElement();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  parsingResult.append( &quot;&lt;&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  parsingResult.append( se.getName() );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if( se.getName().getLocalPart().equals( &quot;catalog&quot; ) ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  parsingResult.append( &quot;id=&quot;&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  parsingResult.append( se.getAttributeByName( new QName( &quot;id&quot; ) ).getValue());<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  parsingResult.append( &quot;&quot;&quot; ) ;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  parsingResult.append( &quot;&gt;&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } else if( event.isCharacters() ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  parsingResult.append( event.asCharacters().getData() );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } else if( event.isEndElement() ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  parsingResult.append( &quot;&lt;/&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  parsingResult.append( event.asEndElement().getName() );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  parsingResult.append( &quot;&gt;&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  System.out.println( parsingResult );<br>
&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  public static void writeXMLByStAX() throws XMLStreamException, FileNotFoundException ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  XMLOutputFactory factory = XMLOutputFactory.newInstance();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  XMLStreamWriter writer = factory.createXMLStreamWriter( new FileOutputStream( &quot;output.xml&quot; ) );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  writer.writeStartDocument();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  writer.writeCharacters( &quot; &quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  writer.writeComment( &quot;testing comment&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  writer.writeCharacters( &quot; &quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  writer.writeStartElement( &quot;catalogs&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  writer.writeNamespace( &quot;myNS&quot;, &quot;<a href="http://blog.csdn.net/Chinajash">http://blog.csdn.net/Chinajash</a>&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  writer.writeAttribute( &quot;owner&quot;, &quot;sina&quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  writer.writeCharacters( &quot; &quot; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  writer.writeStartElement(&quot;<a href="http://blog.csdn.net/Chinajash">http://blog.csdn.net/Chinajash</a>&quot;, &quot;catalog&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  writer.writeAttribute(&quot;id&quot;,&quot;007&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  writer.writeCharacters(&quot;Apparel&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  // 写入catalog元素的结束标签<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  writer.writeEndElement();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  // 写入catalogs元素的结束标签<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  writer.writeEndElement();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  // 结束 XML 文档<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  writer.writeEndDocument();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  writer.close();</p>
<p>&nbsp;&nbsp;&nbsp;  }<br>
}</p>
<p>test.xml:</p>
<p> </p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>
&lt;catalogs&gt;<br>
&nbsp;&nbsp;&nbsp;  &lt;catalog id=&quot;001&quot;&gt;Book&lt;/catalog&gt;<br>
&nbsp;&nbsp;&nbsp;  &lt;catalog id=&quot;002&quot;&gt;Video&lt;/catalog&gt;<br>
&lt;/catalogs&gt;</p>
<p>8. Web Service. 由于Web服务日趋流行，利用Web服务的功能性的API特征正从最新的Java EE版本中向Java SE 6平台迁移。换言之，针对Web服务不需另外加入额外的工具，在Java EE和Java SE平台拥有相同的API。野马将大把不同的Web服务相关的API加到标准的工具柜中：以JSR 181针对Java 平台的Web服务元数据，通过JSR 224的基于XML 的Web服务Java API（JAX-WS）；针对Java的带有附件的SOAP API（SAAJ）作为JSR 67 。与三个Web服务API相关的包新增到Java SE 6.0里：JAX－WS API 放置到javax.xml.ws包； SAAJ类在javax.xml.soap 包； Web服务的元数据类放置在javax.jws包里。 下面是一个简单的例子，　下面的代码是要作为web service发布的类。</p>
<p><br>
package hello;<br>
import javax.jws.WebService;<br>
import javax.xml.ws.Endpoint;</p>
<p>@WebService<br>
public class CircleFunctions ...{<br>
&nbsp;&nbsp;&nbsp;  public double getArea( int radius ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return Math.PI * radius * radius;<br>
&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  public double getCircumference( int radius ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return Math.PI * radius * 2;<br>
&nbsp;&nbsp;&nbsp;  }<br>
&nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  public static void main( String[] args ) ...{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Endpoint.publish( &quot;<a href="http://localhost:8888/WebServiceExample/circlefunctions">http://localhost:8888/WebServiceExample/circlefunctions</a>&quot;, new CircleFunctions());<br>
&nbsp;&nbsp;&nbsp;  }<br>
}</p>
<p> </p>
<p>处理的方法如下：<br>
javac -d ./ CircleFunctions.java<br>
wsgen hello.CircleFunctions<br>
java hello.CircleFunctions<br>
然后在浏览器中输入如下url,你将得到一个xml页面：<br>
http: //localhost:8888/WebServiceExample/circlefunctions?WSDL</p>
<p>参考网页：<br>
1.Desktop和SystemTray. <a href="http://dev.yesky.com/411/3019911.shtml">http://dev.yesky.com/411/3019911.shtml</a><br>
2.Console. <a href="http://dev.yesky.com/133/3032133.shtml">http://dev.yesky.com/133/3032133.shtml</a><br>
3.Compiler API. <a href="http://developer.51cto.com/art/200701/37359.htm">http://developer.51cto.com/art/200701/37359.htm</a><br>
4.HttpServer API. <a href="http://www.testage.net/QA/Dev/200701/1396.htm">http://www.testage.net/QA/Dev/200701/1396.htm</a><br>
5. 对脚本语言的支持<a href="http://blog.edwardro.com/read.php?167">http://blog.edwardro.com/read.php?167</a><br>
6. 插入式注解处理API. <a href="http://ourconan.com.cn/article.php?itemid-2113-type-blog.html">http://ourconan.com.cn/article.php?itemid-2113-type-blog.html</a><br>
7.StAX. <a href="http://ourconan.com.cn/article.php?itemid-2111-type-blog.html">http://ourconan.com.cn/article.php?itemid-2111-type-blog.html</a><br>
8.Web Service. <a href="http://www.360doc.com/showWeb/0/0/298124.aspx">http://www.360doc.com/showWeb/0/0/298124.aspx</a><br>
9.JDK1.5的Annotation<br>
<a href="http://lzqdiy.bokee.com/viewdiary.14724866.html">http://lzqdiy.bokee.com/viewdiary.14724866.html</a></p>
<p><br>
<a href="http://blog.csdn.net/xumingming64398966/archive/2007/01/19/1487811.aspx">http://blog.csdn.net/xumingming64398966/archive/2007/01/19/1487811.aspx</a></p></div></body></html>