<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>《设计模式精解》读后感 -gthought</title></head><body><h1>《设计模式精解》读后感 -gthought</h1><div><p><font size="+0">《设计模式精解》读后感 -gthought</font></p>
<p><font size="+0">转自</font><a href="http://www.blogjava.net/killme2008/archive/2007/03/03/101592.html"><font size="+0">http://www.blogjava.net/killme2008/archive/2007/03/03/101592.html</font></a></p>
<p><font size="+0">&nbsp;&nbsp;  模式一直是J2EE领域的热门话题。两年前，对刚开始自学java并且到处碰壁的我，一本在图书馆借的《java与模式》看的我云里雾里，尽管心里面觉的他讲的很有道理，可对于没有实际项目经验的我，真正的理解和应用还很远很远。转眼工作快一年多了了，也做了几个不大不小的项目，尽管还只是个代码工人水准的，但是对于模式的兴趣越发浓厚，于是从书堆里找出来买了好久的GOF《设计模式》。这本书是圣经级别了，可我对C++的了解有限（虽然在学校里还是狠狠啃过好几本大部头，现在忘光了），而且这本圣经对初学者似乎不太友好，对模式也以罗列各条目为主，例子失当。于是买了《设计模式精解》，看china-pub的书评都说对初学者很有用，而且翻译的人也是我很佩服的gigix。<br>
&nbsp;&nbsp;&nbsp;  在春节期间读完了这本书，本书详细介绍了13种常见的设计模式，以一个实际问题引出了对面向对象新观点和设计模式的讨论，在介绍完所有的模式后，更难能可贵的是作者详细介绍了自己对模式的使用经验（使用共同点/变化点分析，使用分析矩阵等），整本书读下来令人心旷神怡。<br>
我们为什么要学习设计模式呢？总之是为了获得可以复用和容易扩展的解决方案，建立通用术语以方便团队内的沟通交流，另外，模式能让你以更高的层次或者说视角去观察问题，这样的视角将你从过早处理细节的泥潭中解放出来。模式本身就是对如何创建优良面向对象设计策略的实现：<br>
&nbsp;&nbsp;&nbsp;  1.针对接口编程<br>
&nbsp;&nbsp;&nbsp;  2.优先使用对象组合，而不是类继承<br>
&nbsp;&nbsp;&nbsp;  3.发现并封装变化点<br>
&nbsp;&nbsp;&nbsp;  你可以在每一个模式的背后或者每一个优秀设计的背后看到这些原则的影子。比如abstract factory、adapter、strategy体现了针对接口编程，composite、bridge体现了优先使用组合而不是继承等。<br>
&nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;  作者解释了面向对象的新观点:<br>
&nbsp;&nbsp;&nbsp;  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  原来的观点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  新的观点<br>
<br>
对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  伴随有方法的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  拥有责任的实体，或者说拥有特定行为的实体 <br>
<br>
<br>
封装&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  数据隐藏 &nbsp;&nbsp;  各种形式的封装，1.数据的封装，2.方法的封装<br>
&nbsp;&nbsp;  3.父类对子类的隐藏&nbsp;&nbsp;  4.其他对象的封装<br>
<br>
继承 &nbsp;&nbsp;  特化和复用 对象分类的一种方法<br>
<br>
&nbsp;&nbsp;&nbsp;  这些观点其实并不新，Martin Fowler提出了软件开发过程中的三种视觉：概念、规格和实现，过去我们对面向对象的观点来自于实现的角度(代码的角度）去观察，而新的观点只是从概念的角度重新观察面向对象设计。<br>
&nbsp;&nbsp;&nbsp;  深入到具体模式的讨论，记录一些需要注意的问题：<br>
1.Adapter与Facade模式的区别<br>
它们都是包装器，但是两者也有细微的区别:<br>
.两个模式中，我们都有已经存在的类（或者说系统）<br>
.Facade模式中，我们无需针对接口编程；而Adapter模式我们必须针对接口编程<br>
.Adapter模式通常是为了保持多态，而Facade模式对此不感兴趣<br>
.动机不同，Facade模式是为了简化接口，而Adapter模式是针对一个现存的接口编程<br>
结论：Facade模式简化接口，而Adapter模式将接口转换成另一个现有的接口<br>
<br>
2.Bridge模式的理解<br>
Bridge模式的意图是将抽象部分与它的实现部分分离，使它们可以独立的变化。这里的关键点是需要理解&ldquo;实现部分&rdquo;，如果把&ldquo;实现部分&rdquo;看成&ldquo;对象外部、被对象使用的某种东西&rdquo;，此模式就很好理解了。我们将变化转移到一个使用或者拥有变化的对象（此对象是指抽象类的对象和用来实现抽象类的派生类的对象）。当出现继承的类爆炸情况时，也许你该考虑此模式的应用场景了。此模式的UML图<br>
<img height="185" alt="Bridge1.jpg" width="553" border="0" src="http://www.blogjava.net/images/blogjava_net/killme2008/Bridge1.jpg"><br>
<br>
<br>
3.Observer模式，实现自己的观察者模式也是很简单，不过java已经内置了对此模式的支持。java.util.Observer和java.util.Observable是此模式的一个实现版本，实际应用中你所需要做的只是实现Observer接口，和继承Observable类<br>
<br>
4.Decorator模式是为现有的功能动态添加附加功能的一种方法，UML图如下<br>
<img height="288" alt="ShowImg.jpg" width="391" border="0" src="http://www.blogjava.net/images/blogjava_net/killme2008/ShowImg.jpg"><br>
java的IO库是典型的应用实现，java.io.InputStream和java.io.OutputStream就是图中的Component接口，FilterInputStream继承InputStream（也就是图中的Decorator，装饰器），其他的如ByteArrayInputStream、FileInputStream等直接继承自InputStream的类就是被装饰对象，而继承FilterInputStream的就是各式各样的装饰者。<br>
<br>
5.Strategy模式是一种定义算法家族的方法，所有的算法都做相同的工作，它们只是拥有不同的实现。当你的代码中出现了很多switch或者if else的语句，你应该考虑此模式。Strategy模式带来的缺点是类的数量的增加，在java中可以通过将实现类作为嵌套类放在Strategy抽象类中来解决。<br>
<br>
6.singleton模式的实现<br>
单线程应用：<br>
第一种：静态初始化<br>
</font></p>
<div style="border-right: rgb(204,204,204) 1px solid; padding-right: 5px; border-top: rgb(204,204,204) 1px solid; padding-left: 4px; font-size: 13px; padding-bottom: 4px; border-left: rgb(204,204,204) 1px solid; width: 98%; padding-top: 4px; border-bottom: rgb(204,204,204) 1px solid; background-color: rgb(238,238,238)"><font size="+0"><span style="color: rgb(0,0,255)">public</span><span style="color: rgb(0,0,0)"> </span><span style="color: rgb(0,0,255)">class</span></font><font size="+0"><span style="color: rgb(0,0,0)"> Singleton {<br>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(0,0,255)">private</span></font><font size="+0"><span style="color: rgb(0,0,0)"> Singleton() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(0,0,255)">private</span><span style="color: rgb(0,0,0)"> </span><span style="color: rgb(0,0,255)">static</span><span style="color: rgb(0,0,0)"> Singleton instance </span><span style="color: rgb(0,0,0)">=</span><span style="color: rgb(0,0,0)"> </span><span style="color: rgb(0,0,255)">new</span></font><font size="+0"><span style="color: rgb(0,0,0)"> Singleton();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(0,0,255)">public</span><span style="color: rgb(0,0,0)"> </span><span style="color: rgb(0,0,255)">static</span></font><font size="+0"><span style="color: rgb(0,0,0)"> Singleton getInstance() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(0,0,255)">return</span></font><span style="color: rgb(0,0,0)"><font size="+0"> instance;<br>
&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
}</font></span></div>
<p><br>
<font size="+0">第二种：lazy loading<br>
</font></p>
<div style="border-right: rgb(204,204,204) 1px solid; padding-right: 5px; border-top: rgb(204,204,204) 1px solid; padding-left: 4px; font-size: 13px; padding-bottom: 4px; border-left: rgb(204,204,204) 1px solid; width: 98%; padding-top: 4px; border-bottom: rgb(204,204,204) 1px solid; background-color: rgb(238,238,238)"><font size="+0"><span style="color: rgb(0,0,255)">public</span><span style="color: rgb(0,0,0)">&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(0,0,255)">class</span></font><font size="+0"><span style="color: rgb(0,0,0)">&nbsp;&nbsp;&nbsp;  Singleton&nbsp;&nbsp;&nbsp;  {&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;  　　</span><span style="color: rgb(0,0,255)">private</span><span style="color: rgb(0,0,0)">&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(0,0,255)">static</span><span style="color: rgb(0,0,0)">&nbsp;&nbsp;&nbsp;  Singleton&nbsp;&nbsp;&nbsp;  instance&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(0,0,0)">=</span><span style="color: rgb(0,0,0)">&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(0,0,255)">null</span></font><font size="+0"><span style="color: rgb(0,0,0)">;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;  　　</span><span style="color: rgb(0,0,255)">public</span><span style="color: rgb(0,0,0)">&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(0,0,255)">static</span><span style="color: rgb(0,0,0)">&nbsp;&nbsp;  </span></font><span style="color: rgb(0,0,0)"><font size="+0">Singleton&nbsp;&nbsp;&nbsp;  getInstance()&nbsp;&nbsp;&nbsp;  {&nbsp;&nbsp;<br>
</font></span><span style="color: rgb(0,128,0)"><br>
</span><font size="+0"><span style="color: rgb(0,0,0)">&nbsp;&nbsp;  　　</span><span style="color: rgb(0,0,255)">if</span><span style="color: rgb(0,0,0)">&nbsp;&nbsp;&nbsp;  (instance</span><span style="color: rgb(0,0,0)">==</span><span style="color: rgb(0,0,255)">null</span></font><font size="+0"><span style="color: rgb(0,0,0)">)&nbsp;&nbsp;<br>
&nbsp;&nbsp;  　　　　instance＝</span><span style="color: rgb(0,0,255)">new</span></font><font size="+0"><span style="color: rgb(0,0,0)">&nbsp;&nbsp;&nbsp;  Singleton();&nbsp;&nbsp;<br>
&nbsp;&nbsp;  　　</span><span style="color: rgb(0,0,255)">return</span></font><span style="color: rgb(0,0,0)"><font size="+0">&nbsp;&nbsp;&nbsp;  instance;&nbsp;&nbsp;&nbsp;  　　}&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;  }&nbsp;&nbsp;</font></span></div>
<p><br>
<font size="+0">多线程环境下：在C++中安全的Double-Checked Locking模式，在java中是不安全的，详细原因与java的内存管理模型有关，请见dreamstone的文章</font><a href="http://www.blogjava.net/dreamstone/archive/2006/11/04/79026.html"><font size="+0">《java中的模式&mdash;&mdash;单态》</font></a><br>
<font size="+0">安全的实现方法是使用同步：<br>
</font></p>
<div style="border-right: rgb(204,204,204) 1px solid; padding-right: 5px; border-top: rgb(204,204,204) 1px solid; padding-left: 4px; font-size: 13px; padding-bottom: 4px; border-left: rgb(204,204,204) 1px solid; width: 98%; padding-top: 4px; border-bottom: rgb(204,204,204) 1px solid; background-color: rgb(238,238,238)"><font size="+0"><span style="color: rgb(0,0,0)">&nbsp;&nbsp;  </span><span style="color: rgb(0,0,255)">public</span><span style="color: rgb(0,0,0)"> </span><span style="color: rgb(0,0,255)">class</span></font><span style="color: rgb(0,0,0)"><font size="+0"> Singleton {&nbsp;&nbsp;<br>
&nbsp;&nbsp;  </font></span><font size="+0"><span style="color: rgb(0,0,0)">&nbsp;&nbsp;  <br>
&nbsp;&nbsp;  </span><span style="color: rgb(0,0,255)">static</span></font><span style="color: rgb(0,0,0)"><font size="+0"> Singleton instance;&nbsp;&nbsp;<br>
&nbsp;&nbsp;  </font></span><font size="+0"><span style="color: rgb(0,0,0)">&nbsp;&nbsp;  <br>
&nbsp;&nbsp;  </span><span style="color: rgb(0,0,0)">&nbsp;&nbsp;  </span><span style="color: rgb(0,0,255)">public</span><span style="color: rgb(0,0,0)"> </span><span style="color: rgb(0,0,255)">static</span><span style="color: rgb(0,0,0)"> </span><span style="color: rgb(0,0,255)">synchronized</span></font><font size="+0"><span style="color: rgb(0,0,0)"> Singleton getInstance() {&nbsp;&nbsp;<br>
&nbsp;&nbsp;  </span><span style="color: rgb(0,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;  </span><span style="color: rgb(0,0,255)">if</span><span style="color: rgb(0,0,0)"> (instance </span><span style="color: rgb(0,0,0)">==</span><span style="color: rgb(0,0,0)"> </span><span style="color: rgb(0,0,255)">null</span></font><font size="+0"><span style="color: rgb(0,0,0)">)&nbsp;&nbsp;<br>
&nbsp;&nbsp;  </span><span style="color: rgb(0,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  instance </span><span style="color: rgb(0,0,0)">==</span><span style="color: rgb(0,0,0)"> </span><span style="color: rgb(0,0,255)">new</span></font><font size="+0"><span style="color: rgb(0,0,0)"> Singleton();&nbsp;&nbsp;<br>
&nbsp;&nbsp;  </span><span style="color: rgb(0,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;  </span><span style="color: rgb(0,0,255)">return</span></font><span style="color: rgb(0,0,0)"><font size="+0"> instance;&nbsp;&nbsp;<br>
&nbsp;&nbsp;  </font></span><span style="color: rgb(0,0,0)"><font size="+0">&nbsp;&nbsp;  }&nbsp;&nbsp;<br>
</font></span><font size="+0"><span style="color: rgb(0,0,0)">&nbsp;&nbsp;  <br>
</span><span style="color: rgb(0,0,0)">}&nbsp;&nbsp;</span></font></div>
<p><br>
<font size="+0">《Effective Java》中提到的另一种写法<br>
</font></p>
<div style="border-right: rgb(204,204,204) 1px solid; padding-right: 5px; border-top: rgb(204,204,204) 1px solid; padding-left: 4px; font-size: 13px; padding-bottom: 4px; border-left: rgb(204,204,204) 1px solid; width: 98%; padding-top: 4px; border-bottom: rgb(204,204,204) 1px solid; background-color: rgb(238,238,238)"><font size="+0"><span style="color: rgb(0,0,255)">public</span><span style="color: rgb(0,0,0)"> </span><span style="color: rgb(0,0,255)">class</span></font><font size="+0"><span style="color: rgb(0,0,0)"> Singleton {<br>
<br>
&nbsp;&nbsp;</span><span style="color: rgb(0,0,255)">static</span><span style="color: rgb(0,0,0)"> </span><span style="color: rgb(0,0,255)">class</span></font><font size="+0"><span style="color: rgb(0,0,0)"> SingletonHolder {<br>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(0,0,255)">static</span><span style="color: rgb(0,0,0)"> Singleton instance </span><span style="color: rgb(0,0,0)">=</span><span style="color: rgb(0,0,0)"> </span><span style="color: rgb(0,0,255)">new</span></font><font size="+0"><span style="color: rgb(0,0,0)"> Singleton();<br>
&nbsp;&nbsp;  }<br>
<br>
&nbsp;&nbsp;</span><span style="color: rgb(0,0,255)">public</span><span style="color: rgb(0,0,0)"> </span><span style="color: rgb(0,0,255)">static</span></font><font size="+0"><span style="color: rgb(0,0,0)"> Singleton getInstance() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: rgb(0,0,255)">return</span></font><span style="color: rgb(0,0,0)"><font size="+0"> SingletonHolder.instance;<br>
&nbsp;&nbsp;  }<br>
<br>
}</font></span></div>
<p><br>
<font size="+0">&nbsp;&nbsp;&nbsp;  在介绍完13个模式之后，作者提出了 一种称为分析矩阵的方法，详细讨论不是这篇短文能说的完，有兴趣请找来此书的电子版看看。简单来讲，先从问题领域中分析出所有的变化点和共同点，观察每一种必须实现的功能并作为矩阵的行，而矩阵中的列表示特定情况中的特定实现；然后观察行，并根据场景探讨使用合适的模式；最后观察列，从整体上考虑整个问题的模式的使用。在出现的概念的场景中添加新的概念来进行设计。<br>
<br>
&nbsp;&nbsp;&nbsp;  最后，作者总结了面向对象的原则：<br>
.&ldquo;对象&rdquo;是负有定义良好的责任的东西<br>
.对象对自己负责<br>
.封装意味着<br>
&mdash;&mdash;数据隐藏<br>
&mdash;&mdash;类隐藏（藏在抽象类或者接口后面）<br>
&mdash;&mdash;实现隐藏（变化封装为对象进行引用）<br>
.使用共同点/变化点分析抽象出行为和数据中的变化点<br>
.针对接口编程<br>
.把继承考虑为一种封装变化的方法，而不是为现有的对象制造特殊情况<br>
.将变化点封装在一个类中，并使之与其他变化点相分离<br>
.力求松耦合<br>
.力求高内聚<br>
.绝对细心地应用&ldquo;一次并且只有一次&rdquo;规则（只在一个地方实现一条规则） <br>
&nbsp;&nbsp;  书本只是提供了模式的介绍和参照，真正的应用还是要靠自己日常工作中的观察和体验，我将继续在工作中理解并贯彻这些原则。</font></p></div></body></html>