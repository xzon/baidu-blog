<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>一个简易的正则表达式实现</title></head><body><h1>一个简易的正则表达式实现</h1><div><pre> </pre>
<pre><font color="#00ffff"><strong><h1>一个简易的正则表达式实现</h1>这是我对c/c++论坛上的一道面试题给出的答案。可以支持两个连续的?通配符，也分别支持?放在模式匹配字符串首尾的情况。<br>对模式匹配字符串和输入字符串的处理都只需要一次遍历。<br>程序的设计原理就是实现了一个确定性有穷自动机(DFA)，这个DFA由一个state数组来具体实现。每个state数组元素对该一个通配符被匹配的情况。如果通配符之后的字符串被匹配，就转移到下一个状态。反之，则只是将匹配的字符串数加1。在输入字符串结束后，如果DFA的状态不是接收状态，则认为字符串不匹配。<br>程序的总体结构比较简单，便于扩充和维护。<br>关于这个主题的讨论请见这里：http://bbs.chinaunix.net/forum/viewtopic.php?t=598235<br><p>题目要求见注释：</p></strong></font></pre>
<pre> </pre>
<pre><font color="#00ffff"><strong>/*</strong></font><br><font color="#00ffff"><strong> * Design and write, using C (without C++ or language extentions), an </strong></font><br><font color="#00ffff"><strong> * implementation for the following function prototype:</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * bool matchAndTranslate(const char* inputString, const char* translationEntry,</strong></font><br><font color="#00ffff"><strong> *                          char* outputString);</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * where </strong></font><br><font color="#00ffff"><strong> * inputString is a null-terminated string with a maximum length of 64 </strong></font><br><font color="#00ffff"><strong> * characters in the character set of </strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * translationEntry is a null-terminated string with a maximum length of 195 </strong></font><br><font color="#00ffff"><strong> * characters in the form of /matchingPattern/translationPattern/</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * matchingPattern is a character string with a maximum length of 64 characters</strong></font><br><font color="#00ffff"><strong> * in the character set of </strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * * is a wildcard in the matchingPattern for 0 or more characters in the</strong></font><br><font color="#00ffff"><strong> * set </strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * ? is a wildcard in the matchingPattern for any single character in the</strong></font><br><font color="#00ffff"><strong> * set </strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * the maximum allowable number of wildcards in matchingPattern is 8</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * translationPattern is a character string with a maximum length of 128 </strong></font><br><font color="#00ffff"><strong> * characters in the character set of </strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * %% in the translationPattern designates a translation to %</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * %1,%2,..,%8 in the translationPattern designates a translation to the first </strong></font><br><font color="#00ffff"><strong> * to eighth corresponding wildcard match in matchingPattern if exists or to a </strong></font><br><font color="#00ffff"><strong> * null string  if the wildcard match does not exist.  There can be </strong></font><br><font color="#00ffff"><strong> * multiple %1, %2, etc. in translationPattern.</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * outputString is a buffer of sufficient length provided by caller for output.</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * Function description:</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * This function matches the entire inputString to the matchingPattern.</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * If a match if found, the inputString will be translated according to the </strong></font><br><font color="#00ffff"><strong> * translationPattern to form the outputString and a true (i.e. 1) will be </strong></font><br><font color="#00ffff"><strong> * returned.</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * If a match is not found, a false (i.e. 0) will be returned.</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * This function assumes the caller will ensure the inputString, the </strong></font><br><font color="#00ffff"><strong> * translationEntry, and the size of the outputString conform to its </strong></font><br><font color="#00ffff"><strong> * specifications and therefore will not verify.</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * This function prefers as few characters as possible in * wildcard match.</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * Sample input:</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * AAB1CDAB12CD081112AB3CD_OUT</strong></font><br><font color="#00ffff"><strong> * AAB23CD03022002AB3CD3081112_OUT</strong></font><br><font color="#00ffff"><strong> * 2003A02A08AB3CD_OUT</strong></font><br><font color="#00ffff"><strong> * 2003A02A08AB34CD88AB3CD99_ERR</strong></font><br><font color="#00ffff"><strong> * 2003A02A08AB37CD88AB3C992_ERR</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * Sample translationTable:</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * / *A*AB?CD*_* /MATCH_[%1]_[%2]_[%3]_[%4]_[%5]/</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * Corresponding output and outputString:</strong></font><br><font color="#00ffff"><strong> *</strong></font><br><font color="#00ffff"><strong> * true, MATCH_[]_[]_[1]_[AB12CD081112AB3CD]_[OUT]</strong></font><br><font color="#00ffff"><strong> * true, MATCH_[]_[AB23CD03022002]_[3]_[3081112]_[OUT]</strong></font><br><font color="#00ffff"><strong> * true, MATCH_[2003]_[02A08]_[3]_[]_[OUT]</strong></font><br><font color="#00ffff"><strong> * true, MATCH_[2003]_[02A08AB34CD88]_[3]_[99]_[ERR]</strong></font><br><font color="#00ffff"><strong> *          false, <undefined></undefined> </strong></font><br><font color="#00ffff"><strong> </strong></font><font color="#00ffff"><strong>*/</strong></font><br><br><font color="#8080ff"><strong>#define _GNU_SOURCE</strong></font><br><font color="#8080ff"><strong>#include </strong></font><font color="#ff40ff"><strong><string.h></string.h></strong></font><br><font color="#8080ff"><strong>#include </strong></font><font color="#ff40ff"><strong><stdlib.h></stdlib.h></strong></font><br><font color="#8080ff"><strong>#include </strong></font><font color="#ff40ff"><strong><stdio.h></stdio.h></strong></font><br><br><font color="#8080ff"><strong>#define TRUE </strong></font><font color="#ff40ff"><strong>1</strong></font><br><font color="#8080ff"><strong>#define FALSE </strong></font><font color="#ff40ff"><strong>0</strong></font><br><br><font color="#00ffff"><strong>/*</strong></font><br><font color="#00ffff"><strong> * word: point to the first matched character in inputString</strong></font><br><font color="#00ffff"><strong> * n_word: the length of string word</strong></font><br><font color="#00ffff"><strong> * match_str: point to the first character in translationEntry </strong></font><br><font color="#00ffff"><strong> * n_match_str: the length of string match_str</strong></font><br><font color="#00ffff"><strong> * question_mark_flag: the number of characters that the matched state for ?</strong></font><br><font color="#00ffff"><strong> *                     should accept </strong></font><br><font color="#00ffff"><strong> * op: function for corresponding state</strong></font><br><font color="#00ffff"><strong> </strong></font><font color="#00ffff"><strong>*/</strong></font><br><font color="#00ff00"><strong>struct</strong></font> state {<br>    <font color="#00ff00"><strong>int</strong></font> n_word;<br>    <font color="#00ff00"><strong>const</strong></font> <font color="#00ff00"><strong>char</strong></font> *word;<br>    <font color="#00ff00"><strong>int</strong></font> n_match_str;<br>    <font color="#00ff00"><strong>const</strong></font> <font color="#00ff00"><strong>char</strong></font> *match_str;<br>    <font color="#00ff00"><strong>int</strong></font> question_mark_flag;<br>    <font color="#00ff00"><strong>void</strong></font> (*op)(<font color="#00ff00"><strong>struct</strong></font> state *this, <font color="#00ff00"><strong>int</strong></font> *current_state,<br>            <font color="#00ff00"><strong>const</strong></font> <font color="#00ff00"><strong>char</strong></font> **current_char);<br>};<br><br><font color="#00ff00"><strong>int</strong></font> accepting_state = <font color="#ff40ff"><strong>0</strong></font>;<br><font color="#00ff00"><strong>char</strong></font> *output_fmt;<br><br><font color="#00ffff"><strong>// start state</strong></font><br><font color="#00ff00"><strong>void</strong></font> op_start(<font color="#00ff00"><strong>struct</strong></font> state *this, <font color="#00ff00"><strong>int</strong></font> *current_state,<br>        <font color="#00ff00"><strong>const</strong></font> <font color="#00ff00"><strong>char</strong></font> **current_char)<br>{<br>    <font color="#ffff00"><strong>if</strong></font>((<font color="#ff40ff"><strong>NULL</strong></font> == this-&gt;match_str) &amp;&amp; (*current_state != accepting_state)) {<br>        *current_state += <font color="#ff40ff"><strong>1</strong></font>;<br>        *current_char -= <font color="#ff40ff"><strong>1</strong></font>;<br>        <font color="#ffff00"><strong>return</strong></font>;<br>    }<br><br>    <font color="#ffff00"><strong>if</strong></font>(!strncmp(*current_char, this-&gt;match_str, this-&gt;n_match_str) &amp;&amp;<br>            (*current_state != accepting_state)) {<br>        *current_char += this-&gt;n_match_str - <font color="#ff40ff"><strong>1</strong></font>;<br>        *current_state += <font color="#ff40ff"><strong>1</strong></font>;<br>    }<br>}<br><br><font color="#00ffff"><strong>// state for *</strong></font><br><font color="#00ff00"><strong>void</strong></font> op_asterisk(<font color="#00ff00"><strong>struct</strong></font> state *this, <font color="#00ff00"><strong>int</strong></font> *current_state,<br>        <font color="#00ff00"><strong>const</strong></font> <font color="#00ff00"><strong>char</strong></font> **current_char)<br>{<br>    <font color="#ffff00"><strong>if</strong></font> (<font color="#ff40ff"><strong>NULL</strong></font> == this-&gt;word)<br>        this-&gt;word = *current_char;<br><br>    <font color="#ffff00"><strong>if</strong></font>(!strncmp(*current_char, this-&gt;match_str, this-&gt;n_match_str) &amp;&amp;<br>            (*current_state != accepting_state)) {<br>        *current_char += this-&gt;n_match_str - <font color="#ff40ff"><strong>1</strong></font>;<br>        *current_state += <font color="#ff40ff"><strong>1</strong></font>;<br>    }<br>    <font color="#ffff00"><strong>else</strong></font> {<br>        this-&gt;n_word++;<br>    }<br>}<br><br><font color="#00ffff"><strong>// state for ?</strong></font><br><font color="#00ff00"><strong>void</strong></font> op_qusetion_mark(<font color="#00ff00"><strong>struct</strong></font> state *this, <font color="#00ff00"><strong>int</strong></font> *current_state,<br>        <font color="#00ff00"><strong>const</strong></font> <font color="#00ff00"><strong>char</strong></font> **current_char)<br>{<br>    <font color="#00ff00"><strong>struct</strong></font> state *pre;<br><br>    <font color="#ffff00"><strong>if</strong></font> (<font color="#ff40ff"><strong>NULL</strong></font> == this-&gt;word)<br>        this-&gt;word = *current_char;<br><br>    <font color="#ffff00"><strong>if</strong></font>(!strncmp(*current_char, this-&gt;match_str, this-&gt;n_match_str) &amp;&amp;<br>            (this-&gt;question_mark_flag == this-&gt;n_word) &amp;&amp;<br>                (*current_state != accepting_state)) {<br>        *current_char += this-&gt;n_match_str - <font color="#ff40ff"><strong>1</strong></font>;<br>        *current_state += <font color="#ff40ff"><strong>1</strong></font>;<br>    }<br>    <font color="#ffff00"><strong>else</strong></font> <font color="#ffff00"><strong>if</strong></font>(this-&gt;question_mark_flag != this-&gt;n_word) {<br>        this-&gt;n_word++;<br>    }<br>    <font color="#ffff00"><strong>else</strong></font> {<br>        <font color="#00ffff"><strong>// back to previous state</strong></font><br>        *current_state -= <font color="#ff40ff"><strong>1</strong></font>;<br>        pre = this - <font color="#ff40ff"><strong>1</strong></font>;<br>        pre-&gt;n_word += pre-&gt;n_match_str + this-&gt;n_word + <font color="#ff40ff"><strong>1</strong></font>;<br><br>        <font color="#00ffff"><strong>// reset current state</strong></font><br>        this-&gt;word = <font color="#ff40ff"><strong>NULL</strong></font>;<br>        this-&gt;n_word = <font color="#ff40ff"><strong>0</strong></font>;<br>    }<br>}<br><br><font color="#00ff00"><strong>void</strong></font> init_state(<font color="#00ff00"><strong>struct</strong></font> state *st, <font color="#00ff00"><strong>int</strong></font> *idx, <font color="#00ff00"><strong>int</strong></font> *n_str, <font color="#00ff00"><strong>const</strong></font> <font color="#00ff00"><strong>char</strong></font> *str_pos)<br>{<br>    st[*idx].match_str = (<font color="#ff40ff"><strong>0</strong></font> == *n_str) ? <font color="#ff40ff"><strong>NULL</strong></font> : str_pos;<br>    st[*idx].n_match_str = *n_str;<br>    (*idx)++;<br>    *n_str = <font color="#ff40ff"><strong>0</strong></font>;<br>}<br><br><font color="#00ff00"><strong>void</strong></font> init_dfa(<font color="#00ff00"><strong>struct</strong></font> state *st, <font color="#00ff00"><strong>const</strong></font> <font color="#00ff00"><strong>char</strong></font> *translationEntry)<br>{<br>    <font color="#00ff00"><strong>const</strong></font> <font color="#00ff00"><strong>char</strong></font> *ch = translationEntry;<br>    <font color="#00ff00"><strong>int</strong></font> idx = <font color="#ff40ff"><strong>0</strong></font>;        <font color="#00ffff"><strong>// state array index</strong></font><br>    <font color="#00ff00"><strong>int</strong></font> i = <font color="#ff40ff"><strong>0</strong></font>;<br>    <font color="#00ff00"><strong>int</strong></font> counter = <font color="#ff40ff"><strong>0</strong></font>;<br><br>    ch++;   <font color="#00ffff"><strong>// pass by the first character /</strong></font><br>    <font color="#ffff00"><strong>while</strong></font>(<font color="#ff40ff"><strong>/</strong></font> != *ch) {<br>        <font color="#ffff00"><strong>if</strong></font>(<font color="#ff40ff"><strong>*</strong></font> == *ch) {<br>            init_state(st, &amp;idx, &amp;i, ch - i);<br>            st[idx].op = op_asterisk;<br>        }<br>        <font color="#ffff00"><strong>else</strong></font> <font color="#ffff00"><strong>if</strong></font>(<font color="#ff40ff"><strong>?</strong></font> == *ch) {<br>                counter++;<br>        }<br>        <font color="#ffff00"><strong>else</strong></font> {<br>            <font color="#ffff00"><strong>if</strong></font>(counter &gt; <font color="#ff40ff"><strong>0</strong></font>) {<br>                init_state(st, &amp;idx, &amp;i, ch - i - counter);<br>                st[idx].op = op_qusetion_mark;<br>                st[idx].question_mark_flag = counter;<br>                counter = <font color="#ff40ff"><strong>0</strong></font>;<br>            }<br>            i++;<br>        }<br>        ch++;<br>    }<br><br>    <font color="#ffff00"><strong>if</strong></font>(counter &gt; <font color="#ff40ff"><strong>0</strong></font>) {<br>        init_state(st, &amp;idx, &amp;i, ch - i - counter);<br>        st[idx].op = op_qusetion_mark;<br>        st[idx].question_mark_flag = counter;<br>    }<br><br>    <font color="#00ffff"><strong>// accepting_state is the last state</strong></font><br>    accepting_state = idx;<br>    <font color="#00ffff"><strong>// st[0] is the start state</strong></font><br>    st[<font color="#ff40ff"><strong>0</strong></font>].op = op_start;<br>    <font color="#00ffff"><strong>// match pattern string for the accepting_state</strong></font><br>    st[accepting_state].match_str = (<font color="#ff40ff"><strong>0</strong></font> == i) ? <font color="#ff40ff"><strong>NULL</strong></font> : ch - i;<br>    st[accepting_state].n_match_str = i;<br>    <font color="#00ffff"><strong>// output format string</strong></font><br>    output_fmt = strndup(ch + <font color="#ff40ff"><strong>1</strong></font>,<br>            strlen(translationEntry) - (ch - translationEntry + <font color="#ff40ff"><strong>1</strong></font>) - <font color="#ff40ff"><strong>1</strong></font>);<br>}<br><br><font color="#00ff00"><strong>void</strong></font> output_result(<font color="#00ff00"><strong>struct</strong></font> state *st, <font color="#00ff00"><strong>char</strong></font> *outputString)<br>{<br>    <font color="#00ff00"><strong>int</strong></font> i = <font color="#ff40ff"><strong>0</strong></font>, j;<br>    <font color="#00ff00"><strong>const</strong></font> <font color="#00ff00"><strong>char</strong></font> *cp = output_fmt;<br>    <font color="#00ff00"><strong>int</strong></font> is_matched = FALSE;<br><br>    <font color="#ffff00"><strong>while</strong></font>( != *cp) {<br>        <font color="#ffff00"><strong>if</strong></font>(TRUE == is_matched) {<br>            j = atoi(cp);<br>            strncpy(outputString + i, st[j].word, st[j].n_word);<br>            i += st[j].n_word;<br>            is_matched = FALSE;<br>        }<br>        <font color="#ffff00"><strong>else</strong></font> <font color="#ffff00"><strong>if</strong></font>(<font color="#ff40ff"><strong>%</strong></font> == *cp) {<br>            is_matched = TRUE;<br>        }<br>        <font color="#ffff00"><strong>else</strong></font><br>            *(outputString + i++) = *cp;<br><br>        cp++;<br>    }<br>}<br><br><font color="#00ff00"><strong>int</strong></font> matchAndTranslate(<font color="#00ff00"><strong>const</strong></font> <font color="#00ff00"><strong>char</strong></font>* inputString, <font color="#00ff00"><strong>const</strong></font> <font color="#00ff00"><strong>char</strong></font>* translationEntry,<br>        <font color="#00ff00"><strong>char</strong></font>* outputString)<br>{<br>    <font color="#00ff00"><strong>struct</strong></font> state st[<font color="#ff40ff"><strong>8</strong></font>];<br>    <font color="#00ff00"><strong>const</strong></font> <font color="#00ff00"><strong>char</strong></font> *cp = inputString;<br>    <font color="#00ff00"><strong>int</strong></font> current_state = <font color="#ff40ff"><strong>0</strong></font>;<br><br>    bzero(st, <font color="#ffff00"><strong>sizeof</strong></font>(st));<br>    init_dfa(st, translationEntry);<br><br>    <font color="#ffff00"><strong>while</strong></font>(*cp != ) {<br>        st[current_state].op(&amp;st[current_state], &amp;current_state, &amp;cp);<br>        cp++;<br>    }<br><br>    <font color="#ffff00"><strong>if</strong></font> (current_state != accepting_state) {<br>        free(output_fmt);<br>        <font color="#ffff00"><strong>return</strong></font> FALSE;<br>    }<br>    <font color="#ffff00"><strong>else</strong></font> {<br>        output_result(st, outputString);<br>        free(output_fmt);<br>        <font color="#ffff00"><strong>return</strong></font> TRUE;<br>    }<br>}<br><br><font color="#00ff00"><strong>int</strong></font> main()<br>{<br>    <font color="#00ff00"><strong>char</strong></font> *in_str[] = {<br>        <font color="#ff40ff"><strong>&quot;AAB1CDAB12CD081112AB3CD_OUT&quot;</strong></font>,<br>        <font color="#ff40ff"><strong>&quot;AAB23CD03022002AB3CD3081112_OUT&quot;</strong></font>,<br>        <font color="#ff40ff"><strong>&quot;2003A02A08AB3CD_OUT&quot;</strong></font>,<br>        <font color="#ff40ff"><strong>&quot;2003A02A08AB34CD88AB3CD99_ERR&quot;</strong></font>,<br>        <font color="#ff40ff"><strong>&quot;2003A02A08AB37CD88AB3C992_ERR&quot;</strong></font><br>    };<br><br>    <font color="#00ff00"><strong>char</strong></font> *pattern[] = {<br>        <font color="#ff40ff"><strong>&quot;/*A*AB?CD*_OU?/MATCH_[%1]_[%2]_[%3]_[%4]_[%5]/&quot;</strong></font>,<br>        <font color="#ff40ff"><strong>&quot;/*A*AB?CD*_*/MATCH_[%1]_[%2]_[%3]_[%4]_[%5]/&quot;</strong></font>,<br>    };<br>    <font color="#00ff00"><strong>char</strong></font> out_str[<font color="#ff40ff"><strong>1024</strong></font>];<br>    <font color="#00ff00"><strong>int</strong></font> i,j;<br>    <font color="#00ff00"><strong>int</strong></font> ret;<br><br>    <font color="#ffff00"><strong>for</strong></font> (j = <font color="#ff40ff"><strong>0</strong></font>; j &lt; <font color="#ff40ff"><strong>2</strong></font>; j++) {<br>        printf(<font color="#ff40ff"><strong>&quot;pattern: </strong></font><font color="#ff6060"><strong>%s</strong></font><font color="#ff6060"><strong>\n</strong></font><font color="#ff40ff"><strong>&quot;</strong></font>, pattern[j]);<br>        <font color="#ffff00"><strong>for</strong></font>(i = <font color="#ff40ff"><strong>0</strong></font>; i &lt; <font color="#ff40ff"><strong>5</strong></font>; i++) {<br>            bzero(out_str, <font color="#ffff00"><strong>sizeof</strong></font>(out_str));<br>            ret = matchAndTranslate(in_str[i], pattern[j], out_str);<br>            <font color="#ffff00"><strong>if</strong></font>(FALSE == ret)<br>                printf(<font color="#ff40ff"><strong>&quot;false, <undefined></undefined></strong></font><font color="#ff6060"><strong>\n</strong></font><font color="#ff40ff"><strong>&quot;</strong></font>);<br>            <font color="#ffff00"><strong>else</strong></font><br>                printf(<font color="#ff40ff"><strong>&quot;true, </strong></font><font color="#ff6060"><strong>%s</strong></font><font color="#ff6060"><strong>\n</strong></font><font color="#ff40ff"><strong>&quot;</strong></font>, out_str);<br>        }<br>        printf(<font color="#ff40ff"><strong>&quot;</strong></font><font color="#ff6060"><strong>\n</strong></font><font color="#ff40ff"><strong>&quot;</strong></font>);<br>    }<br>}</pre></div></body></html>