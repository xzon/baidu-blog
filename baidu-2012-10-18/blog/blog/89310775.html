<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>软件设计精要与模式-hxzon爱读书</title></head><body><h1>软件设计精要与模式-hxzon爱读书</h1><div><p><a href="http://book.csdn.net/bookfiles/350"><font color="#336699">软件设计精要与模式-</font></a>hxzon爱读书</p>
<p align="center">第1篇 设 计 之要</p>
<p class="MsoToc1">第1章 设计之道<sup>...... </sup>2</p>
<p class="MsoToc2">1.1 计划的设计与演进的设计<sup>...... </sup>2</p>
<p class="MsoToc2">1.2 架构设计的标准<sup>...... </sup>4</p>
<p class="MsoToc2">1.3 过度设计，还是简单设计<sup>...... </sup>6</p>
<p class="MsoToc2">1.4 需要设计模式吗<sup>...... </sup>8</p>
<p class="MsoToc2">1.5 重构是必然的<sup>...... </sup>9</p>
<p class="MsoToc2">1.6 UML重要吗<sup>...... </sup>10</p>
<p class="MsoToc2">1.7 测试驱动开发<sup>...... </sup>11</p>
<p class="MsoToc1">第2章 封装变化<sup>...... </sup>13</p>
<p class="MsoToc2">2.1 设计模式之鹄的<sup>...... </sup>13</p>
<p class="MsoToc2">2.2 如何封装变化<sup>...... </sup>14</p>
<p class="MsoToc3">2.2.1 封装用户请求的变化<sup>..... </sup>14</p>
<p class="MsoToc3">2.2.2 封装对象创建的变化<sup>..... </sup>17</p>
<p class="MsoToc3">2.2.3 封装算法实现的变化<sup>..... </sup>21</p>
<p class="MsoToc2">2.3 依赖注入<sup>...... </sup>26</p>
<p class="MsoToc1">第3章 体验重构<sup>...... </sup>28</p>
<p class="MsoToc2">3.1 一个阶乘容器<sup>...... </sup>29</p>
<p class="MsoToc2">3.2 代码的坏味道<sup>...... </sup>30</p>
<p class="MsoToc2">3.3 需求发生变化<sup>...... </sup>31</p>
<p class="MsoToc2">3.4 运用重构利器<sup>...... </sup>32</p>
<p class="MsoToc2">3.5 引入设计模式<sup>...... </sup>35</p>
<p class="MsoToc1">第4章 测试驱动开发实践<sup>...... </sup>39</p>
<p class="MsoToc2">4.1 发现价值与生产价值<sup>...... </sup>40</p>
<p class="MsoToc2">4.2 在测试驱动开发过程中运用面向对象编程思想<sup>...... </sup>44</p>
<p class="MsoToc2">4.3 适时小结<sup>...... </sup>50</p>
<p class="MsoToc2">4.4 收获价值<sup>...... </sup>50</p>
<p class="MsoToc2">4.5 无上之力<sup>...... </sup>51</p>
<p class="MsoToc1">第5章 设计，由你掌握<sup>...... </sup>53</p>
<p class="MsoToc2">5.1 从需求开始<sup>...... </sup>54</p>
<p class="MsoToc2">5.2 需求改变了<sup>...... </sup>56</p>
<p class="MsoToc2">5.3 如果不熟悉设计模式<sup>...... </sup>56</p>
<p class="MsoToc2">5.4 山穷水尽疑无路<sup>...... </sup>60</p>
<p class="MsoToc2">5.5 柳暗花明又一村<sup>...... </sup>62</p>
<p class="MsoToc2">5.6 尽善尽美的结局<sup>...... </sup>69</p>
<p style="text-align: center; text-indent: 0cm; margin: 12pt 0cm 6pt" class="MsoNormal" align="center">第2篇 .NET Framework与设计模式</p>
<p class="MsoToc1">第6章 Factory Method模式<sup>...... </sup>74</p>
<p class="MsoToc2">6.1 &ldquo;嫁祸江东&rdquo;之计<sup>...... </sup>74</p>
<p class="MsoToc2">6.2 WebRequest对象的创建<sup>...... </sup>78</p>
<p class="MsoToc2">6.3 具体对象创建的彻底解耦<sup>...... </sup>80</p>
<p class="MsoToc1">第7章 Composite模式<sup>...... </sup>89</p>
<p class="MsoToc2">7.1 一个字处理软件的实例<sup>...... </sup>89</p>
<p class="MsoToc2">7.2 .NET Framework中的控件<sup>...... </sup>95</p>
<p class="MsoToc2">7.3 &ldquo;复合方式&rdquo;的Composite模式<sup>...... </sup>98</p>
<p class="MsoToc1">第8章 Decorator模式<sup>...... </sup>107</p>
<p class="MsoToc2">8.1 一步一步走向Decorator模式<sup>...... </sup>107</p>
<p class="MsoToc2">8.2 .NET Framework中流的处理<sup>...... </sup>117</p>
<p class="MsoToc1">第9章 Iterator模式<sup>...... </sup>122</p>
<p class="MsoToc2">9.1 学会分辨对象的职责<sup>...... </sup>122</p>
<p class="MsoToc2">9.2 Iterator模式大观园<sup>...... </sup>127</p>
<p class="MsoToc2">9.3 Iterator模式在.NET Framework中的实现<sup>...... </sup>128</p>
<p class="MsoToc2">9.4 透晓foreach语句的实质<sup>...... </sup>132</p>
<p class="MsoToc1">第10章 Strategy模式<sup>...... </sup>136</p>
<p class="MsoToc2">10.1 一个税务系统实例<sup>...... </sup>136</p>
<p class="MsoToc2">10.2 .NET Framework中的Provider对象<sup>...... </sup>138</p>
<p class="MsoToc2">10.3 .NET Framework中的配置节管理<sup>...... </sup>142</p>
<p style="text-align: center; text-indent: 0cm; margin: 18pt 0cm 9.6pt" class="MsoNormal" align="center">第3篇 媒体播放器的设计之旅</p>
<p class="MsoToc1">第11章 面向对象设计与Factory Method模式<sup>...... </sup>146</p>
<p class="MsoToc2">11.1 拙劣的设计意味着噩梦的产生<sup>...... </sup>146</p>
<p class="MsoToc2">11.2 走向面向对象设计之路<sup>...... </sup>148</p>
<p class="MsoToc2">11.3 接口分离<sup>...... </sup>153</p>
<p class="MsoToc2">11.4 引入Factory Method模式<sup>...... </sup>157</p>
<p class="MsoToc2">11.5 飞翔的翅膀<sup>...... </sup>161</p>
<p class="MsoToc1">第12章 探讨Adapter模式<sup>...... </sup>164</p>
<p class="MsoToc2">12.1 设计走向死胡同<sup>...... </sup>164</p>
<p class="MsoToc2">12.2 引入Adapter模式<sup>...... </sup>165</p>
<p class="MsoToc2">12.3 类的Adapter模式<sup>...... </sup>165</p>
<p class="MsoToc2">12.4 对象的Adapter模式<sup>...... </sup>169</p>
<p class="MsoToc1">第13章 从Adapter模式到Decorator模式<sup>...... </sup>176</p>
<p class="MsoToc2">13.1 考察对象的Adapter模式<sup>...... </sup>176</p>
<p class="MsoToc2">13.2 引入Decorator模式<sup>...... </sup>181</p>
<p class="MsoToc2">13.3 正宗的Decorator模式<sup>...... </sup>184</p>
<p class="MsoToc1">第14章 Visitor模式探索<sup>...... </sup>188</p>
<p class="MsoToc2">14.1 Visitor模式是否可行<sup>...... </sup>188</p>
<p class="MsoToc2">14.2 实现Visitor模式<sup>...... </sup>189</p>
<p class="MsoToc2">14.3 改进后的Visitor模式<sup>...... </sup>195</p>
<p class="MsoToc2">14.4 合理运用Visitor模式<sup>...... </sup>200</p>
<p class="MsoToc1">第15章 再谈Adapter模式<sup>...... </sup>202</p>
<p class="MsoToc2">15.1 新的应用场景<sup>...... </sup>202</p>
<p class="MsoToc2">15.2 &ldquo;狼&rdquo;与&ldquo;羊&rdquo;的关系<sup>...... </sup>203</p>
<p class="MsoToc2">15.3 引入Adapter模式<sup>...... </sup>206</p>
<p style="text-align: center; text-indent: 0cm; margin: 18pt 0cm 9.6pt" class="MsoNormal" align="center">第4篇 设计模式应用实践</p>
<p class="MsoToc1">第16章 Abstract Factory模式应用实践<sup>...... </sup>214</p>
<p class="MsoToc2">16.1 需求分析&mdash;&mdash;报表组件<sup>...... </sup>214</p>
<p class="MsoToc2">16.2 糟糕的设计<sup>...... </sup>215</p>
<p class="MsoToc2">16.3 引入Abstract Factory模式<sup>...... </sup>217</p>
<p class="MsoToc2">16.4 工厂对象的使用<sup>...... </sup>220</p>
<p class="MsoToc2">16.5 引入Adapter模式扩展Abstract Factory结构<sup>...... </sup>222</p>
<p class="MsoToc2">16.6 接口还是抽象类<sup>...... </sup>223</p>
<p class="MsoToc1">第17章 Builder模式应用实践<sup>...... </sup>227</p>
<p class="MsoToc2">17.1 需求分析&mdash;&mdash;装配设备对象<sup>...... </sup>227</p>
<p class="MsoToc2">17.2 糟糕的设计<sup>...... </sup>230</p>
<p class="MsoToc2">17.3 引入Builder模式<sup>...... </sup>233</p>
<p class="MsoToc2">17.4 从容应对扩展<sup>...... </sup>237</p>
<p class="MsoToc1">第18章 Command模式应用实践<sup>...... </sup>239</p>
<p class="MsoToc2">18.1 需求分析&mdash;&mdash;安装向导<sup>...... </sup>239</p>
<p class="MsoToc2">18.2 糟糕的设计<sup>...... </sup>240</p>
<p class="MsoToc2">18.3 引入Command模式<sup>...... </sup>243</p>
<p class="MsoToc2">18.4 进一步完善<sup>...... </sup>246</p>
<p class="MsoToc1">第19章 Chain Of Responsibility模式应用实践<sup>...... </sup>251</p>
<p class="MsoToc2">19.1 需求分析&mdash;&mdash;应用服务管理器<sup>...... </sup>252</p>
<p class="MsoToc2">19.2 简单有效的设计<sup>...... </sup>254</p>
<p class="MsoToc2">19.3 利用抽象引入Template Method模式<sup>...... </sup>258</p>
<p class="MsoToc2">19.4 方向错误了吗<sup>...... </sup>262</p>
<p class="MsoToc2">19.5 Chain Of Responsibility模式<sup>...... </sup>264</p>
<p class="MsoToc1">第 20章 Observer模式应用实践<sup>...... </sup>276</p>
<p class="MsoToc2">20.1 需求分析&mdash;&mdash;监控设备状态<sup>...... </sup>277</p>
<p class="MsoToc2">20.2 引入Observer模式<sup>...... </sup>278</p>
<p class="MsoToc2">20.3 利用事件与委托改进Observer模式<sup>...... </sup>282</p>
<p class="MsoToc1">第 21章 Proxy模式应用实践<sup>...... </sup>287</p>
<p class="MsoToc2">21.1 需求分析&mdash;&mdash;设备控件显示<sup>...... </sup>287</p>
<p class="MsoToc2">21.2 引入Proxy模式<sup>...... </sup>288</p>
<p class="MsoToc2">21.3 完善设计<sup>...... </sup>293</p>
<p class="MsoToc1">第 22章 复合的设计模式应用实践<sup>...... </sup>299</p>
<p class="MsoToc2">22.1 需求分析<sup>...... </sup>299</p>
<p class="MsoToc2">22.2 糟糕的设计<sup>...... </sup>300</p>
<p class="MsoToc2">22.3 面向对象的设计思想<sup>...... </sup>302</p>
<p class="MsoToc2">22.4 引入Strategy模式<sup>...... </sup>303</p>
<p class="MsoToc2">22.5 需求发生变化<sup>...... </sup>307</p>
<p class="MsoToc2">22.6 引入Template Method模式<sup>...... </sup>307</p>
<p class="MsoToc2">22.7 合理的设计才是最好的设计<sup>...... </sup>311</p>
<p class="MsoToc2">22.8 引入Bridge模式<sup>...... </sup>312</p>
<p class="MsoToc2">22.9 接口分离<sup>...... </sup>319</p>
<p class="MsoToc2">22.10 引入Abstract Factory模式<sup>...... </sup>323</p>
<p style="text-align: center; text-indent: 0cm; margin: 18pt 0cm 12pt" class="MsoNormal" align="center">第5篇 .NET体系架构设计</p>
<p class="MsoToc1">第 23章 软件体系架构设计<sup>...... </sup>332</p>
<p class="MsoToc2">23.1 分层式架构设计<sup>...... </sup>333</p>
<p class="MsoToc2">23.2 分层式架构设计的优劣<sup>...... </sup>334</p>
<p class="MsoToc2">23.3 PetShop架构设计的版本演化<sup>...... </sup>335</p>
<p class="MsoToc2">23.4 PetShop 4.0的系统架构设计<sup>...... </sup>338</p>
<p class="MsoToc1">第 24章 数据访问层设计<sup>...... </sup>342</p>
<p style="line-height: 16.8pt" class="MsoToc2">24.1 数据库样式<sup>...... </sup>342</p>
<p style="line-height: 16.8pt" class="MsoToc2">24.2 数据库对象<sup>...... </sup>344</p>
<p style="line-height: 16.8pt" class="MsoToc2">24.3 SQL语句之瘤<sup>...... </sup>348</p>
<p style="line-height: 16.8pt" class="MsoToc2">24.4 运用ORM的思想<sup>...... </sup>350</p>
<p style="line-height: 16.8pt" class="MsoToc2">24.5 事务的处理<sup>...... </sup>352</p>
<p style="line-height: 16.8pt" class="MsoToc2">24.6 具有简单工厂特质的Abstract Factory模式<sup>...... </sup>355</p>
<p style="line-height: 16.8pt" class="MsoToc1">第 25章 消息处理<sup>...... </sup>359</p>
<p style="line-height: 16.8pt" class="MsoToc2">25.1 MSMQ的实现<sup>...... </sup>359</p>
<p style="line-height: 16.8pt" class="MsoToc3">25.1.1 消息处理模块的组成<sup>..... </sup>359</p>
<p style="line-height: 16.8pt" class="MsoToc3">25.1.2 消息接口<sup>..... </sup>360</p>
<p style="line-height: 16.8pt" class="MsoToc3">25.1.3 消息接口的实现<sup>..... </sup>361</p>
<p style="line-height: 16.8pt" class="MsoToc3">25.1.4 消息工厂<sup>..... </sup>363</p>
<p style="line-height: 16.8pt" class="MsoToc3">25.1.5 后台处理应用程序<sup>..... </sup>365</p>
<p style="line-height: 16.8pt" class="MsoToc3">25.1.6 引入Strategy模式<sup>..... </sup>367</p>
<p style="line-height: 16.8pt" class="MsoToc2">25.2 分布式处理<sup>...... </sup>368</p>
<p style="line-height: 16.8pt" class="MsoToc1">第 26章 ASP.NET缓存<sup>...... </sup>370</p>
<p style="line-height: 16.8pt" class="MsoToc2">26.1 ASP.NET缓存概述<sup>...... </sup>370</p>
<p style="line-height: 16.8pt" class="MsoToc2">26.2 SqlCacheDependency特性<sup>...... </sup>373</p>
<p style="line-height: 16.8pt" class="MsoToc3">26.2.1 利用aspnet_regsql工具<sup>..... </sup>373</p>
<p style="line-height: 16.8pt" class="MsoToc3">26.2.2 利用SqlCacheDependencyAdmin类<sup>..... </sup>376</p>
<p style="line-height: 16.8pt" class="MsoToc2">26.3 ASP.NET缓存在PetShop 4.0中的实现<sup>...... </sup>377</p>
<p style="line-height: 16.8pt" class="MsoToc3">26.3.1 CacheDependency接口<sup>..... </sup>377</p>
<p style="line-height: 16.8pt" class="MsoToc3">26.3.2 CacheDependency实现<sup>..... </sup>378</p>
<p style="line-height: 16.8pt" class="MsoToc3">26.3.3 CacheDependency工厂<sup>..... </sup>379</p>
<p style="line-height: 16.8pt" class="MsoToc3">26.3.4 引入Facade模式<sup>..... </sup>381</p>
<p style="line-height: 16.8pt" class="MsoToc3">26.3.5 引入Proxy模式<sup>..... </sup>384</p>
<p style="line-height: 16.8pt" class="MsoToc1">第 27章 业务逻辑层设计<sup>...... </sup>387</p>
<p style="line-height: 16.8pt" class="MsoToc2">27.1 与领域专家合作<sup>...... </sup>388</p>
<p class="MsoToc2">27.2 业务逻辑层的模式应用<sup>...... </sup>391</p>
<p class="MsoToc2">27.3 PetShop的业务逻辑层设计<sup>...... </sup>391</p>
<p class="MsoToc2">27.4 与数据访问层的通信<sup>...... </sup>395</p>
<p class="MsoToc2">27.5 面向接口设计<sup>...... </sup>396</p>
<p class="MsoToc1">第 28章 表示层设计<sup>...... </sup>400</p>
<p class="MsoToc2">28.1 MVC模式<sup>...... </sup>400</p>
<p class="MsoToc2">28.2 Page Controller模式的应用<sup>...... </sup>402</p>
<p class="MsoToc2">28.3 ASP.NET控件<sup>...... </sup>405</p>
<p class="MsoToc2">28.4 ASP.NET 2.0新特性<sup>...... </sup>411</p>
<p class="MsoToc3">28.4.1 Profile特性<sup>..... </sup>412</p>
<p class="MsoToc3">28.4.2 Membership特性<sup>..... </sup>416</p>
<p class="MsoToc3">28.4.3 ASP.NET登录控件<sup>..... </sup>423</p>
<p class="MsoToc3">28.4.4 Master Page特性<sup>..... </sup>424</p>
<p class="MsoToc1">参考文献<sup>...... </sup>429</p></div></body></html>