<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>形象说明UML中的包含与扩展的区别</title></head><body><h1>形象说明UML中的包含与扩展的区别</h1><div><p>形象说明UML中的包含与扩展的区别</p>
<div>举个网上流行的例子:比如你从1楼要去5楼,那爬楼梯是必须的,则爬楼梯是&quot;包含关系&quot;,如果你上到2楼时,顺便去了趟卫生间,则去卫生间是&quot;扩展关系&quot;。</div>
<div> </div>
<div>另外转载一篇网上摘录的关于UML中关联，泛化和依赖关系比较说明。但是还有点不是很清楚，关联，泛化和依赖还有包含、扩展是一个分类体系中的吗？欢迎大家解惑。</div>
<div>
<p><font face="Arial">类与类之间的关系对于理解面向对象具有很重要的作用，以前在面试的时候也经常被问到这个问题，在这里我就介绍一下。<br>
类与类之间存在以下关系:<br>
<strong><font color="#3366ff">(1)泛化(Generalization)<br>
(2)关联(Association)<br>
(3)依赖(Dependency)<br>
(4)聚合(Aggregation)</font></strong></font></p>
<p><font face="Arial"><strong>UML图与应用代码例子:</strong><br>
<strong><font color="#ff9900" size="4"><font color="#3366ff">1.泛化(Generalization)</font><br>
</font><font color="#339966" size="3">[泛化]</font><br>
</strong>表示类与类之间的继承关系，接口与接口之间的继承关系，或类对接口的实现关系。一般化的关系是从子类指向父类的，与继承或实现的方法相反。<br>
<font color="#339966" size="3"><strong>[具体表现]<br>
</strong></font><font color="#ff0000">父类</font> 父类实例＝new <font color="#ff0000">子类</font>()<br>
<strong><font color="#339966" size="3">[UML图](图1.1)<br>
</font><br>
</strong><font face="Arial"><font color="#339966"><strong>图1.1</strong></font> <strong>Animal类与Tiger类,Dog类的泛化关系<br>
</strong></font><br>
<strong><font color="#339966" size="3">[代码表现]</font><br>
<br>
</strong></font></p>
<div>
<div> </div>
<ol>
    <li><span><span>class</span><span><strong> Animal{} &nbsp;&nbsp;</strong></span></span><strong> </strong></li>
    <li><span>class</span><strong><span> Tiger </span><span>extends</span><span> Animal{} &nbsp;&nbsp;</span> </strong></li>
    <li><span>public</span><strong><span> </span><span>class</span><span> Test &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>{ &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>void</span><span> test() &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;  { &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Animal a=</span><span>new</span><span> Tiger(); &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;  } &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>}&nbsp;&nbsp;</span> </strong></li>
</ol>
</div>
<br>
<font face="Arial"><strong><font color="#3366ff" size="4">2.依赖(Dependency)</font><br>
</strong><font color="#339966" size="3"><strong>[依赖]<br>
</strong></font>对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。<br>
<font color="#339966" size="3"><strong>[具体表现]<br>
</strong></font>依赖关系表现在<font color="#ff0000">局部变量</font>，<font color="#ff0000">方法的参数</font>，以及对<font color="#ff0000">静态方法的调用</font><br>
<font color="#339966" size="3"><strong>[现实例子]<br>
</strong></font>比如说你要去拧螺丝，你是不是要借助(也就是依赖)螺丝刀(Screwdriver)来帮助你完成拧螺丝(screw)的工作<br>
<font color="#339966" size="3"><strong>[UML表现](图1.2)</strong></font><br>
<p align="left"><font face="Arial"><strong><font color="#339966">图1.2 </font>Person类与Screwdriver类的依赖关系</strong><br>
<font face="Arial"><font color="#339966" size="3"><strong><br>
[代码表现] </strong></font></font></font></p>
<div>
<div> </div>
<ol>
    <li><span><span>public</span><strong><span> </span><span>class</span><span> Person{ &nbsp;&nbsp;</span></strong></span><strong> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>/** 拧螺丝 */</span><span>&nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>void</span><span> screw(Screwdriver screwdriver){ &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  screwdriver.screw(); &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;  } &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>}&nbsp;&nbsp;</span> </strong></li>
</ol>
</div>
<br>
<font face="Arial"><strong><font color="#3366ff" size="4">3.关联(Association)</font><br>
</strong><font color="#339966" size="3"><strong>[关联]<br>
</strong></font>对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。<br>
<font color="#339966" size="3"><strong>[具体表现]<br>
</strong></font>关联关系是使用<font color="#ff0000">实例变量</font>来实现<br>
<font color="#339966" size="3"><strong>[现实例子]<br>
</strong></font>比如客户和订单，每个订单对应特定的客户，每个客户对应一些特定的订单；再例如公司和员工，每个公司对应一些特定的员工，每个员工对应一特定的公司<br>
<strong><font color="#339966" size="3">[UML图] (图1.3)<br>
</font><br>
<font face="Arial"><strong><font color="#339966">图1.3 </font></strong>公司和员工的关联关系</font></strong></font><br>
<font face="Arial"><strong><br>
<font color="#339966" size="3">[代码表现]</font></strong>
<div>
<div> </div>
<ol>
    <li><span><span>public</span><strong><span> </span><span>class</span><span> Company{ &nbsp;&nbsp;</span></strong></span><strong> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>private</span><span> Employee employee; &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> Employee getEmployee(){ &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>return</span><span> employee; &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;  } &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>void</span><span> setEmployee(Employee employee){ &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>this</span><span>.employee=employee; &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;  } &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>//公司运作 </span><span>&nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>void</span><span> run(){ &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  employee.startWorking(); &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;  } &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>}&nbsp;&nbsp;</span> </strong></li>
</ol>
</div>
</font></font><font face="Arial"><strong><font color="#3366ff" size="4">(4)聚合（Aggregation）</font><br>
<font color="#339966" size="3">[聚合]<br>
</font></strong>当对象A被加入到对象B中，成为对象B的组成部分时，对象B和对象A之间为聚集关系。聚合是关联关系的一种，是较强的关联关系，强调的是<font color="#ff0000">整体</font>与<font color="#ff0000">部分</font>之间的关系。<br>
<font color="#339966" size="3"><strong>[具体表现]<br>
</strong></font>与关联关系一样，聚合关系也是通过<font color="#ff0000">实例变量</font>来实现这样关系的。关联关系和聚合关系来语法上是没办法区分的，从<font color="#ff0000">语义</font>上才能<font color="#ff0000">更好的区分</font>两者的区别。<br>
<font color="#339966" size="3"><strong>[关联与聚合的区别]</strong></font><br>
(1)关联关系所涉及的两个对象是处在同一个层次上的。比如人和自行车就是一种关联关系，而不是聚合关系，因为人不是由自行车组成的。<br>
聚合关系涉及的两个对象处于不平等的层次上，一个代表整体，一个代表部分。比如电脑和它的显示器、键盘、主板以及内存就是聚集关系，因为主板是电脑的组成部分。<br>
(2) 对于具有聚集关系（尤其是强聚集关系）的两个对象，整体对象会制约它的组成对象的生命周期。部分类的对象不能单独存在，它的生命周期依赖于整体类的对象的 生命周期，当整体消失，部分也就随之消失。比如张三的电脑被偷了，那么电脑的所有组件也不存在了，除非张三事先把一些电脑的组件（比如硬盘和内存）拆了下 来。<br>
<font color="#339966" size="3"><strong>[UML图](图1.4)</strong></font><br>
<strong><br>
<font face="Arial"><strong><font color="#339966">图1.3 </font><font color="#000000">电脑和组件的聚合关系</font></strong></font><br>
<br>
<font face="Arial"><font color="#339966" size="3"><strong>[代码表现]</strong></font></font></strong>
<div>
<div> </div>
<ol>
    <li><span><span>public</span><strong><span> </span><span>class</span><span> Computer{ &nbsp;&nbsp;</span></strong></span><strong> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>private</span><span> CPU cpu; &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> CPU getCPU(){ &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>return</span><span> cpu; &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;  } &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>void</span><span> setCPU(CPU cpu){ &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>this</span><span>.cpu=cpu; &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;  } &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>//开启电脑 </span><span>&nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>void</span><span> start(){ &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>//cpu运作 </span><span>&nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  cpu.run(); &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>&nbsp;&nbsp;&nbsp;&nbsp;  } &nbsp;&nbsp;</span> </strong></li>
    <li><strong><span>}&nbsp;&nbsp;</span> </strong></li>
</ol>
</div>
</font></div></div></body></html>