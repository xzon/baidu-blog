<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>《Web Services概论》复习大纲-hxzon</title></head><body><h1>《Web Services概论》复习大纲-hxzon</h1><div><div>《Web Services概论》复习大纲-hxzon</div>
<div> </div>
<div>第一章 Web Services概述</div>
<div> </div>
<div>1、Web服务的基本概念（选择或填空）</div>
<div> </div>
<div>&#8226;是新一代的Web应用程序，它代表了组件技术和Web技术的结合；<br>
&#8226;是一类可通过开放的互联网协议访问的软件组件，具有黑匣子的功能，可以在不关心功能如何实现的情况下重用；<br>
&#8226;远程而透明地调用和集成世界任何一个角落的一个服务（可运行在不同平台上）；<br>
&#8226;被普遍认为是下一代分布式系统开发的模型。<br>
W3C定义：<br>
Web服务是一种通过URI标识的软件应用，其接口及绑定形式可以通过XML标准定义、描述和检索，并能通过XML消息及互联网协议完成与其他应用的直接交互。</div>
<div> </div>
<div>2、Web Service的特征（选择或填空）</div>
<div> </div>
<div>自描述、良好的封装性、松散耦合、使用标准协议规范、高度可互操作性、高度可集成能力、动态性</div>
<div> </div>
<div>3、Web Services模型（图1-3或ch1.ppt中的WS模型）（选择或填空）</div>
<div> </div>
<div>（1）理解Web Services模型的工作过程<br>
（2）三种角色及其职责：<br>
服务提供者（Service Provider）、服务请求者（Service Requestor）、服务注册中心（Service Registry）<br>
（3）三种操作：发布（Publish）、查找（Find）、绑定/调用（Bind/Invoke）</div>
<div> </div>
<div>4、Web Services协议栈（图1-3或ch1.ppt中的协议栈）<br>
 理解协议栈各协议层的作用与技术特点：HTTP等、SOAP、WSDL、UDDI（直接的UDDI发布和静态的UDDI发现）和WSFL</div>
<div> </div>
<div>5、Web 服务开发生命周期(p13)<br>
 构建、部署、运行、管理<br>
6、Web Services的发展阶段及其特征<br>
第一阶段 Simple Web Services <br>
第二阶段 EAI Web Services <br>
第三阶段 Business Web Services</div>
<div> </div>
<div>7、Web Service的适用场合<br>
跨防火墙的通信 、应用程序集成、B2B的集成 、软件和数据重用</div>
<div> </div>
<div>8、Web Service的分类</div>
<div> </div>
<div>Business-Oriented Web Service、Customer-Oriented Web Service、Device-Oriented Web Service、System-Oriented Web Service</div>
<div> </div>
<div>思考题：<br>
1、为什么说Web服务具有良好的封装性？<br>
2、如何理解Web服务的松散耦合特性，试举例说明。<br>
3、为什么说Web服务具有高度可互操作性？试举例加以简要说明。<br>
<font color="#ff0000">4、与目前流行的多层开发架构（如J2EE）相比，采用Web Services技术来实现企业计算有什么优缺点？（可综合PPT的Traditional C/S vs. Web Services，Web Application vs. Web Services和Web Service与EAI的特点来论述）</font></div>
<div> </div>
<div>第二章 XML基础</div>
<div> </div>
<div>1、XML的基本概念（选择或填空）</div>
<div> </div>
<div>1/ XML是 Extensible Markup Language (可扩展标记语言)的简称，是一种元语言(定义其他语言的系统 )<br>
2/ 1996年, W3C（World Wide Web Consortium，互联网联合组织）为了克服HTML的局限性, 在SGML的基础上创建XML<br>
3/ HTML是SGML的一个应用，XML是SGML的一个子集, 并且已经成为Internet上事实的数据交换标准<br>
4/ SGML是标准通用化标记语言（Standard Generalized Markup Language）的简称，是一种用标记（tag）来描述文档资料的国际标准通用语言</div>
<div> </div>
<div>2、XML的特点（选择或填空）<br>
 <br>
可扩展性、对文档内容具有自描述能力，支持智能代码和智能搜索、结构化数据表达能力、良好的通用数据格式，跨平台以及语言独立、强大的超链接功能、文档的表示形式多样化、降低了对服务端的要求</div>
<div> </div>
<div>3、XML1.0及其相关规范可以被分为两大部分:（了解，选择或填空）<br>
&#61550;1/ 核心层:<br>
&#61550;XML 1.0语法：包含文档结构，元素，属性，注释，实体等多个部分内容的规定<br>
&#61550;XML的描述和验证:&#61472;DTD (Document Type Definition,文档类型定义)和Schema(模式)<br>
&#61550;<font color="#ff0000">XML命名空间(Namespaces)<br>
</font>&#61550;2/ 应用程序支持层:<br>
&#61550;1）XML信息集合(XML Infoset)<br>
&#61550;2）XML定位与链接:<br>
&#61550;XML Base规范：设置XML文档的基本URI<br>
XPath (XML路径语言)<br>
&#61550;XPointer (XML指针语言)<br>
&#61550;XLink (XML链接语言)<br>
&#61550;XInclude (XML包含)<br>
&#61550;XFI(文档片断交换)<br>
XQuery (XML查询语言)<br>
3）XML转换:<br>
&#61550;CSS(Cascading Style Sheet层叠样式图)<br>
&#61550;XSL（eXtensible Style Language可扩展样式语言）：有一个子集为XSLT(用于转换的XSL)<br>
XSL-FO（Formated Object格式化对象）是一个XML词汇表</div>
<div> </div>
<div>4、XML文档逻辑结构</div>
<div> </div>
<div>&#61550;1/ 序言(Prolog,可选)<br>
&#61550;XML声明(XML版本声明、编码方式等通用信息)<br>
&#61550;DTD声明<br>
&#61550;2/ 主体(Body):<br>
&#61550;元素:其他元素、字符数据、字符引用、实体引用、字符数据段（CDATA）<br>
&#61550;命名空间声明，标记，属性<br>
&#61550;3/ 尾声(Epilog, 可出现在任何部分的其他可选内容)<br>
&#61550;注释（注释不能出现在XML声明之前）<br>
&#61550;处理指令（Processing Instruction）<br>
&#61550;紧跟元素树后面的空白：空格、回车符、换行符、制表符</div>
<div> </div>
<div>5、XML文档物理结构</div>
<div> </div>
<div>1/ 一个XML文档可能包含一个或多个存储单元。它们被称为实体(entity)。<br>
2/ 实体都具有内容，并且除了文档实体和外部DTD子集之外都用名字(name)进行标识。<br>
3/ 实体可分为外部实体和内部实体</div>
<div> </div>
<div>6、理解三种 XML 文档的含义<br>
无效文档（Invalid）、有效文档（Valid）、格式良好的文档（Well-Formed）</div>
<div> </div>
<div><font color="#ff0000">7、XML文档规则（重点掌握，主要出现在选择、填空和改错题，参考PPT的内容）</font></div>
<div> </div>
<div> 理解字符、声明、注释、根元素、元素不能重叠或嵌套、结束标记、元素内容（空元素）、元素区分大小写、属性、处理指令(PI)、CDATA段、命名空间</div>
<div> </div>
<div>8、XML文档的语法限制和语义限制<br>
&#61550;语法限制：格式良好（Well-formed）<br>
&#61550;语义限制：有效（Valid）</div>
<div> </div>
<div><font color="#ff0000">9、课堂的XML改错例子和作业XML（1）（重点，改错题或应用题）</font></div>
<div> </div>
<div><br>
第三章 XML Schema</div>
<div> </div>
<div>1、DTD的基本概念</div>
<div> </div>
<div>1/ 文档类型定义(Document Type Definition, DTD)起源于SGML中更复杂的DTD, 是一组能融合在XML数据中或者以单独的文档存在的声明,用于对XML文档进行描述和校验,以保证XML文档的有效性<br>
2/ DTD使用非XML语法的文法来定义一些规则,这些规则描述了XML的结构和语法,以及被允许出现的XML数据内容<br>
3/ 一个文档只能与一个DTD相关联</div>
<div> </div>
<div>2、XML Schema的基本概念</div>
<div> </div>
<div>1/ XML Schema是W3C的推荐标准，于2001年5月正式发布<br>
2/ XML Schema同DTD一样是负责定义和描述XML文档的结构和内容模式<br>
3/ 它可以定义XML文档中存在哪些元素和元素之间的关系，并且可以定义元素和属性的数据类型。<br>
4/ XML Schema本身是一个XML文档，它符合XML语法结构。可以用通用的XML解析器解析它；它使用 XML 名称空间而不是 DOCTYPE</div>
<div> </div>
<div>3、比较DTD与XML Schema，了解两者的特点（优缺点）</div>
<div> </div>
<div>4、模式文档和实例文档</div>
<div> </div>
<div>（1）模式文档是包含结构的文档，以.xsd作为后缀名；而实例文档是包含实际的 XML 数据的文档<br>
<font color="#ff0000">（2）通过名称空间联系模式文档和实例文档<br>
 1/ Schema文件中没有给出目标命名空间 （实例文档中通过xsi:noNamespaceSchemaLocation属性指定XML Schema文档的位置）<br>
 2/ Schema文件中给出目标命名空间 Schema文件中通过属性targetNamespace设置目标名称空间的值；<br>
 XML实例文件中通过属性xsi:schemaLocation指明XML Schema的位置<br>
</font>(3)模式文档只是一个 XML 文档，它的预定义的元素和属性描述另一个 XML 文档的结构<br>
1/ 模式文档由一个schema元素和一系列子元素组成，大多数子元素为element, complexType, 和simpleType，这些决定了在实例文档中的元素的表现方式和内容；<br>
2/通过出现在schema元素中的命名空间声明xmlns:xsd=&ldquo;http://www.w3.org/2001/XMLSchema&rdquo;，在模式文档中的每一个元素都有一个与XML Schema命名空间相联系的命名空间前缀&ldquo;xsd:&rdquo;。前缀&ldquo;xsd:&rdquo;被约定用于表示XML Schema命名空间，而不是模式文档作者自己的词汇表</div>
<div> </div>
<div><font color="#ff0000">6、模式文档元素定义（重点掌握，主要出现在改错和应用题，参考PPT的内容）</font></div>
<div> </div>
<div>（1）模式文档元素类型可以分为复合类型（&lt;xsd:complexType&gt;）和简单类型（&lt;xsd:simpleType&gt;）<br>
 复合类型:元素如果包含子元素或者是带有属性则被称为复合类型<br>
简单类型: 元素如果仅仅包含数字、字符串或者其他数据等，但不包含任何子元素则称为简单类型。<br>
属性值通常是简单类型，因为属性值不能包含任何结构</div>
<div> </div>
<div>（2）创建新的简单类型</div>
<div> </div>
<div><font color="#ff0000">内建简单类型、使用层面（facets）创建简单类型、有限制的值、枚举</font>、列表(list)、联合（Union）</div>
<div> </div>
<div>（3）复杂类型</div>
<div> </div>
<div><font color="#ff0000">使用匿名的 complexTypes、引用现存的元素、指定元素出现的次数（minOccurs 和maxOccurs）、指定元素的默认值（fixed和default）、属性的定义（匿名形式和有名形式）、指定属性约束和缺省值（使用&lt;xsd:attribute&gt;元素的use和value属性）、基于简单类型的复合类型（定义基于简单类型，但具有属性的复合类型）、</font>混合内容（在&lt;xsd:complexType&gt;元素中将mixed属性设置为&ldquo;true&rdquo;）、模式注释（&lt;xsd:annotation&gt;, &lt;xsd:documentation&gt;, &lt;xsd:appInfo&gt;三个元素用于为模式增加注释）、complexTypes中元素的次序（<font color="#ff0000">sequence、 choice、 all、</font> group和 attributeGroup）、<font color="#ff0000">匿名类型定义、&#61472;有名的类型定义、衍生类型（ extension和 restriction）、简单内容和复杂内容（ simpleContent和 complexContent）</font></div>
<div> </div>
<div><font color="#ff0000">（4）理解局部验证</font></div>
<div> </div>
<div>7、了解XML Schema文档的重用</div>
<div> </div>
<div>（1）XML Schema组成细节中存在着重用的机制<br>
（2）XML Schema的整个文档也可以进行重用<br>
包含（include）和导入（import）两种方式实现<br>
include : 两者的名称空间必须一致;<br>
import : import元素中导入的XML Schema的名称空间可以不一致。</div>
<div> </div>
<div>8、了解XML文档解析：DOM和SAX</div>
<div> </div>
<div>（1）两种基本的处理方式<br>
DOM：基于树结构的（Tree-based）<br>
SAX：基于事件的（Event-based）<br>
（2）比较DOM和SAX的优缺点</div>
<div> </div>
<div>9、了解XML文档转换：XSL和XSLT</div>
<div> </div>
<div>（1）如何把一个XML文件以某种可视形式表现出来<br>
&#61550;直接让浏览器或者阅读器支持<br>
&#61550;CSS + 脚本<br>
&#61550;转换为HTML: XPath + XSLT<br>
（2）XSL由XSL-FO (formatting objects)(格式化输出)和XSLT (结构转换)两种分支语言组成,前者主要用于页面格式定义,后者主要用于对XML文档进行转换<br>
（2）比较CSS和XSL的特点</div>
<div> </div>
<div><font color="#ff0000">10、作业XML（2）（重点，应用题）</font></div>
<div> </div>
<div>第四章 SOAP</div>
<div> </div>
<div>1、关于SOAP的基本概念</div>
<div> </div>
<div>1/ 简单对象访问协议 SOAP（Simple Object Access Protocol）是在松散的、分布的环境中使用XML交换结构化的和类型化的信息的一种简单协议。<br>
2/ SOAP本身并不定义任何应用语义，如编程模型或特定语义实现，它只定义了一种简单的以模块化的方式包装数据的机制。<br>
&#61550; 3/ SOAP没有定义任何底层的传输协议<br>
&#61550; 4/ SOAP的调用效率比较低<br>
HTTP不是有效率的通信协议<br>
XML需要额外的文件解析</div>
<div> </div>
<div>2、W3C对SOAP的定义</div>
<div> </div>
<div>&#61550;<font color="#ff0000">SOAP是一种轻量级协议</font>，用于在分散或分布的环境中交换结构化信息。<br>
&#61550;SOAP应用XML技术定义一种可扩展的消息框架，该框架提供了一种能够在各种底层协议进行消息交换的构造形式。<br>
&#61550;该框架已被设计成独立于任何特定的编程模型和其他特殊的实现语义。</div>
<div> </div>
<div>3、SOAP设计目标<br>
&#61550;简单性（Simplicity）<br>
&#61550;可扩展性（Extensibility）</div>
<div> </div>
<div><font color="#ff0000">4、SOAP由4部分组成：</font></div>
<div> </div>
<div>（1）SOAP封装（SOAP Envelope）：构造定义了一个整体的表示框架，可用于表示<br>
&#61550; （2）SOAP编码规则（SOAP Encoding Rules）：定义了一套编码机制用于交换应用程序定义的数据类型的实例<br>
（3）SOAP RPC表示（SOAP RPC Presentation）：定义了一个用于表示远程过程调用和响应的约定<br>
（4）SOAP绑定（SOAP Binding）：定义了一种使用底层传输协议来完成在节点间交换SOAP封装的约定。</div>
<div> </div>
<div>5、SOAP术语（选择或填空题）<br>
&#61550;SOAP绑定<br>
&#61550;SOAP节点<br>
&#61550;SOAP消息<br>
SOAP封装（SOAP Envelope）<br>
SOAP条目</div>
<div> </div>
<div>&#61550;消息发送者和接收者概念<br>
&#61550;SOAP发送者(SOAP sender)<br>
&#61550;SOAP接收者(SOAP receiver)<br>
&#61550;SOAP消息路径(SOAP message path)<br>
&#61550;初始SOAP发送者(Initial SOAP sender)<br>
&#61550;SOAP中介(SOAP intermediary)<br>
&#61550;最终SOAP接收者(Ultimate SOAP receiver)</div>
<div> </div>
<div>6、SOAP与XML的关系（了解，选择或填空题）</div>
<div> </div>
<div>（1）所有的SOAP消息都是使用XML格式来编码的<br>
SOAP应用程序在生成由SOAP定义的所有元素和属性的时候，应该包含恰当的SOAP命名空间。 <br>
SOAP消息不能够包含DTD，同时SOAP消息也不能够包含PI(Processing Instructions) <br>
（2）了解SOAP定义的命名空间<br>
1/ SOAP信封(envelope)的命名空间标识为 &quot;<a href="http://www.w3.org/2001/06/soap-envelope">http://www.w3.org/2001/06/soap-envelope</a>&quot; <br>
2/ SOAP的编码规则的命名空间标识为 <br>
&quot;<a href="http://www.w3.org/2001/06/soap-encoding">http://www.w3.org/2001/06/soap-encoding</a>&quot; <br>
&#61550; 3/ SOAP mustUnderstand fault的命名空间标识为 <br>
&quot;<a href="http://www.w3.org/2001/06/soap-faults">http://www.w3.org/2001/06/soap-faults</a>&quot; <br>
&#61550; 4/ SOAP upgrade的命名空间标识为 <br>
&quot;<a href="http://www.w3.org/2001/06/soap-upgrade">http://www.w3.org/2001/06/soap-upgrade</a>&quot;</div>
<div> </div>
<div><font color="#ff0000">7、SOAP消息结构</font></div>
<div> </div>
<div>&#61550;SOAP消息由一个强制的SOAP Envelope、一个可选的SOAP Header和一个强制的SOAP Body组成的XML文档。<br>
&#61550;1/ SOAP Envelope<br>
&#61550; 表示一个SOAP消息的顶级元素<br>
&#61550;2/ SOAP Header<br>
&#61550; 能够被SOAP消息路径中任意的SOAP接收者处理的一组SOAP条目。<br>
&#61550; SOAP定义了很少的一些属性来用于指明谁可以处理该特性以及它是可选的还是强制的。<br>
&#61550;3/ SOAP Body<br>
Body为该消息的最终接收者所想要得到的那些强制信息提供了一个容器。此外，SOAP定义了Body的一个子元素Fault用于报告错误。</div>
<div> </div>
<div><font color="#ff0000">8、理解SOAP消息的各个元素（选择，填空和应用题）</font></div>
<div> </div>
<div>（1）SOAP Envelope元素：语法规则<br>
（2）SOAP Header元素<br>
SOAP Header的作用；Header条目；Header 的语法规则；Header条目的编码规则；SOAP消息路径中各个节点对消息的处理过程（读、处理或更新Header条目 ）；actor属性的含义（next角色和ultimate receiver角色）；mustUnderstand属性的含义；重点理解PPT中订购单SOAP消息处理的例子<br>
（3）SOAP Body元素<br>
1/ Body条目携带端到端的信息，可以是：<br>
Application data(XML document) (document style)<br>
RPC method and parameters(rpc style)<br>
SOAP fault<br>
2/ Body的语法规则<br>
3/ Body条目的编码规则<br>
（4）SOAP错误（SOAP Fault）<br>
如果SOAP消息需要包含SOAP Fault元素的话，它必须作为一个Body条目出现，同时在Body元素内它必须不出现多于一次(至多出现一次)。</div>
<div> </div>
<div>了解SOAP Fault元素的子元素： faultcode、 faultstring、 faultactor、 detail <br>
了解SOAP中定义的faultcode值： VersionMismatch、 MustUnderstand、 Client、 Server</div>
<div> </div>
<div>9、SOAP消息交换（了解，选择或填空题）</div>
<div> </div>
<div>SOAP应用模式：请求/响应模式、 Fire-and-forget模式、高级消息交换模式、增量解析和处理模式和缓存模式</div>
<div> </div>
<div>10、SOAP消息编码</div>
<div> </div>
<div>（1）定义了一套<font color="#ff0000">编码机制</font>用于交换应用程序定义的数据类型的<font color="#ff0000">实例</font><br>
<font color="#ff0000">（2）对每个包含一个值的元素，值的类型表示必须满足以下至少一个条件：<br>
(a) 包含该值的元素实例包含一个xsi:type属性，<br>
(b) 包含该值的元素实例包含在一个具备enc: arrayType属性的元素中(可能是被设置成default的)<br>
(c) 该元素的名带有一个类型的明确关联，而该类型由一个模式来决定。 <br>
（3）重点理解PPT的例子（填空、应用题）：<br>
structure、 muli-reference 、 single-reference 、 enc:Array 、 enc:arrayType</font></div>
<div> </div>
<div>11、SOAP RPC表示（问答题）</div>
<div> </div>
<div>&#61550;（1）为实施一个方法调用，需要以下信息<br>
&#61550;目标SOAP节点的URI<br>
&#61550;方法名<br>
&#61550;可选的方法或过程的特征<br>
&#61550;方法或过程的参数<br>
&#61550;可选的头数据<br>
<font color="#ff0000">&#61550;（2）RPC调用和响应都是在SOAP Body元素中传递<br>
&#61550;一个方法调用被建模成一个结构struct<br>
&#61550;一个方法响应被建模成一个结构struct<br>
&#61550;方法调用错误使用SOAP Fault元素来编码</font></div>
<div> </div>
<div>12、SOAP绑定：在HTTP中使用SOAP（填空或问答）</div>
<div> </div>
<div><font color="#ff0000">（1）SOAP HTTP请求： HTTP GET 请求和 HTTP POST请求（ SOAP1.1使用）<br>
（2）重点理解HTTP Header中的SOAPAction字段<br>
 SOAPAction头字段的存在及其内容可以被服务器例如防火墙用于在HTTP中过滤SOAP请求消息。<br>
</font>（3）了解SOAP HTTP响应</div>
<div> </div>
<div><font color="#ff0000">思考题：<br>
</font>&#61550;1、在SOAP消息中为什么要进行编码？请给出你的理解。<br>
&#61550;2、结合Actor属性和mustUnderstand属性，简述SOAP节点是如何处理SOAP Header条目的。<br>
&#61550;3、SOAP Fault元素应该出现在SOAP Header还是SOAP Body？预定义的SOAP faultCode有哪几种？ <br>
&#61550;4、利用XML消息传递RPC调用时，RPC调用在SOAP的请求与响应消息中是如何表示的？<br>
&#61550;5、SOAP消息是用XML来进行类型编码的，那么SOAP消息实质上是XML模式文档还是实例文档？在SOAP的编码规则中，如何表示一个值的类型？<br>
&#61550;6、在HTTP中使用SOAP1.1时，为什么在HTTP Header中使用SOAPAction？它有什么作用？</div>
<div> </div>
<div>第5章 WSDL</div>
<div> </div>
<div>1、WSDL的基本概念</div>
<div> </div>
<div>（1）WSDL（Web Service Description Language）定义了一套基于XML的语法，将Web Service描述为能够进行消息交换的服务访问点或端口的集合。<br>
（2）WSDL将 Web 服务描述为一组端点(Endpoints)，这些端点会处理包含面向文档或面向过程的（RPC）的消息。<br>
（3）操作和消息都是被抽象描述的，然后被绑定到一个具体的网络协议和消息格式，用来定义端点。相关的具体端点被合并到抽象的端点或服务中。</div>
<div> </div>
<div><font color="#ff0000">2、WSDL基本的服务描述分成了两部分：服务接口和服务实现。(选择或填空题)</font></div>
<div> </div>
<div>（1）服务接口定义：是一种抽象的服务定义，它可以被多个服务实现定义实例化和引用<br>
 包括的WSDL元素：types 、message 、operations、portType<br>
（2）服务实现定义：描述给定服务提供者如何实现特定服务接口的 WSDL 文档<br>
 包括的WSDL元素：binding、Service、Port</div>
<div> </div>
<div>3、理解上述几种WSDL元素的含义与语法(选择或填空题)</div>
<div> </div>
<div>（1）types：使用W3C XML Schema做类型系统<br>
（2）Messages：进行交换的抽象的、已经被定义了类型的数据<br>
（3）operations：活动的抽象描述；引用输入和/或输出消息<br>
（4）portType：操作的集合；一个服务的抽象定义<br>
<font color="#ff0000">活动行为模式分类（PPT的例子，重点）：<br>
请求-响应（request-response）；征求-响应（solicit-response）；<br>
单向(one-way)；通知(notification)<br>
（5）binding：为特定的Port type关联具体的协议和数据格式（编码规则）<br>
1/ 协议类型： SOAP（SOAP 1.1 over HTTP or SOAP 1.1 over SMTP）；HTTP GET/POST；MIME<br>
 &lt;binding&gt;元素中包含对应的&lt;soap:binding&gt;、&lt;http:binding&gt;和 &lt;mime:binding&gt;子元素<br>
2/ 编码规则： SOAP encoding；RDF encoding</font></div>
<div> </div>
<div>（6）Port：定义单一的通信端点<br>
绑定的端点地址：URL for HTTP, email address for SMTP</div>
<div> </div>
<div>（7）Service：有关Port的集合</div>
<div> </div>
<div><font color="#ff0000">4、SOAP绑定扩展(SOAP Binding Extension)(重点，选择、填空或应用题)</font></div>
<div> </div>
<div>（1）WSDL支持对SOAP1.1端点的绑定：<br>
&#61550;指定 SOAP 作为绑定的协议<br>
&#61550;指定SOAP endpoint的地址<br>
&#61550;指定SOAPAction HTTP header的URI (只对SOAP/HTTP有效)<br>
&#61550;列出SOAP envelope的Header定义</div>
<div> </div>
<div><font color="#ff0000">（2）采用SOAP命名空间：<br>
&#61550;xmlns:soap=&quot;</font><a href="http://schemas.xmlsoap.org/wsdl/soap/"><font color="#ff0000">http://schemas.xmlsoap.org/wsdl/soap/</font></a><font color="#ff0000">&quot;<br>
</font>（3）&lt;soap:binding&gt;元素： transport和 style（rpc或document，两者影响在传输时SOAP消息的BODY部分的构造方式）属性<br>
（4）&lt;soap:operation&gt;元素：soapAction属性， Style属性<br>
use属性指定编码规则： use=encoded意味着消息的组成部分引用抽象类型，而具体的模式由encodingStyle属性定义的编码形式中给出；use=literal意味着WSDL文档中提供的消息定义就直接写入SOAP体中而不使用另一种编码机制。<br>
（5）&lt;soap:body&gt;元素<br>
<font color="#ff0000">区分&lt;soap:body&gt;里的sytle的RPC风格和Document风格<br>
</font> 1/ RPC：<br>
WSDL文档中的&lt;message&gt;可以有多个&lt;part&gt;，每个&lt;part&gt;类型应该出现在wrapper元素（即operation）里的参数或返回值；<br>
SOAP消息的BODY部分采用struct格式；每部分出现的顺序同调用参数的顺序<br>
 2/ Document：<br>
WSDL文档的每个&lt;message&gt;只有一个&lt;part&gt;元素，&lt;part&gt;元素所引用的类型由&lt;types&gt;定义<br>
SOAP消息的 Body 元素包含的是XML文档片段<br>
<font color="#ff0000"> 理解use=&quot;literal|encoded&quot;的含义<br>
 理解style与use属性值的四种组合（结合PPT的例子，重点掌握，应用题）：<br>
</font>style=&rdquo;rpc&rdquo; and use=&rdquo;encoded&rdquo;<br>
style=&rdquo;rpc&rdquo; and use=&rdquo; literal&rdquo;<br>
style=&rdquo;document&rdquo; and use=&rdquo;encoded&rdquo;<br>
style=&rdquo;document&rdquo; and use=&rdquo;literal&rdquo;</div>
<div> </div>
<div>第6章 UDDI</div>
<div> </div>
<div>1、UDDI的基本概念（选择或填空题）</div>
<div> </div>
<div>统一描述、发现和集成协议(UDDI, Universal Description, Discovery and Integration)是一套基于Web的、分布式的、为Web服务提供的信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web服务注册以使得别的企业能够发现的访问协议的实现标准。</div>
<div> </div>
<div>（1）UDDI规范<br>
（2）UDDI Registry (UDDI注册中心) <br>
（3）UDDI Operator Site (UDDI注册中心操作入口站点，简称UDDI操作入口) <br>
（4）Compatible UDDI Registry(兼容的UDDI注册中心)</div>
<div> </div>
<div>2、UDDI技术体系结构包括三部分： UDDI data model、UDDI API、UDDI cloud services</div>
<div> </div>
<div>3、UDDI计划的核心组件是UDDI商业注册（UBR），UDDI商业注册所提供的信息包含三部分（选择或填空题）：<br>
 White Page：包含地址、联系方法、已知的企业标识等<br>
Yellow Page：包含基于标准分类法的行业类别<br>
Industry: NAICS：北美工业分类系统<br>
Product/Services: UN/SPSC ：通用标准产品和服务分类<br>
Location: ISO 3166：国际标准地理区域。<br>
Green Page：包含关于该企业所提供的Web Service的技术信息，其形式可能是指向文件或URL的指针，而这些文件或URL是为服务发现机制服务的。</div>
<div> </div>
<div>4、UDDI节点类型： Public、 Private、 Shared/Semi-Private（选择或填空题）</div>
<div> </div>
<div>5、UDDI数据模型</div>
<div> </div>
<div><font color="#ff0000"> UDDI包含一个XMLSchema，用以描述四种信息的核心类型：<br>
 businessEntity（商业实体）（White Pages）<br>
 businessService（服务信息）(Yellow Pages)<br>
 bindingTemplate（绑定模板）(Green Pages)<br>
 tModel (Technical Model)（技术模型）</font></div>
<div> </div>
<div>（1）businessEntity 元素：对关于企业的信息进行建模；<br>
如何识别该公司或商业实体？<br>
<font color="#ff0000">1/ 具有唯一的businessKey值（UUID）<br>
 2/ 利用identifierBag元素里的其他唯一的值，用来标识该公司<br>
 3/ 利用categoryBag元素里注册的多个商业分类来标识<br>
</font>（2）businessService 元素：包含单个Web Service或一组相关Web Services的信息，每个businessService元素都有一个唯一的servicekey，&#61472;应该指定businessKey来关联提供该服务的商业实体。<br>
（3）bindingTemplate元素<br>
访问入口的URL（accessPoint元素）包含一个Web服务的文本描述（可选的）一个或者多个指向&lt; tModel &gt;结构的引用<br>
（4）tModel 提供了关于Web服务规范、分类规范以及标识符规范的元数据信息<br>
tModels主要用来提供指向外部技术规范的指针（如到WSDL的指针）。<font color="#ff0000">注意：tModel 不仅仅是指向Web services，如果需要的话，它还可以指向任意的外部规范，如D-U-N-S号<br>
</font>1/ categoryBag结构：分类可以将UDDI注册中心的数据按照行业类别、产品类别或者地区代码组织在一起。<font color="#ff0000">阅读PPT的&ldquo;tModel例子&rdquo;<br>
</font>2/ 标识符identifierBag</div>
<div> </div>
<div>6、从 WSDL 到 UDDI 的映射（选择、填空或应用）</div>
<div> </div>
<div>（1）一个完整的WSDL服务描述是由一个服务接口和一个服务实现文档组成<br>
 <font color="#ff0000">WSDL 服务接口描述是作为 UDDI tModel 发布的<br>
 而 WSDL 服务实现描述是作为 UDDI businessService 发布的<br>
 阅读并理解图&ldquo;从 WSDL 到 UDDI 的映射概览&rdquo;（PPT）或课本图6-6，图6-7</font></div>
<div> </div>
<div>（2）Services接口到tModel的映射<br>
<font color="#ff0000"> 阅读并理解表&ldquo;tModel与WSDL 服务接口文档元素之间的映射&rdquo;（PPT）或课本P133中的映射规则。阅读课本例子P133-134</font></div>
<div> </div>
<div>（3）Services实现到businessService的映射<br>
<font color="#ff0000"> 阅读并理解表&ldquo;businessService与WSDL 服务实现文档元素之间的映射&rdquo;（PPT）或课本P136中的映射规则。阅读课本例子P136-137</font></div>
<div> </div>
<div>7、UDDI APIs（选择或填空题）</div>
<div> </div>
<div>（1）两种发布与查找服务的方式<br>
 1/ 通过人工浏览UDDI cloud service所提供的网页来获得<br>
 2/ 通过UDDI API来编程实现Web服务的发布与查找<br>
<font color="#ff0000">（2）两种UDDI API：查询API和发布API<br>
（3）了解查询API的三种查询模式：<br>
 1/ 浏览模式<br>
 2/ 对象深入模式<br>
 3/ 调用模式<br>
</font>（4）发布API<br>
 1/ 发布的含义有两层：<br>
首先是商业实体信息的初次注册，同时还有对相关描述和web服务的发布；<br>
其次，是对注册信息的维护，包括信息的更新和删除操作。</div>
<div> </div>
<div><font color="#ff0000"> 2/ 发布API需要经过授权认证才能访问UDDI操作入口站点的，这个入口站点由每一个商业实体在开始时选定，一旦选定站点，以后只能通过该站点更新操作。<br>
</font>（5）查询与发布服务接口的不同点<br>
1/ 使用不同是XML文档、数据结构以及访问点<br>
2/ 查询API不要求授权访问，使用HTTP访问协议<br>
3/ 发布API需要授权，使用HTTPS协议</div>
<div> </div>
<div>第七章 JAX-RPC</div>
<div> </div>
<div>1、JAX-RPC的基本概念（选择或填空题）</div>
<div> </div>
<div>（1）JAX-RPC(Java API for XML-based RPC)是J2EE1.4平台上的开发Web Services 的主要技术之一<br>
 通过交换SOAP 1.1 消息来完成RPC操作<br>
 Web service 端点和客户都可以使用JAXRPC 编程模型来实现</div>
<div> </div>
<div><font color="#ff0000">（2）JAX-RPC运行时系统<br>
1/ JAX-RPC 实现的核心:<br>
&ndash;为编码或者是解码SOAP提供运行服务的类库<br>
&ndash; 实现 JAX-RPC APIs<br>
2/ 客户端:<br>
&ndash;基于J2SE, J2EE or J2ME平台的运行系统<br>
3/ 服务端:<br>
&ndash; J2EE 容器: EJB容器 or Servlet容器</font></div>
<div> </div>
<div>2、类型映射（选择、填空或应用题）<br>
 在两者(SOAP/WSDL或XML与具体的编程语言)之间需要一种标准的类型映射方式，否则将面临互操作的问题。</div>
<div> </div>
<div><font color="#ff0000">（1）XML 数据类型到JAVA的映射<br>
涉及XML的简单内建类型、Array、简单内建类型的枚举、XML结构和复杂类型到Java语言表示的映射，阅读PPT的关于complexType到JavaBeans映射例子<br>
</font>（2）Java到XML数据类型的映射<br>
 由JAX-RPC runtime system自动执行映射过程<br>
只有JAX-RPC 支持的 Java 数据类型才能够作为被传递的参数和返回值</div>
<div> </div>
<div>3、WSDL到Java的映射</div>
<div> </div>
<div><font color="#ff0000">（1）JAX-RPC与WSDL的关系<br>
 1/ JAX-RPC将 Web Service描述为remote interfaces与methods的集合；<br>
 2/ WSDL将Web Service描述为ports与operations的集合<br>
 3/ 可以通过工具在两种集合之间进行转换：<br>
 对于JAX-RPC RI 工具：<br>
 1）在服务器端，wscompile 可以从服务定义接口创建WSDL的抽象接口部分；<br>
 2）在服务器端，wsdeploy 能够创建WSDL的包括port 地址的具体实现部分，以及tie classes；<br>
 3）在客户端，wscompile 工具可以从WSDL文档创建 stubs类</font></div>
<div> </div>
<div>（2）JAX-RPC API 定义了所有到WSDL或来自WSDL的映射细节</div>
<div> </div>
<div>（3）WSDL到Java的映射规则</div>
<div> </div>
<div><font color="#ff0000"> 1/一个 WSDL文档映射到 一个 Java 包<br>
 2/ WSDL的抽象部分（wsdl:portType, wsdl:operation, wsdl:message）映射到Java接口和类<br>
 3/ WSDL的具体绑定部分（wsdl:binding, wsdl:port, wsdl:service）映射到Java表示</font></div>
<div> </div>
<div>（4）WSDL的抽象部分到Java的映射规则<br>
<font color="#ff0000">1/ 一个wsdl:portType 映射到一个扩展java.rmi.Remote的Java接口 (服务定义接口) <br>
2/ 一个wsdl:operation 映射到服务定义接口的一个方法<br>
3/ wsdl:message映射到方法的参数<br>
4/ wsdl:message的wsdl:type映射到参数的类型</font></div>
<div> </div>
<div><font color="#ff0000"> 阅读PPT的例子：portType到Java interface的映射，要求能够根据WSDL文档的描述，写出相应的Java类，或反之。（应用题）</font></div>
<div> </div>
<div>（5）WSDL的抽象绑定部分到Java的映射规则（理解）<br>
<font color="#ff0000">1/ wsdl:service 被映射到javax.xml.rpc.Service 接口的一个实现<br>
2/ JAX-RPC 运行时提供实现<br>
3/ javax.xml.rpc.Service 类就像一个工厂，它产生 <br>
1）产生stub类的实例<br>
2）为服务端口提供动态代理(Dynamic proxy)<br>
3）为激发服务端口上的远程操作生成javax.xml.rpc.Call的实例</font></div>
<div> </div>
<div>4、服务客户端编程模型</div>
<div> </div>
<div><font color="#ff0000">（1）三种客户端编程模型<br>
</font>基于存根Stub（Stub-based）：接口和实现都在编译时创建<br>
动态代理（Dynamic proxy）：接口在编译时创建，而实现在运行时创建<br>
动态调用接口（Dynamic invocation interface ,DII）：接口和实现都在运行时创建<br>
<font color="#ff0000">（2）通过作业的HelloClient例子掌握Stub和动态代理方式的实现过程（包括基本的编译和打包，源代码）（应用题，程序填空）<br>
</font>（3）了解DII模型，仔细体会三种模型的异同<br>
<font color="#ff0000">（4）结合HelloService例子，简述利用JAX-RPC在J2EE 1.4和J2EE App Server 8.1的环境下开发一个Web Service的基本步骤。（简答）</font></div>
<div> </div>
<div>5、服务端点模型（选择、填空题）</div>
<div> </div>
<div><font color="#ff0000">（1）服务端点的类型：<br>
</font>基于Servlet的端点(Servlet based endpoint )：由JAX-RPC 1.0规范说明；<br>
基于EJB的无状态会话Bean(Stateless session bean)：由EJB 2.1规范说明<br>
（2）J2EE 1.4平台的关于Web Services的视图<br>
 1/ 客户端的视图：JAX-RPC<br>
 2/ 服务器端的视图：<br>
 1）基于Servlet的端点：JAX-RPC；运行时系统由Web容器提供<br>
 2）基于EJB的无状态会话Bean：EJB 2.1；运行时系统由EJB容器提供</div>
<div> </div>
<div>基本题型（设想）：<br>
1、选择、填空：考基本的概念和理解；注重理解，有少量的记忆<br>
2、改错：注重理解，有少量的记忆，主要集中在XML<br>
3、简答：本大纲中标注的内容,理解+记忆<br>
4、应用：本大纲中标注的内容,理解+少量记忆（如基本的XML语法、程序填空等）</div>
<div> </div>
<div> </div></div></body></html>